NOME FILE: docker-compose.yml

# ===================================================== # 🐳 docker-compose.yml - LearnEnglishVOC (Updated with ENV support) # =====================================================  version: '3.8'  networks:   learnenglishvoc_network:     driver: bridge  services:   # ====== PRODUCTION SERVICE (existing) ======   learnenglishvoc:     container_name: learnenglishvoc     image: ghcr.io/merlinoalbus/learnenglishvoc:latest          # ====== ENVIRONMENT VARIABLES (NUOVO) ======     environment:       # CRITICO: API key deve essere passata dall'esterno       # Usa: export REACT_APP_GEMINI_API_KEY=your_key prima di docker-compose up       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}              # Configurazione production       - REACT_APP_ENVIRONMENT=production       - REACT_APP_DEBUG_LOGGING=false       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_AI_TIMEOUT=15000       - REACT_APP_AI_MAX_RETRIES=3       - REACT_APP_MOCK_AI_RESPONSES=false          # ====== RESOURCE LIMITS (existing) ======     deploy:       resources:         limits:           cpus: '0.5'           memory: 512M         reservations:           cpus: '0.1'           memory: 128M          # ====== NETWORKING & PORTS (existing) ======     networks:       - learnenglishvoc_network     ports:       - '12345:80'          # ====== RELIABILITY ======     restart: unless-stopped          # ====== HEALTH CHECK (NUOVO) ======     healthcheck:       test: ["CMD", "curl", "-f", "http://localhost/health", "||", "curl", "-f", "http://localhost/"]       interval: 30s       timeout: 10s       retries: 3       start_period: 40s      # ====== DEVELOPMENT SERVICE (NUOVO - opzionale) ======   learnenglishvoc-dev:     profiles: ["dev"]     container_name: learnenglishvoc-dev     build:       context: .       dockerfile: Dockerfile.dev          environment:       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}       - REACT_APP_ENVIRONMENT=development       - REACT_APP_DEBUG_LOGGING=true       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_MOCK_AI_RESPONSES=false          # Carica da .env.local se esiste (per development)     env_file:       - .env.local          ports:       - '3000:3000'          volumes:       - .:/app       - /app/node_modules          networks:       - learnenglishvoc_network          command: npm start    # ====== STAGING SERVICE (NUOVO - opzionale) ======   learnenglishvoc-staging:     profiles: ["staging"]     container_name: learnenglishvoc-staging     image: ghcr.io/merlinoalbus/learnenglishvoc:latest          environment:       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}       - REACT_APP_ENVIRONMENT=staging       - REACT_APP_DEBUG_LOGGING=true       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_AI_TIMEOUT=15000       - REACT_APP_AI_MAX_RETRIES=3          deploy:       resources:         limits:           cpus: '0.3'           memory: 256M         reservations:           cpus: '0.1'           memory: 64M          networks:       - learnenglishvoc_network          ports:       - '8080:80'          restart: unless-stopped          healthcheck:       test: ["CMD", "curl", "-f", "http://localhost/"]       interval: 30s       timeout: 10s       retries: 3  # ===================================================== # 🔐 DEPLOYMENT INSTRUCTIONS: #  # PRODUCTION (existing service): # export REACT_APP_GEMINI_API_KEY=your_production_api_key # docker-compose up -d learnenglishvoc #  # DEVELOPMENT (new service): # echo "REACT_APP_GEMINI_API_KEY=your_dev_key" > .env.local # docker-compose --profile dev up #  # STAGING (new service): # export REACT_APP_GEMINI_API_KEY=your_staging_key # docker-compose --profile staging up -d #  # CHECK STATUS: # docker-compose ps # docker-compose logs learnenglishvoc #  # =====================================================

================================================================================

NOME FILE: Dockerfile

# ===================================================== # 🐳 Dockerfile - Vocabulary Master (Secure Build) # =====================================================  # Multi-stage build per ottimizzazione FROM node:18-alpine AS builder  # Set working directory WORKDIR /app  # Copy package files COPY package*.json ./  # Install dependencies RUN npm ci --only=production && npm cache clean --force  # Copy source code COPY . .  # Build args per environment variables (opzionali per build-time) ARG REACT_APP_ENVIRONMENT=production ARG REACT_APP_ENABLE_AI_FEATURES=true ARG REACT_APP_DEBUG_LOGGING=false  # Set environment variables per build ENV REACT_APP_ENVIRONMENT=$REACT_APP_ENVIRONMENT ENV REACT_APP_ENABLE_AI_FEATURES=$REACT_APP_ENABLE_AI_FEATURES ENV REACT_APP_DEBUG_LOGGING=$REACT_APP_DEBUG_LOGGING  # IMPORTANTE: NON includere REACT_APP_GEMINI_API_KEY qui! # Sarà passata a runtime tramite docker run o docker-compose  # Build the app RUN npm run build  # ===================================================== # Production Stage # ===================================================== FROM nginx:alpine  # Copy built app COPY --from=builder /app/build /usr/share/nginx/html  # Copy nginx configuration COPY nginx.conf /etc/nginx/nginx.conf  # Expose port EXPOSE 80  # Health check HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \   CMD curl -f http://localhost/ || exit 1  # Start nginx CMD ["nginx", "-g", "daemon off;"]

================================================================================

NOME FILE: Dockerfile.dev

# ===================================================== # 🐳 Dockerfile.dev - Development Environment # =====================================================  FROM node:18-alpine  # Set working directory WORKDIR /app  # Install dependencies for development COPY package*.json ./ RUN npm install  # Copy source code COPY . .  # Create .env.local if it doesn't exist (for container) RUN if [ ! -f .env.local ]; then cp .env.example .env.local; fi  # Expose port EXPOSE 3000  # Start development server CMD ["npm", "start"]

================================================================================

NOME FILE: INTEGRATION_GUIDE.md

# 🔄 Integration Guide - Security Configuration  ## Overview  Questa guida ti aiuterà a integrare il nuovo sistema di configurazione sicura nella tua app Vocabulary Master esistente. La migrazione sposta tutte le credenziali da file hardcodati a environment variables.  ---  ## 📋 Pre-Migration Checklist  ### Before Starting - [ ] **Backup dei dati utente** (esporta vocabolario dall'app) - [ ] **Backup del repository** (`git checkout -b backup-before-security-update`) - [ ] **Nota la tua API key attuale** (se presente in `appConstants.js`) - [ ] **Test dell'app corrente** per verificare funzionalità  ### Required Tools - [ ] Node.js >= 16.0.0 - [ ] npm >= 8.0.0 - [ ] Git (per version control) - [ ] Editor di testo  ---  ## 🚀 Step-by-Step Integration  ### Step 1: Backup e Preparazione  ```bash # Crea branch di backup git checkout -b backup-before-security-update git push origin backup-before-security-update  # Torna al branch principale git checkout main  # Aggiorna le dipendenze npm install ```  ### Step 2: Integra i Nuovi File  1. **Crea la directory `config/`:**    ```bash    mkdir -p src/config    ```  2. **Crea la directory `scripts/`:**    ```bash    mkdir -p scripts    ```  3. **Aggiungi i nuovi file:**    - Copia `src/config/appConfig.js` ✅    - Copia `scripts/config-status.js` ✅    - Copia `scripts/security-check.js` ✅    - Copia `.env.example` ✅    - Aggiorna `.gitignore` ✅  ### Step 3: Migra la Configurazione  1. **Salva la tua API key attuale:**    - Apri `src/constants/appConstants.js`    - Copia il valore di `apiKey` dalla configurazione `AI_CONFIG`    - Conserva temporaneamente questo valore  2. **Sostituisci i file esistenti:**    - Sostituisci `src/constants/appConstants.js` con la versione aggiornata ✅    - Sostituisci `src/services/aiService.js` con la versione aggiornata ✅  3. **Crea il file environment:**    ```bash    npm run setup:env    ```  4. **Configura la tua API key:**    ```bash    # Modifica .env.local    nano .env.local    ```        Aggiungi:    ```bash    REACT_APP_GEMINI_API_KEY=la_tua_api_key_qui    REACT_APP_ENVIRONMENT=development    REACT_APP_DEBUG_LOGGING=true    ```  ### Step 4: Aggiorna package.json  Aggiungi i nuovi script al tuo `package.json`:  ```json {   "scripts": {     "setup:env": "cp .env.example .env.local && echo 'Created .env.local - Please add your API keys!'",     "check:env": "node scripts/check-env.js",     "security:check": "npm audit && node scripts/security-check.js",     "config:status": "node scripts/config-status.js"   } } ```  ### Step 5: Test della Migrazione  1. **Verifica la configurazione:**    ```bash    npm run config:status    ```  2. **Test di sicurezza:**    ```bash    npm run security:check    ```  3. **Avvia l'app:**    ```bash    npm start    ```  4. **Verifica funzionalità AI:**    - Prova ad aggiungere una nuova parola    - Verifica che l'AI assistant funzioni    - Controlla la console per messaggi di debug  ---  ## 🔧 Troubleshooting  ### Problema: "AI Service not configured"  **Causa:** API key non trovata  **Soluzione:** ```bash # Verifica configurazione npm run config:status  # Se .env.local è vuoto: echo "REACT_APP_GEMINI_API_KEY=la_tua_api_key" >> .env.local  # Riavvia il server npm start ```  ### Problema: Import errors dopo l'aggiornamento  **Causa:** Cambiamenti nei path di import  **Soluzione:** ```javascript // VECCHIO (potrebbe non funzionare più) import { AI_CONFIG } from '../constants/appConstants';  // NUOVO (raccomandato) import AppConfig from '../config/appConfig'; // Use: AppConfig.ai instead of AI_CONFIG  // COMPATIBILITY (funziona ma deprecated) import { AI_CONFIG } from '../constants/appConstants'; // Continua a funzionare grazie ai re-exports ```  ### Problema: Build fails in production  **Causa:** Environment variables non configurate nel hosting  **Soluzione:**  **Per Vercel:** ```bash # Nel dashboard Vercel: # Settings → Environment Variables # Aggiungi: REACT_APP_GEMINI_API_KEY = your_api_key ```  **Per Netlify:** ```bash # Nel dashboard Netlify: # Site Settings → Environment Variables # Aggiungi: REACT_APP_GEMINI_API_KEY = your_api_key ```  ### Problema: Security check fails  **Causa:** API key ancora hardcodata nel codice  **Soluzione:** ```bash # Trova API keys nel codice grep -r "AIzaSy" src/  # Rimuovi manualmente ogni occorrenza trovata # Le API keys devono essere solo in .env.local ```  ---  ## 🔄 Migrazione di Componenti Esistenti  ### Se hai componenti che usano le vecchie configurazioni:  **Prima (Deprecated):** ```javascript import { AI_CONFIG, ERROR_MESSAGES } from '../constants/appConstants';  const apiKey = AI_CONFIG.apiKey; const timeout = AI_CONFIG.timeout; ```  **Dopo (Recommended):** ```javascript import AppConfig, { ERROR_MESSAGES, isAIAvailable } from '../config/appConfig';  const apiKey = AppConfig.ai.apiKey; const timeout = AppConfig.ai.timeout; const canUseAI = isAIAvailable(); ```  ### Per componenti che controllano disponibilità AI:  **Prima:** ```javascript const aiEnabled = !!AI_CONFIG.apiKey; ```  **Dopo:** ```javascript import { isAIAvailable } from '../config/appConfig'; const aiEnabled = isAIAvailable(); ```  ---  ## 📦 Deployment Checklist  ### Before Deploying  - [ ] **Configurazione testata localmente** - [ ] **Security check passato**: `npm run security:check` - [ ] **No API keys nel codice sorgente** - [ ] **Environment variables configurate nel hosting** - [ ] **Build di test**: `npm run build`  ### Hosting Configuration  **Vercel:** ```bash # Environment Variables: REACT_APP_GEMINI_API_KEY=your_production_api_key REACT_APP_ENVIRONMENT=production ```  **Netlify:** ```bash # Environment Variables: REACT_APP_GEMINI_API_KEY=your_production_api_key REACT_APP_ENVIRONMENT=production ```  **Other Platforms:** - Consulta la documentazione del tuo provider - Assicurati che tutte le variabili inizino con `REACT_APP_`  ---  ## 🔍 Validation Steps  ### Post-Migration Testing  1. **Functionality Test:**    ```bash    npm start    # Test: Add new word with AI assistance    # Test: All existing features work    # Test: Statistics and data export    ```  2. **Security Validation:**    ```bash    npm run security:check    # Should pass with no critical issues    ```  3. **Configuration Check:**    ```bash    npm run config:status    # Should show all green checkmarks    ```  4. **Build Test:**    ```bash    npm run build    # Should complete without errors    ```  ### Rollback Plan  Se qualcosa va storto:  ```bash # Torna al backup git checkout backup-before-security-update  # Se necessario, ripristina i dati utente # dall'export fatto prima della migrazione ```  ---  ## 🎯 Success Criteria  La migrazione è completata con successo quando:  - ✅ App starts without errors - ✅ AI features work with environment variables - ✅ Security check passes - ✅ No hardcoded credentials in source code - ✅ Production build works - ✅ All existing features functional - ✅ User data preserved  ---  ## 📞 Support  Se incontri problemi durante la migrazione:  1. **Check console errors** per messaggi specifici 2. **Run diagnostic tools**: `npm run config:status` 3. **Review security guide**: `SECURITY_SETUP.md` 4. **Check environment variables** sono configurate correttamente  **Common Issues:** - API key format incorrect - Environment variables not reloaded - Import paths changed - Production environment not configured  Seguendo questa guida passo-passo, dovresti riuscire a migrare la tua app esistente al nuovo sistema di configurazione sicura senza perdita di funzionalità! 🚀

================================================================================

NOME FILE: nginx.conf

# ===================================================== # 📁 nginx.conf - Nginx Configuration per Production # =====================================================  events {     worker_connections 1024; }  http {     include       /etc/nginx/mime.types;     default_type  application/octet-stream;          # Logging     log_format main '$remote_addr - $remote_user [$time_local] "$request" '                     '$status $body_bytes_sent "$http_referer" '                     '"$http_user_agent" "$http_x_forwarded_for"';          access_log /var/log/nginx/access.log main;     error_log /var/log/nginx/error.log warn;          # Performance     sendfile on;     tcp_nopush on;     tcp_nodelay on;     keepalive_timeout 65;     types_hash_max_size 2048;          # Compression     gzip on;     gzip_vary on;     gzip_min_length 1024;     gzip_proxied any;     gzip_comp_level 6;     gzip_types         application/javascript         application/json         application/xml+rss         application/atom+xml         image/svg+xml         text/css         text/javascript         text/xml         text/plain;      server {         listen 80;         server_name localhost;         root /usr/share/nginx/html;         index index.html;          # Security headers         add_header X-Frame-Options "SAMEORIGIN" always;         add_header X-Content-Type-Options "nosniff" always;         add_header X-XSS-Protection "1; mode=block" always;         add_header Referrer-Policy "strict-origin-when-cross-origin" always;          # Handle React Router         location / {             try_files $uri $uri/ /index.html;         }          # Cache static assets         location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {             expires 1y;             add_header Cache-Control "public, immutable";         }          # Health check endpoint         location /health {             access_log off;             return 200 "healthy\n";             add_header Content-Type text/plain;         }          # Security: hide nginx version         server_tokens off;     } }

================================================================================

NOME FILE: postcss.config.js

// postcss.config.js // This file is part of the Tailwind CSS configuration for the Vocabulary Learning App. // It sets up PostCSS with Tailwind CSS and Autoprefixer to process CSS files. // The configuration ensures that Tailwind CSS styles are applied correctly and that vendor prefixes are added for better browser compatibility. // The PostCSS configuration is essential for building the application's styles and ensuring a consistent look across different browsers. // It is used in conjunction with Tailwind CSS to create a responsive and modern user interface.   module.exports = {   plugins: {     tailwindcss: {},     autoprefixer: {},   }, }

================================================================================

NOME FILE: README.md

// README.md - Vocabulary App Refactored Structure # 📚 Vocabulary Learning App - Refactored  ## 🎯 Overview App modulare per l'apprendimento del vocabolario inglese con statistiche avanzate, completamente refactorizzata per migliorare la manutenibilità e la scalabilità.  ## 🏗️ Struttura Modulare  ### 📁 Hooks Personalizzati (`/src/hooks/`) - **`useLocalStorage.js`** - Gestione persistente del localStorage con error handling - **`useWords.js`** - Gestione completa delle parole (CRUD operations) - **`useTest.js`** - Logica del sistema di test e quiz - **`useNotification.js`** - Sistema di notifiche toast  ### 🧩 Componenti (`/src/components/`) - **`TestCard.js`** - Carta 3D interattiva per visualizzazione parole - **`TestResults.js`** - Schermata risultati con analisi dettagliata - **`AddWordForm.js`** - Form avanzato per aggiunta/modifica parole - **`WordsList.js`** - Lista interattiva del vocabolario - **`JSONManager.js`** - Gestione import/export dati JSON - **`StatsOverview.js`** - Dashboard statistiche con grafici  ### 🛠️ Utilità (`/src/utils/`) - **`categoryUtils.js`** - Gestione categorie e stili - **`textUtils.js`** - Formattazione testi e risultati  ### 🎨 UI Components (`/src/components/ui/`) - **`button.js`** - Componente Button riutilizzabile - **`card.js`** - Sistema di Card modulari - **`input.js`** - Input components - **`modal.js`** - Sistema modale - **`textarea.js`** - Textarea component  ## ✨ Miglioramenti della Refactorizzazione  ### 🔧 Separazione delle Responsabilità - **Hooks** gestiscono la logica di business - **Componenti** si occupano solo della UI - **Utilità** per funzioni pure e helpers  ### 📈 Vantaggi 1. **Manutenibilità**: Codice più organizzato e facile da modificare 2. **Riusabilità**: Componenti e hooks riutilizzabili 3. **Testabilità**: Ogni modulo è testabile indipendentemente 4. **Scalabilità**: Struttura pronta per nuove funzionalità 5. **Performance**: Ottimizzazioni con useMemo e useCallback  ### 🎯 Error Handling Migliorato - Gestione errori centralizzata nei hooks - Notifiche user-friendly per ogni operazione - Validazione dati robusta  ### 💾 Gestione Stato Ottimizzata - localStorage gestito tramite hook dedicato - Stato locale separato da quello globale - Riduzione re-render non necessari  ## 🚀 Come Utilizzare  ### Installazione ```bash npm install npm start ```  ### Struttura File Principale ``` src/ ├── hooks/ │   ├── useLocalStorage.js │   ├── useWords.js │   ├── useTest.js │   └── useNotification.js ├── components/ │   ├── ui/ │   ├── TestCard.js │   ├── TestResults.js │   ├── AddWordForm.js │   ├── WordsList.js │   ├── JSONManager.js │   └── StatsOverview.js ├── utils/ │   ├── categoryUtils.js │   └── textUtils.js ├── App.js (refactored) ├── App.css └── index.js ```  ## 🔄 Migrazione dal Codice Originale  ### Cosa è Cambiato 1. **App.js**: Ridotto da ~800 righe a ~200 righe 2. **Hooks**: Logica estratta in hooks riutilizzabili 3. **Componenti**: UI separata in componenti specifici 4. **Utilità**: Funzioni pure estratte in moduli dedicati  ### Compatibilità - ✅ Tutte le funzionalità originali mantenute - ✅ Stessi dati localStorage compatibili - ✅ Stesso design e UX - ✅ Performance migliorate  ## 🧪 Testing Strategy  ### Hooks Testing ```javascript // Esempio test per useWords import { renderHook, act } from '@testing-library/react'; import { useWords } from '../hooks/useWords';  test('should add word correctly', () => {   const { result } = renderHook(() => useWords());      act(() => {     result.current.addWord({       english: 'test',       italian: 'prova'     });   });      expect(result.current.words).toHaveLength(1); }); ```  ### Component Testing ```javascript // Esempio test per TestCard import { render, fireEvent } from '@testing-library/react'; import TestCard from '../components/TestCard';  test('should flip card on click', () => {   const mockWord = { english: 'test', italian: 'prova' };   const mockOnFlip = jest.fn();      const { getByRole } = render(     <TestCard word={mockWord} showMeaning={false} onFlip={mockOnFlip} />   );      fireEvent.click(getByRole('button'));   expect(mockOnFlip).toHaveBeenCalled(); }); ```  ## 🔮 Roadmap Future  ### Prossimi Miglioramenti 1. **Context API** per stato globale più complesso 2. **React Query** per caching avanzato 3. **Virtualization** per liste grandi 4. **Service Worker** per offline support 5. **Unit Tests** completi per ogni modulo  ### Nuove Funzionalità Potenziali - 🔊 Audio pronuncia parole - 🌐 Sincronizzazione cloud - 👥 Modalità multiplayer - 📱 PWA support - 🎮 Gamification avanzata  ## 📝 Note Tecniche  ### Patterns Utilizzati - **Custom Hooks** per logica riutilizzabile - **Compound Components** per UI modulari - **Render Props** dove appropriato - **Error Boundaries** per error handling  ### Performance Optimizations - `useMemo` per calcoli costosi - `useCallback` per funzioni stabili - `React.memo` per componenti puri - Lazy loading per componenti pesanti  ### Accessibilità - ARIA labels appropriati - Navigazione keyboard-friendly - Contrasti colori conformi WCAG - Screen reader support  ---  ## 🤝 Contribuire  1. Fork del repository 2. Crea feature branch (`git checkout -b feature/amazing-feature`) 3. Commit changes (`git commit -m 'Add amazing feature'`) 4. Push to branch (`git push origin feature/amazing-feature`) 5. Open Pull Request  ---  **Vocabulary Master** - La tua app intelligente per imparare l'inglese! 🚀

================================================================================

NOME FILE: SECURITY_SETUP.md

# 🔐 Security Setup Guide - Vocabulary Master  ## Overview  Questa guida spiega come configurare in modo sicuro le credenziali e le variabili d'ambiente per l'app Vocabulary Master. L'app utilizza l'API Gemini di Google per le funzionalità AI.  ## ⚠️ Principi di Sicurezza  ### ❌ Non Fare Mai - **Non committare API keys** nel codice sorgente - **Non condividere** file `.env` con credenziali reali - **Non hardcodare** credenziali nei file JavaScript - **Non utilizzare** credenziali di produzione in development  ### ✅ Best Practices - Utilizzare environment variables per tutte le credenziali - Mantenere separati i file di configurazione per dev/staging/production - Utilizzare `.env.local` per development (ignorato da git) - Rigenerare le API keys se compromesse  ---  ## 🚀 Setup Development  ### 1. Ottieni una API Key Gemini  1. Vai su [Google AI Studio](https://makersuite.google.com/app/apikey) 2. Accedi con il tuo account Google 3. Clicca su "Create API Key" 4. Copia la chiave generata  ### 2. Configura Environment Variables  1. **Copia il template delle variabili:**    ```bash    cp .env.example .env.local    ```  2. **Modifica `.env.local`** e aggiungi la tua API key:    ```bash    # Sostituisci con la tua vera API key    REACT_APP_GEMINI_API_KEY=tu_chiave_api_qui        # Configurazione per development    REACT_APP_ENVIRONMENT=development    REACT_APP_DEBUG_LOGGING=true    ```  3. **Verifica che `.env.local` sia nel `.gitignore`** (già incluso)  ### 3. Avvia l'App  ```bash npm start ```  L'app dovrebbe ora funzionare con le funzionalità AI abilitate.  ---  ## 🔧 Variabili d'Ambiente Disponibili  ### Required (Obbligatorie) ```bash # API Key per Gemini AI (obbligatoria per funzionalità AI) REACT_APP_GEMINI_API_KEY=your_api_key_here ```  ### Optional (Opzionali) ```bash # Configurazione AI Service REACT_APP_GEMINI_API_URL=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent REACT_APP_AI_TIMEOUT=15000 REACT_APP_AI_MAX_RETRIES=3 REACT_APP_AI_RETRY_DELAY=1000  # App Environment REACT_APP_ENVIRONMENT=development REACT_APP_DEBUG_LOGGING=true  # Feature Flags REACT_APP_ENABLE_AI_FEATURES=true REACT_APP_ENABLE_STATISTICS=true REACT_APP_ENABLE_DATA_MANAGEMENT=true  # Development REACT_APP_MOCK_AI_RESPONSES=false REACT_APP_MOCK_DELAY=1500 ```  ---  ## 🌐 Setup Production  ### Vercel Deployment  1. **Nel dashboard Vercel:**    - Vai su Project Settings → Environment Variables    - Aggiungi: `REACT_APP_GEMINI_API_KEY` = `la_tua_api_key`    - Aggiungi: `REACT_APP_ENVIRONMENT` = `production`  2. **Rideploy il progetto** per applicare le nuove variabili  ### Netlify Deployment  1. **Nel dashboard Netlify:**    - Vai su Site Settings → Environment Variables    - Aggiungi le variabili necessarie    - Rebuilda il sito  ### Altri Hosting Providers  Consulta la documentazione del tuo provider per aggiungere environment variables: - **Heroku:** `heroku config:set REACT_APP_GEMINI_API_KEY=your_key` - **Railway:** Dashboard → Variables - **DigitalOcean App Platform:** Settings → Environment Variables  ---  ## 🛠️ Configurazione Avanzata  ### Mock Mode per Development  Se non hai una API key o vuoi testare senza fare chiamate API:  ```bash # In .env.local REACT_APP_MOCK_AI_RESPONSES=true REACT_APP_MOCK_DELAY=1500 ```  ### Debug e Logging  Per debug esteso in development:  ```bash # In .env.local REACT_APP_DEBUG_LOGGING=true REACT_APP_ENVIRONMENT=development ```  ### Feature Flags  Disabilita funzionalità specifiche se necessario:  ```bash # Disabilita funzionalità AI REACT_APP_ENABLE_AI_FEATURES=false  # Disabilita statistiche REACT_APP_ENABLE_STATISTICS=false ```  ---  ## 🐛 Troubleshooting  ### App non trova l'API Key  **Sintomi:** - Messaggio "AI Service not configured" - Funzionalità AI disabilitate  **Soluzioni:** 1. Verifica che `.env.local` esista e contenga `REACT_APP_GEMINI_API_KEY` 2. Riavvia il server development (`npm start`) 3. Controlla la console per errori di configurazione  ### API Key non valida  **Sintomi:** - Errori "API Error 400" o "Invalid API key"  **Soluzioni:** 1. Verifica che l'API key sia corretta 2. Controlla che l'API key sia abilitata su Google AI Studio 3. Rigenera una nuova API key se necessario  ### Funzionalità AI non disponibili  **Sintomi:** - Bottoni AI disabilitati - Modalità mock attiva  **Soluzioni:** 1. Controlla `REACT_APP_ENABLE_AI_FEATURES=true` 2. Verifica che `REACT_APP_MOCK_AI_RESPONSES=false` 3. Controlla la console per errori di configurazione  ---  ## 🔄 Migration da Versione Precedente  Se stai migrando da una versione con API key hardcoddata:  ### 1. Backup dei Dati ```bash # Esporta i tuoi dati dall'app prima della migrazione ```  ### 2. Update del Codice ```bash git pull origin main npm install ```  ### 3. Setup Environment ```bash cp .env.example .env.local # Aggiungi la tua API key a .env.local ```  ### 4. Rimuovi API Key dal Codice (se presente) - ⚠️ Non lasciare API keys nel codice sorgente - Le credenziali ora vengono caricate da environment variables  ---  ## 📋 Checklist Sicurezza  ### Prima del Deploy - [ ] Nessuna API key nel codice sorgente - [ ] File `.env.local` non committato - [ ] Variabili d'ambiente configurate nel hosting provider - [ ] API key valida e funzionante - [ ] Test delle funzionalità AI in production  ### Manutenzione Periodica - [ ] Rotazione delle API keys ogni 6-12 mesi - [ ] Monitoring dell'uso delle API - [ ] Review dei permessi e accessi - [ ] Backup delle configurazioni  ---  ## 🆘 Supporto  ### Documentation - [Google AI Studio](https://makersuite.google.com/) - [Gemini API Documentation](https://ai.google.dev/docs) - [React Environment Variables](https://create-react-app.dev/docs/adding-custom-environment-variables/)  ### In caso di problemi di sicurezza 1. **Rimuovi immediatamente** credenziali compromesse dal codice 2. **Rigenera** tutte le API keys interessate 3. **Forza push** del repository pulito 4. **Verifica** che nessuna credenziale sia esposta  ---  **⚠️ Ricorda: La sicurezza è responsabilità di tutti. Mai committare credenziali!**

================================================================================

NOME FILE: tailwind.config.js

// tailwind.config.js // This file is part of the Tailwind CSS configuration for the Vocabulary Learning App. // It defines the content paths, theme extensions, colors, border radii, keyframes, and animations used throughout the application. // The configuration allows for custom styling and theming, ensuring a consistent look and feel across the application. // It is essential for building the application's styles and ensuring a responsive and modern user interface.  module.exports = {   content: [     "./src/**/*.{js,jsx,ts,tsx}",     "./public/index.html"   ],   theme: {     extend: {       colors: {         border: "hsl(var(--border))",         input: "hsl(var(--input))",         ring: "hsl(var(--ring))",         background: "hsl(var(--background))",         foreground: "hsl(var(--foreground))",         primary: {           DEFAULT: "hsl(var(--primary))",           foreground: "hsl(var(--primary-foreground))",         },         secondary: {           DEFAULT: "hsl(var(--secondary))",           foreground: "hsl(var(--secondary-foreground))",         },         destructive: {           DEFAULT: "hsl(var(--destructive))",           foreground: "hsl(var(--destructive-foreground))",         },         muted: {           DEFAULT: "hsl(var(--muted))",           foreground: "hsl(var(--muted-foreground))",         },         accent: {           DEFAULT: "hsl(var(--accent))",           foreground: "hsl(var(--accent-foreground))",         },         popover: {           DEFAULT: "hsl(var(--popover))",           foreground: "hsl(var(--popover-foreground))",         },         card: {           DEFAULT: "hsl(var(--card))",           foreground: "hsl(var(--card-foreground))",         },       },       borderRadius: {         lg: "var(--radius)",         md: "calc(var(--radius) - 2px)",         sm: "calc(var(--radius) - 4px)",       },       keyframes: {         "accordion-down": {           from: { height: 0 },           to: { height: "var(--radix-accordion-content-height)" },         },         "accordion-up": {           from: { height: "var(--radix-accordion-content-height)" },           to: { height: 0 },         },         "fade-in": {           "0%": { opacity: 0 },           "100%": { opacity: 1 },         },         "slide-in": {           "0%": { transform: "translateY(20px)", opacity: 0 },           "100%": { transform: "translateY(0)", opacity: 1 },         },       },       animation: {         "accordion-down": "accordion-down 0.2s ease-out",         "accordion-up": "accordion-up 0.2s ease-out",         "fade-in": "fade-in 0.5s ease-out",         "slide-in": "slide-in 0.3s ease-out",       },     },   },   plugins: [], }

================================================================================

NOME FILE: public\index.html

<!--  /public/index.html  This file is the main HTML template for the Vocabulary Learning App. --> <!DOCTYPE html> <html lang="it"> <head>     <meta charset="utf-8" />     <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />     <meta name="viewport" content="width=device-width, initial-scale=1" />     <meta name="theme-color" content="#000000" />     <meta             name="description"             content="App per lo studio del vocabolario inglese con statistiche avanzate"     />     <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />     <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />     <title>📚 Vocabulary Learning App</title> </head> <body> <noscript>È necessario abilitare JavaScript per utilizzare questa app.</noscript> <div id="root"></div> </body> </html>

================================================================================

NOME FILE: scripts\config-status.js

#!/usr/bin/env node  // ===================================================== // 📁 scripts/config-status.js - Configuration Status Check // =====================================================  const fs = require('fs'); const path = require('path');  // Colors for console output const colors = {   reset: '\x1b[0m',   bright: '\x1b[1m',   red: '\x1b[31m',   green: '\x1b[32m',   yellow: '\x1b[33m',   blue: '\x1b[34m',   magenta: '\x1b[35m',   cyan: '\x1b[36m' };  function colorize(text, color) {   return `${colors[color]}${text}${colors.reset}`; }  function logHeader(text) {   console.log('\n' + colorize('='.repeat(60), 'cyan'));   console.log(colorize(`🔧 ${text}`, 'cyan'));   console.log(colorize('='.repeat(60), 'cyan')); }  function logSection(text) {   console.log('\n' + colorize(`📋 ${text}`, 'blue'));   console.log(colorize('-'.repeat(40), 'blue')); }  function logSuccess(text) {   console.log(colorize(`✅ ${text}`, 'green')); }  function logWarning(text) {   console.log(colorize(`⚠️  ${text}`, 'yellow')); }  function logError(text) {   console.log(colorize(`❌ ${text}`, 'red')); }  function logInfo(text) {   console.log(colorize(`ℹ️  ${text}`, 'blue')); }  // Check if file exists function fileExists(filePath) {   try {     return fs.existsSync(path.resolve(filePath));   } catch (error) {     return false;   } }  // Read environment variable from .env files function readEnvFile(filePath) {   try {     if (!fileExists(filePath)) return {};          const content = fs.readFileSync(path.resolve(filePath), 'utf8');     const env = {};          content.split('\n').forEach(line => {       line = line.trim();       if (line && !line.startsWith('#')) {         const [key, ...valueParts] = line.split('=');         if (key && valueParts.length > 0) {           env[key.trim()] = valueParts.join('=').trim();         }       }     });          return env;   } catch (error) {     return {};   } }  // Get environment variable value function getEnvVar(key, envFiles = []) {   // Check process.env first (runtime environment)   if (process.env[key]) {     return process.env[key];   }      // Check .env files   for (const envFile of envFiles) {     const env = readEnvFile(envFile);     if (env[key]) {       return env[key];     }   }      return undefined; }  // Validate API key format function validateApiKey(apiKey) {   if (!apiKey) return { valid: false, reason: 'Missing' };   if (apiKey.length < 20) return { valid: false, reason: 'Too short' };   if (apiKey === 'your_gemini_api_key_here') return { valid: false, reason: 'Default template value' };   if (apiKey === 'your_api_key_here') return { valid: false, reason: 'Default template value' };   return { valid: true, reason: 'Valid format' }; }  // Main configuration check function checkConfiguration() {   logHeader('Vocabulary Master - Configuration Status');      // Environment files to check   const envFiles = ['.env.local', '.env.development', '.env'];      logSection('Environment Files');      let hasEnvFile = false;   envFiles.forEach(file => {     if (fileExists(file)) {       logSuccess(`Found: ${file}`);       hasEnvFile = true;     } else {       logInfo(`Not found: ${file}`);     }   });      if (!hasEnvFile) {     logWarning('No environment files found');     logInfo('Run: npm run setup:env');   }      // Check example file   if (fileExists('.env.example')) {     logSuccess('Template file: .env.example');   } else {     logError('Missing: .env.example template');   }      logSection('Environment Variables');      // Required variables   const requiredVars = [     { key: 'REACT_APP_GEMINI_API_KEY', description: 'Gemini AI API Key', required: true }   ];      // Optional variables   const optionalVars = [     { key: 'REACT_APP_ENVIRONMENT', description: 'App Environment' },     { key: 'REACT_APP_DEBUG_LOGGING', description: 'Debug Logging' },     { key: 'REACT_APP_ENABLE_AI_FEATURES', description: 'AI Features Enabled' },     { key: 'REACT_APP_MOCK_AI_RESPONSES', description: 'Mock AI Responses' },     { key: 'REACT_APP_AI_TIMEOUT', description: 'AI Request Timeout' },     { key: 'REACT_APP_AI_MAX_RETRIES', description: 'AI Max Retries' }   ];      let allConfigured = true;      // Check required variables   console.log('\n' + colorize('Required Variables:', 'bright'));   requiredVars.forEach(({ key, description, required }) => {     const value = getEnvVar(key, envFiles);          if (value) {       if (key === 'REACT_APP_GEMINI_API_KEY') {         const validation = validateApiKey(value);         if (validation.valid) {           logSuccess(`${key}: Configured (${validation.reason})`);         } else {           logError(`${key}: ${validation.reason}`);           allConfigured = false;         }       } else {         logSuccess(`${key}: ${value}`);       }     } else {       if (required) {         logError(`${key}: Missing (${description})`);         allConfigured = false;       } else {         logWarning(`${key}: Not set (${description})`);       }     }   });      // Check optional variables   console.log('\n' + colorize('Optional Variables:', 'bright'));   optionalVars.forEach(({ key, description }) => {     const value = getEnvVar(key, envFiles);     if (value) {       logInfo(`${key}: ${value}`);     } else {       logInfo(`${key}: Using default`);     }   });      logSection('Configuration Status');      // Overall status   if (allConfigured) {     logSuccess('Configuration is complete!');     logSuccess('All required variables are properly set');   } else {     logError('Configuration is incomplete!');     logError('Some required variables are missing or invalid');   }      // Feature availability   const apiKey = getEnvVar('REACT_APP_GEMINI_API_KEY', envFiles);   const aiEnabled = getEnvVar('REACT_APP_ENABLE_AI_FEATURES', envFiles);   const mockMode = getEnvVar('REACT_APP_MOCK_AI_RESPONSES', envFiles);      console.log('\n' + colorize('Feature Availability:', 'bright'));      if (apiKey && validateApiKey(apiKey).valid) {     if (aiEnabled === 'false') {       logWarning('AI Features: Disabled by configuration');     } else {       logSuccess('AI Features: Available');     }   } else {     if (mockMode === 'true') {       logWarning('AI Features: Mock mode (no real API calls)');     } else {       logError('AI Features: Unavailable (no valid API key)');     }   }      logSection('Security Check');      // Check for hardcoded credentials with smart filtering   const sourceFiles = [     'src/constants/appConstants.js',     'src/services/aiService.js',     'src/config/appConfig.js'   ];      let securityIssues = false;      sourceFiles.forEach(file => {     if (fileExists(file)) {       try {         const content = fs.readFileSync(path.resolve(file), 'utf8');                  // Smart patterns that avoid false positives         const suspiciousPatterns = [           {             pattern: /['"]AIzaSy[0-9A-Za-z-_]{33}['"]/g,             name: 'Google API Key'           },           {             pattern: /apiKey\s*[:=]\s*['"][A-Za-z0-9-_]{20,}['"]/g,             name: 'Hardcoded API Key'           }         ];                  let fileHasIssues = false;                  suspiciousPatterns.forEach(({ pattern, name }) => {           const matches = content.match(pattern);           if (matches) {             // Filter out false positives             const realMatches = matches.filter(match => {               // Skip placeholder values               if (match.includes('your_api_key') ||                    match.includes('your_key_here') ||                    match.includes('example') ||                    match.includes('placeholder')) {                 return false;               }                              // Check if it's in a comment               const lines = content.split('\n');               const matchLine = lines.find(line => line.includes(match));               if (matchLine && (matchLine.trim().startsWith('//') ||                                matchLine.trim().startsWith('*') ||                               matchLine.includes('RIMOSSA PER SICUREZZA'))) {                 return false;               }                              return true;             });                          if (realMatches.length > 0) {               fileHasIssues = true;             }           }         });                  if (fileHasIssues) {           logError(`Real security issues in: ${file}`);           securityIssues = true;         } else {           logSuccess(`Clean: ${file}`);         }       } catch (error) {         logWarning(`Could not check: ${file}`);       }     }   });      if (!securityIssues) {     logSuccess('No hardcoded credentials detected');   } else {     logError('Security issues found! Remove hardcoded credentials');   }      logSection('Recommendations');      if (!allConfigured) {     console.log('\n' + colorize('To fix configuration issues:', 'yellow'));     console.log('1. Copy template: ' + colorize('cp .env.example .env.local', 'cyan'));     console.log('2. Get API key: ' + colorize('https://makersuite.google.com/app/apikey', 'cyan'));     console.log('3. Add API key to .env.local');     console.log('4. Restart development server');   }      if (securityIssues) {     console.log('\n' + colorize('To fix security issues:', 'red'));     console.log('1. Remove hardcoded credentials from source files');     console.log('2. Use environment variables instead');     console.log('3. Commit clean code only');   }      console.log('\n' + colorize('For more help:', 'blue'));   console.log('📖 Read: SECURITY_SETUP.md');   console.log('🔧 Run: npm run setup:env');      logHeader('Configuration Check Complete');      // Exit with appropriate code   process.exit(allConfigured && !securityIssues ? 0 : 1); }  // Run the check if (require.main === module) {   checkConfiguration(); }  module.exports = { checkConfiguration };

================================================================================

NOME FILE: scripts\security-check.js

#!/usr/bin/env node  // ===================================================== // 📁 scripts/security-check.js - Security Audit Script // =====================================================  const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process');  // Colors for console output const colors = {   reset: '\x1b[0m',   bright: '\x1b[1m',   red: '\x1b[31m',   green: '\x1b[32m',   yellow: '\x1b[33m',   blue: '\x1b[34m',   magenta: '\x1b[35m',   cyan: '\x1b[36m' };  function colorize(text, color) {   return `${colors[color]}${text}${colors.reset}`; }  function logHeader(text) {   console.log('\n' + colorize('='.repeat(60), 'magenta'));   console.log(colorize(`🔐 ${text}`, 'magenta'));   console.log(colorize('='.repeat(60), 'magenta')); }  function logSection(text) {   console.log('\n' + colorize(`🔍 ${text}`, 'blue'));   console.log(colorize('-'.repeat(40), 'blue')); }  function logSuccess(text) {   console.log(colorize(`✅ ${text}`, 'green')); }  function logWarning(text) {   console.log(colorize(`⚠️  ${text}`, 'yellow')); }  function logError(text) {   console.log(colorize(`🚨 ${text}`, 'red')); }  function logInfo(text) {   console.log(colorize(`ℹ️  ${text}`, 'blue')); }  function logCritical(text) {   console.log(colorize(`💥 CRITICAL: ${text}`, 'red')); }  // Check if file exists function fileExists(filePath) {   try {     return fs.existsSync(path.resolve(filePath));   } catch (error) {     return false;   } }  // Get all files in directory recursively function getAllFiles(dirPath, arrayOfFiles = []) {   const files = fs.readdirSync(dirPath);    files.forEach(file => {     const fullPath = path.join(dirPath, file);     if (fs.statSync(fullPath).isDirectory()) {       // Skip node_modules, build, and other non-source directories       if (!['node_modules', 'build', '.git', 'dist', 'coverage'].includes(file)) {         arrayOfFiles = getAllFiles(fullPath, arrayOfFiles);       }     } else {       arrayOfFiles.push(fullPath);     }   });    return arrayOfFiles; }  // Security patterns to check for const SECURITY_PATTERNS = [   {     name: 'Google API Keys',     pattern: /['"]AIzaSy[0-9A-Za-z-_]{33}['"]/g,     severity: 'CRITICAL',     description: 'Google API key detected'   },   {     name: 'Hardcoded API Keys',     pattern: /apiKey\s*[:=]\s*['"][A-Za-z0-9-_]{20,}['"]/g,     severity: 'HIGH',     description: 'Hardcoded API key'   },   {     name: 'Environment Variables in Code',     pattern: /REACT_APP_[A-Z_]+\s*[:=]\s*['"][^'"]+['"]/g,     severity: 'MEDIUM',     description: 'Environment variable with hardcoded value'   },   {     name: 'AWS Keys',     pattern: /AKIA[0-9A-Z]{16}/g,     severity: 'CRITICAL',     description: 'AWS access key detected'   },   {     name: 'Private Keys',     pattern: /-----BEGIN [A-Z ]+PRIVATE KEY-----/g,     severity: 'CRITICAL',     description: 'Private key detected'   },   {     name: 'Database URLs',     pattern: /(mongodb|postgres|mysql):\/\/[^\s'"]+/g,     severity: 'HIGH',     description: 'Database connection string'   },   {     name: 'JWT Tokens',     pattern: /eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*/g,     severity: 'HIGH',     description: 'JWT token detected'   },   {     name: 'Slack Tokens',     pattern: /xox[bpoa]-[0-9]{12}-[0-9]{12}-[0-9]{12}-[a-z0-9]{32}/g,     severity: 'HIGH',     description: 'Slack token detected'   } ];  // File extensions to check const CHECK_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.json', '.env', '.md', '.yml', '.yaml'];  // Files that should never contain credentials const CRITICAL_FILES = [   'package.json',   'package-lock.json',   'yarn.lock',   'README.md',   'SECURITY_SETUP.md' ];  function checkFileForSecrets(filePath) {   try {     const content = fs.readFileSync(filePath, 'utf8');     const issues = [];          // Skip checking template files and examples     const fileName = path.basename(filePath);     if (fileName.includes('.example') || fileName.includes('template') || fileName.includes('sample')) {       return issues;     }          SECURITY_PATTERNS.forEach(({ name, pattern, severity, description }) => {       const matches = content.match(pattern);       if (matches) {         // Filter out false positives         const realMatches = matches.filter(match => {           // Skip comments and documentation           const lines = content.split('\n');           const matchLine = lines.find(line => line.includes(match));           if (matchLine && (matchLine.trim().startsWith('//') || matchLine.trim().startsWith('*') || matchLine.includes('example') || matchLine.includes('your_api_key'))) {             return false;           }                      // Skip placeholder values           if (match.includes('your_api_key') || match.includes('your_key_here') || match.includes('example') || match.includes('placeholder')) {             return false;           }                      return true;         });                  realMatches.forEach(match => {           issues.push({             file: filePath,             pattern: name,             severity,             description,             match: match.substring(0, 50) + (match.length > 50 ? '...' : ''),             line: content.substring(0, content.indexOf(match)).split('\n').length           });         });       }     });          return issues;   } catch (error) {     return [];   } }  function checkGitignore() {   logSection('Git Ignore Check');      const gitignorePath = '.gitignore';   const requiredPatterns = [     '.env',     '.env.local',     '.env.development.local',     '.env.test.local',     '.env.production.local',     '*.backup',     '*.bak',     '*-secrets.*',     '*-credentials.*'   ];      if (!fileExists(gitignorePath)) {     logError('No .gitignore file found');     return false;   }      const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');   const missingPatterns = [];      requiredPatterns.forEach(pattern => {     if (!gitignoreContent.includes(pattern)) {       missingPatterns.push(pattern);     }   });      if (missingPatterns.length === 0) {     logSuccess('Git ignore properly configured');     return true;   } else {     logWarning(`Missing patterns in .gitignore: ${missingPatterns.join(', ')}`);     return false;   } }  function checkEnvironmentFiles() {   logSection('Environment Files Check');      const envFiles = ['.env', '.env.local', '.env.development', '.env.production'];   let hasIssues = false;      envFiles.forEach(file => {     if (fileExists(file)) {       if (file === '.env.example') {         logSuccess(`Template file found: ${file}`);       } else {         logWarning(`Environment file detected: ${file}`);         logInfo('Ensure this file is in .gitignore and contains no real credentials');                  // Check if it's tracked by git         try {           execSync(`git ls-files --error-unmatch ${file}`, { stdio: 'ignore' });           logCritical(`Environment file ${file} is tracked by Git!`);           hasIssues = true;         } catch (error) {           logSuccess(`Environment file ${file} is not tracked by Git`);         }       }     }   });      return !hasIssues; }  function checkCommitHistory() {   logSection('Git History Check');      try {     // Check recent commits for potential credential leaks     const recentCommits = execSync('git log --oneline -10 --grep="key\\|secret\\|password\\|token" -i', {        encoding: 'utf8',       stdio: 'pipe'     });          if (recentCommits.trim()) {       logWarning('Found commits with potential credential-related messages:');       console.log(recentCommits);     } else {       logSuccess('No suspicious commit messages found');     }          return true;   } catch (error) {     logInfo('Could not check git history (no git repository or no commits)');     return true;   } }  function runNpmAudit() {   logSection('NPM Security Audit');      try {     const auditResult = execSync('npm audit --audit-level=moderate --json', {        encoding: 'utf8',       stdio: 'pipe'     });          const audit = JSON.parse(auditResult);          if (audit.metadata.vulnerabilities.total === 0) {       logSuccess('No security vulnerabilities found in dependencies');       return true;     } else {       const { info, low, moderate, high, critical } = audit.metadata.vulnerabilities;              if (critical > 0) {         logCritical(`${critical} critical vulnerabilities found`);       }       if (high > 0) {         logError(`${high} high vulnerabilities found`);       }       if (moderate > 0) {         logWarning(`${moderate} moderate vulnerabilities found`);       }       if (low > 0) {         logInfo(`${low} low vulnerabilities found`);       }       if (info > 0) {         logInfo(`${info} info vulnerabilities found`);       }              logInfo('Run "npm audit fix" to attempt automatic fixes');       return critical === 0 && high === 0; // Allow moderate and below     }   } catch (error) {     try {       // Try without JSON flag for older npm versions       execSync('npm audit', { stdio: 'inherit' });       return true;     } catch (error2) {       logWarning('Could not run npm audit');       return true;     }   } }  function main() {   logHeader('Security Audit - Vocabulary Master');      let overallSecure = true;   let criticalIssues = 0;   let highIssues = 0;   let mediumIssues = 0;      // Check for hardcoded secrets in files   logSection('Source Code Secret Scan');      try {     const allFiles = getAllFiles('./src');     const sourceFiles = allFiles.filter(file =>        CHECK_EXTENSIONS.some(ext => file.endsWith(ext))     );          let totalIssues = 0;          sourceFiles.forEach(file => {       const issues = checkFileForSecrets(file);       if (issues.length > 0) {         issues.forEach(issue => {           totalIssues++;           const icon = issue.severity === 'CRITICAL' ? '💥' :                        issue.severity === 'HIGH' ? '🚨' : '⚠️';                      console.log(`${icon} ${colorize(issue.severity, 'red')} in ${colorize(issue.file, 'yellow')}:${issue.line}`);           console.log(`   ${issue.description}: ${colorize(issue.match, 'red')}`);                      if (issue.severity === 'CRITICAL') criticalIssues++;           else if (issue.severity === 'HIGH') highIssues++;           else mediumIssues++;         });       }     });          if (totalIssues === 0) {       logSuccess('No secrets detected in source code');     } else {       logError(`Found ${totalIssues} potential security issues`);       overallSecure = false;     }   } catch (error) {     logWarning('Could not scan source files');   }      // Check critical files   logSection('Critical Files Check');      CRITICAL_FILES.forEach(file => {     if (fileExists(file)) {       const issues = checkFileForSecrets(file);       if (issues.length > 0) {         logCritical(`Secrets found in critical file: ${file}`);         criticalIssues += issues.length;         overallSecure = false;       } else {         logSuccess(`Clean: ${file}`);       }     }   });      // Run other checks   const gitignoreOk = checkGitignore();   const envFilesOk = checkEnvironmentFiles();   const commitHistoryOk = checkCommitHistory();   const npmAuditOk = runNpmAudit();      overallSecure = overallSecure && gitignoreOk && envFilesOk && commitHistoryOk && npmAuditOk;      // Final assessment   logSection('Security Assessment');      if (criticalIssues > 0) {     logCritical(`${criticalIssues} critical security issues found`);   }   if (highIssues > 0) {     logError(`${highIssues} high-severity issues found`);   }   if (mediumIssues > 0) {     logWarning(`${mediumIssues} medium-severity issues found`);   }      if (overallSecure && criticalIssues === 0) {     logSuccess('Security audit passed!');     logSuccess('No critical security issues detected');   } else {     logError('Security audit failed!');     logError('Critical security issues must be addressed');   }      // Recommendations   logSection('Security Recommendations');      if (criticalIssues > 0 || highIssues > 0) {     console.log('\n' + colorize('🔥 IMMEDIATE ACTIONS REQUIRED:', 'red'));     console.log('1. Remove all hardcoded credentials from source code');     console.log('2. Move credentials to environment variables');     console.log('3. Add .env* files to .gitignore');     console.log('4. Review git history for leaked credentials');     console.log('5. Regenerate any exposed API keys');   }      console.log('\n' + colorize('🔐 General Security Best Practices:', 'blue'));   console.log('• Use environment variables for all secrets');   console.log('• Keep .env files out of version control');   console.log('• Regularly rotate API keys and credentials');   console.log('• Run security audits before each deployment');   console.log('• Use HTTPS for all external API calls');   console.log('• Keep dependencies updated');      console.log('\n' + colorize('📚 Resources:', 'cyan'));   console.log('• Security Setup Guide: SECURITY_SETUP.md');   console.log('• Environment Config: npm run config:status');   console.log('• Git Secrets Tool: https://github.com/awslabs/git-secrets');      logHeader('Security Audit Complete');      // Exit with appropriate code   const exitCode = (criticalIssues === 0 && overallSecure) ? 0 : 1;   if (exitCode !== 0) {     logError('Security audit failed - fix issues before deployment');   }      process.exit(exitCode); }  // Run the security check if (require.main === module) {   main(); }  module.exports = { main };

================================================================================

NOME FILE: src\App.css

/* App.css - Stili aggiornati per la nuova versione */  * {   margin: 0;   padding: 0;   box-sizing: border-box; }  body {   font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;   background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);   min-height: 100vh;   color: #333; }  .app {   min-height: 100vh;   display: flex;   flex-direction: column; }  /* ===== HEADER MIGLIORATO ===== */ .app-header {   background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);   color: white;   padding: 1.5rem 2rem;   box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); }  .header-content {   max-width: 1200px;   margin: 0 auto;   display: flex;   justify-content: space-between;   align-items: center;   gap: 2rem; }  .header-main h1 {   font-size: 2.2rem;   margin-bottom: 0.5rem;   font-weight: 700; }  .header-main p {   opacity: 0.9;   font-size: 1.1rem; }  .header-stats {   display: flex;   gap: 1.5rem;   align-items: center; }  .header-stat {   text-align: center;   min-width: 60px; }  .header-stat span {   display: block;   font-size: 1.4rem;   font-weight: bold;   line-height: 1; }  .header-stat small {   font-size: 0.8rem;   opacity: 0.8;   margin-top: 0.2rem;   display: block; }  .header-stat.streak span {   font-size: 1.2rem; }  /* ===== NAVIGATION MIGLIORATA ===== */ .app-nav {   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-bottom: 1px solid rgba(0, 0, 0, 0.1);   padding: 0.5rem 0;   position: sticky;   top: 0;   z-index: 100; }  .nav-container {   max-width: 1200px;   margin: 0 auto;   display: flex;   gap: 0.5rem;   padding: 0 1rem;   justify-content: center;   overflow-x: auto; }  .nav-btn {   display: flex;   flex-direction: column;   align-items: center;   gap: 0.3rem;   padding: 0.8rem 1rem;   border: none;   background: transparent;   border-radius: 12px;   cursor: pointer;   transition: all 0.2s ease;   min-width: 80px;   position: relative;   text-decoration: none;   color: #555; }  .nav-btn:hover {   background: rgba(52, 152, 219, 0.1);   transform: translateY(-1px); }  .nav-btn.active {   background: linear-gradient(145deg, #3498db, #2980b9);   color: white;   box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);   transform: translateY(-1px); }  .nav-icon {   font-size: 1.3rem;   line-height: 1; }  .nav-text {   font-size: 0.8rem;   font-weight: 500;   white-space: nowrap; }  .nav-badge {   position: absolute;   top: 0.2rem;   right: 0.2rem;   background: #e74c3c;   color: white;   font-size: 0.7rem;   padding: 0.1rem 0.4rem;   border-radius: 10px;   min-width: 18px;   text-align: center;   line-height: 1.2;   font-weight: bold; }  /* ===== INDICATORE SEZIONE ===== */ .section-indicator {   background: rgba(255, 255, 255, 0.9);   backdrop-filter: blur(10px);   padding: 0.8rem 2rem;   display: flex;   align-items: center;   gap: 0.8rem;   border-bottom: 1px solid rgba(0, 0, 0, 0.05); }  .indicator-icon {   font-size: 1.2rem; }  .indicator-text {   font-weight: 600;   color: #2c3e50;   font-size: 1rem; }  /* ===== MAIN CONTENT ===== */ .app-main {   flex: 1;   max-width: 1200px;   margin: 0 auto;   padding: 2rem;   width: 100%; }  /* ===== SCHERMATA INIZIALE TEST ===== */ .start-test {   text-align: center;   padding: 3rem 2rem; }  .start-test-content {   max-width: 600px;   margin: 0 auto;   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-radius: 20px;   padding: 3rem 2rem;   box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); }  .start-test h2 {   color: #2c3e50;   margin-bottom: 2rem;   font-size: 2rem; }  .test-info {   display: grid;   grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));   gap: 1rem;   margin: 2rem 0; }  .info-card {   background: linear-gradient(145deg, #f8f9fa, #ffffff);   border: 1px solid #e9ecef;   border-radius: 12px;   padding: 1.2rem 0.8rem;   display: flex;   flex-direction: column;   align-items: center;   gap: 0.5rem;   transition: transform 0.2s ease; }  .info-card:hover {   transform: translateY(-2px); }  .info-icon {   font-size: 1.8rem;   line-height: 1; }  .info-card strong {   font-size: 1.5rem;   color: #2c3e50;   font-weight: bold; }  .info-card p {   font-size: 0.8rem;   color: #7f8c8d;   text-align: center;   margin: 0; }  .btn-large {   font-size: 1.1rem;   padding: 1rem 2rem;   margin: 2rem 0 1rem 0; }  .help-text {   color: #7f8c8d;   font-style: italic;   margin-top: 1rem; }  /* ===== PULSANTI GENERALI ===== */ .btn {   padding: 0.8rem 1.5rem;   border: none;   border-radius: 10px;   font-size: 0.95rem;   font-weight: 600;   cursor: pointer;   transition: all 0.2s ease;   display: inline-flex;   align-items: center;   gap: 0.5rem;   text-decoration: none;   justify-content: center; }  .btn:disabled {   opacity: 0.6;   cursor: not-allowed;   transform: none !important; }  .btn-primary {   background: linear-gradient(145deg, #3498db, #2980b9);   color: white;   box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3); }  .btn-primary:hover:not(:disabled) {   background: linear-gradient(145deg, #2980b9, #21618c);   transform: translateY(-2px);   box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4); }  .btn-secondary {   background: linear-gradient(145deg, #95a5a6, #7f8c8d);   color: white;   box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3); }  .btn-secondary:hover:not(:disabled) {   background: linear-gradient(145deg, #7f8c8d, #6c7b7d);   transform: translateY(-2px);   box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4); }  /* ===== ERROR VIEW ===== */ .error-view {   text-align: center;   padding: 3rem 2rem;   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-radius: 20px;   max-width: 500px;   margin: 2rem auto;   box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); }  .error-view h2 {   color: #e74c3c;   margin-bottom: 1rem; }  .error-view p {   color: #7f8c8d;   margin-bottom: 2rem; }  /* ===== FOOTER MIGLIORATO ===== */ .app-footer {   background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);   color: white;   padding: 1.5rem 2rem;   margin-top: auto; }  .footer-content {   max-width: 1200px;   margin: 0 auto;   display: flex;   justify-content: space-between;   align-items: center;   gap: 1rem; }  .footer-info p {   margin: 0;   font-size: 0.95rem; }  .footer-stats {   display: flex;   align-items: center;   gap: 0.8rem;   font-size: 0.9rem;   opacity: 0.9; }  .footer-stats span {   white-space: nowrap; }  /* ===== RESPONSIVE DESIGN ===== */ @media (max-width: 768px) {   .app-header {     padding: 1rem;   }      .header-content {     flex-direction: column;     gap: 1rem;     text-align: center;   }      .header-main h1 {     font-size: 1.8rem;   }      .header-main p {     font-size: 1rem;   }      .header-stats {     gap: 1rem;   }      .nav-container {     padding: 0 0.5rem;     gap: 0.2rem;   }      .nav-btn {     min-width: 60px;     padding: 0.6rem 0.5rem;   }      .nav-text {     font-size: 0.7rem;   }      .section-indicator {     padding: 0.6rem 1rem;   }      .app-main {     padding: 1rem;   }      .start-test-content {     padding: 2rem 1rem;   }      .test-info {     grid-template-columns: repeat(2, 1fr);     gap: 0.8rem;   }      .info-card {     padding: 1rem 0.5rem;   }      .footer-content {     flex-direction: column;     gap: 0.8rem;     text-align: center;   }      .footer-stats {     flex-wrap: wrap;     justify-content: center;   } }  @media (max-width: 480px) {   .header-main h1 {     font-size: 1.5rem;   }      .test-info {     grid-template-columns: 1fr;   }      .nav-text {     display: none;   }      .nav-btn {     min-width: 50px;     padding: 0.8rem 0.3rem;   }      .indicator-text {     font-size: 0.9rem;   } }  /* ===== ANIMAZIONI ===== */ @keyframes slideIn {   from {     opacity: 0;     transform: translateY(20px);   }   to {     opacity: 1;     transform: translateY(0);   } }  @keyframes fadeIn {   from {     opacity: 0;   }   to {     opacity: 1;   } }  .app-main > * {   animation: slideIn 0.3s ease-out; }  .nav-btn {   animation: fadeIn 0.2s ease-out; }  /* ===== FOCUS E ACCESSIBILITÀ ===== */ .nav-btn:focus, .btn:focus {   outline: 2px solid #3498db;   outline-offset: 2px; }  .nav-btn.active:focus {   outline-color: rgba(255, 255, 255, 0.8); }  @media (prefers-reduced-motion: reduce) {   *,   *::before,   *::after {     animation-duration: 0.01ms !important;     animation-iteration-count: 1 !important;     transition-duration: 0.01ms !important;   } }

================================================================================

NOME FILE: src\App.js

// ===================================================== // 📁 src/App.js - VERSIONE PULITA (Dual-System Rimosso) // =====================================================  import React from 'react'; import { AppProvider } from './contexts/AppContext'; import { NotificationProvider } from './contexts/NotificationContext'; import { AppLayout } from './layouts/AppLayout'; import { AppRouter } from './components/AppRouter'; import { ErrorBoundary } from './components/ErrorBoundary'; import './App.css';  // ===================================================== // 🧹 CLEANED: App Component (Dual-System Rimosso) // ===================================================== const VocabularyApp = () => {   return (     <ErrorBoundary>       <NotificationProvider>         <AppProvider>           <AppLayout>             <AppRouter />           </AppLayout>         </AppProvider>       </NotificationProvider>     </ErrorBoundary>   ); };  export default VocabularyApp;

================================================================================

NOME FILE: src\index.css

/* /src/index.css This file contains the main CSS styles for the application, including Tailwind CSS imports and custom styles. */ @tailwind base; @tailwind components; @tailwind utilities;  /* Stili di base */ * {   margin: 0;   padding: 0;   box-sizing: border-box; }  body {   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',     'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',     sans-serif;   -webkit-font-smoothing: antialiased;   -moz-osx-font-smoothing: grayscale; }  code {   font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',     monospace; }  /* Utilità personalizzate */ @layer utilities {   .text-balance {     text-wrap: balance;   } }

================================================================================

NOME FILE: src\index.js

// /src/index.js // This file is the entry point for the React application. // It imports the necessary styles and renders the main App component into the root element of the HTML document. // It uses ReactDOM to create a root and render the App component wrapped in React.StrictMode. // This setup ensures that the application is ready for development and production builds with React's best practices. // It is essential for initializing the React application and providing a consistent structure for rendering components.  import React from 'react'; import ReactDOM from 'react-dom/client'; import './index.css'; import App from './App';  const root = ReactDOM.createRoot(document.getElementById('root')); root.render(   <React.StrictMode>     <App />   </React.StrictMode> ); 

================================================================================

NOME FILE: src\config\appConfig.js

// ===================================================== // 📁 src/config/appConfig.js - Secure Configuration per Vocabulary Master // =====================================================  /**  * Configurazione sicura che sostituisce le credenziali hardcodate  */  // Helper per leggere environment variables const getEnvVar = (key, defaultValue = undefined) => {   const value = process.env[key];      // Handle boolean strings   if (value === 'true') return true;   if (value === 'false') return false;      // Handle numeric strings     if (value && !isNaN(value) && !isNaN(parseFloat(value))) {     return parseFloat(value);   }      return value || defaultValue; };  // ====== MAIN CONFIGURATION ====== export const AppConfig = {      // App Metadata (identico al tuo APP_CONFIG)   app: {     name: 'Vocabulary Master',     version: '2.0.0',      description: 'La tua app intelligente per imparare l\'inglese',     environment: getEnvVar('REACT_APP_ENVIRONMENT', 'development')   },    // AI Configuration (sostituisce il tuo AI_CONFIG hardcodato)   ai: {     // SICURO: API key da environment variable invece di hardcoded     apiKey: getEnvVar('REACT_APP_GEMINI_API_KEY'),          // Stesso URL che usavi prima     baseUrl: getEnvVar(       'REACT_APP_GEMINI_API_URL',       'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent'     ),          // Stessi valori che avevi prima     timeout: getEnvVar('REACT_APP_AI_TIMEOUT', 15000),     maxRetries: getEnvVar('REACT_APP_AI_MAX_RETRIES', 3),      retryDelay: getEnvVar('REACT_APP_AI_RETRY_DELAY', 1000),          // Feature flags     enabled: getEnvVar('REACT_APP_ENABLE_AI_FEATURES', true),     mockResponses: getEnvVar('REACT_APP_MOCK_AI_RESPONSES', false)   },    // Test Configuration (identico al tuo TEST_CONFIG)   test: {     warningThresholds: {       slow: 25,       verySlow: 40     },     autoAdvanceDelay: 1500,     hintCooldown: 3000,     maxHintsPerWord: 1,     scoring: {       excellent: 80,       good: 60,       victory: 80     }   },    // Statistics Configuration (identico al tuo STATS_CONFIG)   stats: {     performance: {       excellent: 90,       good: 75,       average: 60,       needsWork: 40     },     maxHistorySize: 1000,     maxRecentTests: 20,     charts: {       maxTimelinePoints: 20,       defaultChartHeight: 300     }   },    // Storage Configuration (identico al tuo STORAGE_CONFIG)   storage: {     keys: {       words: 'vocabulary_words',       stats: 'vocabulary_stats',       testHistory: 'vocabulary_test_history',        settings: 'vocabulary_settings',       wordPerformance: 'wordPerformance'     }   },    // Word Configuration (identico al tuo WORD_CONFIG)   word: {     maxWordLength: 100,     maxTranslationLength: 200,     maxNotesLength: 1000,     maxSentenceLength: 300,     maxChapterLength: 20,     requiredFields: ['english', 'italian'],     optionalFields: ['group', 'sentence', 'notes', 'chapter', 'learned', 'difficult']   },    // UI Configuration (identico al tuo UI_CONFIG)   ui: {     animations: {       fast: 150,       normal: 300,       slow: 500,       cardFlip: 700     },     notifications: {       defaultDuration: 3000,       maxVisible: 5     }   } };  // ====== ERROR MESSAGES (identici ai tuoi) ====== export const ERROR_MESSAGES = {   network: 'Errore di connessione. Controlla la tua connessione internet.',   ai: 'Servizio AI temporaneamente non disponibile. Riprova più tardi.',   aiNotConfigured: 'Servizio AI non configurato. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local',   storage: 'Errore nel salvataggio dei dati. Controlla lo spazio disponibile.',   validation: 'Dati non validi. Controlla i campi obbligatori.',   import: 'Errore durante l\'importazione. Verifica il formato del file.',   export: 'Errore durante l\'esportazione. Riprova.',   generic: 'Si è verificato un errore imprevisto.',   wordNotFound: 'Parola non trovata.',   noWordsAvailable: 'Nessuna parola disponibile per il test.' };  // ====== SUCCESS MESSAGES (identici ai tuoi) ====== export const SUCCESS_MESSAGES = {   wordAdded: 'Parola aggiunta con successo!',   wordUpdated: 'Parola modificata con successo!',   wordDeleted: 'Parola eliminata con successo!',   testCompleted: 'Test completato!',   dataExported: 'Dati esportati con successo!',   dataImported: 'Dati importati con successo!',   settingsSaved: 'Impostazioni salvate!' };  // ====== UTILITY FUNCTIONS ======  /**  * Check if AI is available (has API key)  */ export const isAIAvailable = () => {   return AppConfig.ai.enabled && !!AppConfig.ai.apiKey; };  /**  * Get configuration status  */ export const getConfigurationStatus = () => {   return {     isValid: !!AppConfig.ai.apiKey,     environment: AppConfig.app.environment,     aiConfigured: !!AppConfig.ai.apiKey,     features: {       aiEnabled: isAIAvailable(),       mockMode: AppConfig.ai.mockResponses     }   }; };  // Debug logging se abilitato if (AppConfig.app.environment === 'development') {   const status = getConfigurationStatus();   console.log('🔧 Vocabulary Master Configuration:', {     aiConfigured: status.aiConfigured,     environment: status.environment,     features: status.features   });      if (!status.aiConfigured) {     console.warn('⚠️ AI Service: API key non configurata. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local');   } }  export default AppConfig;

================================================================================


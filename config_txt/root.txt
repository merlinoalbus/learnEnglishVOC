NOME FILE: docker-compose.yml

# ===================================================== # 🐳 docker-compose.yml - LearnEnglishVOC (Updated with ENV support) # =====================================================  version: '3.8'  networks:   learnenglishvoc_network:     driver: bridge  services:   # ====== PRODUCTION SERVICE (existing) ======   learnenglishvoc:     container_name: learnenglishvoc     image: ghcr.io/merlinoalbus/learnenglishvoc:latest          # ====== ENVIRONMENT VARIABLES (NUOVO) ======     environment:       # CRITICO: API key deve essere passata dall'esterno       # Usa: export REACT_APP_GEMINI_API_KEY=your_key prima di docker-compose up       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}              # Configurazione production       - REACT_APP_ENVIRONMENT=production       - REACT_APP_DEBUG_LOGGING=false       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_AI_TIMEOUT=15000       - REACT_APP_AI_MAX_RETRIES=3       - REACT_APP_MOCK_AI_RESPONSES=false          # ====== RESOURCE LIMITS (existing) ======     deploy:       resources:         limits:           cpus: '0.5'           memory: 512M         reservations:           cpus: '0.1'           memory: 128M          # ====== NETWORKING & PORTS (existing) ======     networks:       - learnenglishvoc_network     ports:       - '12345:80'          # ====== RELIABILITY ======     restart: unless-stopped          # ====== HEALTH CHECK (NUOVO) ======     healthcheck:       test: ["CMD", "curl", "-f", "http://localhost/health", "||", "curl", "-f", "http://localhost/"]       interval: 30s       timeout: 10s       retries: 3       start_period: 40s      # ====== DEVELOPMENT SERVICE (NUOVO - opzionale) ======   learnenglishvoc-dev:     profiles: ["dev"]     container_name: learnenglishvoc-dev     build:       context: .       dockerfile: Dockerfile.dev          environment:       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}       - REACT_APP_ENVIRONMENT=development       - REACT_APP_DEBUG_LOGGING=true       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_MOCK_AI_RESPONSES=false          # Carica da .env.local se esiste (per development)     env_file:       - .env.local          ports:       - '3000:3000'          volumes:       - .:/app       - /app/node_modules          networks:       - learnenglishvoc_network          command: npm start    # ====== STAGING SERVICE (NUOVO - opzionale) ======   learnenglishvoc-staging:     profiles: ["staging"]     container_name: learnenglishvoc-staging     image: ghcr.io/merlinoalbus/learnenglishvoc:latest          environment:       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}       - REACT_APP_ENVIRONMENT=staging       - REACT_APP_DEBUG_LOGGING=true       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_AI_TIMEOUT=15000       - REACT_APP_AI_MAX_RETRIES=3          deploy:       resources:         limits:           cpus: '0.3'           memory: 256M         reservations:           cpus: '0.1'           memory: 64M          networks:       - learnenglishvoc_network          ports:       - '8080:80'          restart: unless-stopped          healthcheck:       test: ["CMD", "curl", "-f", "http://localhost/"]       interval: 30s       timeout: 10s       retries: 3  # ===================================================== # 🔐 DEPLOYMENT INSTRUCTIONS: #  # PRODUCTION (existing service): # export REACT_APP_GEMINI_API_KEY=your_production_api_key # docker-compose up -d learnenglishvoc #  # DEVELOPMENT (new service): # echo "REACT_APP_GEMINI_API_KEY=your_dev_key" > .env.local # docker-compose --profile dev up #  # STAGING (new service): # export REACT_APP_GEMINI_API_KEY=your_staging_key # docker-compose --profile staging up -d #  # CHECK STATUS: # docker-compose ps # docker-compose logs learnenglishvoc #  # =====================================================

================================================================================

NOME FILE: Dockerfile

# ===================================================== # 🐳 Dockerfile - Vocabulary Master (WORKING FIX) # =====================================================  # Multi-stage build ottimizzato FROM node:18-alpine AS builder  # Set working directory WORKDIR /app  # ====== OPTIMIZATION 1: Cache dependencies separatamente ====== # Copy SOLO package files per cache layer COPY package*.json ./  # ====== OPTIMIZATION 3: npm ci ottimizzato ====== RUN npm ci --omit=dev --prefer-offline --no-audit --progress=false && \     npm cache clean --force  # ====== BUILD ARGS (tutti necessari) ====== ARG REACT_APP_GEMINI_API_KEY ARG REACT_APP_GEMINI_API_URL=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent ARG REACT_APP_ENVIRONMENT=production ARG REACT_APP_ENABLE_AI_FEATURES=true ARG REACT_APP_DEBUG_LOGGING=false ARG REACT_APP_AI_TIMEOUT=15000 ARG REACT_APP_AI_MAX_RETRIES=3 ARG REACT_APP_AI_RETRY_DELAY=1000 ARG REACT_APP_MOCK_AI_RESPONSES=false ARG REACT_APP_ENABLE_STATISTICS=true ARG REACT_APP_ENABLE_DATA_MANAGEMENT=true  # ====== SET ENV per build (IDENTICO A LOCALE) ====== ENV REACT_APP_GEMINI_API_KEY=$REACT_APP_GEMINI_API_KEY \     REACT_APP_GEMINI_API_URL=$REACT_APP_GEMINI_API_URL \     REACT_APP_ENVIRONMENT=$REACT_APP_ENVIRONMENT \     REACT_APP_ENABLE_AI_FEATURES=$REACT_APP_ENABLE_AI_FEATURES \     REACT_APP_DEBUG_LOGGING=$REACT_APP_DEBUG_LOGGING \     REACT_APP_AI_TIMEOUT=$REACT_APP_AI_TIMEOUT \     REACT_APP_AI_MAX_RETRIES=$REACT_APP_AI_MAX_RETRIES \     REACT_APP_AI_RETRY_DELAY=$REACT_APP_AI_RETRY_DELAY \     REACT_APP_MOCK_AI_RESPONSES=$REACT_APP_MOCK_AI_RESPONSES \     REACT_APP_ENABLE_STATISTICS=$REACT_APP_ENABLE_STATISTICS \     REACT_APP_ENABLE_DATA_MANAGEMENT=$REACT_APP_ENABLE_DATA_MANAGEMENT \     GENERATE_SOURCEMAP=true   # ====== OPTIMIZATION 4: Copy source DOPO deps install ====== COPY . .  # ====== BUILD (senza debug, con fallback) ====== RUN npm run build || (echo "Build failed, trying fallback..." && CI=false npm run build)  # ===================================================== # Production Stage # ===================================================== FROM nginx:alpine  # Copy built app COPY --from=builder /app/build /usr/share/nginx/html  # Use default nginx config (remove nginx.conf copy for now) # COPY nginx.conf /etc/nginx/nginx.conf  # Health check semplificato HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \   CMD wget --no-verbose --tries=1 --spider --timeout=2 http://localhost/ || exit 1  # Expose port EXPOSE 80  # Start nginx CMD ["nginx", "-g", "daemon off;"]

================================================================================

NOME FILE: Dockerfile.dev

# ===================================================== # 🐳 Dockerfile.dev - Development Environment # =====================================================  FROM node:18-alpine  # Set working directory WORKDIR /app  # Install dependencies for development COPY package*.json ./ RUN npm install  # Copy source code COPY . .  # Create .env.local if it doesn't exist (for container) RUN if [ ! -f .env.local ]; then cp .env.example .env.local; fi  # Expose port EXPOSE 3000  # Start development server CMD ["npm", "start"]

================================================================================

NOME FILE: nginx.conf

# ===================================================== # 📁 nginx.conf - Nginx Configuration per Production # =====================================================  events {     worker_connections 1024; }  http {     include       /etc/nginx/mime.types;     default_type  application/octet-stream;          # Logging     log_format main '$remote_addr - $remote_user [$time_local] "$request" '                     '$status $body_bytes_sent "$http_referer" '                     '"$http_user_agent" "$http_x_forwarded_for"';          access_log /var/log/nginx/access.log main;     error_log /var/log/nginx/error.log warn;          # Performance     sendfile on;     tcp_nopush on;     tcp_nodelay on;     keepalive_timeout 65;     types_hash_max_size 2048;          # Compression     gzip on;     gzip_vary on;     gzip_min_length 1024;     gzip_proxied any;     gzip_comp_level 6;     gzip_types         application/javascript         application/json         application/xml+rss         application/atom+xml         image/svg+xml         text/css         text/javascript         text/xml         text/plain;      server {         listen 80;         server_name localhost;         root /usr/share/nginx/html;         index index.html;          # Security headers         add_header X-Frame-Options "SAMEORIGIN" always;         add_header X-Content-Type-Options "nosniff" always;         add_header X-XSS-Protection "1; mode=block" always;         add_header Referrer-Policy "strict-origin-when-cross-origin" always;          # Handle React Router         location / {             try_files $uri $uri/ /index.html;         }          # Cache static assets         location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {             expires 1y;             add_header Cache-Control "public, immutable";         }          # Health check endpoint         location /health {             access_log off;             return 200 "healthy\n";             add_header Content-Type text/plain;         }          # Security: hide nginx version         server_tokens off;     } }

================================================================================

NOME FILE: postcss.config.js

// postcss.config.js // This file is part of the Tailwind CSS configuration for the Vocabulary Learning App. // It sets up PostCSS with Tailwind CSS and Autoprefixer to process CSS files. // The configuration ensures that Tailwind CSS styles are applied correctly and that vendor prefixes are added for better browser compatibility. // The PostCSS configuration is essential for building the application's styles and ensuring a consistent look across different browsers. // It is used in conjunction with Tailwind CSS to create a responsive and modern user interface.   module.exports = {   plugins: {     tailwindcss: {},     autoprefixer: {},   }, }

================================================================================

NOME FILE: tailwind.config.js

// tailwind.config.js // This file is part of the Tailwind CSS configuration for the Vocabulary Learning App. // It defines the content paths, theme extensions, colors, border radii, keyframes, and animations used throughout the application. // The configuration allows for custom styling and theming, ensuring a consistent look and feel across the application. // It is essential for building the application's styles and ensuring a responsive and modern user interface.  module.exports = {   content: [     "./src/**/*.{js,jsx,ts,tsx}",     "./public/index.html"   ],   theme: {     extend: {       colors: {         border: "hsl(var(--border))",         input: "hsl(var(--input))",         ring: "hsl(var(--ring))",         background: "hsl(var(--background))",         foreground: "hsl(var(--foreground))",         primary: {           DEFAULT: "hsl(var(--primary))",           foreground: "hsl(var(--primary-foreground))",         },         secondary: {           DEFAULT: "hsl(var(--secondary))",           foreground: "hsl(var(--secondary-foreground))",         },         destructive: {           DEFAULT: "hsl(var(--destructive))",           foreground: "hsl(var(--destructive-foreground))",         },         muted: {           DEFAULT: "hsl(var(--muted))",           foreground: "hsl(var(--muted-foreground))",         },         accent: {           DEFAULT: "hsl(var(--accent))",           foreground: "hsl(var(--accent-foreground))",         },         popover: {           DEFAULT: "hsl(var(--popover))",           foreground: "hsl(var(--popover-foreground))",         },         card: {           DEFAULT: "hsl(var(--card))",           foreground: "hsl(var(--card-foreground))",         },       },       borderRadius: {         lg: "var(--radius)",         md: "calc(var(--radius) - 2px)",         sm: "calc(var(--radius) - 4px)",       },       keyframes: {         "accordion-down": {           from: { height: 0 },           to: { height: "var(--radix-accordion-content-height)" },         },         "accordion-up": {           from: { height: "var(--radix-accordion-content-height)" },           to: { height: 0 },         },         "fade-in": {           "0%": { opacity: 0 },           "100%": { opacity: 1 },         },         "slide-in": {           "0%": { transform: "translateY(20px)", opacity: 0 },           "100%": { transform: "translateY(0)", opacity: 1 },         },       },       animation: {         "accordion-down": "accordion-down 0.2s ease-out",         "accordion-up": "accordion-up 0.2s ease-out",         "fade-in": "fade-in 0.5s ease-out",         "slide-in": "slide-in 0.3s ease-out",       },     },   },   plugins: [], }

================================================================================

NOME FILE: public\index.html

<!--  /public/index.html  This file is the main HTML template for the Vocabulary Learning App. --> <!DOCTYPE html> <html lang="it"> <head>     <meta charset="utf-8" />     <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />     <meta name="viewport" content="width=device-width, initial-scale=1" />     <meta name="theme-color" content="#000000" />     <meta             name="description"             content="App per lo studio del vocabolario inglese con statistiche avanzate"     />     <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />     <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />     <title>📚 Vocabulary Learning App</title> </head> <body> <noscript>È necessario abilitare JavaScript per utilizzare questa app.</noscript> <div id="root"></div> </body> </html>

================================================================================

NOME FILE: scripts\config-status.js

#!/usr/bin/env node  // ===================================================== // 📁 scripts/config-status.js - Configuration Status Check // =====================================================  const fs = require('fs'); const path = require('path');  // Colors for console output const colors = {   reset: '\x1b[0m',   bright: '\x1b[1m',   red: '\x1b[31m',   green: '\x1b[32m',   yellow: '\x1b[33m',   blue: '\x1b[34m',   magenta: '\x1b[35m',   cyan: '\x1b[36m' };  function colorize(text, color) {   return `${colors[color]}${text}${colors.reset}`; }  function logHeader(text) {   console.log('\n' + colorize('='.repeat(60), 'cyan'));   console.log(colorize(`🔧 ${text}`, 'cyan'));   console.log(colorize('='.repeat(60), 'cyan')); }  function logSection(text) {   console.log('\n' + colorize(`📋 ${text}`, 'blue'));   console.log(colorize('-'.repeat(40), 'blue')); }  function logSuccess(text) {   console.log(colorize(`✅ ${text}`, 'green')); }  function logWarning(text) {   console.log(colorize(`⚠️  ${text}`, 'yellow')); }  function logError(text) {   console.log(colorize(`❌ ${text}`, 'red')); }  function logInfo(text) {   console.log(colorize(`ℹ️  ${text}`, 'blue')); }  // Check if file exists function fileExists(filePath) {   try {     return fs.existsSync(path.resolve(filePath));   } catch (error) {     return false;   } }  // Read environment variable from .env files function readEnvFile(filePath) {   try {     if (!fileExists(filePath)) return {};          const content = fs.readFileSync(path.resolve(filePath), 'utf8');     const env = {};          content.split('\n').forEach(line => {       line = line.trim();       if (line && !line.startsWith('#')) {         const [key, ...valueParts] = line.split('=');         if (key && valueParts.length > 0) {           env[key.trim()] = valueParts.join('=').trim();         }       }     });          return env;   } catch (error) {     return {};   } }  // Get environment variable value function getEnvVar(key, envFiles = []) {   // Check process.env first (runtime environment)   if (process.env[key]) {     return process.env[key];   }      // Check .env files   for (const envFile of envFiles) {     const env = readEnvFile(envFile);     if (env[key]) {       return env[key];     }   }      return undefined; }  // Validate API key format function validateApiKey(apiKey) {   if (!apiKey) return { valid: false, reason: 'Missing' };   if (apiKey.length < 20) return { valid: false, reason: 'Too short' };   if (apiKey === 'your_gemini_api_key_here') return { valid: false, reason: 'Default template value' };   if (apiKey === 'your_api_key_here') return { valid: false, reason: 'Default template value' };   return { valid: true, reason: 'Valid format' }; }  // Main configuration check function checkConfiguration() {   logHeader('Vocabulary Master - Configuration Status');      // Environment files to check   const envFiles = ['.env.local', '.env.development', '.env'];      logSection('Environment Files');      let hasEnvFile = false;   envFiles.forEach(file => {     if (fileExists(file)) {       logSuccess(`Found: ${file}`);       hasEnvFile = true;     } else {       logInfo(`Not found: ${file}`);     }   });      if (!hasEnvFile) {     logWarning('No environment files found');     logInfo('Run: npm run setup:env');   }      // Check example file   if (fileExists('.env.example')) {     logSuccess('Template file: .env.example');   } else {     logError('Missing: .env.example template');   }      logSection('Environment Variables');      // Required variables   const requiredVars = [     { key: 'REACT_APP_GEMINI_API_KEY', description: 'Gemini AI API Key', required: true }   ];      // Optional variables   const optionalVars = [     { key: 'REACT_APP_ENVIRONMENT', description: 'App Environment' },     { key: 'REACT_APP_DEBUG_LOGGING', description: 'Debug Logging' },     { key: 'REACT_APP_ENABLE_AI_FEATURES', description: 'AI Features Enabled' },     { key: 'REACT_APP_MOCK_AI_RESPONSES', description: 'Mock AI Responses' },     { key: 'REACT_APP_AI_TIMEOUT', description: 'AI Request Timeout' },     { key: 'REACT_APP_AI_MAX_RETRIES', description: 'AI Max Retries' }   ];      let allConfigured = true;      // Check required variables   console.log('\n' + colorize('Required Variables:', 'bright'));   requiredVars.forEach(({ key, description, required }) => {     const value = getEnvVar(key, envFiles);          if (value) {       if (key === 'REACT_APP_GEMINI_API_KEY') {         const validation = validateApiKey(value);         if (validation.valid) {           logSuccess(`${key}: Configured (${validation.reason})`);         } else {           logError(`${key}: ${validation.reason}`);           allConfigured = false;         }       } else {         logSuccess(`${key}: ${value}`);       }     } else {       if (required) {         logError(`${key}: Missing (${description})`);         allConfigured = false;       } else {         logWarning(`${key}: Not set (${description})`);       }     }   });      // Check optional variables   console.log('\n' + colorize('Optional Variables:', 'bright'));   optionalVars.forEach(({ key, description }) => {     const value = getEnvVar(key, envFiles);     if (value) {       logInfo(`${key}: ${value}`);     } else {       logInfo(`${key}: Using default`);     }   });      logSection('Configuration Status');      // Overall status   if (allConfigured) {     logSuccess('Configuration is complete!');     logSuccess('All required variables are properly set');   } else {     logError('Configuration is incomplete!');     logError('Some required variables are missing or invalid');   }      // Feature availability   const apiKey = getEnvVar('REACT_APP_GEMINI_API_KEY', envFiles);   const aiEnabled = getEnvVar('REACT_APP_ENABLE_AI_FEATURES', envFiles);   const mockMode = getEnvVar('REACT_APP_MOCK_AI_RESPONSES', envFiles);      console.log('\n' + colorize('Feature Availability:', 'bright'));      if (apiKey && validateApiKey(apiKey).valid) {     if (aiEnabled === 'false') {       logWarning('AI Features: Disabled by configuration');     } else {       logSuccess('AI Features: Available');     }   } else {     if (mockMode === 'true') {       logWarning('AI Features: Mock mode (no real API calls)');     } else {       logError('AI Features: Unavailable (no valid API key)');     }   }      logSection('Security Check');      // Check for hardcoded credentials with smart filtering   const sourceFiles = [     'src/constants/appConstants.js',     'src/services/aiService.js',     'src/config/appConfig.js'   ];      let securityIssues = false;      sourceFiles.forEach(file => {     if (fileExists(file)) {       try {         const content = fs.readFileSync(path.resolve(file), 'utf8');                  // Smart patterns that avoid false positives         const suspiciousPatterns = [           {             pattern: /['"]AIzaSy[0-9A-Za-z-_]{33}['"]/g,             name: 'Google API Key'           },           {             pattern: /apiKey\s*[:=]\s*['"][A-Za-z0-9-_]{20,}['"]/g,             name: 'Hardcoded API Key'           }         ];                  let fileHasIssues = false;                  suspiciousPatterns.forEach(({ pattern, name }) => {           const matches = content.match(pattern);           if (matches) {             // Filter out false positives             const realMatches = matches.filter(match => {               // Skip placeholder values               if (match.includes('your_api_key') ||                    match.includes('your_key_here') ||                    match.includes('example') ||                    match.includes('placeholder')) {                 return false;               }                              // Check if it's in a comment               const lines = content.split('\n');               const matchLine = lines.find(line => line.includes(match));               if (matchLine && (matchLine.trim().startsWith('//') ||                                matchLine.trim().startsWith('*') ||                               matchLine.includes('RIMOSSA PER SICUREZZA'))) {                 return false;               }                              return true;             });                          if (realMatches.length > 0) {               fileHasIssues = true;             }           }         });                  if (fileHasIssues) {           logError(`Real security issues in: ${file}`);           securityIssues = true;         } else {           logSuccess(`Clean: ${file}`);         }       } catch (error) {         logWarning(`Could not check: ${file}`);       }     }   });      if (!securityIssues) {     logSuccess('No hardcoded credentials detected');   } else {     logError('Security issues found! Remove hardcoded credentials');   }      logSection('Recommendations');      if (!allConfigured) {     console.log('\n' + colorize('To fix configuration issues:', 'yellow'));     console.log('1. Copy template: ' + colorize('cp .env.example .env.local', 'cyan'));     console.log('2. Get API key: ' + colorize('https://makersuite.google.com/app/apikey', 'cyan'));     console.log('3. Add API key to .env.local');     console.log('4. Restart development server');   }      if (securityIssues) {     console.log('\n' + colorize('To fix security issues:', 'red'));     console.log('1. Remove hardcoded credentials from source files');     console.log('2. Use environment variables instead');     console.log('3. Commit clean code only');   }      console.log('\n' + colorize('For more help:', 'blue'));   console.log('📖 Read: SECURITY_SETUP.md');   console.log('🔧 Run: npm run setup:env');      logHeader('Configuration Check Complete');      // Exit with appropriate code   process.exit(allConfigured && !securityIssues ? 0 : 1); }  // Run the check if (require.main === module) {   checkConfiguration(); }  module.exports = { checkConfiguration };

================================================================================

NOME FILE: scripts\deploy.sh

#!/bin/bash  # ===================================================== # 📁 scripts/deploy.sh - Deployment Script per LearnEnglishVOC # =====================================================  set -e  # Exit on any error  # Colors for output RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' NC='\033[0m' # No Color  # Functions log_info() {     echo -e "${BLUE}ℹ️  $1${NC}" }  log_success() {     echo -e "${GREEN}✅ $1${NC}" }  log_warning() {     echo -e "${YELLOW}⚠️  $1${NC}" }  log_error() {     echo -e "${RED}❌ $1${NC}" }  # Configuration CONTAINER_NAME="learnenglishvoc" IMAGE_NAME="ghcr.io/merlinoalbus/learnenglishvoc:latest" ENVIRONMENT="${1:-production}"  # Main deployment function deploy() {     log_info "🚀 Starting deployment for environment: $ENVIRONMENT"          # Check if API key is set     if [ -z "$REACT_APP_GEMINI_API_KEY" ]; then         if [ "$ENVIRONMENT" = "development" ] && [ -f ".env.local" ]; then             log_info "Using API key from .env.local for development"         else             log_error "REACT_APP_GEMINI_API_KEY environment variable not set!"             log_info "Set it with: export REACT_APP_GEMINI_API_KEY=your_api_key"             exit 1         fi     else         log_success "API key found in environment"     fi          # Pre-deployment checks     log_info "🔍 Running pre-deployment checks..."          # Check Docker is running     if ! docker info > /dev/null 2>&1; then         log_error "Docker is not running!"         exit 1     fi     log_success "Docker is running"          # Check if container exists and stop it     if docker ps -q -f name="$CONTAINER_NAME" | grep -q .; then         log_info "🛑 Stopping existing container..."         docker-compose down         log_success "Container stopped"     fi          # Pull latest image (for production)     if [ "$ENVIRONMENT" = "production" ] || [ "$ENVIRONMENT" = "staging" ]; then         log_info "📥 Pulling latest image..."         docker pull "$IMAGE_NAME"         log_success "Image updated"     fi          # Deploy based on environment     case $ENVIRONMENT in         "production")             log_info "🏭 Deploying to PRODUCTION..."             docker-compose up -d learnenglishvoc             ;;         "staging")             log_info "🧪 Deploying to STAGING..."             docker-compose --profile staging up -d             ;;         "development")             log_info "🛠️ Starting DEVELOPMENT environment..."             docker-compose --profile dev up             ;;         *)             log_error "Unknown environment: $ENVIRONMENT"             log_info "Usage: $0 [production|staging|development]"             exit 1             ;;     esac          # Wait for container to be ready     log_info "⏳ Waiting for container to be ready..."     sleep 10          # Health check     if [ "$ENVIRONMENT" = "production" ]; then         PORT="12345"     elif [ "$ENVIRONMENT" = "staging" ]; then         PORT="8080"     else         PORT="3000"     fi          # Test if app is responding     for i in {1..30}; do         if curl -s -f "http://localhost:$PORT" > /dev/null; then             log_success "🎉 Deployment successful! App is running on port $PORT"                          # Show container status             echo ""             log_info "📊 Container Status:"             docker-compose ps                          # Show logs             echo ""             log_info "📝 Recent logs:"             docker-compose logs --tail=20 learnenglishvoc 2>/dev/null || docker-compose logs --tail=20                          # Configuration check (if in production/staging)             if [ "$ENVIRONMENT" != "development" ]; then                 echo ""                 log_info "🔧 Testing configuration..."                 if docker exec "$CONTAINER_NAME" which node > /dev/null 2>&1; then                     # If Node.js is available in container, run config check                     docker exec "$CONTAINER_NAME" node scripts/config-status.js 2>/dev/null || log_info "Config check not available in production image"                 fi             fi                          echo ""             log_success "🌐 Access your app at: http://localhost:$PORT"             exit 0         fi                  log_info "Waiting for app to start... ($i/30)"         sleep 2     done          log_error "❌ Deployment failed! App is not responding after 60 seconds"          # Show logs for debugging     echo ""     log_info "📝 Container logs for debugging:"     docker-compose logs learnenglishvoc 2>/dev/null || docker-compose logs          exit 1 }  # Show usage if no arguments if [ $# -eq 0 ]; then     echo "🐳 LearnEnglishVOC Deployment Script"     echo ""     echo "Usage: $0 [environment]"     echo ""     echo "Environments:"     echo "  production  - Deploy to production (port 12345)"     echo "  staging     - Deploy to staging (port 8080)"     echo "  development - Start development server (port 3000)"     echo ""     echo "Examples:"     echo "  $0 production"     echo "  $0 staging"     echo "  $0 development"     echo ""     echo "Note: Set REACT_APP_GEMINI_API_KEY environment variable before running"     exit 0 fi  # Run deployment deploy

================================================================================

NOME FILE: scripts\extract.ps1

param(     [Parameter(Mandatory=$true)]     [string]$SourcePath,          [Parameter(Mandatory=$false)]     [string]$OutputFile = "extracted_files_content.txt",      [Parameter(Mandatory=$false)]     [string[]]$PathsToSkip )  # Verifica che il path esista if (-not (Test-Path -Path $SourcePath)) {     Write-Error "Il path specificato non esiste: $SourcePath"     exit 1 }  # Converte il path in formato assoluto $resolvedSourcePath = Resolve-Path -Path $SourcePath  # Definisce le estensioni di file da processare $TargetExtensions = @('.js','.conf', '.yml', '.yaml', '.html', '.css', '.ts', '.tsx', '.vue', '.scss', '.properties', '.sh', '.ps1')  # Lista di esclusione per cartelle di sistema/build $ExcludedFolders = @('.idea', '.gitignore','config_txt','.github', 'node_modules', 'dist', 'build', 'vendor', 'coverage', 'test', 'tests', 'tmp', 'temp')  # Svuota il file di output prima di iniziare if (Test-Path -Path $OutputFile) {     Clear-Content -Path $OutputFile } else {     New-Item -Path $OutputFile -ItemType File -Force | Out-Null }  Write-Host "Inizio scansione del path: $($resolvedSourcePath.Path) (Ricorsiva)" -ForegroundColor Cyan  # Converte i percorsi da saltare in percorsi assoluti $ResolvedPathsToSkip = @() if ($null -ne $PathsToSkip -and $PathsToSkip.Count -gt 0) {     foreach ($path in $PathsToSkip) {         try {             # Risolve il percorso relativo in assoluto             $absolutePath = Resolve-Path -Path $path -ErrorAction Stop             $ResolvedPathsToSkip += $absolutePath.Path             Write-Host "Percorso da saltare risolto: $($absolutePath.Path)" -ForegroundColor DarkYellow         } catch {             Write-Warning "Impossibile risolvere il percorso da saltare: $path"         }     } }  # Contatori $ProcessedFiles = 0 $SkippedFiles = 0  try {     $AllFiles = Get-ChildItem -Path $resolvedSourcePath.Path -Recurse -File          foreach ($File in $AllFiles) {         # Calcola il percorso relativo         $RelativePath = $File.FullName.Substring($resolvedSourcePath.Path.Length).TrimStart('\')         if ([string]::IsNullOrEmpty($RelativePath)) { $RelativePath = $File.Name }          # Controlla se il file appartiene a un percorso da saltare         $isPathManuallySkipped = $false         if ($ResolvedPathsToSkip.Count -gt 0) {             foreach ($absolutePathToSkip in $ResolvedPathsToSkip) {                 # Confronta i percorsi assoluti                 if ($File.FullName.StartsWith($absolutePathToSkip, [System.StringComparison]::OrdinalIgnoreCase)) {                     $isPathManuallySkipped = $true                     Write-Host "Saltato (Percorso escluso manualmente): $RelativePath" -ForegroundColor Red                     break                 }             }         }                  if ($isPathManuallySkipped) {             $SkippedFiles++             continue         }                  # Verifica se il file è in una cartella esclusa         $isFolderExcluded = $false         $ExclusionReason = ""         foreach ($ExcludedFolder in $ExcludedFolders) {             if ($File.DirectoryName -like "*\$ExcludedFolder" -or $File.DirectoryName -like "*\$ExcludedFolder\*") {                 $isFolderExcluded = $true                 $ExclusionReason = $ExcludedFolder                 break             }         }                  if ($isFolderExcluded) {             $SkippedFiles++             continue         }                  # Verifica l'estensione         $ShouldProcess = $false         if (($File.Extension -in $TargetExtensions) -or ($File.Name -eq "Dockerfile") -or ($File.Name -like "Dockerfile.*")) {             $ShouldProcess = $true         }                  if (-not $ShouldProcess) {             Write-Host "Saltato (Tipo di file non valido): $RelativePath" -ForegroundColor Yellow             $SkippedFiles++             continue         }                  try {             Write-Host "Processando: $RelativePath" -ForegroundColor Gray             $FileContent = Get-Content -Path $File.FullName -Raw -ErrorAction Stop -Encoding UTF8             $FileContent = $FileContent -replace "\r?\n", " "                          if ([string]::IsNullOrEmpty($FileContent.Trim())) {                 $FileContent = "[FILE VUOTO]"             }                          $OutputContent = @" NOME FILE: $RelativePath  $FileContent  ================================================================================  "@                          Add-Content -Path $OutputFile -Value $OutputContent -Encoding UTF8             $ProcessedFiles++                      } catch {             Write-Warning "Errore durante la lettura del file: $($File.FullName) - $($_.Exception.Message)"             $SkippedFiles++         }     }          # Statistiche finali     Write-Host "`n=== STATISTICHE ($($resolvedSourcePath.Path)) ===" -ForegroundColor Green     Write-Host "File processati: $ProcessedFiles" -ForegroundColor Green     Write-Host "File saltati: $SkippedFiles" -ForegroundColor Yellow     Write-Host "Output salvato in: $OutputFile" -ForegroundColor Green      } catch {     Write-Error "Errore durante l'esecuzione dello script: $($_.Exception.Message)"     exit 1 }  Write-Host "`nCompletato per $($resolvedSourcePath.Path)`n" -ForegroundColor Green

================================================================================

NOME FILE: scripts\security-check.js

#!/usr/bin/env node  // ===================================================== // 📁 scripts/security-check.js - Security Audit Script // =====================================================  const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process');  // Colors for console output const colors = {   reset: '\x1b[0m',   bright: '\x1b[1m',   red: '\x1b[31m',   green: '\x1b[32m',   yellow: '\x1b[33m',   blue: '\x1b[34m',   magenta: '\x1b[35m',   cyan: '\x1b[36m' };  function colorize(text, color) {   return `${colors[color]}${text}${colors.reset}`; }  function logHeader(text) {   console.log('\n' + colorize('='.repeat(60), 'magenta'));   console.log(colorize(`🔐 ${text}`, 'magenta'));   console.log(colorize('='.repeat(60), 'magenta')); }  function logSection(text) {   console.log('\n' + colorize(`🔍 ${text}`, 'blue'));   console.log(colorize('-'.repeat(40), 'blue')); }  function logSuccess(text) {   console.log(colorize(`✅ ${text}`, 'green')); }  function logWarning(text) {   console.log(colorize(`⚠️  ${text}`, 'yellow')); }  function logError(text) {   console.log(colorize(`🚨 ${text}`, 'red')); }  function logInfo(text) {   console.log(colorize(`ℹ️  ${text}`, 'blue')); }  function logCritical(text) {   console.log(colorize(`💥 CRITICAL: ${text}`, 'red')); }  // Check if file exists function fileExists(filePath) {   try {     return fs.existsSync(path.resolve(filePath));   } catch (error) {     return false;   } }  // Get all files in directory recursively function getAllFiles(dirPath, arrayOfFiles = []) {   const files = fs.readdirSync(dirPath);    files.forEach(file => {     const fullPath = path.join(dirPath, file);     if (fs.statSync(fullPath).isDirectory()) {       // Skip node_modules, build, and other non-source directories       if (!['node_modules', 'build', '.git', 'dist', 'coverage'].includes(file)) {         arrayOfFiles = getAllFiles(fullPath, arrayOfFiles);       }     } else {       arrayOfFiles.push(fullPath);     }   });    return arrayOfFiles; }  // Security patterns to check for const SECURITY_PATTERNS = [   {     name: 'Google API Keys',     pattern: /['"]AIzaSy[0-9A-Za-z-_]{33}['"]/g,     severity: 'CRITICAL',     description: 'Google API key detected'   },   {     name: 'Hardcoded API Keys',     pattern: /apiKey\s*[:=]\s*['"][A-Za-z0-9-_]{20,}['"]/g,     severity: 'HIGH',     description: 'Hardcoded API key'   },   {     name: 'Environment Variables in Code',     pattern: /REACT_APP_[A-Z_]+\s*[:=]\s*['"][^'"]+['"]/g,     severity: 'MEDIUM',     description: 'Environment variable with hardcoded value'   },   {     name: 'AWS Keys',     pattern: /AKIA[0-9A-Z]{16}/g,     severity: 'CRITICAL',     description: 'AWS access key detected'   },   {     name: 'Private Keys',     pattern: /-----BEGIN [A-Z ]+PRIVATE KEY-----/g,     severity: 'CRITICAL',     description: 'Private key detected'   },   {     name: 'Database URLs',     pattern: /(mongodb|postgres|mysql):\/\/[^\s'"]+/g,     severity: 'HIGH',     description: 'Database connection string'   },   {     name: 'JWT Tokens',     pattern: /eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*/g,     severity: 'HIGH',     description: 'JWT token detected'   },   {     name: 'Slack Tokens',     pattern: /xox[bpoa]-[0-9]{12}-[0-9]{12}-[0-9]{12}-[a-z0-9]{32}/g,     severity: 'HIGH',     description: 'Slack token detected'   } ];  // File extensions to check const CHECK_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.json', '.env', '.md', '.yml', '.yaml'];  // Files that should never contain credentials const CRITICAL_FILES = [   'package.json',   'package-lock.json',   'yarn.lock',   'README.md',   'SECURITY_SETUP.md' ];  function checkFileForSecrets(filePath) {   try {     const content = fs.readFileSync(filePath, 'utf8');     const issues = [];          // Skip checking template files and examples     const fileName = path.basename(filePath);     if (fileName.includes('.example') || fileName.includes('template') || fileName.includes('sample')) {       return issues;     }          SECURITY_PATTERNS.forEach(({ name, pattern, severity, description }) => {       const matches = content.match(pattern);       if (matches) {         // Filter out false positives         const realMatches = matches.filter(match => {           // Skip comments and documentation           const lines = content.split('\n');           const matchLine = lines.find(line => line.includes(match));           if (matchLine && (matchLine.trim().startsWith('//') || matchLine.trim().startsWith('*') || matchLine.includes('example') || matchLine.includes('your_api_key'))) {             return false;           }                      // Skip placeholder values           if (match.includes('your_api_key') || match.includes('your_key_here') || match.includes('example') || match.includes('placeholder')) {             return false;           }                      return true;         });                  realMatches.forEach(match => {           issues.push({             file: filePath,             pattern: name,             severity,             description,             match: match.substring(0, 50) + (match.length > 50 ? '...' : ''),             line: content.substring(0, content.indexOf(match)).split('\n').length           });         });       }     });          return issues;   } catch (error) {     return [];   } }  function checkGitignore() {   logSection('Git Ignore Check');      const gitignorePath = '.gitignore';   const requiredPatterns = [     '.env',     '.env.local',     '.env.development.local',     '.env.test.local',     '.env.production.local',     '*.backup',     '*.bak',     '*-secrets.*',     '*-credentials.*'   ];      if (!fileExists(gitignorePath)) {     logError('No .gitignore file found');     return false;   }      const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');   const missingPatterns = [];      requiredPatterns.forEach(pattern => {     if (!gitignoreContent.includes(pattern)) {       missingPatterns.push(pattern);     }   });      if (missingPatterns.length === 0) {     logSuccess('Git ignore properly configured');     return true;   } else {     logWarning(`Missing patterns in .gitignore: ${missingPatterns.join(', ')}`);     return false;   } }  function checkEnvironmentFiles() {   logSection('Environment Files Check');      const envFiles = ['.env', '.env.local', '.env.development', '.env.production'];   let hasIssues = false;      envFiles.forEach(file => {     if (fileExists(file)) {       if (file === '.env.example') {         logSuccess(`Template file found: ${file}`);       } else {         logWarning(`Environment file detected: ${file}`);         logInfo('Ensure this file is in .gitignore and contains no real credentials');                  // Check if it's tracked by git         try {           execSync(`git ls-files --error-unmatch ${file}`, { stdio: 'ignore' });           logCritical(`Environment file ${file} is tracked by Git!`);           hasIssues = true;         } catch (error) {           logSuccess(`Environment file ${file} is not tracked by Git`);         }       }     }   });      return !hasIssues; }  function checkCommitHistory() {   logSection('Git History Check');      try {     // Check recent commits for potential credential leaks     const recentCommits = execSync('git log --oneline -10 --grep="key\\|secret\\|password\\|token" -i', {        encoding: 'utf8',       stdio: 'pipe'     });          if (recentCommits.trim()) {       logWarning('Found commits with potential credential-related messages:');       console.log(recentCommits);     } else {       logSuccess('No suspicious commit messages found');     }          return true;   } catch (error) {     logInfo('Could not check git history (no git repository or no commits)');     return true;   } }  function runNpmAudit() {   logSection('NPM Security Audit');      try {     const auditResult = execSync('npm audit --audit-level=moderate --json', {        encoding: 'utf8',       stdio: 'pipe'     });          const audit = JSON.parse(auditResult);          if (audit.metadata.vulnerabilities.total === 0) {       logSuccess('No security vulnerabilities found in dependencies');       return true;     } else {       const { info, low, moderate, high, critical } = audit.metadata.vulnerabilities;              if (critical > 0) {         logCritical(`${critical} critical vulnerabilities found`);       }       if (high > 0) {         logError(`${high} high vulnerabilities found`);       }       if (moderate > 0) {         logWarning(`${moderate} moderate vulnerabilities found`);       }       if (low > 0) {         logInfo(`${low} low vulnerabilities found`);       }       if (info > 0) {         logInfo(`${info} info vulnerabilities found`);       }              logInfo('Run "npm audit fix" to attempt automatic fixes');       return critical === 0 && high === 0; // Allow moderate and below     }   } catch (error) {     try {       // Try without JSON flag for older npm versions       execSync('npm audit', { stdio: 'inherit' });       return true;     } catch (error2) {       logWarning('Could not run npm audit');       return true;     }   } }  function main() {   logHeader('Security Audit - Vocabulary Master');      let overallSecure = true;   let criticalIssues = 0;   let highIssues = 0;   let mediumIssues = 0;      // Check for hardcoded secrets in files   logSection('Source Code Secret Scan');      try {     const allFiles = getAllFiles('./src');     const sourceFiles = allFiles.filter(file =>        CHECK_EXTENSIONS.some(ext => file.endsWith(ext))     );          let totalIssues = 0;          sourceFiles.forEach(file => {       const issues = checkFileForSecrets(file);       if (issues.length > 0) {         issues.forEach(issue => {           totalIssues++;           const icon = issue.severity === 'CRITICAL' ? '💥' :                        issue.severity === 'HIGH' ? '🚨' : '⚠️';                      console.log(`${icon} ${colorize(issue.severity, 'red')} in ${colorize(issue.file, 'yellow')}:${issue.line}`);           console.log(`   ${issue.description}: ${colorize(issue.match, 'red')}`);                      if (issue.severity === 'CRITICAL') criticalIssues++;           else if (issue.severity === 'HIGH') highIssues++;           else mediumIssues++;         });       }     });          if (totalIssues === 0) {       logSuccess('No secrets detected in source code');     } else {       logError(`Found ${totalIssues} potential security issues`);       overallSecure = false;     }   } catch (error) {     logWarning('Could not scan source files');   }      // Check critical files   logSection('Critical Files Check');      CRITICAL_FILES.forEach(file => {     if (fileExists(file)) {       const issues = checkFileForSecrets(file);       if (issues.length > 0) {         logCritical(`Secrets found in critical file: ${file}`);         criticalIssues += issues.length;         overallSecure = false;       } else {         logSuccess(`Clean: ${file}`);       }     }   });      // Run other checks   const gitignoreOk = checkGitignore();   const envFilesOk = checkEnvironmentFiles();   const commitHistoryOk = checkCommitHistory();   const npmAuditOk = runNpmAudit();      overallSecure = overallSecure && gitignoreOk && envFilesOk && commitHistoryOk && npmAuditOk;      // Final assessment   logSection('Security Assessment');      if (criticalIssues > 0) {     logCritical(`${criticalIssues} critical security issues found`);   }   if (highIssues > 0) {     logError(`${highIssues} high-severity issues found`);   }   if (mediumIssues > 0) {     logWarning(`${mediumIssues} medium-severity issues found`);   }      if (overallSecure && criticalIssues === 0) {     logSuccess('Security audit passed!');     logSuccess('No critical security issues detected');   } else {     logError('Security audit failed!');     logError('Critical security issues must be addressed');   }      // Recommendations   logSection('Security Recommendations');      if (criticalIssues > 0 || highIssues > 0) {     console.log('\n' + colorize('🔥 IMMEDIATE ACTIONS REQUIRED:', 'red'));     console.log('1. Remove all hardcoded credentials from source code');     console.log('2. Move credentials to environment variables');     console.log('3. Add .env* files to .gitignore');     console.log('4. Review git history for leaked credentials');     console.log('5. Regenerate any exposed API keys');   }      console.log('\n' + colorize('🔐 General Security Best Practices:', 'blue'));   console.log('• Use environment variables for all secrets');   console.log('• Keep .env files out of version control');   console.log('• Regularly rotate API keys and credentials');   console.log('• Run security audits before each deployment');   console.log('• Use HTTPS for all external API calls');   console.log('• Keep dependencies updated');      console.log('\n' + colorize('📚 Resources:', 'cyan'));   console.log('• Security Setup Guide: SECURITY_SETUP.md');   console.log('• Environment Config: npm run config:status');   console.log('• Git Secrets Tool: https://github.com/awslabs/git-secrets');      logHeader('Security Audit Complete');      // Exit with appropriate code   const exitCode = (criticalIssues === 0 && overallSecure) ? 0 : 1;   if (exitCode !== 0) {     logError('Security audit failed - fix issues before deployment');   }      process.exit(exitCode); }  // Run the security check if (require.main === module) {   main(); }  module.exports = { main };

================================================================================

NOME FILE: scripts\wrapper.ps1

# Definisce il percorso della cartella di configurazione $configFolder = ".\..\config_txt"  # Definisce l'elenco dei percorsi gestiti separatamente $specificPaths = @(     "..\src\views",     "..\src\utils",     "..\src\services",     "..\src\layouts",     "..\src\hooks",     "..\src\contexts",     "..\src\constants",     "..\src\components" )  # Crea la cartella 'config' se non esiste if (-not (Test-Path -Path $configFolder -PathType Container)) {     New-Item -Path $configFolder -ItemType Directory }  # Cancella tutti i file .txt nella cartella 'config' Remove-Item -Path "$configFolder\*.txt" -ErrorAction SilentlyContinue  # Esegue gli script di estrazione  # Chiamata alla root, ricorsiva, ma saltando i percorsi specifici .\extract.ps1 -SourcePath ".\..\" -OutputFile "$configFolder\root.txt" -PathsToSkip $specificPaths  # Chiamate specifiche .\extract.ps1 -SourcePath ".\..\src\views" -OutputFile "$configFolder\views.txt" .\extract.ps1 -SourcePath ".\..\src\utils" -OutputFile "$configFolder\utils.txt" .\extract.ps1 -SourcePath ".\..\src\services" -OutputFile "$configFolder\services.txt" .\extract.ps1 -SourcePath ".\..\src\layouts" -OutputFile "$configFolder\layouts.txt" .\extract.ps1 -SourcePath ".\..\src\hooks" -OutputFile "$configFolder\hooks.txt" .\extract.ps1 -SourcePath ".\..\src\contexts" -OutputFile "$configFolder\contexts.txt" .\extract.ps1 -SourcePath ".\..\src\constants" -OutputFile "$configFolder\constants.txt" .\extract.ps1 -SourcePath ".\..\src\components" -OutputFile "$configFolder\components.txt"  Write-Host "Operazione completata! I file di output sono stati creati nella cartella '$configFolder'."

================================================================================

NOME FILE: src\App.css

/* App.css - Stili aggiornati per la nuova versione */  * {   margin: 0;   padding: 0;   box-sizing: border-box; }  body {   font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;   background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);   min-height: 100vh;   color: #333; }  .app {   min-height: 100vh;   display: flex;   flex-direction: column; }  /* ===== HEADER MIGLIORATO ===== */ .app-header {   background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);   color: white;   padding: 1.5rem 2rem;   box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); }  .header-content {   max-width: 1200px;   margin: 0 auto;   display: flex;   justify-content: space-between;   align-items: center;   gap: 2rem; }  .header-main h1 {   font-size: 2.2rem;   margin-bottom: 0.5rem;   font-weight: 700; }  .header-main p {   opacity: 0.9;   font-size: 1.1rem; }  .header-stats {   display: flex;   gap: 1.5rem;   align-items: center; }  .header-stat {   text-align: center;   min-width: 60px; }  .header-stat span {   display: block;   font-size: 1.4rem;   font-weight: bold;   line-height: 1; }  .header-stat small {   font-size: 0.8rem;   opacity: 0.8;   margin-top: 0.2rem;   display: block; }  .header-stat.streak span {   font-size: 1.2rem; }  /* ===== NAVIGATION MIGLIORATA ===== */ .app-nav {   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-bottom: 1px solid rgba(0, 0, 0, 0.1);   padding: 0.5rem 0;   position: sticky;   top: 0;   z-index: 100; }  .nav-container {   max-width: 1200px;   margin: 0 auto;   display: flex;   gap: 0.5rem;   padding: 0 1rem;   justify-content: center;   overflow-x: auto; }  .nav-btn {   display: flex;   flex-direction: column;   align-items: center;   gap: 0.3rem;   padding: 0.8rem 1rem;   border: none;   background: transparent;   border-radius: 12px;   cursor: pointer;   transition: all 0.2s ease;   min-width: 80px;   position: relative;   text-decoration: none;   color: #555; }  .nav-btn:hover {   background: rgba(52, 152, 219, 0.1);   transform: translateY(-1px); }  .nav-btn.active {   background: linear-gradient(145deg, #3498db, #2980b9);   color: white;   box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);   transform: translateY(-1px); }  .nav-icon {   font-size: 1.3rem;   line-height: 1; }  .nav-text {   font-size: 0.8rem;   font-weight: 500;   white-space: nowrap; }  .nav-badge {   position: absolute;   top: 0.2rem;   right: 0.2rem;   background: #e74c3c;   color: white;   font-size: 0.7rem;   padding: 0.1rem 0.4rem;   border-radius: 10px;   min-width: 18px;   text-align: center;   line-height: 1.2;   font-weight: bold; }  /* ===== INDICATORE SEZIONE ===== */ .section-indicator {   background: rgba(255, 255, 255, 0.9);   backdrop-filter: blur(10px);   padding: 0.8rem 2rem;   display: flex;   align-items: center;   gap: 0.8rem;   border-bottom: 1px solid rgba(0, 0, 0, 0.05); }  .indicator-icon {   font-size: 1.2rem; }  .indicator-text {   font-weight: 600;   color: #2c3e50;   font-size: 1rem; }  /* ===== MAIN CONTENT ===== */ .app-main {   flex: 1;   max-width: 1200px;   margin: 0 auto;   padding: 2rem;   width: 100%; }  /* ===== SCHERMATA INIZIALE TEST ===== */ .start-test {   text-align: center;   padding: 3rem 2rem; }  .start-test-content {   max-width: 600px;   margin: 0 auto;   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-radius: 20px;   padding: 3rem 2rem;   box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); }  .start-test h2 {   color: #2c3e50;   margin-bottom: 2rem;   font-size: 2rem; }  .test-info {   display: grid;   grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));   gap: 1rem;   margin: 2rem 0; }  .info-card {   background: linear-gradient(145deg, #f8f9fa, #ffffff);   border: 1px solid #e9ecef;   border-radius: 12px;   padding: 1.2rem 0.8rem;   display: flex;   flex-direction: column;   align-items: center;   gap: 0.5rem;   transition: transform 0.2s ease; }  .info-card:hover {   transform: translateY(-2px); }  .info-icon {   font-size: 1.8rem;   line-height: 1; }  .info-card strong {   font-size: 1.5rem;   color: #2c3e50;   font-weight: bold; }  .info-card p {   font-size: 0.8rem;   color: #7f8c8d;   text-align: center;   margin: 0; }  .btn-large {   font-size: 1.1rem;   padding: 1rem 2rem;   margin: 2rem 0 1rem 0; }  .help-text {   color: #7f8c8d;   font-style: italic;   margin-top: 1rem; }  /* ===== PULSANTI GENERALI ===== */ .btn {   padding: 0.8rem 1.5rem;   border: none;   border-radius: 10px;   font-size: 0.95rem;   font-weight: 600;   cursor: pointer;   transition: all 0.2s ease;   display: inline-flex;   align-items: center;   gap: 0.5rem;   text-decoration: none;   justify-content: center; }  .btn:disabled {   opacity: 0.6;   cursor: not-allowed;   transform: none !important; }  .btn-primary {   background: linear-gradient(145deg, #3498db, #2980b9);   color: white;   box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3); }  .btn-primary:hover:not(:disabled) {   background: linear-gradient(145deg, #2980b9, #21618c);   transform: translateY(-2px);   box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4); }  .btn-secondary {   background: linear-gradient(145deg, #95a5a6, #7f8c8d);   color: white;   box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3); }  .btn-secondary:hover:not(:disabled) {   background: linear-gradient(145deg, #7f8c8d, #6c7b7d);   transform: translateY(-2px);   box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4); }  /* ===== ERROR VIEW ===== */ .error-view {   text-align: center;   padding: 3rem 2rem;   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-radius: 20px;   max-width: 500px;   margin: 2rem auto;   box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); }  .error-view h2 {   color: #e74c3c;   margin-bottom: 1rem; }  .error-view p {   color: #7f8c8d;   margin-bottom: 2rem; }  /* ===== FOOTER MIGLIORATO ===== */ .app-footer {   background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);   color: white;   padding: 1.5rem 2rem;   margin-top: auto; }  .footer-content {   max-width: 1200px;   margin: 0 auto;   display: flex;   justify-content: space-between;   align-items: center;   gap: 1rem; }  .footer-info p {   margin: 0;   font-size: 0.95rem; }  .footer-stats {   display: flex;   align-items: center;   gap: 0.8rem;   font-size: 0.9rem;   opacity: 0.9; }  .footer-stats span {   white-space: nowrap; }  /* ===== RESPONSIVE DESIGN ===== */ @media (max-width: 768px) {   .app-header {     padding: 1rem;   }      .header-content {     flex-direction: column;     gap: 1rem;     text-align: center;   }      .header-main h1 {     font-size: 1.8rem;   }      .header-main p {     font-size: 1rem;   }      .header-stats {     gap: 1rem;   }      .nav-container {     padding: 0 0.5rem;     gap: 0.2rem;   }      .nav-btn {     min-width: 60px;     padding: 0.6rem 0.5rem;   }      .nav-text {     font-size: 0.7rem;   }      .section-indicator {     padding: 0.6rem 1rem;   }      .app-main {     padding: 1rem;   }      .start-test-content {     padding: 2rem 1rem;   }      .test-info {     grid-template-columns: repeat(2, 1fr);     gap: 0.8rem;   }      .info-card {     padding: 1rem 0.5rem;   }      .footer-content {     flex-direction: column;     gap: 0.8rem;     text-align: center;   }      .footer-stats {     flex-wrap: wrap;     justify-content: center;   } }  @media (max-width: 480px) {   .header-main h1 {     font-size: 1.5rem;   }      .test-info {     grid-template-columns: 1fr;   }      .nav-text {     display: none;   }      .nav-btn {     min-width: 50px;     padding: 0.8rem 0.3rem;   }      .indicator-text {     font-size: 0.9rem;   } }  /* ===== ANIMAZIONI ===== */ @keyframes slideIn {   from {     opacity: 0;     transform: translateY(20px);   }   to {     opacity: 1;     transform: translateY(0);   } }  @keyframes fadeIn {   from {     opacity: 0;   }   to {     opacity: 1;   } }  .app-main > * {   animation: slideIn 0.3s ease-out; }  .nav-btn {   animation: fadeIn 0.2s ease-out; }  /* ===== FOCUS E ACCESSIBILITÀ ===== */ .nav-btn:focus, .btn:focus {   outline: 2px solid #3498db;   outline-offset: 2px; }  .nav-btn.active:focus {   outline-color: rgba(255, 255, 255, 0.8); }  @media (prefers-reduced-motion: reduce) {   *,   *::before,   *::after {     animation-duration: 0.01ms !important;     animation-iteration-count: 1 !important;     transition-duration: 0.01ms !important;   } }

================================================================================

NOME FILE: src\App.js

// ===================================================== // 📁 src/App.js - REACT IMPORT FORZATO // =====================================================  // ⭐ IMPORT PROTETTO che VS Code NON PUÒ RIMUOVERE import React, { useEffect } from 'react'; // Questo uso esplicito impedisce la rimozione automatica: const ReactVersion = React.version; console.log('React loaded:', ReactVersion);  import './App.css'; import { AppRouter } from './components/AppRouter'; import { ErrorTracker, MainAppErrorBoundary } from './components/ErrorBoundaries'; import { AppProvider } from './contexts/AppContext'; import { NotificationProvider } from './contexts/NotificationContext'; import { AppLayout } from './layouts/AppLayout';  const VocabularyApp = () => {   // 🆘 EMERGENCY EXPORT SENZA HOOK (import diretto localStorage)   useEffect(() => {     const handleEmergencyExport = () => {       try {         // ⭐ IMPORT DIRETTO senza hook per evitare problemi context         const words = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');         const stats = JSON.parse(localStorage.getItem('vocabularyStats') || '{}');         const testHistory = JSON.parse(localStorage.getItem('testHistory') || '[]');         const wordPerformance = JSON.parse(localStorage.getItem('wordPerformance') || '{}');                  const exportData = {           words,           stats,           testHistory,           wordPerformance,           exportDate: new Date().toISOString(),           version: '2.3',           dataTypes: ['words', 'stats', 'testHistory', 'wordPerformance'],           totalTests: testHistory.length,           totalWords: words.length,           totalWordPerformance: Object.keys(wordPerformance).length,           description: 'EMERGENCY backup v2.3: parole + statistiche + cronologia + performance'         };                  const dataStr = JSON.stringify(exportData, null, 2);         const blob = new Blob([dataStr], { type: 'application/json' });         const url = URL.createObjectURL(blob);                  const link = document.createElement('a');         link.href = url;         link.download = `vocabulary-EMERGENCY-backup-v2.3-${new Date().toISOString().split('T')[0]}.json`;         document.body.appendChild(link);         link.click();         document.body.removeChild(link);         URL.revokeObjectURL(url);          alert('✅ Export di emergenza completato!');       } catch (error) {         console.error('❌ Emergency export failed:', error);         alert('❌ Export fallito');       }     };      // ⭐ AGGIUNGI FORCE MIGRATION per testing     const handleForceMigration = () => {       // Trigger re-check migrazione nel router       window.location.hash = '#migration';       window.location.reload();     };      window.addEventListener('emergencyExport', handleEmergencyExport);     window.addEventListener('forceExport', handleEmergencyExport);     window.addEventListener('forceMigration', handleForceMigration);      return () => {       window.removeEventListener('emergencyExport', handleEmergencyExport);       window.removeEventListener('forceExport', handleEmergencyExport);       window.removeEventListener('forceMigration', handleForceMigration);     };   }, []);    return (     <MainAppErrorBoundary        onAppError={(error, errorInfo) => {         ErrorTracker.logError(error, 'Main App', { errorInfo });                  if (process.env.NODE_ENV === 'development') {           console.group('🚨 Main App Error Caught');           console.error('Error:', error);           console.groupEnd();         }       }}     >       <NotificationProvider>         <AppProvider>           <AppLayout>             <AppRouter />           </AppLayout>         </AppProvider>       </NotificationProvider>     </MainAppErrorBoundary>   ); };  export default VocabularyApp;

================================================================================

NOME FILE: src\index.css

/* /src/index.css This file contains the main CSS styles for the application, including Tailwind CSS imports and custom styles. */ @tailwind base; @tailwind components; @tailwind utilities;  /* Stili di base */ * {   margin: 0;   padding: 0;   box-sizing: border-box; }  body {   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',     'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',     sans-serif;   -webkit-font-smoothing: antialiased;   -moz-osx-font-smoothing: grayscale; }  code {   font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',     monospace; }  /* Utilità personalizzate */ @layer utilities {   .text-balance {     text-wrap: balance;   } }

================================================================================

NOME FILE: src\index.js

// /src/index.js // This file is the entry point for the React application. // It imports the necessary styles and renders the main App component into the root element of the HTML document. // It uses ReactDOM to create a root and render the App component wrapped in React.StrictMode. // This setup ensures that the application is ready for development and production builds with React's best practices. // It is essential for initializing the React application and providing a consistent structure for rendering components.  import React from 'react'; import ReactDOM from 'react-dom/client'; import App from './App'; import './index.css';  const root = ReactDOM.createRoot(document.getElementById('root')); root.render(   <React.StrictMode>     <App />   </React.StrictMode> ); 

================================================================================

NOME FILE: src\config\appConfig.ts

// ===================================================== // 📁 src/config/appConfig.ts - Type-Safe Configuration for Vocabulary Master // =====================================================  import type {    ApplicationConfig,    ConfigurationStatus,    ErrorMessages,    SuccessMessages  } from '../types/config';  /**  * Type-safe configuration that replaces hardcoded credentials  */  // Helper for reading environment variables with type safety const getEnvVar = (key: string, defaultValue?: string): string | undefined => {   const value = process.env[key];      // Handle boolean strings   if (value === 'true') return 'true';   if (value === 'false') return 'false';      // Handle numeric strings - keep as string for flexibility   if (value && !isNaN(Number(value)) && !isNaN(parseFloat(value))) {     return value;   }      return value || defaultValue; };  // Convert string to number safely const getEnvNumber = (key: string, defaultValue: number): number => {   const value = getEnvVar(key);   if (value === undefined) return defaultValue;      const parsed = parseFloat(value);   return isNaN(parsed) ? defaultValue : parsed; };  // Convert string to boolean safely const getEnvBoolean = (key: string, defaultValue: boolean): boolean => {   const value = getEnvVar(key);   if (value === undefined) return defaultValue;      return value === 'true'; };  // ====== MAIN CONFIGURATION ====== export const AppConfig: ApplicationConfig = {      // App Metadata   app: {     name: 'Vocabulary Master',     version: '2.0.0',      description: 'La tua app intelligente per imparare l\'inglese',     environment: (getEnvVar('REACT_APP_ENVIRONMENT', 'development') as 'development' | 'production' | 'test') || 'development'   },    // AI Configuration - Type-safe with proper fallbacks   ai: {     // SECURE: API key from environment variable instead of hardcoded     apiKey: getEnvVar('REACT_APP_GEMINI_API_KEY'),          // Same URL as before     baseUrl: getEnvVar(       'REACT_APP_GEMINI_API_URL'     ) || 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent',          // Type-safe numeric values     timeout: getEnvNumber('REACT_APP_AI_TIMEOUT', 15000),     maxRetries: getEnvNumber('REACT_APP_AI_MAX_RETRIES', 3),      retryDelay: getEnvNumber('REACT_APP_AI_RETRY_DELAY', 1000),          // Feature flags with type safety     enabled: getEnvBoolean('REACT_APP_ENABLE_AI_FEATURES', true),     mockResponses: getEnvBoolean('REACT_APP_MOCK_AI_RESPONSES', false)   },    // Test Configuration   test: {     warningThresholds: {       slow: 25,       verySlow: 40     },     autoAdvanceDelay: 1500,     hintCooldown: 3000,     maxHintsPerWord: 1,     scoring: {       excellent: 80,       good: 60,       victory: 80     }   },    // Statistics Configuration   stats: {     performance: {       excellent: 90,       good: 75,       average: 60,       needsWork: 40     },     maxHistorySize: 1000,     maxRecentTests: 20,     charts: {       maxTimelinePoints: 20,       defaultChartHeight: 300     }   },    // Storage Configuration   storage: {     keys: {       words: 'vocabularyWords',       stats: 'vocabulary_stats',       testHistory: 'vocabulary_test_history',        settings: 'vocabulary_settings',       wordPerformance: 'wordPerformance'     }   },    // Word Configuration with type safety   word: {     maxWordLength: 100,     maxTranslationLength: 200,     maxNotesLength: 1000,     maxSentenceLength: 300,     maxChapterLength: 20,     requiredFields: ['english', 'italian'],     optionalFields: ['group', 'sentence', 'notes', 'chapter', 'learned', 'difficult']   },    // UI Configuration   ui: {     animations: {       fast: 150,       normal: 300,       slow: 500,       cardFlip: 700     },     notifications: {       defaultDuration: 3000,       maxVisible: 5     }   } };  // ====== ERROR MESSAGES ====== export const ERROR_MESSAGES: ErrorMessages = {   network: 'Errore di connessione. Controlla la tua connessione internet.',   ai: 'Servizio AI temporaneamente non disponibile. Riprova più tardi.',   aiNotConfigured: 'Servizio AI non configurato. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local',   storage: 'Errore nel salvataggio dei dati. Controlla lo spazio disponibile.',   validation: 'Dati non validi. Controlla i campi obbligatori.',   import: 'Errore durante l\'importazione. Verifica il formato del file.',   export: 'Errore durante l\'esportazione. Riprova.',   generic: 'Si è verificato un errore imprevisto.',   wordNotFound: 'Parola non trovata.',   noWordsAvailable: 'Nessuna parola disponibile per il test.' };  // ====== SUCCESS MESSAGES ====== export const SUCCESS_MESSAGES: SuccessMessages = {   wordAdded: 'Parola aggiunta con successo!',   wordUpdated: 'Parola modificata con successo!',   wordDeleted: 'Parola eliminata con successo!',   testCompleted: 'Test completato!',   dataExported: 'Dati esportati con successo!',   dataImported: 'Dati importati con successo!',   settingsSaved: 'Impostazioni salvate!' };  // ====== UTILITY FUNCTIONS ======  /**  * Check if AI is available (has API key) - Type-safe  */ export const isAIAvailable = (): boolean => {   return AppConfig.ai.enabled && !!AppConfig.ai.apiKey; };  /**  * Get configuration status - Type-safe  */ export const getConfigurationStatus = (): ConfigurationStatus => {   return {     isValid: !!AppConfig.ai.apiKey,     environment: AppConfig.app.environment,     aiConfigured: !!AppConfig.ai.apiKey,     features: {       aiEnabled: isAIAvailable(),       mockMode: AppConfig.ai.mockResponses     }   }; };  // Debug logging in development with type safety if (AppConfig.app.environment === 'development') {   const status = getConfigurationStatus();   console.log('🔧 Vocabulary Master Configuration (TypeScript):', {     aiConfigured: status.aiConfigured,     environment: status.environment,     features: status.features,     typeChecking: '✅ Active'   });      if (!status.aiConfigured) {     console.warn('⚠️ AI Service: API key non configurata. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local');   } }  // Default export for compatibility export default AppConfig;

================================================================================

NOME FILE: src\types\components.ts

// ===================================================== // 📁 src/types/components.ts - Component Type Definitions // =====================================================  import React from 'react'; import { Word, WordInput } from './global';  // ===== BASIC COMPONENT PROPS =====  export interface BaseComponentProps {   className?: string;   children?: React.ReactNode; }  // ===== UI COMPONENT PROPS =====  export interface CardProps extends BaseComponentProps {   // Card inherits from BaseComponentProps }  export interface CardHeaderProps extends BaseComponentProps {   // CardHeader inherits from BaseComponentProps }  export interface CardTitleProps extends BaseComponentProps {   // CardTitle inherits from BaseComponentProps }  export interface CardDescriptionProps extends BaseComponentProps {   // CardDescription inherits from BaseComponentProps }  export interface CardContentProps extends BaseComponentProps {   // CardContent inherits from BaseComponentProps }  export interface CardFooterProps extends BaseComponentProps {   // CardFooter inherits from BaseComponentProps }  export interface ButtonProps extends BaseComponentProps {   variant?: 'default' | 'outline' | 'ghost' | 'destructive';   size?: 'default' | 'sm' | 'lg';   disabled?: boolean;   onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;   type?: 'button' | 'submit' | 'reset'; }  export interface InputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'className'> {   className?: string; }  export interface TextareaProps extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, 'className'> {   className?: string; }  // ===== FORM COMPONENT PROPS =====  export interface EnhancedAddWordFormProps {   onAddWord: (wordData: WordInput) => Promise<void>;   editingWord: Word | null;   onClearForm: () => void; }  export interface FormValidation {   [key: string]: string; }  // ===== TEST COMPONENT PROPS =====  export interface TestCardProps {   word: Word;   showMeaning: boolean;   onFlip: () => void;   showHint: boolean;   hintUsed: boolean; }  // ===== LOADING COMPONENT PROPS =====  export interface SmartLoadingIndicatorProps {   isLoading: boolean;   operation?: string;   duration?: number;   customIcon?: React.ComponentType<any>; }  export interface ErrorWithRetryProps {   error: Error;   onRetry: () => void;   canRetry: boolean;   retryCount: number;   maxRetries: number;   isRetrying: boolean; }  // ===== ERROR BOUNDARY PROPS =====  export interface ErrorBoundaryProps {   children: React.ReactNode;   fallback?: React.ComponentType<{ error: Error; resetError: () => void }>;   onError?: (error: Error, errorInfo: React.ErrorInfo) => void; }  export interface AIServiceErrorBoundaryProps {   children: React.ReactNode;   onAIError: (error: Error) => void; }  export interface FormErrorBoundaryProps {   children: React.ReactNode;   formName: string;   onFormError: (error: Error) => void; }  // ===== CONTEXT COMPONENT PROPS =====  export interface AppProviderProps {   children: React.ReactNode; }  export interface NotificationProviderProps {   children: React.ReactNode; }  // ===== HIGHER-ORDER COMPONENT TYPES =====  export type WithLoadingProps<T = {}> = T & {   isLoading: boolean;   error?: Error | null; };  export type WithNotificationProps<T = {}> = T & {   showNotification: (message: string, type?: 'success' | 'error' | 'warning' | 'info') => void;   showError: (error: Error, context?: string) => void;   showSuccess: (message: string) => void;   showWarning: (message: string) => void; };  // ===== COMPONENT STATE TYPES =====  export interface FormState {   english: string;   italian: string;   group: string;   sentence: string;   notes: string;   chapter: string;   learned: boolean;   difficult: boolean; }  export interface TestCardState {   isFlipped: boolean;   showHint: boolean;   hintUsed: boolean; }  // ===== EVENT HANDLER TYPES =====  export type InputChangeHandler = (field: keyof FormState, value: string | boolean) => void; export type ButtonClickHandler = (event: React.MouseEvent<HTMLButtonElement>) => void; export type FormSubmitHandler = (event: React.FormEvent<HTMLFormElement>) => void;  // ===== RENDER PROPS TYPES =====  export interface RenderLoadingProps {   isLoading: boolean;   error: Error | null;   retry: () => void; }  export type RenderLoadingComponent = (props: RenderLoadingProps) => React.ReactNode;  // ===== COMPONENT REFS =====  export type ButtonRef = React.Ref<HTMLButtonElement>; export type InputRef = React.Ref<HTMLInputElement>; export type TextareaRef = React.Ref<HTMLTextAreaElement>; export type DivRef = React.Ref<HTMLDivElement>;  // ===== STYLE TYPES =====  export interface StyleClasses {   container?: string;   header?: string;   content?: string;   footer?: string;   button?: string;   input?: string;   error?: string;   success?: string;   warning?: string; }  // ===== ANIMATION TYPES =====  export interface AnimationConfig {   duration: number;   easing: string;   delay?: number; }  export interface TransitionProps {   show: boolean;   enter?: string;   enterFrom?: string;   enterTo?: string;   leave?: string;   leaveFrom?: string;   leaveTo?: string; }

================================================================================

NOME FILE: src\types\config.ts

// ===================================================== // 📁 src/types/config.ts - Configuration Type Definitions // =====================================================  /**  * Application configuration types for type-safe configuration management  */  // ===== APP CONFIGURATION =====  export interface AppConfiguration {   name: string;   version: string;   description: string;   environment: 'development' | 'production' | 'test'; }  // ===== AI CONFIGURATION =====  export interface AIConfiguration {   apiKey?: string;   baseUrl: string;   timeout: number;   maxRetries: number;   retryDelay: number;   enabled: boolean;   mockResponses: boolean; }  // ===== TEST CONFIGURATION =====  export interface TestConfiguration {   warningThresholds: {     slow: number;     verySlow: number;   };   autoAdvanceDelay: number;   hintCooldown: number;   maxHintsPerWord: number;   scoring: {     excellent: number;     good: number;     victory: number;   }; }  // ===== STATISTICS CONFIGURATION =====  export interface StatsConfiguration {   performance: {     excellent: number;     good: number;     average: number;     needsWork: number;   };   maxHistorySize: number;   maxRecentTests: number;   charts: {     maxTimelinePoints: number;     defaultChartHeight: number;   }; }  // ===== STORAGE CONFIGURATION =====  export interface StorageConfiguration {   keys: {     words: string;     stats: string;     testHistory: string;     settings: string;     wordPerformance: string;   }; }  // ===== WORD CONFIGURATION =====  export interface WordConfiguration {   maxWordLength: number;   maxTranslationLength: number;   maxNotesLength: number;   maxSentenceLength: number;   maxChapterLength: number;   requiredFields: (keyof import('./global').Word)[];   optionalFields: (keyof import('./global').Word)[]; }  // ===== UI CONFIGURATION =====  export interface UIConfiguration {   animations: {     fast: number;     normal: number;     slow: number;     cardFlip: number;   };   notifications: {     defaultDuration: number;     maxVisible: number;   }; }  // ===== COMBINED CONFIGURATION =====  export interface ApplicationConfig {   app: AppConfiguration;   ai: AIConfiguration;   test: TestConfiguration;   stats: StatsConfiguration;   storage: StorageConfiguration;   word: WordConfiguration;   ui: UIConfiguration; }  // ===== CONFIGURATION STATUS =====  export interface ConfigurationStatus {   isValid: boolean;   environment: string;   aiConfigured: boolean;   features: {     aiEnabled: boolean;     mockMode: boolean;   }; }  // ===== ERROR MESSAGES =====  export interface ErrorMessages {   network: string;   ai: string;   aiNotConfigured: string;   storage: string;   validation: string;   import: string;   export: string;   generic: string;   wordNotFound: string;   noWordsAvailable: string; }  // ===== SUCCESS MESSAGES =====  export interface SuccessMessages {   wordAdded: string;   wordUpdated: string;   wordDeleted: string;   testCompleted: string;   dataExported: string;   dataImported: string;   settingsSaved: string; }

================================================================================

NOME FILE: src\types\global.ts

// ===================================================== // 📁 src/types/global.ts - Global Type Definitions for Vocabulary Master // =====================================================  /**  * Core application types shared across the entire application  */  // ===== BASIC TYPES =====  export type ID = string; export type Timestamp = string; // ISO string export type JSONString = string;  // ===== WORD TYPES =====  /**  * Core word interface - represents a vocabulary word  */ export interface Word {   id: ID;   english: string;   italian: string;   group?: string | null;   sentence?: string | null;   notes?: string | null;   chapter?: string | null;   learned: boolean;   difficult: boolean; }  /**  * Word data for creation (without id)  */ export interface WordInput {   english: string;   italian: string;   group?: string | null;   sentence?: string | null;   notes?: string | null;   chapter?: string | null;   learned?: boolean;   difficult?: boolean; }  /**  * Word update data (partial word)  */ export type WordUpdate = Partial<Omit<Word, 'id'>> & { id: ID };  // ===== STATISTICS TYPES =====  /**  * Basic test statistics  */ export interface TestStats {   correct: number;   incorrect: number;   hints: number;   totalTime?: number;   avgTimePerWord?: number; }  /**  * Enhanced test statistics with timing data  */ export interface EnhancedTestStats extends TestStats {   maxTimePerWord?: number;   minTimePerWord?: number;   totalRecordedTime?: number;   wordTimes?: WordTimeRecord[]; }  /**  * Individual word timing record  */ export interface WordTimeRecord {   wordId: ID;   english: string;   italian: string;   chapter?: string;   timeSpent: number; // milliseconds   isCorrect: boolean;   usedHint: boolean;   timestamp: Timestamp; }  /**  * Overall application statistics  */ export interface AppStats {   totalWords: number;   correctAnswers: number;   incorrectAnswers: number;   hintsUsed: number;   averageScore: number;   testsCompleted: number;   timeSpent: number;   categoriesProgress: Record<string, CategoryProgress>;   dailyProgress: Record<string, DailyProgress>;   difficultyStats: DifficultyStats;   monthlyStats: Record<string, MonthlyStats>;   streakDays: number;   lastStudyDate: string | null;   migrated?: boolean; }  /**  * Category-specific progress  */ export interface CategoryProgress {   correct: number;   total: number;   hints: number; }  /**  * Daily progress tracking  */ export interface DailyProgress {   tests: number;   correct: number;   incorrect: number;   hints: number; }  /**  * Difficulty-based statistics  */ export interface DifficultyStats {   easy: { correct: number; total: number };   medium: { correct: number; total: number };   hard: { correct: number; total: number }; }  /**  * Monthly statistics  */ export interface MonthlyStats {   testsCompleted: number;   correctAnswers: number;   incorrectAnswers: number;   hintsUsed: number;   timeSpent: number; }  // ===== TEST TYPES =====  /**  * Test result record  */ export interface TestResult {   id: number;   timestamp: Date;   totalWords: number;   correctWords: number;   incorrectWords: number;   hintsUsed: number;   totalTime: number;   avgTimePerWord: number;   percentage: number;   wrongWords: Word[];   wordTimes: WordTimeRecord[];   chapterStats: Record<string, ChapterTestStats>;   testParameters: TestParameters;   testType: 'selective' | 'complete';   difficulty: TestDifficulty;   difficultyAnalysis?: DifficultyAnalysis;   legacyDifficulty: 'easy' | 'medium' | 'hard'; }  /**  * Chapter-specific test statistics  */ export interface ChapterTestStats {   totalWords: number;   correctWords: number;   incorrectWords: number;   hintsUsed: number;   percentage: number; }  /**  * Test parameters configuration  */ export interface TestParameters {   selectedChapters: string[];   includeLearnedWords: boolean;   totalAvailableWords: number; }  /**  * Test difficulty levels  */ export type TestDifficulty = 'easy' | 'medium' | 'hard';  /**  * Advanced difficulty analysis  */ export interface DifficultyAnalysis {   difficulty: TestDifficulty;   difficultyReason: string;   totalWords: number;   weightedScore: number;   sizeAdjustment: number;   distribution: {     hard: { count: number; percentage: number };     medium: { count: number; percentage: number };     easy: { count: number; percentage: number };   };   statusBreakdown: Record<string, number>; }  // ===== WORD PERFORMANCE TYPES =====  /**  * Individual word performance tracking  */ export interface WordPerformance {   english: string;   italian: string;   chapter?: string;   attempts: WordAttempt[]; }  /**  * Single word attempt record  */ export interface WordAttempt {   timestamp: Timestamp;   correct: boolean;   usedHint: boolean;   timeSpent: number; }  /**  * Word analysis results  */ export interface WordAnalysis {   id: ID;   english: string;   italian: string;   chapter: string;   group: string;   sentence: string;   notes: string;   learned: boolean;   difficult: boolean;   totalAttempts: number;   correctAttempts: number;   incorrectAttempts: number;   accuracy: number;   recentAccuracy: number;   avgTime: number;   hintsUsed: number;   hintsPercentage: number;   currentStreak: number;   lastAttempt: WordAttempt | null;   status: WordStatus;   trend: 'stable' | 'improving' | 'declining';   difficulty: 'easy' | 'medium' | 'hard' | 'unknown';   needsWork: boolean;   mastered: boolean;   attempts: WordAttempt[];   recommendations: string[]; }  /**  * Word learning status  */ export type WordStatus =    | 'new'    | 'promising'    | 'struggling'    | 'improving'    | 'inconsistent'    | 'consolidated'    | 'critical';  // ===== WORD STATISTICS =====  /**  * Word collection statistics  */ export interface WordStats {   total: number;   learned: number;   unlearned: number;   difficult: number;   normal: number;   chapters: string[];   groups: string[]; }  /**  * Chapter-specific word statistics  */ export interface ChapterStats {   total: number;   learned: number;   unlearned: number;   difficult: number;   normal: number; }  // ===== UI TYPES =====  /**  * Notification types  */ export type NotificationType = 'success' | 'error' | 'warning' | 'info';  /**  * Notification object  */ export interface Notification {   id: number;   message: string;   type: NotificationType;   timestamp: number; }  /**  * Loading states  */ export interface LoadingState {   isLoading: boolean;   error: Error | null;   retryCount: number;   startTime: number | null;   operation: string | null; }  /**  * Loading options  */ export interface LoadingOptions {   timeout?: number;   retryAttempts?: number;   retryDelay?: number;   showTimeoutWarning?: boolean;   showRetryNotifications?: boolean; }  // ===== SERVICE TYPES =====  /**  * AI service response  */ export interface AIAnalysisResult {   italian: string;   group: string;   sentence: string;   notes: string;   chapter: string;   _aiError?: boolean;   _fallbackUsed?: boolean; }  /**  * Service health status  */ export type ServiceHealth = 'healthy' | 'degraded' | 'down' | 'unknown';  /**  * AI service status  */ export interface AIServiceStatus {   configured: boolean;   health: ServiceHealth;   consecutiveFailures: number;   lastSuccessTime: number | null;   lastHealthCheck: number | null;   circuitBreaker?: any;   apiUrl: string;   timeout: number;   canUseAI: boolean;   degradedMode: boolean;   recommendations: string[]; }  /**  * Storage service status  */ export interface StorageServiceStatus {   available: boolean;   health: ServiceHealth;   usage: StorageUsageStats;   lastHealthCheck: number | null;   recommendations: string[]; }  /**  * Storage usage statistics  */ export interface StorageUsageStats {   used: number;   available: number;   total: number;   usedMB: string;   availableMB: string;   usagePercentage: string;   critical: boolean;   warning: boolean;   healthStatus: ServiceHealth;   lastHealthCheck: number | null;   error?: string; }  // ===== ERROR TYPES =====  /**  * Application error with context  */ export interface AppError extends Error {   context?: string;   code?: string;   retryable?: boolean; }  // ===== UTILITY TYPES =====  /**  * Generic API response wrapper  */ export interface ApiResponse<T> {   data: T;   success: boolean;   error?: string;   timestamp: Timestamp; }  /**  * Generic operation result  */ export interface OperationResult<T = void> {   success: boolean;   data?: T;   error?: string; }  // ===== CATEGORY TYPES =====  /**  * Predefined word categories  */ export type WordCategory =    | 'VERBI'   | 'VERBI_IRREGOLARI'   | 'SOSTANTIVI'   | 'AGGETTIVI'   | 'DESCRIZIONI_FISICHE'   | 'POSIZIONE_CORPO'   | 'EMOZIONI'   | 'EMOZIONI_POSITIVE'   | 'EMOZIONI_NEGATIVE'   | 'LAVORO'   | 'FAMIGLIA'   | 'TECNOLOGIA'   | 'VESTITI';  /**  * Category styling information  */ export interface CategoryStyle {   color: string;   icon: string;   bgColor: string;   bgGradient: string; }  // ===== EXPORT ALL ===== export * from './config'; export * from './hooks'; export * from './components';

================================================================================

NOME FILE: src\types\hooks.ts

// ===================================================== // 📁 src/types/hooks.ts - Hooks Type Definitions // =====================================================  import {    Word,    WordInput,    WordStats,    ChapterStats,    TestStats,    EnhancedTestStats,   WordTimeRecord,   AppStats,   TestResult,   WordPerformance,   WordAnalysis,   LoadingState,   LoadingOptions } from './global';  // ===== WORDS HOOK TYPES =====  export interface OptimizedWordsReturn {   // Data   words: Word[];   editingWord: Word | null;   wordStats: WordStats;      // Actions   setEditingWord: (word: Word | null) => void;   addWord: (wordData: WordInput) => Promise<void>;   removeWord: (id: string) => void;   toggleWordLearned: (id: string) => void;   toggleWordDifficult: (id: string) => void;   clearAllWords: () => void;   importWords: (jsonText: string) => number;   forceRefresh: () => void;      // Getters   getWordsByChapter: (chapter: string) => Word[];   getDifficultWordsByChapter: (chapter: string) => Word[];   getAvailableChapters: () => string[];   getChapterStats: (chapter: string) => ChapterStats; }  // ===== TEST HOOK TYPES =====  export interface TestProgress {   current: number;   total: number;   percentage: number;   hints: number; }  export interface TestSummary extends TestProgress {   answered: number;   remaining: number;   accuracy: number;   correct: number;   incorrect: number;   hints: number;   totalTime: number;   avgTimePerWord: number;   maxTimePerWord: number;   minTimePerWord: number;   totalRecordedTime: number;   wordTimes: WordTimeRecord[];   testStartTime: number | null;   hintsPercentage: number;   efficiency: number; }  export type TestCompleteCallback = (   testStats: EnhancedTestStats,   testWords: Word[],   wrongWords: Word[] ) => void;  export interface OptimizedTestReturn {   // State   currentWord: Word | null;   usedWordIds: Set<string>;   showMeaning: boolean;   testMode: boolean;   showResults: boolean;   stats: TestStats;   wrongWords: Word[];   testWords: Word[];   isTransitioning: boolean;      // Hint functionality   showHint: boolean;   hintUsed: boolean;      // Timer functionality   wordTimes: WordTimeRecord[];      // Actions   setShowMeaning: (show: boolean) => void;   toggleHint: () => void;   startTest: (filteredWords: Word[]) => void;   handleAnswer: (isCorrect: boolean) => void;   resetTest: () => void;   startNewTest: () => void;      // Getters   getTestProgress: () => TestProgress;   getTestSummary: () => TestSummary; }  // ===== STATS HOOK TYPES =====  export interface StatsSelectors {   totalTests: number;   totalAnswers: number;   totalHints: number;   accuracyRate: number;   hintsRate: number;   isActiveToday: boolean;   avgTimePerTest: number; }  export interface WeeklyProgressItem {   date: string;   tests: number;   correct: number;   incorrect: number;   hints: number; }  export interface ComputedStats extends StatsSelectors {   weeklyProgress: WeeklyProgressItem[];   isMigrated: boolean;   isProcessing: boolean;   forceUpdate: number; }  export interface EnhancedStatsReturn {   // Data   stats: AppStats;   testHistory: TestResult[];   wordPerformance: Record<string, WordPerformance>;   calculatedStats: ComputedStats;      // State   isInitialized: boolean;   isLoading: boolean;   error: Error | null;   lastSync: number | null;      // Core functions   handleTestComplete: TestCompleteCallback;   exportData: () => void;   importData: (jsonString: string) => void;   clearTestHistory: () => void;   refreshData: () => void;      // Word performance functions   getAllWordsPerformance: () => any[];   getWordAnalysis: (wordId: string) => WordAnalysis | null;   recordWordPerformance: (     word: Word,      isCorrect: boolean,      usedHint: boolean,      timeSpent: number   ) => void;      // Additional functions   addTestToHistory: (testResult: TestResult) => void;   resetStats: () => void;   clearHistoryOnly: () => void;      // Computed values   totalTests: number;   totalAnswers: number;   accuracyRate: number;   hintsRate: number;   weeklyProgress: WeeklyProgressItem[];   isMigrated: boolean; }  // ===== LOADING HOOKS TYPES =====  export interface LoadingStateReturn extends LoadingState {   startLoading: (operationName?: string) => void;   stopLoading: (successMessage?: string) => void;   setError: (error: Error, canRetry?: boolean) => void;   retry: (operation: () => Promise<any>) => Promise<any>;   canRetry: boolean;   duration: number; }  export interface AILoadingReturn extends LoadingStateReturn {   executeAIOperation: (     operation: () => Promise<any>,     operationName?: string   ) => Promise<any>; }  export interface StorageLoadingReturn extends LoadingStateReturn {   executeStorageOperation: (     operation: () => Promise<any>,     operationName?: string   ) => Promise<any>; }  export interface NetworkLoadingReturn extends LoadingStateReturn {   executeNetworkOperation: (     operation: () => Promise<any>,     operationName?: string   ) => Promise<any>; }  // ===== LOCAL STORAGE HOOK TYPES =====  export type LocalStorageValue<T> = T | undefined;  export interface UseLocalStorageReturn<T> {   0: T;   1: (value: T | ((prevValue: T) => T)) => void; }  // ===== NOTIFICATION HOOK TYPES =====  export interface NotificationContextValue {   notifications: import('./global').Notification[];   showNotification: (     message: string,      type?: import('./global').NotificationType,      duration?: number   ) => number;   showError: (error: Error, context?: string) => number;   showSuccess: (message: string) => number;   showWarning: (message: string) => number;   clearAllNotifications: () => void; }

================================================================================

NOME FILE: src\types\optimized.ts

// ===================================================== // 📁 src/types/optimized.ts - STRUTTURA DATI OTTIMIZZATA PER STATISTICHE CORRETTE // =====================================================  export type ID = string; export type Timestamp = string; // ISO string  // ===== ENHANCED WORD STRUCTURE =====  /**  * Struttura ottimizzata per le parole del vocabolario  */ export interface OptimizedWord {   id: ID;   english: string;   italian: string;   group?: string | null;   sentence?: string | string[] | null; // ⭐ UPDATED: Supporta sia singola frase che array   notes?: string | null;   chapter?: string | null;   learned: boolean;   difficult: boolean;   // ⭐ NUOVI CAMPI come richiesto   synonyms: string[];      // Sinonimi in inglese   antonyms: string[];      // Contrari in inglese   createdAt: Timestamp;    // Data creazione   updatedAt: Timestamp;    // Ultima modifica }  /**  * Input per creazione/modifica parola  */ export interface OptimizedWordInput {   english: string;   italian: string;   group?: string | null;   sentence?: string | string[] | null; // ⭐ UPDATED: Supporta sia singola frase che array   notes?: string | null;   chapter?: string | null;   learned?: boolean;   difficult?: boolean;   synonyms?: string[];   antonyms?: string[]; }  // ===== ENHANCED TEST STRUCTURE =====  /**  * Risposta dettagliata per una singola parola durante il test  * ⭐ CRITICAL: Contiene TUTTI i dati necessari per calcoli statistici precisi  */ export interface DetailedWordResponse {   wordId: ID;   timeResponse: number;        // Tempo di risposta in millisecondi   hintsUsed: number;          // Numero di aiuti utilizzati per questa specifica parola   currentDifficulty: TestDifficulty; // Difficoltà percepita per questa parola nel momento del test   isCorrect: boolean;         // Se la risposta è corretta o sbagliata   timestamp: Timestamp;       // Momento esatto della risposta   // ⭐ METADATA ADDIZIONALI per analisi avanzate   attemptNumber?: number;     // Numero del tentativo (per retry)   confidence?: 'low' | 'medium' | 'high'; // Fiducia dell'utente nella risposta }  /**  * Risultato di un test completo - STRUTTURA OTTIMIZZATA  * ⭐ CRITICAL: Questa struttura deve contenere TUTTI i dati per calcoli statistici accurati  */ export interface OptimizedTestResult {   // ⭐ IDENTIFICAZIONE   id: ID;   timestamp: Timestamp;      // ⭐ DATI GLOBALI TEST (calcolati dai dati dettagliati)   totalWords: number;   correctWords: number;   incorrectWords: number;   totalTime: number;           // Tempo totale in millisecondi   avgTimePerWord: number;      // Tempo medio per parola in millisecondi   percentage: number;          // Percentuale di successo (0-100)   difficulty: TestDifficulty;  // Difficoltà calcolata del test   hintsUsed: number;          // Totale aiuti utilizzati nel test      // ⭐ CONFIGURAZIONE TEST   selectedChapters: string[];  // Capitoli selezionati per il test   testType: TestType;         // Tipo di test      // ⭐ RISPOSTE DETTAGLIATE - QUI STANNO I DATI REALI   wrongWords: DetailedWordResponse[];  // Array delle parole sbagliate con dati completi   rightWords: DetailedWordResponse[];  // Array delle parole corrette con dati completi      // ⭐ METADATI   version: string;            // Versione della struttura dati (per future migrazioni)   deviceInfo?: {              // Info del dispositivo (opzionale)     platform: string;     userAgent: string;   }; }  /**  * Tipi di test disponibili  */ export type TestType =    | 'complete'      // Test completo di tutto il vocabolario   | 'selective'     // Test selettivo per capitoli   | 'difficult'     // Test solo parole difficili   | 'learned'       // Test solo parole apprese   | 'mixed'         // Test misto   | 'review'        // Test di ripasso   | 'quick';        // Test veloce  /**  * Livelli di difficoltà  */ export type TestDifficulty = 'easy' | 'medium' | 'hard';  // ===== STATISTICHE AGGREGATE CALCOLATE DAI DATI REALI =====  /**  * Statistiche globali calcolate dai test effettivi  */ export interface ComputedGlobalStats {   // ⭐ CONTATORI GLOBALI (calcolati da OptimizedTestResult[])   totalTests: number;   totalWordsAnswered: number;      // Totale parole risposte (correct + incorrect)   totalCorrectAnswers: number;     // Totale risposte corrette   totalIncorrectAnswers: number;   // Totale risposte sbagliate   totalHintsUsed: number;         // Totale aiuti utilizzati   totalTimeSpent: number;         // Tempo totale speso in millisecondi      // ⭐ PERCENTUALI E MEDIE CALCOLATE   globalAccuracy: number;         // Precisione globale (%)   avgTestAccuracy: number;        // Media delle percentuali dei singoli test   avgTimePerWord: number;         // Tempo medio per parola globale (millisecondi)   avgTimePerTest: number;         // Tempo medio per test (millisecondi)   avgHintsPerTest: number;        // Media aiuti per test   avgHintsPerWord: number;        // Media aiuti per parola   hintsEfficiency: number;        // Efficienza nell'uso degli aiuti (%)      // ⭐ TENDENZE TEMPORALI   currentStreak: number;          // Giorni consecutivi di studio   bestStreak: number;            // Miglior streak mai raggiunto   lastStudyDate: string | null;  // Ultima data di studio (YYYY-MM-DD)   studyFrequency: number;        // Frequenza di studio (test/settimana)   improvementTrend: number;      // Trend di miglioramento (% variazione)      // ⭐ DISTRIBUZIONE DIFFICOLTÀ   difficultyDistribution: {     easy: { count: number; avgAccuracy: number; avgTime: number; };     medium: { count: number; avgAccuracy: number; avgTime: number; };     hard: { count: number; avgAccuracy: number; avgTime: number; };   };      // ⭐ PERFORMANCE PER TIPO TEST   testTypeStats: Record<TestType, {     count: number;     avgAccuracy: number;     avgTime: number;     avgHints: number;   }>;      // ⭐ METADATI   lastCalculated: Timestamp;   dataVersion: string; }  /**  * Statistiche dettagliate per capitolo  */ export interface ComputedChapterStats {   chapter: string;      // ⭐ CONTATORI PAROLE   totalWordsInChapter: number;    // Parole totali nel capitolo   testedWords: number;           // Parole effettivamente testate   uniqueWordsTested: number;     // Parole uniche testate      // ⭐ PERFORMANCE AGGREGATA   totalAttempts: number;         // Tentativi totali su parole del capitolo   correctAttempts: number;       // Tentativi corretti   incorrectAttempts: number;     // Tentativi sbagliati   accuracy: number;              // Accuratezza del capitolo (%)      // ⭐ TIMING E AIUTI   totalTimeSpent: number;        // Tempo totale speso sul capitolo (millisecondi)   avgTimePerWord: number;        // Tempo medio per parola del capitolo   totalHintsUsed: number;        // Aiuti totali utilizzati nel capitolo   hintsPerWord: number;          // Media aiuti per parola   hintsEfficiency: number;       // Efficienza aiuti (%)      // ⭐ PROGRESSI TEMPORALI   firstTestDate: Timestamp | null;  // Prima volta che il capitolo è stato testato   lastTestDate: Timestamp | null;   // Ultima volta che il capitolo è stato testato   improvementTrend: number;          // Trend di miglioramento      // ⭐ DISTRIBUZIONE DIFFICOLTÀ PAROLE   wordsDistribution: {     learned: number;              // Parole apprese nel capitolo     difficult: number;           // Parole difficili nel capitolo     mastered: number;            // Parole completamente padroneggiate     struggling: number;          // Parole con cui si ha difficoltà   }; }  /**  * Analisi dettagliata di una singola parola  */ export interface ComputedWordAnalysis {   // ⭐ IDENTIFICAZIONE   wordId: ID;   english: string;   italian: string;   chapter: string | null;   group: string | null;      // ⭐ CONTATORI TOTALI   totalAttempts: number;         // Tentativi totali su questa parola   correctAttempts: number;       // Tentativi corretti   incorrectAttempts: number;     // Tentativi sbagliati      // ⭐ PERFORMANCE METRICS   accuracy: number;              // Accuratezza (%)   recentAccuracy: number;        // Accuratezza degli ultimi 5 tentativi   consistencyScore: number;      // Score di consistenza      // ⭐ TIMING ANALYSIS   totalTimeSpent: number;        // Tempo totale speso su questa parola   avgTimePerAttempt: number;     // Tempo medio per tentativo   fastestTime: number;           // Tempo più veloce   slowestTime: number;           // Tempo più lento   timeImprovement: number;       // Miglioramento dei tempi (%)      // ⭐ HINTS ANALYSIS   totalHintsUsed: number;        // Aiuti totali utilizzati   hintsPerAttempt: number;       // Media aiuti per tentativo   hintsDecreasingTrend: number;  // Trend di diminuzione aiuti   independence: number;          // Score di indipendenza (%)      // ⭐ LEARNING PATTERNS   currentStreak: number;         // Streak corrente   bestStreak: number;           // Miglior streak   learningVelocity: number;     // Velocità di apprendimento   retentionScore: number;       // Score di ritenzione      // ⭐ TEMPORAL DATA   firstAttempt: Timestamp | null;  // Primo tentativo   lastAttempt: Timestamp | null;   // Ultimo tentativo   daysSinceFirst: number;          // Giorni dal primo tentativo   daysSinceLast: number;           // Giorni dall'ultimo tentativo      // ⭐ CLASSIFICATION   proficiencyLevel: 'beginner' | 'intermediate' | 'advanced' | 'expert';   needsWork: boolean;              // Se la parola ha bisogno di lavoro   isWellMastered: boolean;         // Se la parola è ben padroneggiata   recommendedAction: 'study_more' | 'practice_speed' | 'review_occasionally' | 'maintain';      // ⭐ RECENT ATTEMPTS (per analisi dettagliata)   recentAttempts: DetailedWordResponse[];  // Ultimi 10 tentativi }  // ===== HOOK INTERFACES =====  /**  * Return type per il nuovo hook di statistiche ottimizzato  */ export interface OptimizedStatsReturn {   // ⭐ DATI CALCOLATI   globalStats: ComputedGlobalStats;   chapterStats: ComputedChapterStats[];   wordAnalyses: ComputedWordAnalysis[];      // ⭐ DATI RAW (per debug e analisi avanzate)   allTests: OptimizedTestResult[];   allWords: OptimizedWord[];      // ⭐ STATO   isLoading: boolean;   error: Error | null;   lastCalculated: Timestamp | null;   dataVersion: string;      // ⭐ FUNZIONI DI CALCOLO   recalculateStats: () => void;   getWordAnalysis: (wordId: ID) => ComputedWordAnalysis | null;   getChapterStats: (chapter: string) => ComputedChapterStats | null;      // ⭐ FUNZIONI DI GESTIONE TEST   addTestResult: (testResult: OptimizedTestResult) => void;   removeTestResult: (testId: ID) => void;      // ⭐ FUNZIONI DI FILTRAGGIO   getStatsByDateRange: (startDate: string, endDate: string) => ComputedGlobalStats;   getStatsByTestType: (testType: TestType) => ComputedGlobalStats;   getStatsByDifficulty: (difficulty: TestDifficulty) => ComputedGlobalStats;      // ⭐ EXPORT/IMPORT   exportOptimizedData: () => string;  // JSON string   importOptimizedData: (jsonString: string) => void; }  /**  * Configurazione per il calcolo delle statistiche  */ export interface StatsCalculationConfig {   // ⭐ SOGLIE PER CLASSIFICAZIONI   masteryThreshold: number;      // Soglia per considerare una parola "masterizzata" (default: 90%)   consistencyWindow: number;     // Finestra per calcolo consistenza (default: 10 tentativi)   recentWindow: number;          // Finestra per "recenti" (default: 5 tentativi)      // ⭐ PESI PER CALCOLI   accuracyWeight: number;        // Peso per accuratezza nel calcolo finale   speedWeight: number;           // Peso per velocità nel calcolo finale   consistencyWeight: number;     // Peso per consistenza nel calcolo finale   independenceWeight: number;    // Peso per indipendenza (meno aiuti) nel calcolo finale      // ⭐ OPZIONI DI CALCOLO   includeIncompleteTests: boolean;  // Include test non completati   normalizeByChapter: boolean;      // Normalizza per capitolo   useWeightedAverages: boolean;     // Usa medie pesate per tempo }  // ===== EXPORT TYPES ===== export type {   ComputedChapterStats as ChapterStats, OptimizedStatsReturn as EnhancedStatsReturn, ComputedGlobalStats as GlobalStats, OptimizedTestResult as TestResult, OptimizedWord as Word, ComputedWordAnalysis as WordAnalysis, OptimizedWordInput as WordInput, DetailedWordResponse as WordResponse };  // ===== CONSTANTS ===== export const DEFAULT_STATS_CONFIG: StatsCalculationConfig = {   masteryThreshold: 90,   consistencyWindow: 10,   recentWindow: 5,   accuracyWeight: 0.4,   speedWeight: 0.2,   consistencyWeight: 0.25,   independenceWeight: 0.15,   includeIncompleteTests: false,   normalizeByChapter: true,   useWeightedAverages: true };  export const DATA_VERSION = '3.0.0'; export const STORAGE_KEYS = {   optimizedTests: 'vocabulary_optimized_tests',   optimizedWords: 'vocabulary_optimized_words',   globalStats: 'vocabulary_global_stats',   chapterStats: 'vocabulary_chapter_stats',   wordAnalyses: 'vocabulary_word_analyses',   lastCalculated: 'vocabulary_last_calculated' } as const;

================================================================================


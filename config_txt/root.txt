NOME FILE: docker-compose.yml

# ===================================================== # 🐳 docker-compose.yml - LearnEnglishVOC (Updated with ENV support) # =====================================================  version: '3.8'  networks:   learnenglishvoc_network:     driver: bridge  services:   # ====== PRODUCTION SERVICE (existing) ======   learnenglishvoc:     container_name: learnenglishvoc     image: ghcr.io/merlinoalbus/learnenglishvoc:latest          # ====== ENVIRONMENT VARIABLES (NUOVO) ======     environment:       # CRITICO: API key deve essere passata dall'esterno       # Usa: export REACT_APP_GEMINI_API_KEY=your_key prima di docker-compose up       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}              # Configurazione production       - REACT_APP_ENVIRONMENT=production       - REACT_APP_DEBUG_LOGGING=false       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_AI_TIMEOUT=15000       - REACT_APP_AI_MAX_RETRIES=3       - REACT_APP_MOCK_AI_RESPONSES=false          # ====== RESOURCE LIMITS (existing) ======     deploy:       resources:         limits:           cpus: '0.5'           memory: 512M         reservations:           cpus: '0.1'           memory: 128M          # ====== NETWORKING & PORTS (existing) ======     networks:       - learnenglishvoc_network     ports:       - '12345:80'          # ====== RELIABILITY ======     restart: unless-stopped          # ====== HEALTH CHECK (NUOVO) ======     healthcheck:       test: ["CMD", "curl", "-f", "http://localhost/health", "||", "curl", "-f", "http://localhost/"]       interval: 30s       timeout: 10s       retries: 3       start_period: 40s      # ====== DEVELOPMENT SERVICE (NUOVO - opzionale) ======   learnenglishvoc-dev:     profiles: ["dev"]     container_name: learnenglishvoc-dev     build:       context: .       dockerfile: Dockerfile.dev          environment:       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}       - REACT_APP_ENVIRONMENT=development       - REACT_APP_DEBUG_LOGGING=true       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_MOCK_AI_RESPONSES=false          # Carica da .env.local se esiste (per development)     env_file:       - .env.local          ports:       - '3000:3000'          volumes:       - .:/app       - /app/node_modules          networks:       - learnenglishvoc_network          command: npm start    # ====== STAGING SERVICE (NUOVO - opzionale) ======   learnenglishvoc-staging:     profiles: ["staging"]     container_name: learnenglishvoc-staging     image: ghcr.io/merlinoalbus/learnenglishvoc:latest          environment:       - REACT_APP_GEMINI_API_KEY=${REACT_APP_GEMINI_API_KEY}       - REACT_APP_ENVIRONMENT=staging       - REACT_APP_DEBUG_LOGGING=true       - REACT_APP_ENABLE_AI_FEATURES=true       - REACT_APP_AI_TIMEOUT=15000       - REACT_APP_AI_MAX_RETRIES=3          deploy:       resources:         limits:           cpus: '0.3'           memory: 256M         reservations:           cpus: '0.1'           memory: 64M          networks:       - learnenglishvoc_network          ports:       - '8080:80'          restart: unless-stopped          healthcheck:       test: ["CMD", "curl", "-f", "http://localhost/"]       interval: 30s       timeout: 10s       retries: 3  # ===================================================== # 🔐 DEPLOYMENT INSTRUCTIONS: #  # PRODUCTION (existing service): # export REACT_APP_GEMINI_API_KEY=your_production_api_key # docker-compose up -d learnenglishvoc #  # DEVELOPMENT (new service): # echo "REACT_APP_GEMINI_API_KEY=your_dev_key" > .env.local # docker-compose --profile dev up #  # STAGING (new service): # export REACT_APP_GEMINI_API_KEY=your_staging_key # docker-compose --profile staging up -d #  # CHECK STATUS: # docker-compose ps # docker-compose logs learnenglishvoc #  # =====================================================

================================================================================

NOME FILE: Dockerfile

# ===================================================== # 🐳 Dockerfile - Vocabulary Master (WORKING FIX) # =====================================================  # Multi-stage build ottimizzato FROM node:18-alpine AS builder  # Set working directory WORKDIR /app  # ====== OPTIMIZATION 1: Cache dependencies separatamente ====== # Copy SOLO package files per cache layer COPY package*.json ./  # ====== OPTIMIZATION 3: npm ci ottimizzato ====== RUN npm ci --omit=dev --prefer-offline --no-audit --progress=false && \     npm cache clean --force  # ====== BUILD ARGS (tutti necessari) ====== ARG REACT_APP_GEMINI_API_KEY ARG REACT_APP_GEMINI_API_URL=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent ARG REACT_APP_ENVIRONMENT=production ARG REACT_APP_ENABLE_AI_FEATURES=true ARG REACT_APP_DEBUG_LOGGING=false ARG REACT_APP_AI_TIMEOUT=15000 ARG REACT_APP_AI_MAX_RETRIES=3 ARG REACT_APP_AI_RETRY_DELAY=1000 ARG REACT_APP_MOCK_AI_RESPONSES=false ARG REACT_APP_ENABLE_STATISTICS=true ARG REACT_APP_ENABLE_DATA_MANAGEMENT=true  # ====== SET ENV per build (IDENTICO A LOCALE) ====== ENV REACT_APP_GEMINI_API_KEY=$REACT_APP_GEMINI_API_KEY \     REACT_APP_GEMINI_API_URL=$REACT_APP_GEMINI_API_URL \     REACT_APP_ENVIRONMENT=$REACT_APP_ENVIRONMENT \     REACT_APP_ENABLE_AI_FEATURES=$REACT_APP_ENABLE_AI_FEATURES \     REACT_APP_DEBUG_LOGGING=$REACT_APP_DEBUG_LOGGING \     REACT_APP_AI_TIMEOUT=$REACT_APP_AI_TIMEOUT \     REACT_APP_AI_MAX_RETRIES=$REACT_APP_AI_MAX_RETRIES \     REACT_APP_AI_RETRY_DELAY=$REACT_APP_AI_RETRY_DELAY \     REACT_APP_MOCK_AI_RESPONSES=$REACT_APP_MOCK_AI_RESPONSES \     REACT_APP_ENABLE_STATISTICS=$REACT_APP_ENABLE_STATISTICS \     REACT_APP_ENABLE_DATA_MANAGEMENT=$REACT_APP_ENABLE_DATA_MANAGEMENT \     GENERATE_SOURCEMAP=true   # ====== OPTIMIZATION 4: Copy source DOPO deps install ====== COPY . .  # ====== BUILD (senza debug, con fallback) ====== RUN npm run build || (echo "Build failed, trying fallback..." && CI=false npm run build)  # ===================================================== # Production Stage # ===================================================== FROM nginx:alpine  # Copy built app COPY --from=builder /app/build /usr/share/nginx/html  # Use default nginx config (remove nginx.conf copy for now) # COPY nginx.conf /etc/nginx/nginx.conf  # Health check semplificato HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \   CMD wget --no-verbose --tries=1 --spider --timeout=2 http://localhost/ || exit 1  # Expose port EXPOSE 80  # Start nginx CMD ["nginx", "-g", "daemon off;"]

================================================================================

NOME FILE: Dockerfile.dev

# ===================================================== # 🐳 Dockerfile.dev - Development Environment # =====================================================  FROM node:18-alpine  # Set working directory WORKDIR /app  # Install dependencies for development COPY package*.json ./ RUN npm install  # Copy source code COPY . .  # Create .env.local if it doesn't exist (for container) RUN if [ ! -f .env.local ]; then cp .env.example .env.local; fi  # Expose port EXPOSE 3000  # Start development server CMD ["npm", "start"]

================================================================================

NOME FILE: nginx.conf

# ===================================================== # 📁 nginx.conf - Nginx Configuration per Production # =====================================================  events {     worker_connections 1024; }  http {     include       /etc/nginx/mime.types;     default_type  application/octet-stream;          # Logging     log_format main '$remote_addr - $remote_user [$time_local] "$request" '                     '$status $body_bytes_sent "$http_referer" '                     '"$http_user_agent" "$http_x_forwarded_for"';          access_log /var/log/nginx/access.log main;     error_log /var/log/nginx/error.log warn;          # Performance     sendfile on;     tcp_nopush on;     tcp_nodelay on;     keepalive_timeout 65;     types_hash_max_size 2048;          # Compression     gzip on;     gzip_vary on;     gzip_min_length 1024;     gzip_proxied any;     gzip_comp_level 6;     gzip_types         application/javascript         application/json         application/xml+rss         application/atom+xml         image/svg+xml         text/css         text/javascript         text/xml         text/plain;      server {         listen 80;         server_name localhost;         root /usr/share/nginx/html;         index index.html;          # Security headers         add_header X-Frame-Options "SAMEORIGIN" always;         add_header X-Content-Type-Options "nosniff" always;         add_header X-XSS-Protection "1; mode=block" always;         add_header Referrer-Policy "strict-origin-when-cross-origin" always;          # Handle React Router         location / {             try_files $uri $uri/ /index.html;         }          # Cache static assets         location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {             expires 1y;             add_header Cache-Control "public, immutable";         }          # Health check endpoint         location /health {             access_log off;             return 200 "healthy\n";             add_header Content-Type text/plain;         }          # Security: hide nginx version         server_tokens off;     } }

================================================================================

NOME FILE: postcss.config.js

// postcss.config.js // This file is part of the Tailwind CSS configuration for the Vocabulary Learning App. // It sets up PostCSS with Tailwind CSS and Autoprefixer to process CSS files. // The configuration ensures that Tailwind CSS styles are applied correctly and that vendor prefixes are added for better browser compatibility. // The PostCSS configuration is essential for building the application's styles and ensuring a consistent look across different browsers. // It is used in conjunction with Tailwind CSS to create a responsive and modern user interface.   module.exports = {   plugins: {     tailwindcss: {},     autoprefixer: {},   }, }

================================================================================

NOME FILE: tailwind.config.js

// tailwind.config.js // This file is part of the Tailwind CSS configuration for the Vocabulary Learning App. // It defines the content paths, theme extensions, colors, border radii, keyframes, and animations used throughout the application. // The configuration allows for custom styling and theming, ensuring a consistent look and feel across the application. // It is essential for building the application's styles and ensuring a responsive and modern user interface.  module.exports = {   content: [     "./src/**/*.{js,jsx,ts,tsx}",     "./public/index.html"   ],   theme: {     extend: {       colors: {         border: "hsl(var(--border))",         input: "hsl(var(--input))",         ring: "hsl(var(--ring))",         background: "hsl(var(--background))",         foreground: "hsl(var(--foreground))",         primary: {           DEFAULT: "hsl(var(--primary))",           foreground: "hsl(var(--primary-foreground))",         },         secondary: {           DEFAULT: "hsl(var(--secondary))",           foreground: "hsl(var(--secondary-foreground))",         },         destructive: {           DEFAULT: "hsl(var(--destructive))",           foreground: "hsl(var(--destructive-foreground))",         },         muted: {           DEFAULT: "hsl(var(--muted))",           foreground: "hsl(var(--muted-foreground))",         },         accent: {           DEFAULT: "hsl(var(--accent))",           foreground: "hsl(var(--accent-foreground))",         },         popover: {           DEFAULT: "hsl(var(--popover))",           foreground: "hsl(var(--popover-foreground))",         },         card: {           DEFAULT: "hsl(var(--card))",           foreground: "hsl(var(--card-foreground))",         },       },       borderRadius: {         lg: "var(--radius)",         md: "calc(var(--radius) - 2px)",         sm: "calc(var(--radius) - 4px)",       },       keyframes: {         "accordion-down": {           from: { height: 0 },           to: { height: "var(--radix-accordion-content-height)" },         },         "accordion-up": {           from: { height: "var(--radix-accordion-content-height)" },           to: { height: 0 },         },         "fade-in": {           "0%": { opacity: 0 },           "100%": { opacity: 1 },         },         "slide-in": {           "0%": { transform: "translateY(20px)", opacity: 0 },           "100%": { transform: "translateY(0)", opacity: 1 },         },       },       animation: {         "accordion-down": "accordion-down 0.2s ease-out",         "accordion-up": "accordion-up 0.2s ease-out",         "fade-in": "fade-in 0.5s ease-out",         "slide-in": "slide-in 0.3s ease-out",       },     },   },   plugins: [], }

================================================================================

NOME FILE: public\index.html

<!--  /public/index.html  This file is the main HTML template for the Vocabulary Learning App. --> <!DOCTYPE html> <html lang="it"> <head>     <meta charset="utf-8" />     <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />     <meta name="viewport" content="width=device-width, initial-scale=1" />     <meta name="theme-color" content="#000000" />     <meta             name="description"             content="App per lo studio del vocabolario inglese con statistiche avanzate"     />     <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />     <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />     <title>📚 Vocabulary Learning App</title> </head> <body> <noscript>È necessario abilitare JavaScript per utilizzare questa app.</noscript> <div id="root"></div> </body> </html>

================================================================================

NOME FILE: scripts\config-status.js

#!/usr/bin/env node  // ===================================================== // 📁 scripts/config-status.js - Configuration Status Check // =====================================================  const fs = require('fs'); const path = require('path');  // Colors for console output const colors = {   reset: '\x1b[0m',   bright: '\x1b[1m',   red: '\x1b[31m',   green: '\x1b[32m',   yellow: '\x1b[33m',   blue: '\x1b[34m',   magenta: '\x1b[35m',   cyan: '\x1b[36m' };  function colorize(text, color) {   return `${colors[color]}${text}${colors.reset}`; }  function logHeader(text) {   console.log('\n' + colorize('='.repeat(60), 'cyan'));   console.log(colorize(`🔧 ${text}`, 'cyan'));   console.log(colorize('='.repeat(60), 'cyan')); }  function logSection(text) {   console.log('\n' + colorize(`📋 ${text}`, 'blue'));   console.log(colorize('-'.repeat(40), 'blue')); }  function logSuccess(text) {   console.log(colorize(`✅ ${text}`, 'green')); }  function logWarning(text) {   console.log(colorize(`⚠️  ${text}`, 'yellow')); }  function logError(text) {   console.log(colorize(`❌ ${text}`, 'red')); }  function logInfo(text) {   console.log(colorize(`ℹ️  ${text}`, 'blue')); }  // Check if file exists function fileExists(filePath) {   try {     return fs.existsSync(path.resolve(filePath));   } catch (error) {     return false;   } }  // Read environment variable from .env files function readEnvFile(filePath) {   try {     if (!fileExists(filePath)) return {};          const content = fs.readFileSync(path.resolve(filePath), 'utf8');     const env = {};          content.split('\n').forEach(line => {       line = line.trim();       if (line && !line.startsWith('#')) {         const [key, ...valueParts] = line.split('=');         if (key && valueParts.length > 0) {           env[key.trim()] = valueParts.join('=').trim();         }       }     });          return env;   } catch (error) {     return {};   } }  // Get environment variable value function getEnvVar(key, envFiles = []) {   // Check process.env first (runtime environment)   if (process.env[key]) {     return process.env[key];   }      // Check .env files   for (const envFile of envFiles) {     const env = readEnvFile(envFile);     if (env[key]) {       return env[key];     }   }      return undefined; }  // Validate API key format function validateApiKey(apiKey) {   if (!apiKey) return { valid: false, reason: 'Missing' };   if (apiKey.length < 20) return { valid: false, reason: 'Too short' };   if (apiKey === 'your_gemini_api_key_here') return { valid: false, reason: 'Default template value' };   if (apiKey === 'your_api_key_here') return { valid: false, reason: 'Default template value' };   return { valid: true, reason: 'Valid format' }; }  // Main configuration check function checkConfiguration() {   logHeader('Vocabulary Master - Configuration Status');      // Environment files to check   const envFiles = ['.env.local', '.env.development', '.env'];      logSection('Environment Files');      let hasEnvFile = false;   envFiles.forEach(file => {     if (fileExists(file)) {       logSuccess(`Found: ${file}`);       hasEnvFile = true;     } else {       logInfo(`Not found: ${file}`);     }   });      if (!hasEnvFile) {     logWarning('No environment files found');     logInfo('Run: npm run setup:env');   }      // Check example file   if (fileExists('.env.example')) {     logSuccess('Template file: .env.example');   } else {     logError('Missing: .env.example template');   }      logSection('Environment Variables');      // Required variables   const requiredVars = [     { key: 'REACT_APP_GEMINI_API_KEY', description: 'Gemini AI API Key', required: true }   ];      // Optional variables   const optionalVars = [     { key: 'REACT_APP_ENVIRONMENT', description: 'App Environment' },     { key: 'REACT_APP_DEBUG_LOGGING', description: 'Debug Logging' },     { key: 'REACT_APP_ENABLE_AI_FEATURES', description: 'AI Features Enabled' },     { key: 'REACT_APP_MOCK_AI_RESPONSES', description: 'Mock AI Responses' },     { key: 'REACT_APP_AI_TIMEOUT', description: 'AI Request Timeout' },     { key: 'REACT_APP_AI_MAX_RETRIES', description: 'AI Max Retries' }   ];      let allConfigured = true;      // Check required variables   console.log('\n' + colorize('Required Variables:', 'bright'));   requiredVars.forEach(({ key, description, required }) => {     const value = getEnvVar(key, envFiles);          if (value) {       if (key === 'REACT_APP_GEMINI_API_KEY') {         const validation = validateApiKey(value);         if (validation.valid) {           logSuccess(`${key}: Configured (${validation.reason})`);         } else {           logError(`${key}: ${validation.reason}`);           allConfigured = false;         }       } else {         logSuccess(`${key}: ${value}`);       }     } else {       if (required) {         logError(`${key}: Missing (${description})`);         allConfigured = false;       } else {         logWarning(`${key}: Not set (${description})`);       }     }   });      // Check optional variables   console.log('\n' + colorize('Optional Variables:', 'bright'));   optionalVars.forEach(({ key, description }) => {     const value = getEnvVar(key, envFiles);     if (value) {       logInfo(`${key}: ${value}`);     } else {       logInfo(`${key}: Using default`);     }   });      logSection('Configuration Status');      // Overall status   if (allConfigured) {     logSuccess('Configuration is complete!');     logSuccess('All required variables are properly set');   } else {     logError('Configuration is incomplete!');     logError('Some required variables are missing or invalid');   }      // Feature availability   const apiKey = getEnvVar('REACT_APP_GEMINI_API_KEY', envFiles);   const aiEnabled = getEnvVar('REACT_APP_ENABLE_AI_FEATURES', envFiles);   const mockMode = getEnvVar('REACT_APP_MOCK_AI_RESPONSES', envFiles);      console.log('\n' + colorize('Feature Availability:', 'bright'));      if (apiKey && validateApiKey(apiKey).valid) {     if (aiEnabled === 'false') {       logWarning('AI Features: Disabled by configuration');     } else {       logSuccess('AI Features: Available');     }   } else {     if (mockMode === 'true') {       logWarning('AI Features: Mock mode (no real API calls)');     } else {       logError('AI Features: Unavailable (no valid API key)');     }   }      logSection('Security Check');      // Check for hardcoded credentials with smart filtering   const sourceFiles = [     'src/constants/appConstants.js',     'src/services/aiService.js',     'src/config/appConfig.js'   ];      let securityIssues = false;      sourceFiles.forEach(file => {     if (fileExists(file)) {       try {         const content = fs.readFileSync(path.resolve(file), 'utf8');                  // Smart patterns that avoid false positives         const suspiciousPatterns = [           {             pattern: /['"]AIzaSy[0-9A-Za-z-_]{33}['"]/g,             name: 'Google API Key'           },           {             pattern: /apiKey\s*[:=]\s*['"][A-Za-z0-9-_]{20,}['"]/g,             name: 'Hardcoded API Key'           }         ];                  let fileHasIssues = false;                  suspiciousPatterns.forEach(({ pattern, name }) => {           const matches = content.match(pattern);           if (matches) {             // Filter out false positives             const realMatches = matches.filter(match => {               // Skip placeholder values               if (match.includes('your_api_key') ||                    match.includes('your_key_here') ||                    match.includes('example') ||                    match.includes('placeholder')) {                 return false;               }                              // Check if it's in a comment               const lines = content.split('\n');               const matchLine = lines.find(line => line.includes(match));               if (matchLine && (matchLine.trim().startsWith('//') ||                                matchLine.trim().startsWith('*') ||                               matchLine.includes('RIMOSSA PER SICUREZZA'))) {                 return false;               }                              return true;             });                          if (realMatches.length > 0) {               fileHasIssues = true;             }           }         });                  if (fileHasIssues) {           logError(`Real security issues in: ${file}`);           securityIssues = true;         } else {           logSuccess(`Clean: ${file}`);         }       } catch (error) {         logWarning(`Could not check: ${file}`);       }     }   });      if (!securityIssues) {     logSuccess('No hardcoded credentials detected');   } else {     logError('Security issues found! Remove hardcoded credentials');   }      logSection('Recommendations');      if (!allConfigured) {     console.log('\n' + colorize('To fix configuration issues:', 'yellow'));     console.log('1. Copy template: ' + colorize('cp .env.example .env.local', 'cyan'));     console.log('2. Get API key: ' + colorize('https://makersuite.google.com/app/apikey', 'cyan'));     console.log('3. Add API key to .env.local');     console.log('4. Restart development server');   }      if (securityIssues) {     console.log('\n' + colorize('To fix security issues:', 'red'));     console.log('1. Remove hardcoded credentials from source files');     console.log('2. Use environment variables instead');     console.log('3. Commit clean code only');   }      console.log('\n' + colorize('For more help:', 'blue'));   console.log('📖 Read: SECURITY_SETUP.md');   console.log('🔧 Run: npm run setup:env');      logHeader('Configuration Check Complete');      // Exit with appropriate code   process.exit(allConfigured && !securityIssues ? 0 : 1); }  // Run the check if (require.main === module) {   checkConfiguration(); }  module.exports = { checkConfiguration };

================================================================================

NOME FILE: scripts\deploy.sh

#!/bin/bash  # ===================================================== # 📁 scripts/deploy.sh - Deployment Script per LearnEnglishVOC # =====================================================  set -e  # Exit on any error  # Colors for output RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' NC='\033[0m' # No Color  # Functions log_info() {     echo -e "${BLUE}ℹ️  $1${NC}" }  log_success() {     echo -e "${GREEN}✅ $1${NC}" }  log_warning() {     echo -e "${YELLOW}⚠️  $1${NC}" }  log_error() {     echo -e "${RED}❌ $1${NC}" }  # Configuration CONTAINER_NAME="learnenglishvoc" IMAGE_NAME="ghcr.io/merlinoalbus/learnenglishvoc:latest" ENVIRONMENT="${1:-production}"  # Main deployment function deploy() {     log_info "🚀 Starting deployment for environment: $ENVIRONMENT"          # Check if API key is set     if [ -z "$REACT_APP_GEMINI_API_KEY" ]; then         if [ "$ENVIRONMENT" = "development" ] && [ -f ".env.local" ]; then             log_info "Using API key from .env.local for development"         else             log_error "REACT_APP_GEMINI_API_KEY environment variable not set!"             log_info "Set it with: export REACT_APP_GEMINI_API_KEY=your_api_key"             exit 1         fi     else         log_success "API key found in environment"     fi          # Pre-deployment checks     log_info "🔍 Running pre-deployment checks..."          # Check Docker is running     if ! docker info > /dev/null 2>&1; then         log_error "Docker is not running!"         exit 1     fi     log_success "Docker is running"          # Check if container exists and stop it     if docker ps -q -f name="$CONTAINER_NAME" | grep -q .; then         log_info "🛑 Stopping existing container..."         docker-compose down         log_success "Container stopped"     fi          # Pull latest image (for production)     if [ "$ENVIRONMENT" = "production" ] || [ "$ENVIRONMENT" = "staging" ]; then         log_info "📥 Pulling latest image..."         docker pull "$IMAGE_NAME"         log_success "Image updated"     fi          # Deploy based on environment     case $ENVIRONMENT in         "production")             log_info "🏭 Deploying to PRODUCTION..."             docker-compose up -d learnenglishvoc             ;;         "staging")             log_info "🧪 Deploying to STAGING..."             docker-compose --profile staging up -d             ;;         "development")             log_info "🛠️ Starting DEVELOPMENT environment..."             docker-compose --profile dev up             ;;         *)             log_error "Unknown environment: $ENVIRONMENT"             log_info "Usage: $0 [production|staging|development]"             exit 1             ;;     esac          # Wait for container to be ready     log_info "⏳ Waiting for container to be ready..."     sleep 10          # Health check     if [ "$ENVIRONMENT" = "production" ]; then         PORT="12345"     elif [ "$ENVIRONMENT" = "staging" ]; then         PORT="8080"     else         PORT="3000"     fi          # Test if app is responding     for i in {1..30}; do         if curl -s -f "http://localhost:$PORT" > /dev/null; then             log_success "🎉 Deployment successful! App is running on port $PORT"                          # Show container status             echo ""             log_info "📊 Container Status:"             docker-compose ps                          # Show logs             echo ""             log_info "📝 Recent logs:"             docker-compose logs --tail=20 learnenglishvoc 2>/dev/null || docker-compose logs --tail=20                          # Configuration check (if in production/staging)             if [ "$ENVIRONMENT" != "development" ]; then                 echo ""                 log_info "🔧 Testing configuration..."                 if docker exec "$CONTAINER_NAME" which node > /dev/null 2>&1; then                     # If Node.js is available in container, run config check                     docker exec "$CONTAINER_NAME" node scripts/config-status.js 2>/dev/null || log_info "Config check not available in production image"                 fi             fi                          echo ""             log_success "🌐 Access your app at: http://localhost:$PORT"             exit 0         fi                  log_info "Waiting for app to start... ($i/30)"         sleep 2     done          log_error "❌ Deployment failed! App is not responding after 60 seconds"          # Show logs for debugging     echo ""     log_info "📝 Container logs for debugging:"     docker-compose logs learnenglishvoc 2>/dev/null || docker-compose logs          exit 1 }  # Show usage if no arguments if [ $# -eq 0 ]; then     echo "🐳 LearnEnglishVOC Deployment Script"     echo ""     echo "Usage: $0 [environment]"     echo ""     echo "Environments:"     echo "  production  - Deploy to production (port 12345)"     echo "  staging     - Deploy to staging (port 8080)"     echo "  development - Start development server (port 3000)"     echo ""     echo "Examples:"     echo "  $0 production"     echo "  $0 staging"     echo "  $0 development"     echo ""     echo "Note: Set REACT_APP_GEMINI_API_KEY environment variable before running"     exit 0 fi  # Run deployment deploy

================================================================================

NOME FILE: scripts\extract.ps1

param(     [Parameter(Mandatory=$true)]     [string]$SourcePath,          [Parameter(Mandatory=$false)]     [string]$OutputFile = "extracted_files_content.txt",      [Parameter(Mandatory=$false)]     [string[]]$PathsToSkip )  # Verifica che il path esista if (-not (Test-Path -Path $SourcePath)) {     Write-Error "Il path specificato non esiste: $SourcePath"     exit 1 }  # Converte il path in formato assoluto $resolvedSourcePath = Resolve-Path -Path $SourcePath  # Definisce le estensioni di file da processare $TargetExtensions = @('.js','.conf', '.yml', '.yaml', '.html', '.css', '.ts', '.tsx', '.vue', '.scss', '.properties', '.sh', '.ps1')  # Lista di esclusione per cartelle di sistema/build $ExcludedFolders = @('.idea', '.gitignore','config_txt','.github', 'node_modules', 'dist', 'build', 'vendor', 'coverage', 'test', 'tests', 'tmp', 'temp')  # Svuota il file di output prima di iniziare if (Test-Path -Path $OutputFile) {     Clear-Content -Path $OutputFile } else {     New-Item -Path $OutputFile -ItemType File -Force | Out-Null }  Write-Host "Inizio scansione del path: $($resolvedSourcePath.Path) (Ricorsiva)" -ForegroundColor Cyan  # Converte i percorsi da saltare in percorsi assoluti $ResolvedPathsToSkip = @() if ($null -ne $PathsToSkip -and $PathsToSkip.Count -gt 0) {     foreach ($path in $PathsToSkip) {         try {             # Risolve il percorso relativo in assoluto             $absolutePath = Resolve-Path -Path $path -ErrorAction Stop             $ResolvedPathsToSkip += $absolutePath.Path             Write-Host "Percorso da saltare risolto: $($absolutePath.Path)" -ForegroundColor DarkYellow         } catch {             Write-Warning "Impossibile risolvere il percorso da saltare: $path"         }     } }  # Contatori $ProcessedFiles = 0 $SkippedFiles = 0  try {     $AllFiles = Get-ChildItem -Path $resolvedSourcePath.Path -Recurse -File          foreach ($File in $AllFiles) {         # Calcola il percorso relativo         $RelativePath = $File.FullName.Substring($resolvedSourcePath.Path.Length).TrimStart('\')         if ([string]::IsNullOrEmpty($RelativePath)) { $RelativePath = $File.Name }          # Controlla se il file appartiene a un percorso da saltare         $isPathManuallySkipped = $false         if ($ResolvedPathsToSkip.Count -gt 0) {             foreach ($absolutePathToSkip in $ResolvedPathsToSkip) {                 # Confronta i percorsi assoluti                 if ($File.FullName.StartsWith($absolutePathToSkip, [System.StringComparison]::OrdinalIgnoreCase)) {                     $isPathManuallySkipped = $true                     Write-Host "Saltato (Percorso escluso manualmente): $RelativePath" -ForegroundColor Red                     break                 }             }         }                  if ($isPathManuallySkipped) {             $SkippedFiles++             continue         }                  # Verifica se il file è in una cartella esclusa         $isFolderExcluded = $false         $ExclusionReason = ""         foreach ($ExcludedFolder in $ExcludedFolders) {             if ($File.DirectoryName -like "*\$ExcludedFolder" -or $File.DirectoryName -like "*\$ExcludedFolder\*") {                 $isFolderExcluded = $true                 $ExclusionReason = $ExcludedFolder                 break             }         }                  if ($isFolderExcluded) {             $SkippedFiles++             continue         }                  # Verifica l'estensione         $ShouldProcess = $false         if (($File.Extension -in $TargetExtensions) -or ($File.Name -eq "Dockerfile") -or ($File.Name -like "Dockerfile.*")) {             $ShouldProcess = $true         }                  if (-not $ShouldProcess) {             Write-Host "Saltato (Tipo di file non valido): $RelativePath" -ForegroundColor Yellow             $SkippedFiles++             continue         }                  try {             Write-Host "Processando: $RelativePath" -ForegroundColor Gray             $FileContent = Get-Content -Path $File.FullName -Raw -ErrorAction Stop -Encoding UTF8             $FileContent = $FileContent -replace "\r?\n", " "                          if ([string]::IsNullOrEmpty($FileContent.Trim())) {                 $FileContent = "[FILE VUOTO]"             }                          $OutputContent = @" NOME FILE: $RelativePath  $FileContent  ================================================================================  "@                          Add-Content -Path $OutputFile -Value $OutputContent -Encoding UTF8             $ProcessedFiles++                      } catch {             Write-Warning "Errore durante la lettura del file: $($File.FullName) - $($_.Exception.Message)"             $SkippedFiles++         }     }          # Statistiche finali     Write-Host "`n=== STATISTICHE ($($resolvedSourcePath.Path)) ===" -ForegroundColor Green     Write-Host "File processati: $ProcessedFiles" -ForegroundColor Green     Write-Host "File saltati: $SkippedFiles" -ForegroundColor Yellow     Write-Host "Output salvato in: $OutputFile" -ForegroundColor Green      } catch {     Write-Error "Errore durante l'esecuzione dello script: $($_.Exception.Message)"     exit 1 }  Write-Host "`nCompletato per $($resolvedSourcePath.Path)`n" -ForegroundColor Green

================================================================================

NOME FILE: scripts\security-check.js

#!/usr/bin/env node  // ===================================================== // 📁 scripts/security-check.js - Security Audit Script // =====================================================  const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process');  // Colors for console output const colors = {   reset: '\x1b[0m',   bright: '\x1b[1m',   red: '\x1b[31m',   green: '\x1b[32m',   yellow: '\x1b[33m',   blue: '\x1b[34m',   magenta: '\x1b[35m',   cyan: '\x1b[36m' };  function colorize(text, color) {   return `${colors[color]}${text}${colors.reset}`; }  function logHeader(text) {   console.log('\n' + colorize('='.repeat(60), 'magenta'));   console.log(colorize(`🔐 ${text}`, 'magenta'));   console.log(colorize('='.repeat(60), 'magenta')); }  function logSection(text) {   console.log('\n' + colorize(`🔍 ${text}`, 'blue'));   console.log(colorize('-'.repeat(40), 'blue')); }  function logSuccess(text) {   console.log(colorize(`✅ ${text}`, 'green')); }  function logWarning(text) {   console.log(colorize(`⚠️  ${text}`, 'yellow')); }  function logError(text) {   console.log(colorize(`🚨 ${text}`, 'red')); }  function logInfo(text) {   console.log(colorize(`ℹ️  ${text}`, 'blue')); }  function logCritical(text) {   console.log(colorize(`💥 CRITICAL: ${text}`, 'red')); }  // Check if file exists function fileExists(filePath) {   try {     return fs.existsSync(path.resolve(filePath));   } catch (error) {     return false;   } }  // Get all files in directory recursively function getAllFiles(dirPath, arrayOfFiles = []) {   const files = fs.readdirSync(dirPath);    files.forEach(file => {     const fullPath = path.join(dirPath, file);     if (fs.statSync(fullPath).isDirectory()) {       // Skip node_modules, build, and other non-source directories       if (!['node_modules', 'build', '.git', 'dist', 'coverage'].includes(file)) {         arrayOfFiles = getAllFiles(fullPath, arrayOfFiles);       }     } else {       arrayOfFiles.push(fullPath);     }   });    return arrayOfFiles; }  // Security patterns to check for const SECURITY_PATTERNS = [   {     name: 'Google API Keys',     pattern: /['"]AIzaSy[0-9A-Za-z-_]{33}['"]/g,     severity: 'CRITICAL',     description: 'Google API key detected'   },   {     name: 'Hardcoded API Keys',     pattern: /apiKey\s*[:=]\s*['"][A-Za-z0-9-_]{20,}['"]/g,     severity: 'HIGH',     description: 'Hardcoded API key'   },   {     name: 'Environment Variables in Code',     pattern: /REACT_APP_[A-Z_]+\s*[:=]\s*['"][^'"]+['"]/g,     severity: 'MEDIUM',     description: 'Environment variable with hardcoded value'   },   {     name: 'AWS Keys',     pattern: /AKIA[0-9A-Z]{16}/g,     severity: 'CRITICAL',     description: 'AWS access key detected'   },   {     name: 'Private Keys',     pattern: /-----BEGIN [A-Z ]+PRIVATE KEY-----/g,     severity: 'CRITICAL',     description: 'Private key detected'   },   {     name: 'Database URLs',     pattern: /(mongodb|postgres|mysql):\/\/[^\s'"]+/g,     severity: 'HIGH',     description: 'Database connection string'   },   {     name: 'JWT Tokens',     pattern: /eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*/g,     severity: 'HIGH',     description: 'JWT token detected'   },   {     name: 'Slack Tokens',     pattern: /xox[bpoa]-[0-9]{12}-[0-9]{12}-[0-9]{12}-[a-z0-9]{32}/g,     severity: 'HIGH',     description: 'Slack token detected'   } ];  // File extensions to check const CHECK_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.json', '.env', '.md', '.yml', '.yaml'];  // Files that should never contain credentials const CRITICAL_FILES = [   'package.json',   'package-lock.json',   'yarn.lock',   'README.md',   'SECURITY_SETUP.md' ];  function checkFileForSecrets(filePath) {   try {     const content = fs.readFileSync(filePath, 'utf8');     const issues = [];          // Skip checking template files and examples     const fileName = path.basename(filePath);     if (fileName.includes('.example') || fileName.includes('template') || fileName.includes('sample')) {       return issues;     }          SECURITY_PATTERNS.forEach(({ name, pattern, severity, description }) => {       const matches = content.match(pattern);       if (matches) {         // Filter out false positives         const realMatches = matches.filter(match => {           // Skip comments and documentation           const lines = content.split('\n');           const matchLine = lines.find(line => line.includes(match));           if (matchLine && (matchLine.trim().startsWith('//') || matchLine.trim().startsWith('*') || matchLine.includes('example') || matchLine.includes('your_api_key'))) {             return false;           }                      // Skip placeholder values           if (match.includes('your_api_key') || match.includes('your_key_here') || match.includes('example') || match.includes('placeholder')) {             return false;           }                      return true;         });                  realMatches.forEach(match => {           issues.push({             file: filePath,             pattern: name,             severity,             description,             match: match.substring(0, 50) + (match.length > 50 ? '...' : ''),             line: content.substring(0, content.indexOf(match)).split('\n').length           });         });       }     });          return issues;   } catch (error) {     return [];   } }  function checkGitignore() {   logSection('Git Ignore Check');      const gitignorePath = '.gitignore';   const requiredPatterns = [     '.env',     '.env.local',     '.env.development.local',     '.env.test.local',     '.env.production.local',     '*.backup',     '*.bak',     '*-secrets.*',     '*-credentials.*'   ];      if (!fileExists(gitignorePath)) {     logError('No .gitignore file found');     return false;   }      const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');   const missingPatterns = [];      requiredPatterns.forEach(pattern => {     if (!gitignoreContent.includes(pattern)) {       missingPatterns.push(pattern);     }   });      if (missingPatterns.length === 0) {     logSuccess('Git ignore properly configured');     return true;   } else {     logWarning(`Missing patterns in .gitignore: ${missingPatterns.join(', ')}`);     return false;   } }  function checkEnvironmentFiles() {   logSection('Environment Files Check');      const envFiles = ['.env', '.env.local', '.env.development', '.env.production'];   let hasIssues = false;      envFiles.forEach(file => {     if (fileExists(file)) {       if (file === '.env.example') {         logSuccess(`Template file found: ${file}`);       } else {         logWarning(`Environment file detected: ${file}`);         logInfo('Ensure this file is in .gitignore and contains no real credentials');                  // Check if it's tracked by git         try {           execSync(`git ls-files --error-unmatch ${file}`, { stdio: 'ignore' });           logCritical(`Environment file ${file} is tracked by Git!`);           hasIssues = true;         } catch (error) {           logSuccess(`Environment file ${file} is not tracked by Git`);         }       }     }   });      return !hasIssues; }  function checkCommitHistory() {   logSection('Git History Check');      try {     // Check recent commits for potential credential leaks     const recentCommits = execSync('git log --oneline -10 --grep="key\\|secret\\|password\\|token" -i', {        encoding: 'utf8',       stdio: 'pipe'     });          if (recentCommits.trim()) {       logWarning('Found commits with potential credential-related messages:');       console.log(recentCommits);     } else {       logSuccess('No suspicious commit messages found');     }          return true;   } catch (error) {     logInfo('Could not check git history (no git repository or no commits)');     return true;   } }  function runNpmAudit() {   logSection('NPM Security Audit');      try {     const auditResult = execSync('npm audit --audit-level=moderate --json', {        encoding: 'utf8',       stdio: 'pipe'     });          const audit = JSON.parse(auditResult);          if (audit.metadata.vulnerabilities.total === 0) {       logSuccess('No security vulnerabilities found in dependencies');       return true;     } else {       const { info, low, moderate, high, critical } = audit.metadata.vulnerabilities;              if (critical > 0) {         logCritical(`${critical} critical vulnerabilities found`);       }       if (high > 0) {         logError(`${high} high vulnerabilities found`);       }       if (moderate > 0) {         logWarning(`${moderate} moderate vulnerabilities found`);       }       if (low > 0) {         logInfo(`${low} low vulnerabilities found`);       }       if (info > 0) {         logInfo(`${info} info vulnerabilities found`);       }              logInfo('Run "npm audit fix" to attempt automatic fixes');       return critical === 0 && high === 0; // Allow moderate and below     }   } catch (error) {     try {       // Try without JSON flag for older npm versions       execSync('npm audit', { stdio: 'inherit' });       return true;     } catch (error2) {       logWarning('Could not run npm audit');       return true;     }   } }  function main() {   logHeader('Security Audit - Vocabulary Master');      let overallSecure = true;   let criticalIssues = 0;   let highIssues = 0;   let mediumIssues = 0;      // Check for hardcoded secrets in files   logSection('Source Code Secret Scan');      try {     const allFiles = getAllFiles('./src');     const sourceFiles = allFiles.filter(file =>        CHECK_EXTENSIONS.some(ext => file.endsWith(ext))     );          let totalIssues = 0;          sourceFiles.forEach(file => {       const issues = checkFileForSecrets(file);       if (issues.length > 0) {         issues.forEach(issue => {           totalIssues++;           const icon = issue.severity === 'CRITICAL' ? '💥' :                        issue.severity === 'HIGH' ? '🚨' : '⚠️';                      console.log(`${icon} ${colorize(issue.severity, 'red')} in ${colorize(issue.file, 'yellow')}:${issue.line}`);           console.log(`   ${issue.description}: ${colorize(issue.match, 'red')}`);                      if (issue.severity === 'CRITICAL') criticalIssues++;           else if (issue.severity === 'HIGH') highIssues++;           else mediumIssues++;         });       }     });          if (totalIssues === 0) {       logSuccess('No secrets detected in source code');     } else {       logError(`Found ${totalIssues} potential security issues`);       overallSecure = false;     }   } catch (error) {     logWarning('Could not scan source files');   }      // Check critical files   logSection('Critical Files Check');      CRITICAL_FILES.forEach(file => {     if (fileExists(file)) {       const issues = checkFileForSecrets(file);       if (issues.length > 0) {         logCritical(`Secrets found in critical file: ${file}`);         criticalIssues += issues.length;         overallSecure = false;       } else {         logSuccess(`Clean: ${file}`);       }     }   });      // Run other checks   const gitignoreOk = checkGitignore();   const envFilesOk = checkEnvironmentFiles();   const commitHistoryOk = checkCommitHistory();   const npmAuditOk = runNpmAudit();      overallSecure = overallSecure && gitignoreOk && envFilesOk && commitHistoryOk && npmAuditOk;      // Final assessment   logSection('Security Assessment');      if (criticalIssues > 0) {     logCritical(`${criticalIssues} critical security issues found`);   }   if (highIssues > 0) {     logError(`${highIssues} high-severity issues found`);   }   if (mediumIssues > 0) {     logWarning(`${mediumIssues} medium-severity issues found`);   }      if (overallSecure && criticalIssues === 0) {     logSuccess('Security audit passed!');     logSuccess('No critical security issues detected');   } else {     logError('Security audit failed!');     logError('Critical security issues must be addressed');   }      // Recommendations   logSection('Security Recommendations');      if (criticalIssues > 0 || highIssues > 0) {     console.log('\n' + colorize('🔥 IMMEDIATE ACTIONS REQUIRED:', 'red'));     console.log('1. Remove all hardcoded credentials from source code');     console.log('2. Move credentials to environment variables');     console.log('3. Add .env* files to .gitignore');     console.log('4. Review git history for leaked credentials');     console.log('5. Regenerate any exposed API keys');   }      console.log('\n' + colorize('🔐 General Security Best Practices:', 'blue'));   console.log('• Use environment variables for all secrets');   console.log('• Keep .env files out of version control');   console.log('• Regularly rotate API keys and credentials');   console.log('• Run security audits before each deployment');   console.log('• Use HTTPS for all external API calls');   console.log('• Keep dependencies updated');      console.log('\n' + colorize('📚 Resources:', 'cyan'));   console.log('• Security Setup Guide: SECURITY_SETUP.md');   console.log('• Environment Config: npm run config:status');   console.log('• Git Secrets Tool: https://github.com/awslabs/git-secrets');      logHeader('Security Audit Complete');      // Exit with appropriate code   const exitCode = (criticalIssues === 0 && overallSecure) ? 0 : 1;   if (exitCode !== 0) {     logError('Security audit failed - fix issues before deployment');   }      process.exit(exitCode); }  // Run the security check if (require.main === module) {   main(); }  module.exports = { main };

================================================================================

NOME FILE: scripts\wrapper.ps1

# Definisce il percorso della cartella di configurazione $configFolder = ".\..\config_txt"  # Definisce l'elenco dei percorsi gestiti separatamente $specificPaths = @(     "..\src\views",     "..\src\utils",     "..\src\services",     "..\src\layouts",     "..\src\hooks",     "..\src\contexts",     "..\src\constants",     "..\src\components" )  # Crea la cartella 'config' se non esiste if (-not (Test-Path -Path $configFolder -PathType Container)) {     New-Item -Path $configFolder -ItemType Directory }  # Cancella tutti i file .txt nella cartella 'config' Remove-Item -Path "$configFolder\*.txt" -ErrorAction SilentlyContinue  # Esegue gli script di estrazione  # Chiamata alla root, ricorsiva, ma saltando i percorsi specifici .\extract.ps1 -SourcePath ".\..\" -OutputFile "$configFolder\root.txt" -PathsToSkip $specificPaths  # Chiamate specifiche .\extract.ps1 -SourcePath ".\..\src\views" -OutputFile "$configFolder\views.txt" .\extract.ps1 -SourcePath ".\..\src\utils" -OutputFile "$configFolder\utils.txt" .\extract.ps1 -SourcePath ".\..\src\services" -OutputFile "$configFolder\services.txt" .\extract.ps1 -SourcePath ".\..\src\layouts" -OutputFile "$configFolder\layouts.txt" .\extract.ps1 -SourcePath ".\..\src\hooks" -OutputFile "$configFolder\hooks.txt" .\extract.ps1 -SourcePath ".\..\src\contexts" -OutputFile "$configFolder\contexts.txt" .\extract.ps1 -SourcePath ".\..\src\constants" -OutputFile "$configFolder\constants.txt" .\extract.ps1 -SourcePath ".\..\src\components" -OutputFile "$configFolder\components.txt"  Write-Host "Operazione completata! I file di output sono stati creati nella cartella '$configFolder'."

================================================================================

NOME FILE: src\App.css

/* App.css - Stili aggiornati per la nuova versione */  * {   margin: 0;   padding: 0;   box-sizing: border-box; }  body {   font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;   background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);   min-height: 100vh;   color: #333; }  .app {   min-height: 100vh;   display: flex;   flex-direction: column; }  /* ===== HEADER MIGLIORATO ===== */ .app-header {   background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);   color: white;   padding: 1.5rem 2rem;   box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1); }  .header-content {   max-width: 1200px;   margin: 0 auto;   display: flex;   justify-content: space-between;   align-items: center;   gap: 2rem; }  .header-main h1 {   font-size: 2.2rem;   margin-bottom: 0.5rem;   font-weight: 700; }  .header-main p {   opacity: 0.9;   font-size: 1.1rem; }  .header-stats {   display: flex;   gap: 1.5rem;   align-items: center; }  .header-stat {   text-align: center;   min-width: 60px; }  .header-stat span {   display: block;   font-size: 1.4rem;   font-weight: bold;   line-height: 1; }  .header-stat small {   font-size: 0.8rem;   opacity: 0.8;   margin-top: 0.2rem;   display: block; }  .header-stat.streak span {   font-size: 1.2rem; }  /* ===== NAVIGATION MIGLIORATA ===== */ .app-nav {   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-bottom: 1px solid rgba(0, 0, 0, 0.1);   padding: 0.5rem 0;   position: sticky;   top: 0;   z-index: 100; }  .nav-container {   max-width: 1200px;   margin: 0 auto;   display: flex;   gap: 0.5rem;   padding: 0 1rem;   justify-content: center;   overflow-x: auto; }  .nav-btn {   display: flex;   flex-direction: column;   align-items: center;   gap: 0.3rem;   padding: 0.8rem 1rem;   border: none;   background: transparent;   border-radius: 12px;   cursor: pointer;   transition: all 0.2s ease;   min-width: 80px;   position: relative;   text-decoration: none;   color: #555; }  .nav-btn:hover {   background: rgba(52, 152, 219, 0.1);   transform: translateY(-1px); }  .nav-btn.active {   background: linear-gradient(145deg, #3498db, #2980b9);   color: white;   box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);   transform: translateY(-1px); }  .nav-icon {   font-size: 1.3rem;   line-height: 1; }  .nav-text {   font-size: 0.8rem;   font-weight: 500;   white-space: nowrap; }  .nav-badge {   position: absolute;   top: 0.2rem;   right: 0.2rem;   background: #e74c3c;   color: white;   font-size: 0.7rem;   padding: 0.1rem 0.4rem;   border-radius: 10px;   min-width: 18px;   text-align: center;   line-height: 1.2;   font-weight: bold; }  /* ===== INDICATORE SEZIONE ===== */ .section-indicator {   background: rgba(255, 255, 255, 0.9);   backdrop-filter: blur(10px);   padding: 0.8rem 2rem;   display: flex;   align-items: center;   gap: 0.8rem;   border-bottom: 1px solid rgba(0, 0, 0, 0.05); }  .indicator-icon {   font-size: 1.2rem; }  .indicator-text {   font-weight: 600;   color: #2c3e50;   font-size: 1rem; }  /* ===== MAIN CONTENT ===== */ .app-main {   flex: 1;   max-width: 1200px;   margin: 0 auto;   padding: 2rem;   width: 100%; }  /* ===== SCHERMATA INIZIALE TEST ===== */ .start-test {   text-align: center;   padding: 3rem 2rem; }  .start-test-content {   max-width: 600px;   margin: 0 auto;   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-radius: 20px;   padding: 3rem 2rem;   box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); }  .start-test h2 {   color: #2c3e50;   margin-bottom: 2rem;   font-size: 2rem; }  .test-info {   display: grid;   grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));   gap: 1rem;   margin: 2rem 0; }  .info-card {   background: linear-gradient(145deg, #f8f9fa, #ffffff);   border: 1px solid #e9ecef;   border-radius: 12px;   padding: 1.2rem 0.8rem;   display: flex;   flex-direction: column;   align-items: center;   gap: 0.5rem;   transition: transform 0.2s ease; }  .info-card:hover {   transform: translateY(-2px); }  .info-icon {   font-size: 1.8rem;   line-height: 1; }  .info-card strong {   font-size: 1.5rem;   color: #2c3e50;   font-weight: bold; }  .info-card p {   font-size: 0.8rem;   color: #7f8c8d;   text-align: center;   margin: 0; }  .btn-large {   font-size: 1.1rem;   padding: 1rem 2rem;   margin: 2rem 0 1rem 0; }  .help-text {   color: #7f8c8d;   font-style: italic;   margin-top: 1rem; }  /* ===== PULSANTI GENERALI ===== */ .btn {   padding: 0.8rem 1.5rem;   border: none;   border-radius: 10px;   font-size: 0.95rem;   font-weight: 600;   cursor: pointer;   transition: all 0.2s ease;   display: inline-flex;   align-items: center;   gap: 0.5rem;   text-decoration: none;   justify-content: center; }  .btn:disabled {   opacity: 0.6;   cursor: not-allowed;   transform: none !important; }  .btn-primary {   background: linear-gradient(145deg, #3498db, #2980b9);   color: white;   box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3); }  .btn-primary:hover:not(:disabled) {   background: linear-gradient(145deg, #2980b9, #21618c);   transform: translateY(-2px);   box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4); }  .btn-secondary {   background: linear-gradient(145deg, #95a5a6, #7f8c8d);   color: white;   box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3); }  .btn-secondary:hover:not(:disabled) {   background: linear-gradient(145deg, #7f8c8d, #6c7b7d);   transform: translateY(-2px);   box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4); }  /* ===== ERROR VIEW ===== */ .error-view {   text-align: center;   padding: 3rem 2rem;   background: rgba(255, 255, 255, 0.95);   backdrop-filter: blur(10px);   border-radius: 20px;   max-width: 500px;   margin: 2rem auto;   box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1); }  .error-view h2 {   color: #e74c3c;   margin-bottom: 1rem; }  .error-view p {   color: #7f8c8d;   margin-bottom: 2rem; }  /* ===== FOOTER MIGLIORATO ===== */ .app-footer {   background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);   color: white;   padding: 1.5rem 2rem;   margin-top: auto; }  .footer-content {   max-width: 1200px;   margin: 0 auto;   display: flex;   justify-content: space-between;   align-items: center;   gap: 1rem; }  .footer-info p {   margin: 0;   font-size: 0.95rem; }  .footer-stats {   display: flex;   align-items: center;   gap: 0.8rem;   font-size: 0.9rem;   opacity: 0.9; }  .footer-stats span {   white-space: nowrap; }  /* ===== RESPONSIVE DESIGN ===== */ @media (max-width: 768px) {   .app-header {     padding: 1rem;   }      .header-content {     flex-direction: column;     gap: 1rem;     text-align: center;   }      .header-main h1 {     font-size: 1.8rem;   }      .header-main p {     font-size: 1rem;   }      .header-stats {     gap: 1rem;   }      .nav-container {     padding: 0 0.5rem;     gap: 0.2rem;   }      .nav-btn {     min-width: 60px;     padding: 0.6rem 0.5rem;   }      .nav-text {     font-size: 0.7rem;   }      .section-indicator {     padding: 0.6rem 1rem;   }      .app-main {     padding: 1rem;   }      .start-test-content {     padding: 2rem 1rem;   }      .test-info {     grid-template-columns: repeat(2, 1fr);     gap: 0.8rem;   }      .info-card {     padding: 1rem 0.5rem;   }      .footer-content {     flex-direction: column;     gap: 0.8rem;     text-align: center;   }      .footer-stats {     flex-wrap: wrap;     justify-content: center;   } }  @media (max-width: 480px) {   .header-main h1 {     font-size: 1.5rem;   }      .test-info {     grid-template-columns: 1fr;   }      .nav-text {     display: none;   }      .nav-btn {     min-width: 50px;     padding: 0.8rem 0.3rem;   }      .indicator-text {     font-size: 0.9rem;   } }  /* ===== ANIMAZIONI ===== */ @keyframes slideIn {   from {     opacity: 0;     transform: translateY(20px);   }   to {     opacity: 1;     transform: translateY(0);   } }  @keyframes fadeIn {   from {     opacity: 0;   }   to {     opacity: 1;   } }  .app-main > * {   animation: slideIn 0.3s ease-out; }  .nav-btn {   animation: fadeIn 0.2s ease-out; }  /* ===== FOCUS E ACCESSIBILITÀ ===== */ .nav-btn:focus, .btn:focus {   outline: 2px solid #3498db;   outline-offset: 2px; }  .nav-btn.active:focus {   outline-color: rgba(255, 255, 255, 0.8); }  @media (prefers-reduced-motion: reduce) {   *,   *::before,   *::after {     animation-duration: 0.01ms !important;     animation-iteration-count: 1 !important;     transition-duration: 0.01ms !important;   } }

================================================================================

NOME FILE: src\App.js

// ===================================================== // 📁 src/App.js - ALTERNATIVA: Lazy Import // =====================================================  import React, { useEffect } from 'react'; import { AppProvider } from './contexts/AppContext'; import { NotificationProvider } from './contexts/NotificationContext'; import { AppLayout } from './layouts/AppLayout'; import { AppRouter } from './components/AppRouter'; import { MainAppErrorBoundary, ErrorTracker } from './components/ErrorBoundaries'; import './App.css';  const VocabularyApp = () => {   // 🆘 EMERGENCY EXPORT SENZA HOOK (import diretto localStorage)   useEffect(() => {     const handleEmergencyExport = () => {       try {         // ⭐ IMPORT DIRETTO senza hook per evitare problemi context         const words = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');         const stats = JSON.parse(localStorage.getItem('vocabularyStats') || '{}');         const testHistory = JSON.parse(localStorage.getItem('testHistory') || '[]');         const wordPerformance = JSON.parse(localStorage.getItem('wordPerformance') || '{}');                  const exportData = {           words,           stats,           testHistory,           wordPerformance,           exportDate: new Date().toISOString(),           version: '2.3',           dataTypes: ['words', 'stats', 'testHistory', 'wordPerformance'],           totalTests: testHistory.length,           totalWords: words.length,           totalWordPerformance: Object.keys(wordPerformance).length,           description: 'EMERGENCY backup v2.3: parole + statistiche + cronologia + performance'         };                  const dataStr = JSON.stringify(exportData, null, 2);         const blob = new Blob([dataStr], { type: 'application/json' });         const url = URL.createObjectURL(blob);                  const link = document.createElement('a');         link.href = url;         link.download = `vocabulary-EMERGENCY-backup-v2.3-${new Date().toISOString().split('T')[0]}.json`;         document.body.appendChild(link);         link.click();         document.body.removeChild(link);         URL.revokeObjectURL(url);          alert('✅ Export di emergenza completato!');       } catch (error) {         console.error('❌ Emergency export failed:', error);         alert('❌ Export fallito');       }     };      window.addEventListener('emergencyExport', handleEmergencyExport);     window.addEventListener('forceExport', handleEmergencyExport);      return () => {       window.removeEventListener('emergencyExport', handleEmergencyExport);       window.removeEventListener('forceExport', handleEmergencyExport);     };   }, []);    return (     <MainAppErrorBoundary        onAppError={(error, errorInfo) => {         ErrorTracker.logError(error, 'Main App', { errorInfo });                  if (process.env.NODE_ENV === 'development') {           console.group('🚨 Main App Error Caught');           console.error('Error:', error);           console.groupEnd();         }       }}     >       <NotificationProvider>         <AppProvider>           <AppLayout>             <AppRouter />           </AppLayout>         </AppProvider>       </NotificationProvider>     </MainAppErrorBoundary>   ); };  export default VocabularyApp;

================================================================================

NOME FILE: src\index.css

/* /src/index.css This file contains the main CSS styles for the application, including Tailwind CSS imports and custom styles. */ @tailwind base; @tailwind components; @tailwind utilities;  /* Stili di base */ * {   margin: 0;   padding: 0;   box-sizing: border-box; }  body {   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',     'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',     sans-serif;   -webkit-font-smoothing: antialiased;   -moz-osx-font-smoothing: grayscale; }  code {   font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',     monospace; }  /* Utilità personalizzate */ @layer utilities {   .text-balance {     text-wrap: balance;   } }

================================================================================

NOME FILE: src\index.js

// /src/index.js // This file is the entry point for the React application. // It imports the necessary styles and renders the main App component into the root element of the HTML document. // It uses ReactDOM to create a root and render the App component wrapped in React.StrictMode. // This setup ensures that the application is ready for development and production builds with React's best practices. // It is essential for initializing the React application and providing a consistent structure for rendering components.  import React from 'react'; import ReactDOM from 'react-dom/client'; import './index.css'; import App from './App';  const root = ReactDOM.createRoot(document.getElementById('root')); root.render(   <React.StrictMode>     <App />   </React.StrictMode> ); 

================================================================================

NOME FILE: src\config\appConfig.js

// ===================================================== // 📁 src/config/appConfig.js - Secure Configuration per Vocabulary Master // =====================================================  /**  * Configurazione sicura che sostituisce le credenziali hardcodate  */  // Helper per leggere environment variables const getEnvVar = (key, defaultValue = undefined) => {   const value = process.env[key];      // Handle boolean strings   if (value === 'true') return true;   if (value === 'false') return false;      // Handle numeric strings     if (value && !isNaN(value) && !isNaN(parseFloat(value))) {     return parseFloat(value);   }      return value || defaultValue; };  // ====== MAIN CONFIGURATION ====== export const AppConfig = {      // App Metadata (identico al tuo APP_CONFIG)   app: {     name: 'Vocabulary Master',     version: '2.0.0',      description: 'La tua app intelligente per imparare l\'inglese',     environment: getEnvVar('REACT_APP_ENVIRONMENT', 'development')   },    // AI Configuration (sostituisce il tuo AI_CONFIG hardcodato)   ai: {     // SICURO: API key da environment variable invece di hardcoded     apiKey: getEnvVar('REACT_APP_GEMINI_API_KEY'),          // Stesso URL che usavi prima     baseUrl: getEnvVar(       'REACT_APP_GEMINI_API_URL',       'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent'     ),          // Stessi valori che avevi prima     timeout: getEnvVar('REACT_APP_AI_TIMEOUT', 15000),     maxRetries: getEnvVar('REACT_APP_AI_MAX_RETRIES', 3),      retryDelay: getEnvVar('REACT_APP_AI_RETRY_DELAY', 1000),          // Feature flags     enabled: getEnvVar('REACT_APP_ENABLE_AI_FEATURES', true),     mockResponses: getEnvVar('REACT_APP_MOCK_AI_RESPONSES', false)   },    // Test Configuration (identico al tuo TEST_CONFIG)   test: {     warningThresholds: {       slow: 25,       verySlow: 40     },     autoAdvanceDelay: 1500,     hintCooldown: 3000,     maxHintsPerWord: 1,     scoring: {       excellent: 80,       good: 60,       victory: 80     }   },    // Statistics Configuration (identico al tuo STATS_CONFIG)   stats: {     performance: {       excellent: 90,       good: 75,       average: 60,       needsWork: 40     },     maxHistorySize: 1000,     maxRecentTests: 20,     charts: {       maxTimelinePoints: 20,       defaultChartHeight: 300     }   },    // Storage Configuration (identico al tuo STORAGE_CONFIG)   storage: {     keys: {       words: 'vocabularyWords',       stats: 'vocabulary_stats',       testHistory: 'vocabulary_test_history',        settings: 'vocabulary_settings',       wordPerformance: 'wordPerformance'     }   },    // Word Configuration (identico al tuo WORD_CONFIG)   word: {     maxWordLength: 100,     maxTranslationLength: 200,     maxNotesLength: 1000,     maxSentenceLength: 300,     maxChapterLength: 20,     requiredFields: ['english', 'italian'],     optionalFields: ['group', 'sentence', 'notes', 'chapter', 'learned', 'difficult']   },    // UI Configuration (identico al tuo UI_CONFIG)   ui: {     animations: {       fast: 150,       normal: 300,       slow: 500,       cardFlip: 700     },     notifications: {       defaultDuration: 3000,       maxVisible: 5     }   } };  // ====== ERROR MESSAGES (identici ai tuoi) ====== export const ERROR_MESSAGES = {   network: 'Errore di connessione. Controlla la tua connessione internet.',   ai: 'Servizio AI temporaneamente non disponibile. Riprova più tardi.',   aiNotConfigured: 'Servizio AI non configurato. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local',   storage: 'Errore nel salvataggio dei dati. Controlla lo spazio disponibile.',   validation: 'Dati non validi. Controlla i campi obbligatori.',   import: 'Errore durante l\'importazione. Verifica il formato del file.',   export: 'Errore durante l\'esportazione. Riprova.',   generic: 'Si è verificato un errore imprevisto.',   wordNotFound: 'Parola non trovata.',   noWordsAvailable: 'Nessuna parola disponibile per il test.' };  // ====== SUCCESS MESSAGES (identici ai tuoi) ====== export const SUCCESS_MESSAGES = {   wordAdded: 'Parola aggiunta con successo!',   wordUpdated: 'Parola modificata con successo!',   wordDeleted: 'Parola eliminata con successo!',   testCompleted: 'Test completato!',   dataExported: 'Dati esportati con successo!',   dataImported: 'Dati importati con successo!',   settingsSaved: 'Impostazioni salvate!' };  // ====== UTILITY FUNCTIONS ======  /**  * Check if AI is available (has API key)  */ export const isAIAvailable = () => {   return AppConfig.ai.enabled && !!AppConfig.ai.apiKey; };  /**  * Get configuration status  */ export const getConfigurationStatus = () => {   return {     isValid: !!AppConfig.ai.apiKey,     environment: AppConfig.app.environment,     aiConfigured: !!AppConfig.ai.apiKey,     features: {       aiEnabled: isAIAvailable(),       mockMode: AppConfig.ai.mockResponses     }   }; };  // Debug logging se abilitato if (AppConfig.app.environment === 'development') {   const status = getConfigurationStatus();   console.log('🔧 Vocabulary Master Configuration:', {     aiConfigured: status.aiConfigured,     environment: status.environment,     features: status.features   });      if (!status.aiConfigured) {     console.warn('⚠️ AI Service: API key non configurata. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local');   } }  export default AppConfig;

================================================================================


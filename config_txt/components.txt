NOME FILE: AddWordForm.tsx

import React, { useState, useEffect, useCallback } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Input } from './ui/input'; import { Textarea } from './ui/textarea'; import { Plus, Edit3, Check, Sparkles, Brain, AlertTriangle, RefreshCw } from 'lucide-react'; import { getPredefinedGroups, getCategoryStyle } from '../utils/categoryUtils'; import { useNotification } from '../contexts/NotificationContext'; import { aiService } from '../services/aiService'; import { useAILoading } from '../hooks/useLoadingState'; import { SmartLoadingIndicator, ErrorWithRetry } from '../components/LoadingComponents'; import { AIServiceErrorBoundary, FormErrorBoundary } from '../components/ErrorBoundaries'; import { Word, CreateWordInput, UpdateWordInput } from '../types/entities/Word.types'; interface ArrayInputProps { label: string; icon: string; values: string[]; placeholder: string; onArrayChange: (index: number, value: string) => void; onAddItem: () => void; onRemoveItem: (index: number) => void; maxItems?: number; description?: string; } const ArrayInput: React.FC<ArrayInputProps> = ({ label, icon, values, placeholder, onArrayChange, onAddItem, onRemoveItem, maxItems = 5, description }) => ( <div className="space-y-2"> <label className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center gap-2"> <span>{icon}</span> {label} {description && <span className="text-xs text-gray-500">({description})</span>} </label> <div className="space-y-2"> {values.map((value, index) => ( <div key={index} className="flex gap-2"> <Input placeholder={`${placeholder} ${index + 1}`} value={value} onChange={(e) => onArrayChange(index, e.target.value)} className="border-2 border-gray-200 dark:border-gray-600 rounded-xl flex-1" /> {values.length > 1 && ( <Button type="button" variant="ghost" size="sm" onClick={() => onRemoveItem(index)} className="text-red-500 hover:text-red-700 hover:bg-red-50 px-3" title="Rimuovi elemento" > ✕ </Button> )} </div> ))} {values.length < maxItems && ( <Button type="button" variant="outline" size="sm" onClick={onAddItem} className="w-full border-dashed border-2 border-gray-300 hover:border-gray-400 text-gray-600 hover:text-gray-800" > <Plus className="w-4 h-4 mr-2" /> Aggiungi {label.toLowerCase()} </Button> )} </div> </div> ); interface FormData { english: string; italian: string; group: string; sentences: string[]; synonyms: string[]; antonyms: string[]; notes: string; chapter: string; learned: boolean; difficult: boolean; } interface FormValidation { [key: string]: string; } interface AIServiceStatus { health: 'healthy' | 'degraded' | 'down' | 'unknown'; configured: boolean; consecutiveFailures: number; } interface AddWordFormProps { onAddWord: (word: CreateWordInput) => Promise<void>; onUpdateWord: (word: UpdateWordInput) => Promise<void>; editingWord?: Word | null; onClearForm: () => void; } const AddWordForm: React.FC<AddWordFormProps> = ({ onAddWord, onUpdateWord, editingWord, onClearForm }) => { const [formData, setFormData] = useState<FormData>({ english: '', italian: '', group: '', sentences: [''], synonyms: [''], antonyms: [''], notes: '', chapter: '', learned: false, difficult: false }); const [showAdvancedForm, setShowAdvancedForm] = useState<boolean>(false); const [aiServiceStatus, setAiServiceStatus] = useState<AIServiceStatus | null>(null); const [formValidation, setFormValidation] = useState<FormValidation>({}); const [isRefreshingStatus, setIsRefreshingStatus] = useState<boolean>(false); const { showNotification, showError, showWarning, showSuccess } = useNotification(); const aiLoading = useAILoading(); const checkAIServiceStatus = useCallback(() => { try { const currentStatus = aiService.getServiceStatus(); setAiServiceStatus(currentStatus); console.log('📊 AI Status (passive):', { health: currentStatus.health, configured: currentStatus.configured, consecutiveFailures: currentStatus.consecutiveFailures }); } catch (error) { console.error('❌ Failed to get AI status:', error); setAiServiceStatus(prev => ({ ...prev, health: 'down', configured: false, consecutiveFailures: (prev?.consecutiveFailures || 0) + 1 })); } }, []); const handleRefreshStatus = useCallback(async () => { if (isRefreshingStatus) return; if (!window.confirm('🚨 ATTENZIONE: Questa operazione costa denaro (chiamata API Google). Continuare?')) { return; } setIsRefreshingStatus(true); setAiServiceStatus(prev => ({ ...prev, health: 'unknown' } as AIServiceStatus)); try { console.log('💰 Manual AI health check (COSTS MONEY) - User confirmed'); const isHealthy = await aiService.checkHealth(); const updatedStatus = aiService.getServiceStatus(); setAiServiceStatus(updatedStatus); if (isHealthy) { showSuccess('✅ AI Service verificato come disponibile'); } else { showWarning('⚠️ AI Service non risponde correttamente'); } } catch (error) { console.error('❌ Manual health check failed:', error); showError(error instanceof Error ? error : new Error(String(error)), 'AI Health Check'); setAiServiceStatus(prev => ({ ...prev, health: 'down' } as AIServiceStatus)); } finally { setIsRefreshingStatus(false); } }, [isRefreshingStatus, showSuccess, showWarning, showError]); const validateForm = useCallback((): boolean => { const errors: FormValidation = {}; if (!formData.english.trim()) { errors.english = 'Parola inglese obbligatoria'; } else if (formData.english.trim().length < 2) { errors.english = 'Parola troppo corta (min 2 caratteri)'; } else if (!/^[a-zA-ZÀ-ÿ\s'-]+$/.test(formData.english.trim())) { errors.english = 'Solo caratteri inglesi consentiti (a-z, spazi, apostrofi)'; } if (!formData.italian.trim()) { errors.italian = 'Traduzione italiana obbligatoria'; } else if (formData.italian.trim().length < 2) { errors.italian = 'Traduzione troppo corta (min 2 caratteri)'; } if (formData.group && !getPredefinedGroups().includes(formData.group as any)) { errors.group = 'Categoria non valida'; } setFormValidation(errors); return Object.keys(errors).length === 0; }, [formData]); const handleInputChange = useCallback((field: keyof FormData, value: string | boolean) => { setFormData(prev => ({ ...prev, [field]: value })); if (formValidation[field]) { setFormValidation(prev => { const newValidation = { ...prev }; delete newValidation[field]; return newValidation; }); } }, [formValidation]); const handleArrayChange = useCallback((arrayField: 'sentences' | 'synonyms' | 'antonyms', index: number, value: string) => { setFormData(prev => { const newArray = [...prev[arrayField]]; newArray[index] = value; return { ...prev, [arrayField]: newArray }; }); }, []); const addArrayItem = useCallback((arrayField: 'sentences' | 'synonyms' | 'antonyms') => { setFormData(prev => ({ ...prev, [arrayField]: [...prev[arrayField], ''] })); }, []); const removeArrayItem = useCallback((arrayField: 'sentences' | 'synonyms' | 'antonyms', index: number) => { setFormData(prev => { const newArray = prev[arrayField].filter((_, i) => i !== index); return { ...prev, [arrayField]: newArray.length === 0 ? [''] : newArray }; }); }, []); const handleSentencesChange = useCallback((index: number, value: string) => { handleArrayChange('sentences', index, value); }, [handleArrayChange]); const handleSynonymsChange = useCallback((index: number, value: string) => { handleArrayChange('synonyms', index, value); }, [handleArrayChange]); const handleAntonymsChange = useCallback((index: number, value: string) => { handleArrayChange('antonyms', index, value); }, [handleArrayChange]); const addSentence = useCallback(() => addArrayItem('sentences'), [addArrayItem]); const addSynonym = useCallback(() => addArrayItem('synonyms'), [addArrayItem]); const addAntonym = useCallback(() => addArrayItem('antonyms'), [addArrayItem]); const removeSentence = useCallback((index: number) => removeArrayItem('sentences', index), [removeArrayItem]); const removeSynonym = useCallback((index: number) => removeArrayItem('synonyms', index), [removeArrayItem]); const removeAntonym = useCallback((index: number) => removeArrayItem('antonyms', index), [removeArrayItem]); const handleFieldBlur = useCallback((field: keyof FormData) => { const errors: FormValidation = {}; if (field === 'english') { if (!formData.english.trim()) { errors.english = 'Parola inglese obbligatoria'; } else if (formData.english.trim().length < 2) { errors.english = 'Parola troppo corta'; } else if (!/^[a-zA-ZÀ-ÿ\s'-]+$/.test(formData.english.trim())) { errors.english = 'Solo caratteri inglesi consentiti'; } } if (field === 'italian') { if (!formData.italian.trim()) { errors.italian = 'Traduzione italiana obbligatoria'; } else if (formData.italian.trim().length < 2) { errors.italian = 'Traduzione troppo corta'; } } setFormValidation(prev => ({ ...prev, ...errors })); }, [formData]); const handleAiAssist = useCallback(async () => { if (!formData.english.trim()) { showWarning('⚠️ Inserisci prima una parola inglese!'); return; } if (!aiServiceStatus?.configured) { showError(new Error('🔑 AI Service non configurato'), 'AI Configuration'); return; } try { showNotification('🤖 L\'AI sta analizzando la parola...', 'info'); const aiData = await aiLoading.executeAIOperation( () => aiService.analyzeWordWithFallback(formData.english.trim()), `Analisi di "${formData.english}"` ); const updatedStatus = aiService.getServiceStatus(); setAiServiceStatus(updatedStatus); if (aiData._aiError) { showWarning(`🤖 ${aiData.notes}`); setFormData(prev => ({ ...prev, group: aiData.group || prev.group, notes: aiData.notes || prev.notes })); } else { console.log('🔄 Updating form with AI data:', aiData); setFormData(prev => { const newFormData = { ...prev, italian: aiData.italian || prev.italian, group: aiData.group || prev.group, sentences: (aiData.sentences && aiData.sentences.length > 0) ? aiData.sentences : aiData.sentence ? [aiData.sentence] : prev.sentences, synonyms: (aiData.synonyms && aiData.synonyms.length > 0) ? aiData.synonyms : prev.synonyms, antonyms: (aiData.antonyms && aiData.antonyms.length > 0) ? aiData.antonyms : prev.antonyms, notes: aiData.notes || prev.notes, chapter: aiData.chapter || prev.chapter }; console.log('🎯 New form data:', newFormData); return newFormData; }); if (aiData.italian) { showSuccess('✨ Dati compilati dall\'AI!'); } else { showWarning('🤖 AI ha fornito dati parziali'); } } setShowAdvancedForm(true); } catch (error) { console.error('AI Assist Error:', error); const updatedStatus = aiService.getServiceStatus(); setAiServiceStatus(updatedStatus); const fallbackGroup = aiService.categorizeWordFallback(formData.english.trim()); setFormData(prev => ({ ...prev, group: prev.group || fallbackGroup, notes: prev.notes || `🤖 AI non disponibile. Gruppo suggerito: ${fallbackGroup}` })); setShowAdvancedForm(true); } }, [formData.english, aiServiceStatus, aiLoading, showNotification, showWarning, showSuccess, showError]); const handleSubmit = useCallback(async () => { if (!validateForm()) { showWarning('⚠️ Correggi gli errori nel form'); return; } try { const filterArray = (arr: string[]) => { if (!Array.isArray(arr)) return []; return arr.filter(s => s && typeof s === 'string' && s.trim()).map(s => s.trim()); }; const sentences = filterArray(formData.sentences); const synonyms = filterArray(formData.synonyms); const antonyms = filterArray(formData.antonyms); if (editingWord) { const updateData: UpdateWordInput = { id: editingWord.id, english: formData.english.trim(), italian: formData.italian.trim(), group: formData.group.trim() || undefined, chapter: formData.chapter.trim() || undefined, sentences: sentences.length > 0 ? sentences : undefined, synonyms: synonyms.length > 0 ? synonyms : undefined, antonyms: antonyms.length > 0 ? antonyms : undefined, notes: formData.notes.trim() || undefined, difficult: formData.difficult, learned: formData.learned }; await onUpdateWord(updateData); } else { const wordData: CreateWordInput = { english: formData.english.trim(), italian: formData.italian.trim(), group: formData.group.trim() || undefined, chapter: formData.chapter.trim() || undefined, sentences: sentences.length > 0 ? sentences : undefined, synonyms: synonyms.length > 0 ? synonyms : undefined, antonyms: antonyms.length > 0 ? antonyms : undefined, notes: formData.notes.trim() || undefined, difficult: formData.difficult }; await onAddWord(wordData); } setFormData({ english: '', italian: '', group: '', sentences: [''], synonyms: [''], antonyms: [''], notes: '', chapter: '', learned: false, difficult: false }); setShowAdvancedForm(false); setFormValidation({}); } catch (error) { console.error('Error adding word:', error); showError(error instanceof Error ? error : new Error(String(error)), 'Add Word'); } }, [formData, validateForm, onAddWord, showWarning, showError]); const handleClear = useCallback(() => { const hasData = formData.english.trim() || formData.italian.trim() || formData.sentences.some(s => s.trim()) || formData.synonyms.some(s => s.trim()) || formData.antonyms.some(s => s.trim()) || formData.notes.trim() || formData.group.trim() || formData.chapter.trim() || formData.learned || formData.difficult; if (hasData && !window.confirm('🗑️ Cancellare tutti i dati?')) { return; } setFormData({ english: '', italian: '', group: '', sentences: [''], synonyms: [''], antonyms: [''], notes: '', chapter: '', learned: false, difficult: false }); setShowAdvancedForm(false); setFormValidation({}); onClearForm(); }, [formData, onClearForm]); useEffect(() => { checkAIServiceStatus(); console.log('🔒 AI Status: Manual refresh only (no automatic pings)'); }, [checkAIServiceStatus]); useEffect(() => { if (editingWord) { setFormData({ english: editingWord.english || '', italian: editingWord.italian || '', group: editingWord.group || '', sentences: editingWord.sentences && editingWord.sentences.length > 0 ? editingWord.sentences : [''], synonyms: editingWord.synonyms && editingWord.synonyms.length > 0 ? editingWord.synonyms : [''], antonyms: editingWord.antonyms && editingWord.antonyms.length > 0 ? editingWord.antonyms : [''], notes: editingWord.notes || '', chapter: editingWord.chapter || '', learned: editingWord.learned || false, difficult: editingWord.difficult || false }); setShowAdvancedForm(true); } }, [editingWord]); const renderAIStatusIndicator = () => { if (!aiServiceStatus) return null; const statusConfig = { healthy: { color: 'text-green-600 dark:text-green-400', icon: '🟢', message: 'AI disponibile' }, degraded: { color: 'text-orange-600 dark:text-orange-400', icon: '🟡', message: 'AI instabile' }, down: { color: 'text-red-600 dark:text-red-400', icon: '🔴', message: 'AI non disponibile' }, unknown: { color: 'text-gray-600 dark:text-gray-400', icon: '⚪', message: 'AI sconosciuto' } }; const config = statusConfig[aiServiceStatus.health] || statusConfig.unknown; return ( <div className={`flex items-center gap-2 text-xs ${config.color}`}> <span>{config.icon}</span> <span>{config.message}</span> <Button variant="ghost" size="sm" onClick={handleRefreshStatus} disabled={isRefreshingStatus} className="h-6 px-2 text-xs hover:bg-orange-100 dark:hover:bg-orange-900/30" title="⚠️ ATTENZIONE: Verifica manuale - COSTA DENARO!" > <RefreshCw className={`w-3 h-3 ${isRefreshingStatus ? 'animate-spin' : ''}`} /> {isRefreshingStatus ? '💰' : '💰'} </Button> </div> ); }; const isFormValid = formData.english.trim().length >= 2 && formData.italian.trim().length >= 2 && /^[a-zA-ZÀ-ÿ\s'-]+$/.test(formData.english.trim()) && Object.keys(formValidation).length === 0; return ( <FormErrorBoundary formName="AddWord" onFormError={(error) => showError(error instanceof Error ? error : new Error(String(error)), 'Word Form')}> <Card className="backdrop-blur-sm bg-white/90 dark:bg-gray-800/90 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className={editingWord ? "add-word-form-header-editing" : "add-word-form-header-default"}> <CardTitle className={`flex items-center justify-between ${editingWord ? "text-white" : "text-gray-900 dark:text-gray-100"}`}> {editingWord ? ( <div className="flex items-center gap-3"> <Edit3 className="w-6 h-6" /> <span>Modifica: {editingWord.english}</span> </div> ) : ( <div className="flex items-center gap-3"> <Plus className="w-6 h-6 text-green-600 dark:text-green-400" /> <span className="add-word-form-title-ai"> Aggiungi Nuove Parole </span> </div> )} <div className="flex flex-col gap-2"> <div className="flex gap-2"> {editingWord && ( <Button variant="ghost" size="sm" onClick={handleClear} className="text-white hover:bg-white/20" > ✕ Annulla </Button> )} <Button variant="ghost" size="sm" onClick={() => setShowAdvancedForm(!showAdvancedForm)} className={editingWord ? "text-white hover:bg-white/20" : "text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"} > {showAdvancedForm ? 'Semplice' : 'Avanzato'} </Button> </div> {!editingWord && renderAIStatusIndicator()} </div> </CardTitle> {editingWord && ( <div className="text-blue-100 bg-blue-600/20 p-3 rounded-xl mt-4"> 💡 Modificando "<strong>{editingWord.english}</strong>". Cambia i campi e clicca "Salva Modifiche". </div> )} </CardHeader> <CardContent className="p-6"> <div className="space-y-6"> } <AIServiceErrorBoundary onAIError={(error) => showError(error instanceof Error ? error : new Error(String(error)), 'AI Assistant')}> {aiLoading.isLoading ? ( <div className="p-4 bg-purple-50 dark:bg-purple-900/30 border border-purple-200 dark:border-purple-700 rounded-xl"> <SmartLoadingIndicator isLoading={true} operation={aiLoading.operation || undefined} duration={aiLoading.duration} customIcon={Brain} /> </div> ) : aiLoading.error ? ( <ErrorWithRetry error={aiLoading.error} onRetry={() => aiLoading.retry(() => handleAiAssist())} canRetry={aiLoading.canRetry} retryCount={aiLoading.retryCount} maxRetries={2} isRetrying={aiLoading.isLoading} /> ) : ( <Button onClick={handleAiAssist} disabled={!formData.english.trim() || !aiServiceStatus?.configured || aiLoading.isLoading} className="add-word-ai-special-button" title="💰 Questa operazione costa denaro (chiamata API Google)" > <Sparkles className="w-6 h-6 mr-3" /> 💰 AI Assistant - Compila Automaticamente </Button> )} </AIServiceErrorBoundary> } <div className="space-y-2"> <label className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center gap-2"> <span>📂</span> Categoria </label> <select value={formData.group} onChange={(e) => handleInputChange('group', e.target.value)} className="w-full px-4 py-3 border-2 rounded-xl bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 text-gray-900 dark:text-gray-100 focus:border-blue-500 dark:focus:border-blue-400" > <option value="">Nessun gruppo</option> {getPredefinedGroups().map(group => ( <option key={group} value={group}> {getCategoryStyle(group).icon} {group} </option> ))} </select> </div> } <div className="space-y-2"> <label className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center gap-2"> <span>🎓</span> Stato </label> <div className="space-y-3"> <div className="flex items-center gap-3 p-3 border-2 border-gray-200 dark:border-gray-600 rounded-xl bg-gray-50 dark:bg-gray-800"> <label className="flex items-center gap-2 cursor-pointer"> <div onClick={() => handleInputChange('learned', !formData.learned)} className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${ formData.learned ? 'bg-green-500 border-green-500 text-white' : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800' }`} > {formData.learned && <span className="text-sm">✓</span>} </div> <span className="text-sm font-medium text-gray-700 dark:text-gray-300">Appresa</span> </label> </div> <div className="flex items-center gap-3 p-3 border-2 border-orange-200 dark:border-orange-700 rounded-xl bg-orange-50 dark:bg-orange-900/30"> <label className="flex items-center gap-2 cursor-pointer"> <div onClick={() => handleInputChange('difficult', !formData.difficult)} className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${ formData.difficult ? 'bg-orange-500 border-orange-500 text-white' : 'border-orange-300 dark:border-orange-600 bg-white dark:bg-gray-800' }`} > {formData.difficult && <AlertTriangle className="w-4 h-4" />} </div> <span className="text-sm font-medium text-orange-700 dark:text-orange-300">⭐ Difficile</span> </label> </div> </div> </div> </div> } <ArrayInput label="Frasi di Contesto" icon="💬" values={formData.sentences} placeholder="es. I love this beautiful song" onArrayChange={handleSentencesChange} onAddItem={addSentence} onRemoveItem={removeSentence} maxItems={5} description="per suggerimenti Test" /> } <ArrayInput label="Contrari" icon="↔️" values={formData.antonyms} placeholder="es. ugly, bad" onArrayChange={handleAntonymsChange} onAddItem={addAntonym} onRemoveItem={removeAntonym} maxItems={8} description="per suggerimenti Test" /> </div> } <Button onClick={handleSubmit} disabled={!isFormValid} className={`w-full py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none ${ editingWord ? 'bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700' : 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600' } text-white`} > {editingWord ? ( <> <Check className="w-5 h-5 mr-2" /> Salva Modifiche </> ) : ( <> <Plus className="w-5 h-5 mr-2" /> Aggiungi Parola </> )} </Button> </div> </CardContent> </Card> </FormErrorBoundary> ); }; export default AddWordForm;

================================================================================

NOME FILE: ChapterTestSelector.tsx

import React, { useState, useEffect } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Play, BookOpen, CheckSquare, Square, Target, AlertTriangle, GraduationCap } from 'lucide-react'; import { useNotification } from '../contexts/NotificationContext'; import { Word } from '../types'; interface ChapterTestSelectorProps { words: Word[]; onStartTest: (config: TestConfig) => void; onClose: () => void; } interface TestConfig { selectedChapters: string[]; includeLearnedWords: boolean; testMode: 'normal' | 'difficult-only'; } interface ChapterStats { totalWords: number; learnedWords: number; difficultWords: number; availableForTest: number; } const ChapterTestSelector: React.FC<ChapterTestSelectorProps> = ({ words, onStartTest, onClose }) => { const [selectedChapters, setSelectedChapters] = useState<Set<string>>(new Set()); const [includeLearnedWords, setIncludeLearnedWords] = useState<boolean>(false); const [testMode, setTestMode] = useState<'normal' | 'difficult-only'>('normal'); const { showWarning } = useNotification(); const getAvailableChapters = (): string[] => { const chapters = new Set<string>(); words.forEach(word => { if (word.chapter) { chapters.add(word.chapter); } }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); if (!isNaN(aNum) && !isNaN(bNum)) { return aNum - bNum; } return a.localeCompare(b); }); }; const availableChapters = getAvailableChapters(); const wordsWithoutChapter = words.filter(word => !word.chapter); const getChapterStats = (chapter: string): ChapterStats => { const chapterWords = words.filter(word => word.chapter === chapter); const totalWords = chapterWords.length; const learnedWords = chapterWords.filter(word => word.learned).length; const difficultWords = chapterWords.filter(word => word.difficult).length; let availableForTest = 0; if (testMode === 'difficult-only') { availableForTest = difficultWords; } else { if (includeLearnedWords) { availableForTest = totalWords; } else { availableForTest = chapterWords.filter(word => !word.learned).length; } } return { totalWords, learnedWords, difficultWords, availableForTest }; }; const getWordsWithoutChapterStats = (): ChapterStats => { const totalWords = wordsWithoutChapter.length; const learnedWords = wordsWithoutChapter.filter(word => word.learned).length; const difficultWords = wordsWithoutChapter.filter(word => word.difficult).length; let availableForTest = 0; if (testMode === 'difficult-only') { availableForTest = difficultWords; } else { if (includeLearnedWords) { availableForTest = totalWords; } else { availableForTest = wordsWithoutChapter.filter(word => !word.learned).length; } } return { totalWords, learnedWords, difficultWords, availableForTest }; }; const wordsWithoutChapterStats = getWordsWithoutChapterStats(); const toggleChapterSelection = (chapter: string) => { const newSelection = new Set(selectedChapters); if (newSelection.has(chapter)) { newSelection.delete(chapter); } else { newSelection.add(chapter); } setSelectedChapters(newSelection); }; const selectAllChapters = () => { const allChapters = new Set([...availableChapters]); if (wordsWithoutChapter.length > 0) { allChapters.add('no-chapter'); } setSelectedChapters(allChapters); }; const deselectAllChapters = () => { setSelectedChapters(new Set()); }; const getTotalSelectedWords = (): number => { let total = 0; selectedChapters.forEach(chapter => { if (chapter === 'no-chapter') { total += wordsWithoutChapterStats.availableForTest; } else { total += getChapterStats(chapter).availableForTest; } }); return total; }; const totalSelectedWords = getTotalSelectedWords(); const handleStartTest = () => { if (selectedChapters.size === 0) { showWarning('⚠️ Seleziona almeno un capitolo per il test!'); return; } if (totalSelectedWords === 0) { if (testMode === 'difficult-only') { showWarning('⚠️ Nessuna parola difficile trovata nei capitoli selezionati!'); } else { showWarning('⚠️ Nessuna parola disponibile nei capitoli selezionati!'); } return; } const config: TestConfig = { selectedChapters: Array.from(selectedChapters), includeLearnedWords, testMode }; onStartTest(config); }; useEffect(() => { if (availableChapters.length > 0) { selectAllChapters(); } }, []); return ( <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50"> <Card className="w-full max-w-2xl max-h-[90vh] overflow-y-auto bg-white rounded-2xl shadow-2xl"> <CardHeader className="chapter-test-header"> <CardTitle className="text-2xl font-bold flex items-center gap-3"> <Target className="w-8 h-8" /> Seleziona Capitoli per il Test </CardTitle> </CardHeader> <CardContent className="p-6 space-y-6"> } {testMode === 'normal' && ( <div className="space-y-3"> <h3 className="text-lg font-semibold text-gray-800">Opzioni</h3> <div className="flex items-center gap-3"> <Button variant="outline" size="sm" onClick={() => setIncludeLearnedWords(!includeLearnedWords)} className={`flex items-center gap-2 ${ includeLearnedWords ? 'bg-green-50 border-green-300 text-green-700' : 'bg-gray-50 border-gray-300 text-gray-700' }`} > {includeLearnedWords ? <CheckSquare className="w-4 h-4" /> : <Square className="w-4 h-4" />} Includi parole già apprese </Button> </div> </div> )} } <div className="grid grid-cols-1 md:grid-cols-2 gap-3 max-h-60 overflow-y-auto"> {availableChapters.map(chapter => { const stats = getChapterStats(chapter); const isSelected = selectedChapters.has(chapter); return ( <Card key={chapter} className={`cursor-pointer transition-all duration-300 ${ isSelected ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-gray-300' }`} onClick={() => toggleChapterSelection(chapter)} > <CardContent className="p-4"> <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> {isSelected ? <CheckSquare className="w-5 h-5 text-blue-600" /> : <Square className="w-5 h-5 text-gray-400" />} <div> <p className="font-medium text-gray-900">Capitolo {chapter}</p> <p className="text-sm text-gray-600"> {stats.availableForTest} parole disponibili </p> </div> </div> <div className="text-right"> <p className="text-sm font-medium text-gray-900">{stats.totalWords} totali</p> {stats.difficultWords > 0 && ( <p className="text-xs text-orange-600"> {stats.difficultWords} difficili </p> )} </div> </div> </CardContent> </Card> ); })} } <div className="chapter-test-summary"> <div className="flex items-center justify-between"> <div> <p className="text-sm text-gray-600">Parole selezionate per il test</p> <p className="text-2xl font-bold text-blue-600">{totalSelectedWords}</p> </div> <div className="text-right"> <p className="text-sm text-gray-600">Capitoli selezionati</p> <p className="text-2xl font-bold text-purple-600">{selectedChapters.size}</p> </div> </div> </div>

================================================================================

NOME FILE: ErrorBoundaries.tsx

import React, { Component, ReactNode, ErrorInfo } from 'react'; import { AlertTriangle, RefreshCw, Wifi, Database, Brain, FileX } from 'lucide-react'; import { Button } from './ui/button'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; interface ErrorBoundaryState { hasError: boolean; error: Error | null; errorInfo: ErrorInfo | null; retryCount: number; lastErrorTime: number | null; } interface BaseErrorBoundaryProps { children: ReactNode; boundaryName?: string; maxRetries?: number; retryDelay?: number; onError?: (error: Error, errorInfo: ErrorInfo, boundaryName?: string) => void; onReset?: () => void; fallback?: (error: Error, retry: () => void, reset: () => void, retryCount: number) => ReactNode; } interface SpecializedErrorBoundaryProps { children: ReactNode; onAIError?: (error: Error, errorInfo: ErrorInfo, boundaryName?: string) => void; onStorageError?: (error: Error, errorInfo: ErrorInfo, boundaryName?: string) => void; onNetworkError?: (error: Error, errorInfo: ErrorInfo, boundaryName?: string) => void; onAppError?: (error: Error, errorInfo: ErrorInfo, boundaryName?: string) => void; onFormError?: (error: Error, errorInfo: ErrorInfo, boundaryName?: string) => void; formName?: string; } interface ErrorLog { id: number; timestamp: string; boundary: string; message: string; stack?: string; context: Record<string, any>; userAgent: string; url: string; } class BaseErrorBoundary extends Component<BaseErrorBoundaryProps, ErrorBoundaryState> { constructor(props: BaseErrorBoundaryProps) { super(props); this.state = { hasError: false, error: null, errorInfo: null, retryCount: 0, lastErrorTime: null }; } static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> { return { hasError: true, error, lastErrorTime: Date.now() }; } componentDidCatch(error: Error, errorInfo: ErrorInfo) { this.setState({ error, errorInfo }); console.error(`❌ ${this.props.boundaryName || 'App'} Error:`, { error, errorInfo, retryCount: this.state.retryCount }); if (this.props.onError) { this.props.onError(error, errorInfo, this.props.boundaryName); } } handleRetry = () => { const maxRetries = this.props.maxRetries || 3; if (this.state.retryCount < maxRetries) { setTimeout(() => { this.setState(prevState => ({ hasError: false, error: null, errorInfo: null, retryCount: prevState.retryCount + 1 })); }, this.props.retryDelay || 1000); } else { this.handleReset(); } }; handleReset = () => { this.setState({ hasError: false, error: null, errorInfo: null, retryCount: 0, lastErrorTime: null }); if (this.props.onReset) { this.props.onReset(); } }; render() { if (this.state.hasError) { return this.props.fallback ? this.props.fallback(this.state.error!, this.handleRetry, this.handleReset, this.state.retryCount) : this.renderDefaultError(); } return this.props.children; } renderDefaultError() { const { error, retryCount } = this.state; const maxRetries = this.props.maxRetries || 3; const canRetry = retryCount < maxRetries; return ( <Card className="border-red-200 bg-red-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-red-700"> <AlertTriangle className="w-5 h-5" /> Errore in {this.props.boundaryName || 'Applicazione'} </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-red-600 text-sm"> {error?.message || 'Si è verificato un errore imprevisto'} </p> {retryCount > 0 && ( <p className="text-orange-600 text-xs"> Tentativo {retryCount}/{maxRetries} </p> )} <div className="flex gap-2"> {canRetry ? ( <Button onClick={this.handleRetry} variant="outline" size="sm" className="border-red-300 text-red-700 hover:bg-red-100" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> ) : ( <Button onClick={this.handleReset} variant="outline" size="sm" className="border-red-300 text-red-700 hover:bg-red-100" > <RefreshCw className="w-4 h-4 mr-2" /> Reset Completo </Button> )} </div> </CardContent> </Card> ); } } export const AIServiceErrorBoundary: React.FC<Pick<SpecializedErrorBoundaryProps, 'children' | 'onAIError'>> = ({ children, onAIError }) => ( <BaseErrorBoundary boundaryName="AI Service" maxRetries={2} retryDelay={2000} onError={onAIError} fallback={(error, retry, reset, retryCount) => ( <Card className="border-purple-200 bg-purple-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-purple-700"> <Brain className="w-5 h-5" /> Errore AI Assistant </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-purple-600 text-sm"> {error?.message?.includes('timeout') ? '⏱️ Il servizio AI non risponde' : error?.message?.includes('API') ? '🔑 Problema con l\'API key' : '🤖 AI temporaneamente non disponibile' } </p> <div className="p-3 bg-blue-50 border border-blue-200 rounded-lg"> <p className="text-blue-700 text-sm font-medium mb-2"> 💡 Modalità Manuale Disponibile </p> <p className="text-blue-600 text-xs"> Puoi continuare a inserire parole manualmente. </p> </div> <Button onClick={retryCount < 2 ? retry : reset} variant="outline" size="sm" className="border-purple-300 text-purple-700 hover:bg-purple-100" > <RefreshCw className="w-4 h-4 mr-2" /> {retryCount < 2 ? 'Riprova AI' : 'Reset AI Service'} </Button> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const StorageErrorBoundary: React.FC<Pick<SpecializedErrorBoundaryProps, 'children' | 'onStorageError'>> = ({ children, onStorageError }) => ( <BaseErrorBoundary boundaryName="Storage" maxRetries={1} retryDelay={500} onError={onStorageError} fallback={(error, retry, reset) => ( <Card className="border-orange-200 bg-orange-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-orange-700"> <Database className="w-5 h-5" /> Errore Salvataggio Dati </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-orange-600 text-sm"> {error?.message?.includes('quota') ? '💽 Spazio esaurito. Elimina dati vecchi.' : '💾 Problema nel salvataggio dei dati.' } </p> <div className="p-3 bg-red-50 border border-red-200 rounded-lg"> <p className="text-red-700 text-sm font-medium mb-2"> ⚠️ Rischio Perdita Dati </p> <p className="text-red-600 text-xs"> Esporta backup preventivo. </p> </div> <div className="flex gap-2"> <Button onClick={retry} variant="outline" size="sm" className="border-orange-300 text-orange-700 hover:bg-orange-100" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> <Button onClick={() => { window.dispatchEvent(new CustomEvent('forceExport')); reset(); }} variant="outline" size="sm" className="border-orange-300 text-orange-700 hover:bg-orange-100" > <FileX className="w-4 h-4 mr-2" /> Backup </Button> </div> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const NetworkErrorBoundary: React.FC<Pick<SpecializedErrorBoundaryProps, 'children' | 'onNetworkError'>> = ({ children, onNetworkError }) => ( <BaseErrorBoundary boundaryName="Network" maxRetries={3} retryDelay={3000} onError={onNetworkError} fallback={(error, retry, reset, retryCount) => ( <Card className="border-blue-200 bg-blue-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-blue-700"> <Wifi className="w-5 h-5" /> Errore di Connessione </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-blue-600 text-sm"> {error?.message?.includes('fetch') ? '📡 Nessuna connessione internet' : '🌐 Problema di connessione' } </p> <div className="p-3 bg-green-50 border border-green-200 rounded-lg"> <p className="text-green-700 text-sm font-medium mb-2"> 🔄 Modalità Offline </p> <p className="text-green-600 text-xs"> L'app continua a funzionare offline. </p> </div> <Button onClick={retryCount < 3 ? retry : reset} variant="outline" size="sm" className="border-blue-300 text-blue-700 hover:bg-blue-100" > <RefreshCw className="w-4 h-4 mr-2" /> {retryCount < 3 ? 'Riprova' : 'Reset Rete'} </Button> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const MainAppErrorBoundary: React.FC<Pick<SpecializedErrorBoundaryProps, 'children' | 'onAppError'>> = ({ children, onAppError }) => ( <BaseErrorBoundary boundaryName="Main App" maxRetries={1} retryDelay={1000} onError={onAppError} fallback={(error, retry, reset) => ( <div className="min-h-screen bg-gradient-to-br from-red-50 to-orange-50 flex items-center justify-center p-6"> <Card className="max-w-md w-full border-red-200 bg-white shadow-xl"> <CardHeader> <CardTitle className="flex items-center gap-2 text-red-700 text-center"> <AlertTriangle className="w-6 h-6" /> Errore Applicazione </CardTitle> </CardHeader> <CardContent className="space-y-6 text-center"> <p className="text-red-600"> Errore critico. Tutti i dati sono al sicuro. </p> <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg"> <p className="text-blue-700 text-sm font-medium mb-2"> 🔄 Soluzioni </p> <ul className="text-blue-600 text-xs space-y-1 text-left"> <li>• Ricaricare la pagina (F5)</li> <li>• Svuotare cache browser</li> <li>• Esportare backup</li> </ul> </div> <div className="flex flex-col gap-3"> <Button onClick={() => window.location.reload()} className="bg-red-600 hover:bg-red-700 text-white" > <RefreshCw className="w-4 h-4 mr-2" /> Ricarica App </Button> <Button onClick={() => { window.dispatchEvent(new CustomEvent('emergencyExport')); }} variant="outline" size="sm" className="border-red-300 text-red-700 hover:bg-red-100" > <FileX className="w-4 h-4 mr-2" /> Export Emergenza </Button> </div> </CardContent> </Card> </div> )} > {children} </BaseErrorBoundary> ); export const FormErrorBoundary: React.FC<Pick<SpecializedErrorBoundaryProps, 'children' | 'formName' | 'onFormError'>> = ({ children, formName, onFormError }) => ( <BaseErrorBoundary boundaryName={`${formName} Form`} maxRetries={2} retryDelay={500} onError={onFormError} fallback={(error, retry, reset) => ( <Card className="border-yellow-200 bg-yellow-50"> <CardContent className="p-4"> <div className="flex items-center gap-2 text-yellow-700 mb-3"> <AlertTriangle className="w-4 h-4" /> <span className="font-medium">Errore nel Form</span> </div> <p className="text-yellow-600 text-sm mb-4"> {error?.message?.includes('validation') ? 'Errore di validazione dati' : 'Errore elaborazione form' } </p> <div className="flex gap-2"> <Button onClick={retry} variant="outline" size="sm" className="border-yellow-300 text-yellow-700 hover:bg-yellow-100" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> <Button onClick={reset} variant="outline" size="sm" className="border-yellow-300 text-yellow-700 hover:bg-yellow-100" > Reset Form </Button> </div> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const ErrorTracker = { errors: [] as ErrorLog[], logError(error: Error, boundary: string, context: Record<string, any> = {}) { const errorLog: ErrorLog = { id: Date.now(), timestamp: new Date().toISOString(), boundary, message: error.message, stack: error.stack, context, userAgent: navigator.userAgent, url: window.location.href }; this.errors.push(errorLog); if (this.errors.length > 50) { this.errors = this.errors.slice(-50); } if (process.env.NODE_ENV === 'development') { console.group(`🚨 Error in ${boundary}`); console.error('Error:', error); console.log('Context:', context); console.groupEnd(); } }, exportErrors() { const blob = new Blob([JSON.stringify(this.errors, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `error-log-${new Date().toISOString().split('T')[0]}.json`; a.click(); URL.revokeObjectURL(url); }, clearErrors() { this.errors = []; }, getErrorStats() { const errorsByBoundary: Record<string, number> = {}; this.errors.forEach(error => { errorsByBoundary[error.boundary] = (errorsByBoundary[error.boundary] || 0) + 1; }); return { total: this.errors.length, byBoundary: errorsByBoundary, lastError: this.errors[this.errors.length - 1] }; } };

================================================================================

NOME FILE: ErrorBoundary.tsx

import React, { Component, ReactNode, ErrorInfo } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { AlertTriangle, RefreshCw } from 'lucide-react'; interface ErrorBoundaryState { hasError: boolean; error: Error | null; errorInfo: ErrorInfo | null; } interface ErrorBoundaryProps { children: ReactNode; fallback?: ReactNode; } export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> { constructor(props: ErrorBoundaryProps) { super(props); this.state = { hasError: false, error: null, errorInfo: null }; } static getDerivedStateFromError(error: Error): ErrorBoundaryState { return { hasError: true, error, errorInfo: null }; } componentDidCatch(error: Error, errorInfo: ErrorInfo) { this.setState({ error, errorInfo }); if (process.env.NODE_ENV === 'development') { console.error('ErrorBoundary caught an error:', error, errorInfo); } if (typeof window !== 'undefined' && (window as any).gtag) { (window as any).gtag('event', 'exception', { description: error.toString(), fatal: true }); } } handleReset = () => { this.setState({ hasError: false, error: null, errorInfo: null }); }; render() { if (this.state.hasError) { if (this.props.fallback) { return this.props.fallback; } return ( <div className="error-page-background"> <Card className="max-w-lg w-full bg-white/90 backdrop-blur-sm border-0 shadow-2xl rounded-3xl overflow-hidden"> <CardHeader className="error-card-header"> <div className="text-6xl mb-4"> <AlertTriangle className="w-16 h-16 mx-auto" /> </div> <CardTitle className="text-2xl font-bold text-white"> Oops! Qualcosa è andato storto </CardTitle> <p className="text-red-100 mt-2"> Si è verificato un errore imprevisto </p> </CardHeader> <CardContent className="p-8 text-center"> <div className="space-y-6"> <div className="text-gray-600"> <p className="mb-4"> Non preoccuparti, possiamo provare a risolvere il problema. </p> {process.env.NODE_ENV === 'development' && this.state.error && ( <details className="text-left bg-gray-50 p-4 rounded-lg mb-4"> <summary className="cursor-pointer font-medium text-gray-700 mb-2"> Dettagli tecnici (sviluppo) </summary> <pre className="text-xs text-red-600 overflow-auto max-h-32"> {this.state.error.toString()} {this.state.errorInfo?.componentStack} </pre> </details> )} </div> <div className="flex gap-4 justify-center"> <Button onClick={this.handleReset} className="error-action-button" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> <Button onClick={() => window.location.reload()} variant="outline" className="border-2 border-gray-300 hover:border-gray-400 text-gray-700 px-6 py-3 rounded-xl font-semibold transition-all duration-300" > Ricarica Pagina </Button> </div> </div> </CardContent> </Card> </div> ); } return this.props.children; } }

================================================================================

NOME FILE: JSONManager.tsx

import React, { useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Textarea } from './ui/textarea'; import { FileDown, ChevronDown, ChevronUp, Upload, Download } from 'lucide-react'; import { useNotification } from '../contexts/NotificationContext'; import { Word, WordExportData } from '../types/entities/Word.types'; interface JSONManagerProps { words: Word[]; onImportWords: (jsonData: string) => Promise<number>; } interface ExportData { words: Word[]; exportDate: string; totalWords: number; version: string; appName: string; metadata: { chapters: string[]; groups: string[]; learnedCount: number; difficultCount: number; }; } interface ImportData { words?: Word[]; exportDate?: string; version?: string; metadata?: { chapters?: string[]; groups?: string[]; learnedCount?: number; difficultCount?: number; }; } const JSONManager: React.FC<JSONManagerProps> = ({ words, onImportWords }) => { const [jsonText, setJsonText] = useState<string>(''); const [showSection, setShowSection] = useState<boolean>(false); const [isProcessing, setIsProcessing] = useState<boolean>(false); const { showSuccess, showError, showWarning } = useNotification(); const handleExport = (): void => { if (words.length === 0) { showWarning('⚠️ Nessuna parola da esportare!'); return; } try { setIsProcessing(true); const exportData: ExportData = { words: words, exportDate: new Date().toISOString(), totalWords: words.length, version: '2.0', appName: 'Vocabulary Master', metadata: { chapters: [...new Set(words.map(w => w.chapter).filter(Boolean))] as string[], groups: [...new Set(words.map(w => w.group).filter(Boolean))] as string[], learnedCount: words.filter(w => w.learned).length, difficultCount: words.filter(w => w.difficult).length } }; const dataStr = JSON.stringify(exportData, null, 2); setJsonText(dataStr); setShowSection(true); showSuccess(`✅ ${words.length} parole esportate con successo!`); } catch (error) { console.error('Export error:', error); showError(error instanceof Error ? error : new Error(String(error)), 'Export JSON'); } finally { setIsProcessing(false); } }; const downloadAsFile = (): void => { if (!jsonText.trim()) { showWarning('⚠️ Nessun JSON da scaricare! Esporta prima i dati.'); return; } try { const blob = new Blob([jsonText], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `vocabulary-backup-${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); showSuccess('✅ File scaricato con successo!'); } catch (error) { console.error('Download error:', error); showError(error instanceof Error ? error : new Error(String(error)), 'Download File'); } }; const handleImport = async (): Promise<void> => { if (!jsonText.trim()) { showWarning('⚠️ Inserisci del JSON da importare!'); return; } try { setIsProcessing(true); let parsedData: ImportData | Word[]; try { parsedData = JSON.parse(jsonText.trim()); } catch (parseError) { throw new Error('JSON non valido! Controlla la sintassi.'); } let wordsToImport: Word[]; if (Array.isArray(parsedData)) { wordsToImport = parsedData; } else if (parsedData.words && Array.isArray(parsedData.words)) { wordsToImport = parsedData.words; if (parsedData.metadata) { const exportDate = parsedData.exportDate ? new Date(parsedData.exportDate).toLocaleDateString() : 'legacy'; showSuccess(`📊 Rilevato backup ${parsedData.version || 'legacy'} del ${exportDate}`); } } else { throw new Error('Formato JSON non valido. Atteso array di parole o oggetto con campo "words".'); } if (!wordsToImport || wordsToImport.length === 0) { throw new Error('Nessuna parola trovata nel JSON.'); } const validWords = wordsToImport.filter((word: any) => { return word && typeof word === 'object' && word.english && word.italian && typeof word.english === 'string' && typeof word.italian === 'string'; }); if (validWords.length === 0) { throw new Error('Nessuna parola valida trovata. Ogni parola deve avere almeno "english" e "italian".'); } if (validWords.length < wordsToImport.length) { showWarning(`⚠️ ${wordsToImport.length - validWords.length} parole saltate perché non valide.`); } const importedCount = await onImportWords(JSON.stringify(validWords)); setJsonText(''); setShowSection(true); showSuccess(`✅ ${importedCount} nuove parole importate con successo!`); } catch (error) { console.error('Import error:', error); if (error instanceof Error) { if (error.message.includes('JSON') || error.message.includes('syntax')) { showError(new Error('❌ JSON non valido! Controlla la sintassi.'), 'Import JSON'); } else if (error.message.includes('already exist')) { showWarning('⚠️ Tutte le parole sono già presenti nel vocabolario.'); } else { showError(error, 'Import JSON'); } } else { showError(new Error('Errore sconosciuto durante l\'importazione'), 'Import JSON'); } } finally { setIsProcessing(false); } }; const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>): void => { const file = event.target.files?.[0]; if (!file) return; if (file.type !== 'application/json' && !file.name.endsWith('.json')) { showWarning('⚠️ Seleziona un file JSON valido.'); return; } const reader = new FileReader(); reader.onload = (e) => { try { const content = e.target?.result as string; setJsonText(content); setShowSection(true); showSuccess('📁 File caricato! Verifica il contenuto e clicca "Importa JSON".'); } catch (error) { showError(error instanceof Error ? error : new Error(String(error)), 'File Reading'); } }; reader.onerror = () => { showError(new Error('Errore nella lettura del file'), 'File Reading'); }; reader.readAsText(file); }; const detectJSONFormat = (): string => { try { const parsed = JSON.parse(jsonText); if (Array.isArray(parsed)) { const hasWords = parsed.length > 0; const firstItem = hasWords ? parsed[0] : null; const hasEnglishItalian = firstItem && firstItem.english && firstItem.italian; if (hasEnglishItalian) { return `Array di ${parsed.length} parole (✅ Formato valido)`; } else if (hasWords) { return `Array con ${parsed.length} elementi (⚠️ Verificare formato)`; } else { return 'Array vuoto (❌ Nessuna parola)'; } } else if (parsed.words && Array.isArray(parsed.words)) { return `Backup Export v${parsed.version || '1.0'} con ${parsed.words.length} parole (✅ Formato valido)`; } else { return 'Oggetto JSON (⚠️ Array o campo "words" richiesto)'; } } catch { return 'JSON non valido (❌ Errore sintassi)'; } }; const renderPreviewWords = (): React.ReactNode => { try { const parsed = JSON.parse(jsonText); let wordsArray: Word[] = Array.isArray(parsed) ? parsed : parsed.words; if (wordsArray && wordsArray.length > 0) { const sampleWords = wordsArray.slice(0, 3); return ( <div className="p-3 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-xl"> <p className="text-blue-800 dark:text-blue-200 text-sm font-bold mb-2">👀 Anteprima prime parole:</p> <div className="space-y-1"> {sampleWords.map((word, idx) => ( <div key={idx} className="text-xs text-blue-700 dark:text-blue-300 font-mono"> • {word.english} → {word.italian} {word.chapter && ` (Cap. ${word.chapter})`} {word.group && ` [${word.group}]`} </div> ))} {wordsArray.length > 3 && ( <div className="text-xs text-blue-600 dark:text-blue-400"> ... e altre {wordsArray.length - 3} parole </div> )} </div> </div> ); } } catch { return null; } return null; }; return ( <Card className="backdrop-blur-sm bg-white/90 dark:bg-gray-800/90 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors" onClick={() => setShowSection(!showSection)} > <CardTitle className="flex items-center justify-between"> <div className="flex items-center gap-3"> <FileDown className="w-6 h-6 text-indigo-600 dark:text-purple-400" /> <span className="json-manager-title"> Gestione Dati JSON </span> </div> {showSection ? <ChevronUp className="w-5 h-5 text-gray-400 dark:text-gray-500" /> : <ChevronDown className="w-5 h-5 text-gray-400 dark:text-gray-500" />} </CardTitle> </CardHeader> {showSection && ( <CardContent className="animate-fade-in"> <div className="space-y-6"> <div className="p-4 bg-blue-50 dark:bg-blue-900/30 rounded-2xl border border-blue-200 dark:border-blue-700"> <p className="text-blue-800 dark:text-blue-200 text-sm flex items-center gap-2"> <span className="text-lg">💡</span> Usa questa sezione per fare backup del tuo vocabolario o condividerlo tra dispositivi </p> </div> } {jsonText && ( <div className="space-y-2"> <div className="p-3 bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-700 rounded-xl"> <p className="text-green-800 dark:text-green-200 text-sm"> 💾 <strong>Formato rilevato:</strong> {detectJSONFormat()} </p> </div> } {isProcessing && ( <div className="flex items-center justify-center p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-xl"> <div className="animate-spin w-5 h-5 border-2 border-yellow-500 border-t-transparent rounded-full mr-3"></div> <span className="text-yellow-800 dark:text-yellow-200 font-medium">Elaborazione in corso...</span> </div> )}

================================================================================

NOME FILE: LoadingComponents.tsx

import React from 'react'; import { Loader2, Brain, Database, Wifi, AlertCircle, Clock, RefreshCw } from 'lucide-react'; import { Card, CardContent } from './ui/card'; import { Button } from './ui/button'; interface SmartLoadingIndicatorProps { isLoading: boolean; operation?: string; duration?: number; size?: 'sm' | 'md' | 'lg' | 'xl'; showDuration?: boolean; customIcon?: React.ElementType; customMessage?: string; } interface ProgressLoaderProps { isLoading: boolean; progress?: number; operation?: string; estimatedTime?: number; onCancel?: () => void; } interface ErrorWithRetryProps { error: Error | null; onRetry?: () => void; canRetry?: boolean; retryCount?: number; maxRetries?: number; isRetrying?: boolean; } interface WordFormSkeletonProps { } interface WordListSkeletonProps { count?: number; } interface StatsSkeletonProps { } interface ChartSkeletonProps { } interface InlineLoaderProps { size?: 'sm' | 'md'; text?: string; } interface ButtonLoaderProps extends React.ButtonHTMLAttributes<HTMLButtonElement> { isLoading: boolean; children: React.ReactNode; } interface LoadingDotsProps { size?: 'sm' | 'md' | 'lg'; } interface LoadingSpinnerProps { size?: 'sm' | 'md' | 'lg' | 'xl'; color?: string; } interface LoadingOverlayProps { isLoading: boolean; message?: string; children: React.ReactNode; blur?: boolean; } interface LoadingStateManagerProps { isLoading: boolean; error?: Error | null; onRetry?: () => void; retryCount?: number; maxRetries?: number; loadingComponent?: React.ReactNode; errorComponent?: React.ReactNode; children: React.ReactNode; } export const SmartLoadingIndicator: React.FC<SmartLoadingIndicatorProps> = ({ isLoading, operation, duration, size = 'md', showDuration = true, customIcon = null, customMessage = null }) => { if (!isLoading) return null; const sizeClasses = { sm: 'w-4 h-4', md: 'w-6 h-6', lg: 'w-8 h-8', xl: 'w-12 h-12' }; const getOperationIcon = (): React.ElementType => { if (customIcon) return customIcon; if (operation?.toLowerCase().includes('ai')) return Brain; if (operation?.toLowerCase().includes('storage') || operation?.toLowerCase().includes('save')) return Database; if (operation?.toLowerCase().includes('network') || operation?.toLowerCase().includes('fetch')) return Wifi; return Loader2; }; const Icon = getOperationIcon(); const message = customMessage || operation || 'Caricamento...'; return ( <div className="flex items-center gap-3 text-blue-600"> <Icon className={`${sizeClasses[size]} animate-spin`} /> <div className="flex flex-col"> <span className="text-sm font-medium">{message}</span> {showDuration && duration && duration > 2000 && ( <span className="text-xs text-gray-500"> {Math.round(duration / 1000)}s </span> )} </div> </div> ); }; export const ProgressLoader: React.FC<ProgressLoaderProps> = ({ isLoading, progress, operation, estimatedTime, onCancel }) => { if (!isLoading) return null; return ( <Card className="border-blue-200 bg-blue-50"> <CardContent className="p-6"> <div className="space-y-4"> <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> <Loader2 className="w-5 h-5 animate-spin text-blue-600" /> <span className="font-medium text-blue-800">{operation}</span> </div> {onCancel && ( <Button variant="ghost" size="sm" onClick={onCancel} className="text-blue-600 hover:bg-blue-100" > Annulla </Button> )} </div> {progress !== undefined && ( <div className="space-y-2"> <div className="flex justify-between text-sm text-blue-600"> <span>{Math.round(progress)}%</span> {estimatedTime && ( <span className="flex items-center gap-1"> <Clock className="w-3 h-3" /> {estimatedTime}s </span> )} </div>

================================================================================

NOME FILE: ServiceStatusIndicator.js

import React, { useState, useEffect } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Brain, Database, Wifi, CheckCircle, AlertTriangle, XCircle, RefreshCw, Info } from 'lucide-react'; import { aiService } from '../services/aiService'; import { storageService } from '../services/storageService'; const ServiceStatusIndicator = ({ compact = false, showDetails = false, onStatusChange = null }) => { const [aiStatus, setAiStatus] = useState(null); const [storageStatus, setStorageStatus] = useState(null); const [isRefreshing, setIsRefreshing] = useState(false); const [lastUpdate, setLastUpdate] = useState(null); const checkAllServices = async () => { setIsRefreshing(true); try { const [aiResult, storageResult] = await Promise.all([ aiService.getServiceStatus(), storageService.getServiceStatus() ]); setAiStatus(aiResult); setStorageStatus(storageResult); setLastUpdate(Date.now()); if (onStatusChange) { onStatusChange({ ai: aiResult, storage: storageResult, overall: getOverallHealth(aiResult, storageResult) }); } } catch (error) { console.error('❌ Failed to check service status:', error); } finally { setIsRefreshing(false); } }; const getOverallHealth = (ai, storage) => { if (!ai || !storage) return 'unknown'; if (ai.health === 'down' || storage.health === 'down') return 'critical'; if (ai.health === 'degraded' || storage.health === 'degraded') return 'warning'; if (ai.health === 'healthy' && storage.health === 'healthy') return 'healthy'; return 'unknown'; }; const getStatusIcon = (health) => { switch (health) { case 'healthy': return <CheckCircle className="w-5 h-5 text-green-500" />; case 'degraded': return <AlertTriangle className="w-5 h-5 text-yellow-500" />; case 'down': return <XCircle className="w-5 h-5 text-red-500" />; default: return <Info className="w-5 h-5 text-gray-500" />; } }; const getStatusColor = (health) => { switch (health) { case 'healthy': return 'border-green-200 bg-green-50'; case 'degraded': return 'border-yellow-200 bg-yellow-50'; case 'down': return 'border-red-200 bg-red-50'; default: return 'border-gray-200 bg-gray-50'; } }; useEffect(() => { checkAllServices(); const interval = setInterval(checkAllServices, 30000); return () => clearInterval(interval); }, []); if (compact && (!aiStatus || !storageStatus)) { return ( <div className="flex items-center gap-2 text-gray-500"> <RefreshCw className="w-4 h-4 animate-spin" /> <span className="text-sm">Checking...</span> </div> ); } if (compact) { const overallHealth = getOverallHealth(aiStatus, storageStatus); return ( <div className={`flex items-center gap-2 px-3 py-2 rounded-lg border ${getStatusColor(overallHealth)}`}> {getStatusIcon(overallHealth)} <span className="text-sm font-medium"> {overallHealth === 'healthy' ? 'All Services OK' : overallHealth === 'warning' ? 'Some Issues' : overallHealth === 'critical' ? 'Service Issues' : 'Checking...'} </span> <Button variant="ghost" size="sm" onClick={checkAllServices} disabled={isRefreshing} className="h-6 w-6 p-0" > <RefreshCw className={`w-3 h-3 ${isRefreshing ? 'animate-spin' : ''}`} /> </Button> </div> ); } return ( <Card className="w-full"> <CardHeader> <CardTitle className="flex items-center justify-between"> <span className="flex items-center gap-2"> <Wifi className="w-5 h-5" /> Service Status </span> <Button variant="outline" size="sm" onClick={checkAllServices} disabled={isRefreshing} > <RefreshCw className={`w-4 h-4 mr-2 ${isRefreshing ? 'animate-spin' : ''}`} /> Refresh </Button> </CardTitle> {lastUpdate && ( <p className="text-sm text-gray-500"> Last updated: {new Date(lastUpdate).toLocaleTimeString()} </p> )} </CardHeader> <CardContent className="space-y-4"> } <div className={`p-4 rounded-lg border ${storageStatus ? getStatusColor(storageStatus.health) : 'border-gray-200 bg-gray-50'}`}> <div className="flex items-center justify-between mb-3"> <div className="flex items-center gap-3"> <Database className="w-6 h-6 text-blue-600" /> <div> <h3 className="font-semibold">Local Storage</h3> <p className="text-sm text-gray-600"> {storageStatus?.available ? 'Available' : 'Unavailable'} </p> </div> </div> {storageStatus && getStatusIcon(storageStatus.health)} </div> {storageStatus && showDetails && ( <div className="space-y-2 text-sm"> <div className="grid grid-cols-2 gap-4"> <div> <span className="font-medium">Used:</span> {storageStatus.usage.usedMB}MB </div> <div> <span className="font-medium">Available:</span> {storageStatus.usage.availableMB}MB </div> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className={`h-2 rounded-full ${ storageStatus.usage.critical ? 'bg-red-500' : storageStatus.usage.warning ? 'bg-yellow-500' : 'bg-green-500' }`} style={{ width: `${storageStatus.usage.usagePercentage}%` }} /> </div> {storageStatus.recommendations.length > 0 && ( <div> <span className="font-medium">Recommendations:</span> <ul className="list-disc list-inside mt-1"> {storageStatus.recommendations.map((rec, index) => ( <li key={index} className="text-xs">{rec}</li> ))} </ul> </div> )} </div> )} </div>

================================================================================

NOME FILE: TestCard.tsx

import React from 'react'; import { getCategoryStyle } from '../utils/categoryUtils'; import { formatNotes } from '../utils/textUtils'; import { Word } from '../types/entities/Word.types'; interface TestCardProps { word: Word; showMeaning: boolean; onFlip: () => void; showHint: boolean; hintUsed: boolean; gameMode?: boolean; gameHints?: { synonym?: string[]; antonym?: string[]; context?: string[]; }; onGameHintRequest?: (type: 'synonym' | 'antonym' | 'context') => void; } const TestCard: React.FC<TestCardProps> = ({ word, showMeaning, onFlip, showHint, hintUsed, gameMode = false, gameHints = {}, onGameHintRequest }) => { const sentence = word.sentences && word.sentences.length > 0 ? word.sentences[0] : undefined; return ( <div className="test-card-container interactive-scale" onClick={onFlip} > <div className={`test-card-flip-wrapper ${showMeaning ? 'flipped' : ''}`} > } {!gameMode && sentence && ( <div className="absolute top-6 left-6 right-6"> <div className={`test-card-hint-box ${!showHint ? 'opacity-0 pointer-events-none' : ''}`}> <div className="test-card-hint-header"> <span className="test-card-hint-icon">💡</span> <span className="test-card-hint-label">Suggerimento:</span> {hintUsed && ( <span className="test-card-hint-badge"> Conteggiato </span> )} </div> <div className="test-card-hint-text"> "{sentence}" </div> </div> </div> )} <div className="test-card-word"> <h2 className="test-card-word-text"> {word.english} </h2> </div> } <div className={`test-card-face ${getCategoryStyle(word.group)?.bgGradient || 'test-card-face-back'}`} style={{ backfaceVisibility: 'hidden', transform: 'rotateY(180deg)' }} > <div className="test-card-back-overlay"></div> } <div className="test-card-header"> <div className="test-card-title"> {word.english} </div> </div> } <div className="test-card-content-grid"> } {word.antonyms && word.antonyms.length > 0 && ( <div className="test-card-section"> <div className="test-card-section-header"> <span className="test-card-hint-icon">⚡</span> Contrari: </div> <div className="test-card-section-list"> {word.antonyms.join(', ')} </div> </div> )} } {word.notes && ( <div className="test-card-section"> <div className="test-card-section-header"> <span className="test-card-hint-icon">📝</span> Note: </div> <div className="test-card-notes-content"> {formatNotes(word.notes)} </div> </div> )} </div>

================================================================================

NOME FILE: TestHistory.tsx

import React, { useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { ChevronDown, ChevronUp, BookOpen, Target, Calendar, Award } from 'lucide-react'; import { Word } from '../types/entities/Word.types'; interface TestParameters { selectedChapters: string[]; includeLearnedWords: boolean; totalAvailableWords: number; } interface ChapterStats { percentage: number; correctWords: number; incorrectWords: number; } interface TestHistoryItem { id: string; timestamp: string; percentage: number; totalWords: number; correctWords: number; incorrectWords: number; difficulty: 'easy' | 'medium' | 'hard'; testType: 'complete' | 'selective' | 'unknown'; testParameters?: TestParameters; chapterStats?: Record<string, ChapterStats>; wrongWords?: Word[]; } interface TestHistoryProps { testHistory: TestHistoryItem[]; onClearHistory: () => void; } interface TestHistoryCardProps { test: TestHistoryItem; testNumber: number; isExpanded: boolean; onToggleExpansion: () => void; formatDifficulty: (difficulty: string) => DifficultyFormat; formatTestType: (testType: string) => TestTypeFormat; } interface DifficultyFormat { label: string; color: string; emoji: string; } interface TestTypeFormat { label: string; color: string; emoji: string; } const TestHistory: React.FC<TestHistoryProps> = ({ testHistory, onClearHistory }) => { const [expandedTest, setExpandedTest] = useState<string | null>(null); if (testHistory.length === 0) return null; const toggleTestExpansion = (testId: string): void => { setExpandedTest(expandedTest === testId ? null : testId); }; const formatDifficulty = (difficulty: string): DifficultyFormat => { const difficultyMap: Record<string, DifficultyFormat> = { 'easy': { label: 'Facile', color: 'bg-green-500', emoji: '😊' }, 'medium': { label: 'Medio', color: 'bg-yellow-500', emoji: '😐' }, 'hard': { label: 'Difficile', color: 'bg-red-500', emoji: '😤' } }; return difficultyMap[difficulty] || difficultyMap['medium']; }; const formatTestType = (testType: string): TestTypeFormat => { const typeMap: Record<string, TestTypeFormat> = { 'complete': { label: 'Completo', color: 'bg-blue-500', emoji: '🎯' }, 'selective': { label: 'Selettivo', color: 'bg-purple-500', emoji: '📚' }, 'unknown': { label: 'Standard', color: 'bg-gray-500', emoji: '📝' } }; return typeMap[testType] || typeMap['unknown']; }; return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <CardHeader className="test-history-header"> <div className="flex justify-between items-center"> <CardTitle className="flex items-center gap-3 text-white"> <Calendar className="w-6 h-6" /> Cronologia Test Dettagliata ({testHistory.length}) </CardTitle> <Button onClick={onClearHistory} variant="outline" className="border-white/30 text-white hover:bg-white/20 hover:border-white/50 rounded-xl" > <span className="w-4 h-4 mr-2">🗑️</span> Pulisci </Button> </div> <p className="text-indigo-100 mt-2"> Storico completo con parametri di test, capitoli e performance dettagliate </p> </CardHeader> <CardContent className="p-6"> <div className="space-y-4 max-h-96 overflow-y-auto custom-scrollbar"> {testHistory.map((test, index) => ( <TestHistoryCard key={test.id} test={test} testNumber={testHistory.length - index} isExpanded={expandedTest === test.id} onToggleExpansion={() => toggleTestExpansion(test.id)} formatDifficulty={formatDifficulty} formatTestType={formatTestType} /> ))} </div> </CardContent> </Card> ); }; const TestHistoryCard: React.FC<TestHistoryCardProps> = ({ test, testNumber, isExpanded, onToggleExpansion, formatDifficulty, formatTestType }) => { const difficulty = formatDifficulty(test.difficulty); const testType = formatTestType(test.testType); return ( <div className="test-history-item"> } <div className={`px-4 py-2 rounded-full text-sm font-bold shadow-lg text-white ${ test.percentage >= 80 ? 'bg-gradient-to-r from-green-500 to-emerald-500' : test.percentage >= 60 ? 'bg-gradient-to-r from-blue-500 to-cyan-500' : 'bg-gradient-to-r from-red-500 to-pink-500' }`}> {test.percentage}% </div> } <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${difficulty.color}`}> <span className="mr-1">{difficulty.emoji}</span> {difficulty.label} </div> </div> } <div className="grid grid-cols-3 gap-4"> <div className="bg-blue-50 p-3 rounded-xl text-center"> <div className="text-lg font-bold text-blue-600">{test.totalWords}</div> <div className="text-blue-700 text-xs">Totale</div> </div> <div className="bg-green-50 p-3 rounded-xl text-center"> <div className="text-lg font-bold text-green-600">{test.correctWords}</div> <div className="text-green-700 text-xs">Corrette</div> </div> <div className="bg-red-50 p-3 rounded-xl text-center"> <div className="text-lg font-bold text-red-600">{test.incorrectWords}</div> <div className="text-red-700 text-xs">Sbagliate</div> </div> </div> </div> } {isExpanded && ( <div className="border-t border-gray-200 bg-gray-50"> <div className="p-6 space-y-6"> } {test.chapterStats && Object.keys(test.chapterStats).length > 0 && ( <div> <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2"> <BookOpen className="w-5 h-5" /> Performance per Capitolo </h4> <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"> {Object.entries(test.chapterStats).map(([chapter, stats]) => ( <div key={chapter} className="bg-white p-4 rounded-xl border border-gray-200"> <div className="font-medium text-gray-800 mb-2"> {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`} </div> <div className="space-y-2"> <div className="flex justify-between items-center"> <span className="text-sm text-gray-600">Accuratezza:</span> <span className={`font-bold ${ stats.percentage >= 80 ? 'text-green-600' : stats.percentage >= 60 ? 'text-blue-600' : 'text-red-600' }`}> {stats.percentage}% </span> </div> <div className="flex justify-between items-center text-xs text-gray-500"> <span>Corrette: {stats.correctWords}</span> <span>Sbagliate: {stats.incorrectWords}</span> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className={`h-2 rounded-full ${ stats.percentage >= 80 ? 'bg-green-500' : stats.percentage >= 60 ? 'bg-blue-500' : 'bg-red-500' }`} style={{ width: `${stats.percentage}%` }} ></div> </div> </div> </div> ))} </div> </div> )} } <div className="bg-blue-50 p-4 rounded-xl border border-blue-200"> <h5 className="font-medium text-blue-800 mb-2">💡 Raccomandazioni per il prossimo test:</h5> <div className="text-sm text-blue-700 space-y-1"> {test.percentage < 60 && ( <p>• Rivedi le parole sbagliate prima del prossimo test</p> )} {test.chapterStats && Object.values(test.chapterStats).some(s => s.percentage < 70) && ( <p>• Concentrati sui capitoli con performance inferiore al 70%</p> )} {test.testParameters?.selectedChapters?.length === 1 && ( <p>• Prova a combinare più capitoli per aumentare la varietà</p> )} {test.percentage >= 80 && ( <p>• Ottimo lavoro! Potresti provare un test più difficile</p> )} </div> </div> </div> </div> )} </div> ); }; export default TestHistory;

================================================================================

NOME FILE: TestResults.tsx

import React from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Play, RotateCcw, Check, X, Trophy, Clock, Lightbulb, Target, Timer, Zap } from 'lucide-react'; import { getTestResult } from '../utils/textUtils'; import { formatNotes } from '../utils/textUtils'; import { Word } from '../types/entities/Word.types'; interface TestStats { correct: number; incorrect: number; hints: number; totalTime: number; avgTimePerWord: number; maxTimePerWord: number; minTimePerWord: number; totalRecordedTime: number; total?: number; correctAnswers?: number; incorrectAnswers?: number; right?: number; wrong?: number; hintsUsed?: number; timeSpent?: number; averageTime?: number; } interface WrongWord extends Word { usedHint?: boolean; } interface TestResult { type: 'victory' | 'good' | 'study'; message: string; color: string; } interface TestResultsProps { stats: TestStats; wrongWords: WrongWord[]; onStartNewTest: () => void; onResetTest: () => void; } interface PerformanceMetrics { accuracy: number; hintsUsed: number; totalTime: string; totalTimeSeconds: number; avgTime: number; maxTime: number; minTime: number; totalRecordedTime: string; speedRating: string; efficiency: number; } interface ProcessedStats { correct: number; incorrect: number; hints: number; totalTime: number; avgTimePerWord: number; maxTimePerWord: number; minTimePerWord: number; totalRecordedTime: number; } const TestResults: React.FC<TestResultsProps> = ({ stats, wrongWords, onStartNewTest, onResetTest }) => { const getCorrectStats = (): ProcessedStats => { if (stats && typeof stats === 'object') { const processedStats: ProcessedStats = { correct: stats.correct || 0, incorrect: stats.incorrect || 0, hints: stats.hints || 0, totalTime: stats.totalTime || 0, avgTimePerWord: stats.avgTimePerWord || 0, maxTimePerWord: stats.maxTimePerWord || 0, minTimePerWord: stats.minTimePerWord || 0, totalRecordedTime: stats.totalRecordedTime || 0 }; return processedStats; } if (stats) { const statsAny = stats as any; const correct = statsAny.correct || statsAny.correctAnswers || statsAny.right || 0; const incorrect = statsAny.incorrect || statsAny.incorrectAnswers || statsAny.wrong || 0; const hints = statsAny.hints || statsAny.hintsUsed || 0; const totalTime = statsAny.totalTime || statsAny.timeSpent || 0; const avgTimePerWord = statsAny.avgTimePerWord || statsAny.averageTime || 0; const maxTimePerWord = statsAny.maxTimePerWord || 0; const minTimePerWord = statsAny.minTimePerWord || 0; const totalRecordedTime = statsAny.totalRecordedTime || 0; if (correct > 0 || incorrect > 0) { const legacyStats: ProcessedStats = { correct, incorrect, hints, totalTime, avgTimePerWord, maxTimePerWord, minTimePerWord, totalRecordedTime }; return legacyStats; } } if (wrongWords && Array.isArray(wrongWords)) { const incorrect = wrongWords.length; const correct = Math.max(0, ((stats as any)?.total || 10) - incorrect); const fallbackStats: ProcessedStats = { correct, incorrect, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; return fallbackStats; } const defaultStats: ProcessedStats = { correct: 0, incorrect: 0, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; return defaultStats; }; const finalStats = getCorrectStats(); const totalAnswers = finalStats.correct + finalStats.incorrect; const percentage = totalAnswers > 0 ? Math.round((finalStats.correct / totalAnswers) * 100) : 0; const result = getTestResult({ correct: finalStats.correct, incorrect: finalStats.incorrect, total: totalAnswers }) as TestResult; const formatTime = (seconds: number): string => { if (!seconds || seconds <= 0) return '0:00'; const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }; const performanceMetrics: PerformanceMetrics = { accuracy: percentage, hintsUsed: finalStats.hints, totalTime: formatTime(finalStats.totalTime), totalTimeSeconds: finalStats.totalTime, avgTime: finalStats.avgTimePerWord, maxTime: finalStats.maxTimePerWord, minTime: finalStats.minTimePerWord, totalRecordedTime: formatTime(finalStats.totalRecordedTime), speedRating: finalStats.avgTimePerWord <= 8 ? 'Molto veloce' : finalStats.avgTimePerWord <= 15 ? 'Veloce' : finalStats.avgTimePerWord <= 25 ? 'Normale' : 'Lento', efficiency: Math.max(0, percentage - (finalStats.hints / Math.max(1, totalAnswers) * 100)) }; return ( <div className="stack-lg"> <Card className="test-results-card relative overflow-hidden"> } <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm text-gray-600"> {finalStats.hints > 0 && ( <div className="flex-center gap-1 status-warning px-3 py-2 rounded-lg"> <Lightbulb className="w-4 h-4 text-orange-500" /> <span>{finalStats.hints} aiuti</span> </div> )} {finalStats.totalTime > 0 && ( <div className="flex-center gap-1 status-info px-3 py-2 rounded-lg"> <Clock className="w-4 h-4 text-blue-500" /> <span>{performanceMetrics.totalTime} totale</span> </div> )} {finalStats.avgTimePerWord > 0 && ( <div className="flex-center gap-1 bg-purple-100 px-3 py-2 rounded-lg"> <Target className="w-4 h-4 text-purple-500" /> <span>{finalStats.avgTimePerWord}s media ({performanceMetrics.speedRating})</span> </div> )} {finalStats.maxTimePerWord > 0 && ( <div className="flex-center gap-1 status-error px-3 py-2 rounded-lg"> <Timer className="w-4 h-4 text-red-500" /> <span>{finalStats.maxTimePerWord}s massimo</span> </div> )} </div> </CardHeader> <CardContent className="relative pb-12"> } <div className="test-results-stat-hints"> <div className="test-results-stat-value text-white">{finalStats.hints}</div> <div className="text-orange-100">Aiuti</div> <Lightbulb className="w-8 h-8 mx-auto mt-2 opacity-80" /> </div> } <div className="test-results-stat-score"> <div className="test-results-stat-value text-white">{Math.round(performanceMetrics.efficiency)}%</div> <div className="text-purple-100">Efficienza</div> <Zap className="w-8 h-8 mx-auto mt-2 opacity-80" /> </div> </div> } <div className="test-results-time-item"> <h4 className="test-results-time-title">⏱️ Statistiche Tempo</h4> <div className="stack-sm"> <div className="card-base p-3 border border-indigo-200"> <div className="test-results-time-value">{performanceMetrics.avgTime}s</div> <div className="test-results-time-label">Tempo Medio</div> </div> {finalStats.maxTimePerWord > 0 && ( <div className="card-base p-3 border border-red-200"> <div className="text-lg font-bold text-red-600">{finalStats.maxTimePerWord}s</div> <div className="text-red-800 text-sm">Tempo Massimo</div> </div> )} {finalStats.minTimePerWord > 0 && ( <div className="card-base p-3 border border-green-200"> <div className="text-lg font-bold text-green-600">{finalStats.minTimePerWord}s</div> <div className="text-green-800 text-sm">Tempo Minimo</div> </div> )} </div> </div> } <div className="test-results-time-item"> <h4 className="font-bold text-green-800 mb-3">🏆 Valutazione</h4> <div className="stack-sm"> <div className="card-base p-3 border border-green-200"> <div className="text-lg font-bold text-green-600">{performanceMetrics.speedRating}</div> <div className="text-green-800 text-sm">Velocità</div> </div> <div className="card-base p-3 border border-blue-200"> <div className="text-lg font-bold text-blue-600"> {performanceMetrics.accuracy >= 80 && performanceMetrics.hintsUsed <= 2 ? 'Eccellente' : performanceMetrics.accuracy >= 70 ? 'Molto Buono' : performanceMetrics.accuracy >= 60 ? 'Buono' : 'Da Migliorare'} </div> <div className="text-blue-800 text-sm">Performance</div> </div> </div> </div> </div> } <div className="test-results-actions justify-center"> <Button onClick={onStartNewTest} className="test-results-action-button test-results-retry-button px-8 py-4 text-lg rounded-2xl" > <Play className="w-5 h-5 mr-2" /> Nuovo Test </Button> <Button onClick={onResetTest} variant="outline" className="test-results-action-button test-results-new-button px-8 py-4 text-lg rounded-2xl" > <RotateCcw className="w-5 h-5 mr-2" /> Torna al Menu </Button> </div>

================================================================================

NOME FILE: TestSelector.tsx

import React, { useState, useEffect } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Play, BookOpen, CheckSquare, Square, Target, AlertTriangle, GraduationCap, Clock, HelpCircle, Settings, Zap, Timer, X, Check, Star, Sparkles } from 'lucide-react'; import { useNotification } from '../contexts/NotificationContext'; import { Word } from '../types'; interface TestSelectorProps { words: Word[]; onStartTest: (config: TestConfig) => void; onClose: () => void; } interface TestConfig { selectedChapters: string[]; includeLearnedWords: boolean; testMode: 'normal' | 'difficult-only'; maxTimePerWord?: number; maxHintsPerWord?: number; maxTotalHints?: number; enableTimer: boolean; enableHints: boolean; enableTotalHintsLimit?: boolean; hintsMode?: 'disabled' | 'unlimited' | 'limited'; } interface ChapterStats { totalWords: number; learnedWords: number; difficultWords: number; availableForTest: number; } const TestSelector: React.FC<TestSelectorProps> = ({ words, onStartTest, onClose }) => { const [selectedChapters, setSelectedChapters] = useState<Set<string>>(new Set()); const [includeLearnedWords, setIncludeLearnedWords] = useState<boolean>(false); const [testMode, setTestMode] = useState<'normal' | 'difficult-only'>('normal'); const [enableTimer, setEnableTimer] = useState<boolean>(false); const [maxTimePerWord, setMaxTimePerWord] = useState<number>(30); const [hintsMode, setHintsMode] = useState<'disabled' | 'unlimited' | 'limited'>('limited'); const [maxHintsPerWord, setMaxHintsPerWord] = useState<number>(2); const [maxTotalHints, setMaxTotalHints] = useState<number>(10); const [enableTotalHintsLimit, setEnableTotalHintsLimit] = useState<boolean>(false); const [showOptions, setShowOptions] = useState<boolean>(false); const { showWarning } = useNotification(); const getAvailableChapters = (): string[] => { const chapters = new Set<string>(); words.forEach(word => { if (word.chapter) { chapters.add(word.chapter); } }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); if (!isNaN(aNum) && !isNaN(bNum)) { return aNum - bNum; } return a.localeCompare(b); }); }; const availableChapters = getAvailableChapters(); const wordsWithoutChapter = words.filter(word => !word.chapter); const getChapterStats = (chapter: string): ChapterStats => { const chapterWords = words.filter(word => word.chapter === chapter); const totalWords = chapterWords.length; const learnedWords = chapterWords.filter(word => word.learned).length; const difficultWords = chapterWords.filter(word => word.difficult).length; let availableForTest = 0; if (testMode === 'difficult-only') { availableForTest = difficultWords; } else { if (includeLearnedWords) { availableForTest = totalWords; } else { availableForTest = chapterWords.filter(word => !word.learned).length; } } return { totalWords, learnedWords, difficultWords, availableForTest }; }; const calculateTestDifficulty = (): { level: string; percentage: number; description: string } => { let totalSelectedWords = 0; let difficultWordsSelected = 0; let learnedWordsSelected = 0; selectedChapters.forEach(chapter => { const stats = chapter === 'no-chapter' ? getWordsWithoutChapterStats() : getChapterStats(chapter); totalSelectedWords += stats.availableForTest; difficultWordsSelected += stats.difficultWords; learnedWordsSelected += stats.learnedWords; }); if (totalSelectedWords === 0) { return { level: 'Nessuna', percentage: 0, description: 'Nessuna parola selezionata' }; } let difficultyScore = 0; const difficultPercentage = (difficultWordsSelected / totalSelectedWords) * 100; difficultyScore += (difficultPercentage / 100) * 40; if (testMode === 'difficult-only') { difficultyScore += 30; } else if (!includeLearnedWords) { difficultyScore += 15; } if (enableTimer) { const timeScore = Math.max(0, (60 - maxTimePerWord) / 60) * 15; difficultyScore += timeScore; } if (hintsMode === 'disabled') { difficultyScore += 15; } else if (hintsMode === 'limited') { const hintScore = Math.max(0, (3 - maxHintsPerWord) / 3) * 15; difficultyScore += hintScore; } let level: string; let description: string; if (difficultyScore >= 80) { level = 'Estrema'; description = 'Test molto impegnativo per esperti'; } else if (difficultyScore >= 65) { level = 'Difficile'; description = 'Test impegnativo con sfide significative'; } else if (difficultyScore >= 45) { level = 'Intermedia'; description = 'Test di livello medio, ben bilanciato'; } else if (difficultyScore >= 25) { level = 'Facile'; description = 'Test accessibile per principianti'; } else { level = 'Molto Facile'; description = 'Test di pratica con massimo supporto'; } return { level, percentage: Math.round(difficultyScore), description }; }; const testDifficulty = calculateTestDifficulty(); const getWordsWithoutChapterStats = (): ChapterStats => { const totalWords = wordsWithoutChapter.length; const learnedWords = wordsWithoutChapter.filter(word => word.learned).length; const difficultWords = wordsWithoutChapter.filter(word => word.difficult).length; let availableForTest = 0; if (testMode === 'difficult-only') { availableForTest = difficultWords; } else { if (includeLearnedWords) { availableForTest = totalWords; } else { availableForTest = wordsWithoutChapter.filter(word => !word.learned).length; } } return { totalWords, learnedWords, difficultWords, availableForTest }; }; const wordsWithoutChapterStats = getWordsWithoutChapterStats(); const toggleChapterSelection = (chapter: string) => { const newSelection = new Set(selectedChapters); if (newSelection.has(chapter)) { newSelection.delete(chapter); } else { newSelection.add(chapter); } setSelectedChapters(newSelection); }; const selectAllChapters = () => { const allChapters = new Set([...availableChapters]); if (wordsWithoutChapter.length > 0) { allChapters.add('no-chapter'); } setSelectedChapters(allChapters); }; const deselectAllChapters = () => { setSelectedChapters(new Set()); }; const getTotalSelectedWords = (): number => { let total = 0; selectedChapters.forEach(chapter => { if (chapter === 'no-chapter') { total += wordsWithoutChapterStats.availableForTest; } else { total += getChapterStats(chapter).availableForTest; } }); return total; }; const totalSelectedWords = getTotalSelectedWords(); const handleStartTest = () => { if (selectedChapters.size === 0) { showWarning('⚠️ Seleziona almeno un capitolo per il test!'); return; } if (totalSelectedWords === 0) { if (testMode === 'difficult-only') { showWarning('⚠️ Nessuna parola difficile trovata nei capitoli selezionati!'); } else { showWarning('⚠️ Nessuna parola disponibile nei capitoli selezionati!'); } return; } const config: TestConfig = { selectedChapters: Array.from(selectedChapters), includeLearnedWords, testMode, enableTimer, maxTimePerWord: enableTimer ? maxTimePerWord : undefined, enableHints: hintsMode !== 'disabled', hintsMode, maxHintsPerWord: hintsMode === 'limited' ? maxHintsPerWord : undefined, maxTotalHints: hintsMode === 'limited' && enableTotalHintsLimit ? maxTotalHints : undefined, enableTotalHintsLimit: hintsMode === 'limited' ? enableTotalHintsLimit : false }; onStartTest(config); }; useEffect(() => { if (availableChapters.length > 0) { selectAllChapters(); } }, []); return ( <div className="test-selector-overlay"> <Card className="test-selector-card"> } <div className="relative flex items-center justify-between"> <CardTitle className="text-2xl font-bold flex items-center gap-3 drop-shadow-lg"> <div className="p-2 bg-white/20 rounded-xl backdrop-blur-sm"> <Target className="w-6 h-6" /> </div> <span className="header-title-gradient"> Configurazione Test </span> <Sparkles className="w-5 h-5 text-yellow-300 animate-pulse" /> </CardTitle> <Button variant="ghost" size="sm" onClick={onClose} className="text-white hover:bg-white/20 rounded-full p-3 backdrop-blur-sm transition-all duration-300 hover:scale-110" > <X className="w-5 h-5" /> </Button> </div> </CardHeader> <div className="test-selector-content h-[calc(90vh-100px)] max-h-[calc(90vh-100px)] flex flex-col overflow-hidden"> <CardContent className="p-6 h-full flex flex-col"> } <div className="flex flex-col h-full overflow-hidden"> } <div className="test-mode-container"> <h3 className="test-mode-header"> <div className="test-mode-icon"> <GraduationCap className="w-4 h-4 text-white" /> </div> <span className="test-mode-title"> Modalità Test </span> </h3> <div className="space-y-3"> <button onClick={() => setTestMode('normal')} className={`test-mode-button group ${ testMode === 'normal' ? 'test-mode-button-active' : 'test-mode-button-inactive' }`} > <div className="flex items-center gap-3"> <div className={`p-2 rounded-lg transition-all duration-300 ${ testMode === 'normal' ? 'bg-gradient-to-r from-blue-500 to-indigo-500 shadow-lg' : 'bg-gray-200 dark:bg-gray-600 group-hover:bg-blue-100 dark:group-hover:bg-blue-800' }`}> <BookOpen className={`w-4 h-4 ${testMode === 'normal' ? 'text-white' : 'text-gray-600 dark:text-gray-400'}`} /> </div> <div className="flex-1"> <span className="font-semibold">Test Normale</span> {testMode === 'normal' && <Check className="w-4 h-4 ml-auto inline-block text-blue-600" />} </div> </div> <p className="text-xs mt-2 opacity-80 ml-11">Tutte le parole disponibili per un test completo</p> </button> <button onClick={() => setTestMode('difficult-only')} className={`test-mode-button group ${ testMode === 'difficult-only' ? 'test-mode-button-active' : 'test-mode-button-inactive' }`} > <div className="flex items-center gap-3"> <div className={`p-2 rounded-lg transition-all duration-300 ${ testMode === 'difficult-only' ? 'bg-gradient-to-r from-orange-500 to-red-500 shadow-lg' : 'bg-gray-200 dark:bg-gray-600 group-hover:bg-orange-100 dark:group-hover:bg-orange-800' }`}> <AlertTriangle className={`w-4 h-4 ${testMode === 'difficult-only' ? 'text-white' : 'text-gray-600 dark:text-gray-400'}`} /> </div> <div className="flex-1"> <span className="font-semibold">Solo Difficili</span> {testMode === 'difficult-only' && <Check className="w-4 h-4 ml-auto inline-block text-orange-600" />} </div> </div> <p className="text-xs mt-2 opacity-80 ml-11">Focus sulle parole che necessitano più pratica</p> </button> </div> </div> } {testMode === 'normal' && ( <button onClick={() => setIncludeLearnedWords(!includeLearnedWords)} className={`group w-full p-4 rounded-xl border-2 transition-all duration-300 text-left transform hover:scale-[1.02] ${ includeLearnedWords ? 'border-green-400 bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/40 dark:to-emerald-900/40 text-green-700 dark:text-green-300 shadow-lg shadow-green-200/50 dark:shadow-green-900/30' : 'border-gray-200 dark:border-gray-600 hover:border-green-300 dark:hover:border-green-400 text-gray-700 dark:text-gray-300 bg-white/50 dark:bg-gray-800/50 hover:shadow-md' }`} > <div className="flex items-center gap-3"> <div className={`p-2 rounded-lg transition-all duration-300 ${ includeLearnedWords ? 'bg-gradient-to-r from-green-500 to-emerald-500 shadow-lg' : 'bg-gray-200 dark:bg-gray-600 group-hover:bg-green-100 dark:group-hover:bg-green-800' }`}> {includeLearnedWords ? <CheckSquare className="w-4 h-4 text-white" /> : <Square className="w-4 h-4 text-gray-600 dark:text-gray-400" /> } </div> <span className="font-semibold">Includi parole apprese</span> </div> <p className="text-xs mt-2 opacity-80 ml-11">Ripassa anche le parole che già conosci</p> </button> )} } <div className="timer-config-container"> <button onClick={() => setEnableTimer(!enableTimer)} className="w-full flex items-center gap-2 text-left group" > <div className={`p-1.5 rounded-lg transition-all duration-300 ${ enableTimer ? 'bg-gradient-to-r from-blue-500 to-cyan-500 shadow-lg' : 'bg-blue-200 dark:bg-blue-800 group-hover:bg-blue-300 dark:group-hover:bg-blue-700' }`}> {enableTimer ? <CheckSquare className="w-3 h-3 text-white" /> : <Square className="w-3 h-3 text-blue-600 dark:text-blue-400" /> } </div> <Clock className="w-3 h-3 text-blue-600 dark:text-blue-400" /> <span className="font-medium text-sm text-blue-800 dark:text-blue-200"> Timer: {maxTimePerWord}s </span> </button> {enableTimer && ( <div className="mt-2 animate-slide-down"> <input type="range" min="10" max="120" step="10" value={maxTimePerWord} onChange={(e) => setMaxTimePerWord(parseInt(e.target.value))} className="timer-slider" /> <div className="flex justify-between text-xs text-blue-600 dark:text-blue-400 mt-1"> <span>10s</span> <span>60s</span> <span>120s</span> </div> </div> )} </div> } <div className="pt-2 border-t border-green-200/30"> <button onClick={() => setEnableTotalHintsLimit(!enableTotalHintsLimit)} className="w-full flex items-center gap-2 text-left group mb-2" > <div className={`p-1 rounded transition-all duration-300 ${ enableTotalHintsLimit ? 'bg-green-500 text-white' : 'bg-green-200 dark:bg-green-800 text-green-600 dark:text-green-400' }`}> {enableTotalHintsLimit ? <CheckSquare className="w-2.5 h-2.5" /> : <Square className="w-2.5 h-2.5" /> } </div> <span className="text-xs font-medium text-green-700 dark:text-green-300"> Limite totale: {maxTotalHints} </span> </button> {enableTotalHintsLimit && ( <input type="range" min="5" max="20" step="1" value={maxTotalHints} onChange={(e) => setMaxTotalHints(parseInt(e.target.value))} className="w-full h-1 bg-gradient-to-r from-green-200 to-emerald-200 dark:from-green-700 dark:to-emerald-700 rounded-lg appearance-none cursor-pointer" /> )} </div> </div> )} </div> </div> </div> </div> </div> )} </div> </div> </div> </div> } <div className="flex-1 grid grid-cols-4 gap-3 content-start overflow-y-auto min-h-0"> {availableChapters.map(chapter => { const stats = getChapterStats(chapter); const isSelected = selectedChapters.has(chapter); return ( <button key={chapter} onClick={() => toggleChapterSelection(chapter)} className={`group relative p-4 rounded-xl border-2 transition-all duration-300 text-left transform hover:scale-[1.02] hover:-translate-y-1 ${ isSelected ? 'border-blue-400 bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-blue-900/50 dark:to-indigo-900/50 text-blue-700 dark:text-blue-300 shadow-lg shadow-blue-200/30 dark:shadow-blue-900/20' : 'border-gray-200 dark:border-gray-600 hover:border-blue-300 dark:hover:border-blue-400 text-gray-700 dark:text-gray-300 bg-white/60 dark:bg-gray-800/60 hover:bg-white/80 dark:hover:bg-gray-700/80 hover:shadow-md' }`} > } {wordsWithoutChapter.length > 0 && ( <button onClick={() => toggleChapterSelection('no-chapter')} className={`group relative p-4 rounded-xl border-2 transition-all duration-300 text-left transform hover:scale-[1.02] hover:-translate-y-1 ${ selectedChapters.has('no-chapter') ? 'border-purple-400 bg-gradient-to-br from-purple-50 to-pink-100 dark:from-purple-900/50 dark:to-pink-900/50 text-purple-700 dark:text-purple-300 shadow-lg shadow-purple-200/30 dark:shadow-purple-900/20' : 'border-gray-200 dark:border-gray-600 hover:border-purple-300 dark:hover:border-purple-400 text-gray-700 dark:text-gray-300 bg-white/60 dark:bg-gray-800/60 hover:bg-white/80 dark:hover:bg-gray-700/80 hover:shadow-md' }`} > {selectedChapters.has('no-chapter') && ( <div className="chapter-badge-purple"> <Check className="w-3 h-3 text-white" /> </div> )} <div className="flex items-center gap-2 mb-2"> <div className={`p-1.5 rounded-lg transition-all duration-300 ${ selectedChapters.has('no-chapter') ? 'bg-gradient-to-r from-purple-500 to-pink-500 shadow-md' : 'bg-gray-200 dark:bg-gray-600 group-hover:bg-purple-100 dark:group-hover:bg-purple-800' }`}> {selectedChapters.has('no-chapter') ? <CheckSquare className="w-3 h-3 text-white" /> : <Square className="w-3 h-3 text-gray-600 dark:text-gray-400" /> } </div> <span className="font-bold text-sm">Senza Cap.</span> </div> <div className="space-y-1"> <div className="text-xs font-medium"> {wordsWithoutChapterStats.availableForTest} disponibili </div> <div className="flex items-center gap-2 text-xs opacity-75"> <span className="bg-gray-100 dark:bg-gray-700 px-2 py-0.5 rounded-full"> {wordsWithoutChapterStats.totalWords} tot </span> {wordsWithoutChapterStats.difficultWords > 0 && ( <span className="difficult-badge"> <Star className="w-2 h-2" /> {wordsWithoutChapterStats.difficultWords} </span> )} </div> </div> </button> )} </div> </div> </div> </div> } <div className="flex items-center gap-8 text-sm"> <div className="flex items-center gap-3"> <div className="relative"> <div className="stats-avatar"> <span className="text-white font-bold text-lg">{totalSelectedWords}</span> </div> <div className="absolute -top-1 -right-1 w-4 h-4 bg-yellow-400 rounded-full flex items-center justify-center"> <Sparkles className="w-2 h-2 text-yellow-800" /> </div> </div> <div> <span className="font-bold text-gray-900 dark:text-gray-100">Parole</span> <div className="text-xs text-gray-500 dark:text-gray-400">selezionate</div> </div> </div> <div className="flex items-center gap-3"> <div className="stats-icon-small"> <span className="text-white font-bold">{selectedChapters.size}</span> </div> <div> <span className="font-bold text-gray-900 dark:text-gray-100">Capitoli</span> <div className="text-xs text-gray-500 dark:text-gray-400">attivi</div> </div> </div> <div className="text-xs text-gray-500 dark:text-gray-400 space-y-1"> <div className="flex items-center gap-2"> {testMode === 'difficult-only' ? ( <span className="mode-badge-difficult">⚡ Solo difficili</span> ) : ( <span className="mode-badge-normal">📚 Normale</span> )} </div> <div className="flex items-center gap-2"> {enableTimer && <span className="bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-1 rounded-full">⏱️ {maxTimePerWord}s</span>} {hintsMode !== 'disabled' && ( <span className="bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 px-2 py-1 rounded-full"> 💡 {hintsMode === 'unlimited' ? 'Illimitati' : enableTotalHintsLimit ? `Max ${maxTotalHints} totali` : `Max ${maxHintsPerWord}/parola`} </span> )} </div> </div> </div>

================================================================================

NOME FILE: WordsList.tsx

import React, { useState, useMemo } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Plus, Trash2, Edit3, ChevronDown, ChevronUp, BookOpen, CheckCircle, Circle, Filter, AlertTriangle, Eye, EyeOff } from 'lucide-react'; import { Word } from '../types/entities/Word.types'; interface WordListProps { words: Word[]; onEditWord: (word: Word) => void; onRemoveWord: (wordId: string) => void; onToggleLearned: (wordId: string) => void; onToggleDifficult: (wordId: string) => void; showWordsList: boolean; setShowWordsList: (show: boolean) => void; } interface WordCardProps { word: Word; onEdit: () => void; onRemove: () => void; onToggleLearned: () => void; onToggleDifficult: () => void; } interface CategoryStyle { icon: string; bgColor: string; } interface WordStats { total: number; learned: number; notLearned: number; difficult: number; withChapter: number; filtered: number; } type FilterLearned = 'all' | 'learned' | 'not_learned'; type FilterDifficult = 'all' | 'difficult' | 'not_difficult'; const getCategoryStyle = (group?: string): CategoryStyle => { const categoryMap: Record<string, CategoryStyle> = { 'VERBI': { icon: '⚡', bgColor: 'bg-red-500' }, 'VERBI_IRREGOLARI': { icon: '🔄', bgColor: 'bg-red-600' }, 'SOSTANTIVI': { icon: '🏷️', bgColor: 'bg-blue-500' }, 'AGGETTIVI': { icon: '🎨', bgColor: 'bg-green-500' }, 'FAMIGLIA': { icon: '👨‍👩‍👧‍👦', bgColor: 'bg-pink-400' }, 'TECNOLOGIA': { icon: '💻', bgColor: 'bg-cyan-500' }, 'LAVORO': { icon: '💼', bgColor: 'bg-indigo-500' }, 'DEFAULT': { icon: '📚', bgColor: 'bg-gray-500' } }; return categoryMap[group?.toUpperCase() || 'DEFAULT'] || categoryMap['DEFAULT']; }; const formatNotes = (notes?: string): React.ReactNode => { if (!notes) return null; const keywords = ['Altri Significati', 'Sinonimi', 'Verbo Irregolare', 'Pronuncia', 'Esempi']; let formattedText = notes; keywords.forEach(keyword => { const regex = new RegExp(`(${keyword})\\s*:`, 'gi'); formattedText = formattedText.replace(regex, `**$1:**`); }); return formattedText.split(/(\*\*[^*]+\*\*)/).map((part, index) => { if (part.startsWith('**') && part.endsWith('**')) { return <span key={index} className="font-bold">{part.slice(2, -2)}</span>; } return part; }); }; const WordCard: React.FC<WordCardProps> = ({ word, onEdit, onRemove, onToggleLearned, onToggleDifficult }) => { const [isExpanded, setIsExpanded] = useState(false); const sentencesCount = word.sentences?.length || 0; const synonymsCount = word.synonyms?.length || 0; const antonymsCount = word.antonyms?.length || 0; const hasExtraContent = sentencesCount > 0 || synonymsCount > 0 || antonymsCount > 0 || word.notes; return ( <div className={`rounded-2xl border-2 hover:shadow-lg transition-all duration-300 ${ word.learned ? 'bg-gradient-to-r from-green-50 to-emerald-50 dark:bg-gradient-to-r dark:from-green-900/20 dark:to-emerald-900/20 border-green-200 dark:border-green-700' : word.difficult ? 'bg-gradient-to-r from-red-50 to-orange-50 dark:bg-gradient-to-r dark:from-red-900/20 dark:to-orange-900/20 border-red-200 dark:border-red-700' : 'bg-gradient-to-r from-white to-gray-50 dark:bg-gradient-to-r dark:from-gray-800 dark:to-gray-900 border-gray-100 dark:border-gray-700 hover:border-gray-200 dark:hover:border-gray-600' }`}> <div className="p-4"> } <div className="flex items-center gap-3 flex-1"> <span className={`words-list-title ${ word.learned ? 'opacity-75' : '' }`}> {word.english} </span> <span className="text-gray-600 dark:text-gray-400">→</span> <span className={`text-lg font-medium ${word.learned ? 'text-gray-600 dark:text-gray-400' : 'text-gray-900 dark:text-gray-100'}`}> {word.italian} </span> } <div className="flex items-center gap-1"> } {hasExtraContent && ( <Button onClick={() => setIsExpanded(!isExpanded)} variant="ghost" size="sm" className="p-2 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:text-gray-100" title={isExpanded ? "Chiudi dettagli" : "Mostra dettagli"} > {isExpanded ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />} </Button> )} <Button onClick={onEdit} variant="ghost" size="sm" className="p-2 text-blue-500 hover:text-blue-700" title="Modifica"> <Edit3 className="w-4 h-4" /> </Button> <Button onClick={onRemove} variant="ghost" size="sm" className="p-2 text-red-500 hover:text-red-700" title="Elimina"> <Trash2 className="w-4 h-4" /> </Button> </div> </div> } {isExpanded && hasExtraContent && ( <div className="border-t border-gray-200 mt-4"> <div className="p-4 space-y-4"> } {word.synonyms && word.synonyms.length > 0 && ( <div className="p-3 bg-blue-50 dark:bg-blue-900/20 rounded-xl border border-blue-200 dark:border-blue-700"> <div className="text-blue-600 dark:text-blue-400 font-semibold text-sm mb-2 flex items-center gap-2"> <span>🔄</span> Sinonimi ({word.synonyms.length}): </div> <div className="flex flex-wrap gap-2"> {word.synonyms.map((synonym, index) => ( <span key={index} className="inline-flex items-center px-2 py-1 rounded-lg text-xs font-medium bg-blue-100 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300 border border-blue-200 dark:border-blue-700"> {synonym} </span> ))} </div> </div> )} } {word.notes && ( <div className="p-3 bg-blue-50 dark:bg-blue-900/20 rounded-xl border border-blue-200 dark:border-blue-700"> <div className="text-blue-600 dark:text-blue-400 font-semibold text-sm mb-1 flex items-center gap-2"> <span>📝</span> Note: </div> <div className="text-blue-800 dark:text-blue-300 text-sm whitespace-pre-line"> {formatNotes(word.notes)} </div> </div> )} </div> </div> )} </div> ); }; const WordsList: React.FC<WordListProps> = ({ words, onEditWord, onRemoveWord, onToggleLearned, onToggleDifficult, showWordsList, setShowWordsList }) => { const [filterChapter, setFilterChapter] = useState<string>(''); const [filterLearned, setFilterLearned] = useState<FilterLearned>('all'); const [filterDifficult, setFilterDifficult] = useState<FilterDifficult>('all'); const [filterGroup, setFilterGroup] = useState<string>(''); const [collapsedChapters, setCollapsedChapters] = useState<Set<string>>(new Set()); const availableChapters = useMemo(() => { const chapters = new Set<string>(); words.forEach(word => { if (word.chapter) chapters.add(word.chapter); }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b); }); }, [words]); const availableGroups = useMemo(() => { const groups = new Set<string>(); words.forEach(word => { if (word.group) groups.add(word.group); }); return Array.from(groups).sort(); }, [words]); const toggleChapterCollapse = (chapter: string) => { const newCollapsed = new Set(collapsedChapters); if (newCollapsed.has(chapter)) { newCollapsed.delete(chapter); } else { newCollapsed.add(chapter); } setCollapsedChapters(newCollapsed); }; const wordsWithoutChapter = useMemo(() => { return words.filter(word => !word.chapter); }, [words]); const filteredWords = useMemo(() => { return words.filter(word => { if (filterChapter !== '') { if (filterChapter === 'no-chapter') { if (word.chapter) return false; } else { if (word.chapter !== filterChapter) return false; } } if (filterGroup && word.group !== filterGroup) return false; if (filterLearned === 'learned' && !word.learned) return false; if (filterLearned === 'not_learned' && word.learned) return false; if (filterDifficult === 'difficult' && !word.difficult) return false; if (filterDifficult === 'not_difficult' && word.difficult) return false; return true; }); }, [words, filterChapter, filterGroup, filterLearned, filterDifficult]); const groupedWords = useMemo(() => { return filteredWords.reduce((groups, word) => { const chapter = word.chapter || 'Senza Capitolo'; if (!groups[chapter]) groups[chapter] = []; groups[chapter].push(word); return groups; }, {} as Record<string, Word[]>); }, [filteredWords]); const stats: WordStats = useMemo(() => ({ total: words.length, learned: words.filter(w => w.learned).length, notLearned: words.filter(w => !w.learned).length, difficult: words.filter(w => w.difficult).length, withChapter: words.filter(w => w.chapter).length, filtered: filteredWords.length }), [words, filteredWords]); const clearFilters = () => { setFilterChapter(''); setFilterLearned('all'); setFilterDifficult('all'); setFilterGroup(''); }; return ( <Card className="backdrop-blur-sm bg-white/90 dark:bg-gray-800/90 border-0 dark:border-0 shadow-xl rounded-3xl overflow-hidden mb-12"> <CardHeader className="cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors" onClick={() => setShowWordsList(!showWordsList)} > <CardTitle className="flex items-center justify-between"> <div className="flex items-center gap-3"> <span className="text-2xl">📚</span> <div className="flex flex-col"> <span className="words-list-header-title"> Il Tuo Vocabolario ({stats.total} parole) </span> <div className="flex gap-4 text-sm text-gray-600 dark:text-gray-400 mt-1"> <span>✅ {stats.learned} apprese</span> <span>📖 {stats.notLearned} da studiare</span> <span>⭐ {stats.difficult} difficili</span> <span>📚 {stats.withChapter} con capitolo</span> </div> </div> </div> {showWordsList ? <ChevronUp className="w-5 h-5 text-gray-400 dark:text-gray-600 dark:text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400 dark:text-gray-600 dark:text-gray-400" />} </CardTitle> </CardHeader> {showWordsList && ( <CardContent className="animate-fade-in"> {words.length === 0 ? ( <div className="text-center py-16"> <div className="text-8xl mb-6">📚</div> <h3 className="words-list-empty-title mb-4">Il tuo vocabolario è vuoto</h3> <p className="text-gray-600 dark:text-gray-600 dark:text-gray-400 text-lg mb-8">Aggiungi la tua prima parola per iniziare a studiare!</p> <div className="flex justify-center"> <Button className="words-list-add-button"> <Plus className="w-5 h-5 mr-2" /> Aggiungi Prima Parola </Button> </div> </div> ) : ( <div className="space-y-6"> } <div> <label className="text-sm font-medium text-gray-700 dark:text-gray-900 dark:text-gray-100 mb-2 block">Difficoltà</label> <select value={filterDifficult} onChange={(e) => setFilterDifficult(e.target.value as FilterDifficult)} className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:border-blue-500 dark:focus:border-blue-400 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100" > <option value="all">Tutte le parole</option> <option value="difficult">⭐ Solo difficili</option> <option value="not_difficult">📚 Solo normali</option> </select> </div> <div> <label className="text-sm font-medium text-gray-700 dark:text-gray-900 dark:text-gray-100 mb-2 block">Categoria</label> <select value={filterGroup} onChange={(e) => setFilterGroup(e.target.value)} className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:border-blue-500 dark:focus:border-blue-400 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100" > <option value="">Tutte le categorie</option> {availableGroups.map(group => ( <option key={group} value={group}> {getCategoryStyle(group).icon} {group} </option> ))} </select> </div> <div className="flex items-end"> <Button onClick={clearFilters} variant="outline" className="w-full" > Cancella Filtri </Button> </div> </div> </CardContent> </Card> } <div className="space-y-6 max-h-96 overflow-y-auto custom-scrollbar"> {Object.entries(groupedWords) .sort(([a], [b]) => { if (a === 'Senza Capitolo') return 1; if (b === 'Senza Capitolo') return -1; const aNum = parseInt(a); const bNum = parseInt(b); return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b); }) .map(([chapter, chapterWords]) => { const isCollapsed = collapsedChapters.has(chapter); return ( <div key={chapter} className="space-y-3"> } <span className="text-sm text-red-600 dark:text-red-300 bg-red-200 dark:bg-red-900/20 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.difficult).length} difficili </span> </div> </div>

================================================================================

NOME FILE: admin\AdminPanel.tsx

import React, { useState, useEffect } from "react"; import { Card, CardContent, CardHeader, CardTitle } from "../ui/card"; import { Button } from "../ui/button"; import { Input } from "../ui/input"; import { Badge } from "../ui/badge"; import { Users, Shield, Download, Upload, RotateCcw, Trash2, Search, Filter, MoreVertical, CheckCircle, XCircle, Mail, Calendar, } from "lucide-react"; import { useAuth, useUserRole } from "../../hooks/integration/useAuth"; import { User as UserProfile, UserManagementFilters, UserExportData, UserRole, } from "../../types/entities/User.types"; import { getAllUsers, toggleUserStatus, resetUserPassword, deleteUserData as deleteUser, } from "../../services/authService"; import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator, DropdownMenuTrigger, } from "../ui/dropdown-menu"; export const AdminPanel: React.FC = () => { const { userProfile, isAdmin, role } = useUserRole(); const [users, setUsers] = useState<UserProfile[]>([]); const [loading, setLoading] = useState(true); const [searchTerm, setSearchTerm] = useState(""); const [operationLoading, setOperationLoading] = useState<string | null>(null); const exportData = async (user: UserProfile) => { try { setOperationLoading(`export-${user.id}`); const exportData: UserExportData = { profile: user, words: [], testHistory: [], statistics: [], exportedAt: new Date(), exportedBy: userProfile?.id || "unknown", }; const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json", }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `user-data-${user.email}-${ new Date().toISOString().split("T")[0] }.json`; a.click(); URL.revokeObjectURL(url); console.log("User data exported successfully"); } catch (error) { console.error("Error exporting user data:", error); } finally { setOperationLoading(null); } }; const importData = async (file: File) => { try { setOperationLoading("import"); const text = await file.text(); const data = JSON.parse(text); console.log("Importing data:", data); } catch (error) { console.error("Error importing data:", error); } finally { setOperationLoading(null); } }; const handleToggleUserStatus = async (user: UserProfile) => { try { setOperationLoading(`toggle-${user.id}`); await toggleUserStatus( user.id, !user.isActive, userProfile?.id || "unknown" ); await loadUsers(); } catch (error) { console.error("Error toggling user status:", error); } finally { setOperationLoading(null); } }; const handleResetPassword = async (user: UserProfile) => { try { setOperationLoading(`reset-${user.id}`); await resetUserPassword(user.email, userProfile?.id || "unknown"); console.log(`Password reset email sent to ${user.email}`); } catch (error) { console.error("Error resetting password:", error); } finally { setOperationLoading(null); } }; const handleExportUserData = async (user: UserProfile) => { await exportData(user); }; const handleImportUserData = async (file: File) => { await importData(file); }; const handleDeleteUser = async (user: UserProfile) => { if ( !window.confirm(`Are you sure you want to delete user ${user.email}?`) ) { return; } try { setOperationLoading(`delete-${user.id}`); await deleteUser(user.id, userProfile?.id || "unknown"); await loadUsers(); } catch (error) { console.error("Error deleting user:", error); } finally { setOperationLoading(null); } }; const loadUsers = async () => { try { setLoading(true); const usersList = await getAllUsers(); setUsers(usersList); } catch (error) { console.error("Error loading users:", error); } finally { setLoading(false); } }; useEffect(() => { if (isAdmin) { loadUsers(); } }, [isAdmin]); const filteredUsers = users.filter((user) => { const searchLower = searchTerm.toLowerCase(); return ( user.email.toLowerCase().includes(searchLower) || user.displayName?.toLowerCase().includes(searchLower) || user.id.toLowerCase().includes(searchLower) ); }); if (!isAdmin) { return ( <Card className="w-96 mx-auto mt-8"> <CardHeader> <CardTitle className="flex items-center gap-2 text-red-600"> <Shield className="w-6 h-6" /> Accesso Negato </CardTitle> </CardHeader> <CardContent> <p className="text-gray-600"> Non hai i permessi necessari per accedere al pannello di amministrazione. </p> <p className="text-sm text-gray-500 mt-2"> Contatta l'amministratore per maggiori informazioni. </p> </CardContent> </Card> ); } return ( <div className="space-y-6"> } </Badge> <Badge variant="outline">Users: {users.length}</Badge> <Badge variant="outline"> Active: {users.filter((u) => u.isActive).length} </Badge> </div> </CardContent> </Card> } <Card> <CardHeader> <CardTitle>Lista Utenti</CardTitle> </CardHeader> <CardContent> {loading ? ( <div className="text-center py-8"> <p>Caricamento utenti...</p> </div> ) : filteredUsers.length === 0 ? ( <div className="text-center py-8"> <p className="text-gray-500">Nessun utente trovato</p> </div> ) : ( <div className="space-y-4"> {filteredUsers.map((user) => ( <div key={user.id} className="flex items-center justify-between p-4 border rounded-lg" > <div className="flex items-center gap-4"> <div className="w-10 h-10 bg-gray-100 rounded-full flex items-center justify-center"> <span className="text-sm font-medium"> {user.displayName?.charAt(0) || user.email.charAt(0)} </span> </div> <div> <h4 className="font-medium"> {user.displayName || "N/A"} </h4> <p className="text-sm text-gray-500">{user.email}</p> <div className="flex items-center gap-2 mt-1"> <Badge variant={ user.role === "admin" ? "default" : "secondary" } > {user.role} </Badge> <Badge variant={user.isActive ? "default" : "destructive"} > {user.isActive ? "Attivo" : "Disabilitato"} </Badge> {user.emailVerified && ( <Badge variant="outline"> <CheckCircle className="w-3 h-3 mr-1" /> Verificato </Badge> )} </div> </div> </div> <div className="flex items-center gap-2"> <DropdownMenu> <DropdownMenuTrigger asChild> <Button variant="ghost" size="sm"> <MoreVertical className="w-4 h-4" /> </Button> </DropdownMenuTrigger> <DropdownMenuContent> <DropdownMenuItem onClick={() => handleToggleUserStatus(user)} disabled={operationLoading === `toggle-${user.id}`} > {user.isActive ? "Disabilita" : "Attiva"} </DropdownMenuItem> <DropdownMenuItem onClick={() => handleResetPassword(user)} disabled={operationLoading === `reset-${user.id}`} > Reset Password </DropdownMenuItem> <DropdownMenuSeparator /> <DropdownMenuItem onClick={() => handleExportUserData(user)} disabled={operationLoading === `export-${user.id}`} > Esporta Dati </DropdownMenuItem> <DropdownMenuSeparator /> <DropdownMenuItem onClick={() => handleDeleteUser(user)} disabled={operationLoading === `delete-${user.id}`} className="text-red-600" > Elimina Utente </DropdownMenuItem> </DropdownMenuContent> </DropdownMenu> </div> </div> ))} </div> )} </CardContent> </Card> </div> ); };

================================================================================

NOME FILE: auth\AuthActionHandler.tsx

import React, { useEffect, useState } from "react"; import { Button } from "../ui/button"; import { Input } from "../ui/input"; import { Label } from "../ui/label"; import { Alert, AlertDescription } from "../ui/alert"; import { CheckCircle, AlertCircle, Loader2, Lock, Eye, EyeOff, ArrowLeft, } from "lucide-react"; import { useAuth } from "../../hooks/integration/useAuth"; interface AuthActionHandlerProps { mode: string; oobCode: string; apiKey: string; onComplete?: () => void; } export const AuthActionHandler: React.FC<AuthActionHandlerProps> = ({ mode, oobCode, apiKey, onComplete, }) => { const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); const [success, setSuccess] = useState(false); const [newPassword, setNewPassword] = useState(""); const [confirmPassword, setConfirmPassword] = useState(""); const [showPassword, setShowPassword] = useState(false); const [showConfirmPassword, setShowConfirmPassword] = useState(false); const [email, setEmail] = useState<string>(""); const { confirmPasswordReset, verifyPasswordResetCode, verifyEmail } = useAuth(); useEffect(() => { handleAction(); }, [mode, oobCode]); const handleAction = async () => { setLoading(true); setError(null); try { switch (mode) { case "resetPassword": if (!verifyPasswordResetCode) { throw new Error("Funzione di verifica non disponibile"); } const userEmail = await verifyPasswordResetCode(oobCode); setEmail(userEmail); setLoading(false); break; case "verifyEmail": if (!verifyEmail) { throw new Error("Funzione di verifica email non disponibile"); } await verifyEmail(oobCode); setSuccess(true); setLoading(false); break; default: throw new Error("Modalità non supportata"); } } catch (err: any) { setError(err.message || "Errore durante l'elaborazione dell'azione"); setLoading(false); } }; const handlePasswordReset = async (e: React.FormEvent) => { e.preventDefault(); if (newPassword !== confirmPassword) { setError("Le password non corrispondono"); return; } if (newPassword.length < 6) { setError("La password deve contenere almeno 6 caratteri"); return; } setLoading(true); setError(null); try { if (!confirmPasswordReset) { throw new Error("Funzione di reset password non disponibile"); } await confirmPasswordReset(oobCode, newPassword); setSuccess(true); } catch (err: any) { setError(err.message || "Errore durante il reset della password"); } finally { setLoading(false); } }; if (loading) { return ( <div className="auth-page-background"> <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full mx-4"> <div className="text-center"> <Loader2 className="w-8 h-8 animate-spin mx-auto mb-4 text-blue-600" /> <p className="text-gray-600">Verifica in corso...</p> </div> </div> </div> ); } if (success) { return ( <div className="auth-page-background"> <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full mx-4"> <div className="text-center"> <CheckCircle className="w-12 h-12 text-green-600 mx-auto mb-4" /> <h2 className="text-2xl font-bold text-gray-800 mb-2"> {mode === "resetPassword" ? "Password aggiornata!" : "Email verificata!"} </h2> <p className="text-gray-600 mb-6"> {mode === "resetPassword" ? "La tua password è stata aggiornata con successo." : "Il tuo indirizzo email è stato verificato con successo."} </p> <Button onClick={onComplete} className="auth-button-action" > Continua </Button> </div> </div> </div> ); } if (error) { return ( <div className="auth-page-background"> <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full mx-4"> <div className="text-center"> <AlertCircle className="w-12 h-12 text-red-600 mx-auto mb-4" /> <h2 className="text-2xl font-bold text-gray-800 mb-2"> Errore </h2> <Alert className="border-red-200 bg-red-50 mb-6"> <AlertDescription className="text-red-800"> {error} </AlertDescription> </Alert> <Button onClick={onComplete} variant="outline" className="w-full" > <ArrowLeft className="w-4 h-4 mr-2" /> Torna all'app </Button> </div> </div> </div> ); } if (mode === "resetPassword") { return ( <div className="auth-page-background"> <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full mx-4"> <div className="text-center mb-6"> <Lock className="w-12 h-12 text-blue-600 mx-auto mb-4" /> <h2 className="text-2xl font-bold text-gray-800 mb-2"> Nuova Password </h2> <p className="text-gray-600"> Inserisci la nuova password per {email} </p> </div> <form onSubmit={handlePasswordReset} className="space-y-4"> <div> <Label htmlFor="newPassword" className="text-sm font-medium text-gray-700"> Nuova Password </Label> <div className="relative"> <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" /> <Input id="newPassword" type={showPassword ? "text" : "password"} placeholder="Inserisci la nuova password" value={newPassword} onChange={(e) => setNewPassword(e.target.value)} className="pl-10 pr-10" required /> <button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600" > {showPassword ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />} </button> </div> </div> <div> <Label htmlFor="confirmPassword" className="text-sm font-medium text-gray-700"> Conferma Password </Label> <div className="relative"> <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" /> <Input id="confirmPassword" type={showConfirmPassword ? "text" : "password"} placeholder="Conferma la nuova password" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} className="pl-10 pr-10" required /> <button type="button" onClick={() => setShowConfirmPassword(!showConfirmPassword)} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600" > {showConfirmPassword ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />} </button> </div> </div> <Button type="submit" className="auth-button-action" disabled={loading} > {loading ? ( <> <Loader2 className="w-4 h-4 mr-2 animate-spin" /> Aggiornamento... </> ) : ( "Aggiorna Password" )} </Button> </form> </div> </div> ); } return null; };

================================================================================

NOME FILE: auth\AuthenticatorWrapper.tsx

import React, { useState, useEffect } from "react"; import { Button } from "../ui/button"; import { Input } from "../ui/input"; import { Label } from "../ui/label"; import { Alert, AlertDescription } from "../ui/alert"; import { Shield, Smartphone, QrCode, Key, Copy, CheckCircle, AlertCircle, Loader2, ArrowLeft, } from "lucide-react"; import { useAuth } from "../../hooks/integration/useAuth"; interface AuthenticatorWrapperProps { onComplete?: () => void; onCancel?: () => void; } type AuthenticatorStep = | "setup-start" | "show-qr" | "verify-code" | "setup-complete" | "verify-login"; export const AuthenticatorWrapper: React.FC<AuthenticatorWrapperProps> = ({ onComplete, onCancel, }) => { const [currentStep, setCurrentStep] = useState<AuthenticatorStep>("setup-start"); const [qrCodeUrl, setQrCodeUrl] = useState<string>(""); const [secretKey, setSecretKey] = useState<string>(""); const [verificationCode, setVerificationCode] = useState<string>(""); const [loading, setLoading] = useState(false); const [error, setError] = useState<string | null>(null); const [isSetupMode, setIsSetupMode] = useState(true); const { user } = useAuth(); const generateQRCode = async () => { setLoading(true); try { const secret = generateSecretKey(); const appName = "Learn English VOC"; const userEmail = user?.email || "user@example.com"; const otpUrl = `otpauth: setSecretKey(secret); setQrCodeUrl(otpUrl); setCurrentStep("show-qr"); } catch (err) { setError("Errore nella generazione del codice QR"); } finally { setLoading(false); } }; const generateSecretKey = (): string => { const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"; let result = ""; for (let i = 0; i < 32; i++) { result += chars.charAt(Math.floor(Math.random() * chars.length)); } return result; }; const copySecretKey = () => { navigator.clipboard.writeText(secretKey); }; const verifyAuthenticatorCode = async () => { if (verificationCode.length !== 6) { setError("Il codice deve essere di 6 cifre"); return; } setLoading(true); setError(null); try { const isValid = await verifyTOTPCode(verificationCode, secretKey); if (isValid) { if (isSetupMode) { setCurrentStep("setup-complete"); } else { onComplete?.(); } } else { setError("Codice non valido. Riprova."); } } catch (err) { setError("Errore nella verifica del codice"); } finally { setLoading(false); } }; const verifyTOTPCode = async (code: string, secret: string): Promise<boolean> => { return code === "123456"; }; const renderSetupStart = () => ( <div className="text-center space-y-6"> <div className="mx-auto w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center"> <Shield className="w-8 h-8 text-blue-600" /> </div> <div> <h2 className="text-2xl font-bold text-gray-800 mb-2"> Configura Autenticazione a Due Fattori </h2> <p className="text-gray-600"> Aumenta la sicurezza del tuo account con Google Authenticator </p> </div> <div className="bg-blue-50 p-4 rounded-lg"> <div className="flex items-start space-x-3"> <Smartphone className="w-5 h-5 text-blue-600 mt-0.5" /> <div className="text-left"> <p className="font-medium text-blue-900">Prima di iniziare:</p> <p className="text-sm text-blue-800"> Assicurati di aver installato Google Authenticator sul tuo telefono </p> </div> </div> </div> <div className="space-y-3"> <Button onClick={generateQRCode} className="w-full bg-blue-600 hover:bg-blue-700" disabled={loading} > {loading ? ( <> <Loader2 className="w-4 h-4 mr-2 animate-spin" /> Generazione... </> ) : ( <> <QrCode className="w-4 h-4 mr-2" /> Inizia Configurazione </> )} </Button> <Button onClick={onCancel} variant="outline" className="w-full" > <ArrowLeft className="w-4 h-4 mr-2" /> Annulla </Button> </div> </div> ); const renderQRCode = () => ( <div className="text-center space-y-6"> <div className="mx-auto w-16 h-16 bg-green-100 rounded-full flex items-center justify-center"> <QrCode className="w-8 h-8 text-green-600" /> </div> <div> <h2 className="text-2xl font-bold text-gray-800 mb-2"> Scansiona il Codice QR </h2> <p className="text-gray-600"> Apri Google Authenticator e scansiona questo codice </p> </div>

================================================================================

NOME FILE: auth\ForgotPasswordForm.tsx

import React, { useState } from "react"; import { Button } from "../ui/button"; import { Input } from "../ui/input"; import { Label } from "../ui/label"; import { Mail, Send, Loader2, AlertCircle, CheckCircle, ArrowLeft, } from "lucide-react"; import { useAuth } from "../../hooks/integration/useAuth"; import { Alert, AlertDescription } from "../ui/alert"; interface ForgotPasswordFormProps { onSwitchToLogin: () => void; } export const ForgotPasswordForm: React.FC<ForgotPasswordFormProps> = ({ onSwitchToLogin, }) => { const [email, setEmail] = useState(""); const [emailSent, setEmailSent] = useState(false); const [validationError, setValidationError] = useState(""); const { resetPassword, isResettingPassword, error: authError, clearError, validateEmail, } = useAuth(); const validateForm = (): boolean => { if (!email) { setValidationError("Email è richiesta"); return false; } if (!validateEmail(email)) { setValidationError("Formato email non valido"); return false; } setValidationError(""); return true; }; const handleInputChange = (value: string) => { setEmail(value); if (validationError) { setValidationError(""); } if (authError) { clearError(); } }; const handleSubmit = async (e: React.FormEvent) => { e.preventDefault(); if (!validateForm()) { return; } try { const success = await resetPassword({ email }); if (success) { setEmailSent(true); } } catch (error) { console.error("Password reset error:", error); } }; if (emailSent) { return ( <div className="text-center space-y-6"> <div className="mx-auto w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center"> <CheckCircle className="w-8 h-8 text-blue-600" /> </div> <div> <h3 className="text-xl font-semibold text-gray-800 mb-2"> Email inviata! </h3> <p className="text-gray-600 mb-4"> Abbiamo inviato le istruzioni per reimpostare la password a: </p> <p className="font-semibold text-gray-800 mb-4">{email}</p> <p className="text-sm text-gray-500"> Controlla la tua email e segui le istruzioni per creare una nuova password. </p> </div> <Alert> <Mail className="h-4 w-4" /> <AlertDescription> Non hai ricevuto l'email? Controlla la cartella spam o riprova tra qualche minuto. </AlertDescription> </Alert> <div className="space-y-3"> <Button onClick={() => setEmailSent(false)} variant="outline" className="w-full" > Invia di nuovo </Button> <Button onClick={onSwitchToLogin} variant="ghost" className="w-full"> <ArrowLeft className="mr-2 h-4 w-4" /> Torna al Login </Button> </div> </div> ); } return ( <form onSubmit={handleSubmit} className="space-y-6"> } {authError && ( <Alert className="border-red-200 bg-red-50"> <AlertCircle className="h-4 w-4 text-red-600" /> <AlertDescription className="text-red-800"> {authError.message || "Errore durante l'invio dell'email di reset."} </AlertDescription> </Alert> )} {validationError && ( <Alert className="border-yellow-200 bg-yellow-50"> <AlertCircle className="h-4 w-4 text-yellow-600" /> <AlertDescription className="text-yellow-800"> {validationError} </AlertDescription> </Alert> )} } <Button type="submit" className="auth-button-secondary" disabled={isResettingPassword} > {isResettingPassword ? ( <> <Loader2 className="mr-2 h-4 w-4 animate-spin" /> Invio in corso... </> ) : ( <> <Send className="mr-2 h-4 w-4" /> Invia istruzioni </> )} </Button>

================================================================================

NOME FILE: auth\LoginForm.tsx

import React, { useState, useEffect } from "react"; import { Button } from "../ui/button"; import { Input } from "../ui/input"; import { Label } from "../ui/label"; import { Separator } from "../ui/separator"; import { Alert, AlertDescription } from "../ui/alert"; import { Mail, Lock, Eye, EyeOff, LogIn, Loader2, AlertCircle, } from "lucide-react"; import { useAuth } from "../../hooks/integration/useAuth"; interface LoginFormProps { onSwitchToSignUp?: () => void; onSwitchToForgotPassword?: () => void; onLoginSuccess?: () => void; } interface FormData { email: string; password: string; rememberMe: boolean; } interface ValidationErrors { email?: string; password?: string; } export const LoginForm: React.FC<LoginFormProps> = ({ onSwitchToSignUp = () => {}, onSwitchToForgotPassword = () => {}, onLoginSuccess = () => {}, }) => { const { signIn, signInWithGoogle, isSigningIn, error: authError, clearError, validateEmail: authValidateEmail, isAuthenticated, } = useAuth(); const [formData, setFormData] = useState<FormData>({ email: "", password: "", rememberMe: false, }); const [showPassword, setShowPassword] = useState<boolean>(false); const [validationErrors, setValidationErrors] = useState<ValidationErrors>( {} ); const [localError, setLocalError] = useState<string | null>(null); useEffect(() => { if (isAuthenticated) { onLoginSuccess(); } }, [isAuthenticated, onLoginSuccess]); useEffect(() => { return () => { clearError(); }; }, [clearError]); const error = authError?.message || localError; const validateEmailLocal = (email: string): boolean => { return authValidateEmail(email); }; const validateForm = (): boolean => { const errors: ValidationErrors = {}; if (!formData.email) { errors.email = "Email è richiesta"; } else if (!validateEmailLocal(formData.email)) { errors.email = "Formato email non valido"; } if (!formData.password) { errors.password = "Password è richiesta"; } else if (formData.password.length < 6) { errors.password = "Password deve essere di almeno 6 caratteri"; } setValidationErrors(errors); return Object.keys(errors).length === 0; }; const handleInputChange = ( field: keyof FormData, value: string | boolean ): void => { setFormData((prev) => ({ ...prev, [field]: value })); if (validationErrors[field as keyof ValidationErrors]) { setValidationErrors((prev) => ({ ...prev, [field]: undefined, })); } if (error) { setLocalError(null); clearError(); } }; const handleSubmit = async ( e: React.FormEvent<HTMLFormElement> ): Promise<void> => { e.preventDefault(); if (!validateForm()) { return; } try { const success = await signIn({ email: formData.email, password: formData.password, }); if (success) { } } catch (error) { console.error("Login error:", error); setLocalError("Si è verificato un errore durante il login"); } }; const handleGoogleSignIn = async (): Promise<void> => { try { clearError(); setLocalError(null); const success = await signInWithGoogle(); if (success) { } } catch (error) { console.error("Google sign-in error:", error); setLocalError("Si è verificato un errore con il login Google"); } }; return ( <form onSubmit={handleSubmit} className="space-y-6"> } <div className="space-y-2"> <Label htmlFor="email" className="text-sm font-medium text-gray-700"> Email </Label> <div className="relative"> <Mail className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" /> <Input id="email" type="email" placeholder="mario.rossi@example.com" value={formData.email} onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleInputChange("email", e.target.value) } className={`pl-10 h-12 rounded-xl border-2 transition-all duration-200 ${ validationErrors.email ? "border-red-300 focus:border-red-500" : "border-gray-200 focus:border-blue-500" }`} disabled={isSigningIn} /> </div> {validationErrors.email && ( <p className="text-sm text-red-600">{validationErrors.email}</p> )} </div> } <div className="flex items-center justify-between"> <div className="flex items-center space-x-2"> <input id="remember" type="checkbox" checked={formData.rememberMe} onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleInputChange("rememberMe", e.target.checked) } className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" disabled={isSigningIn} /> <Label htmlFor="remember" className="text-sm text-gray-600"> Ricordami </Label> </div> <button type="button" onClick={onSwitchToForgotPassword} className="text-sm text-blue-600 hover:text-blue-800 p-0 h-auto bg-transparent border-none cursor-pointer" disabled={isSigningIn} > Password dimenticata? </button> </div> } <div className="relative"> <Separator className="my-6" /> <span className="absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white px-4 text-sm text-gray-500"> oppure </span> </div> } <div className="text-center"> <span className="text-sm text-gray-600">Non hai un account? </span> <button type="button" onClick={onSwitchToSignUp} className="text-sm text-blue-600 hover:text-blue-800 p-0 h-auto font-semibold bg-transparent border-none cursor-pointer" disabled={isSigningIn} > Registrati ora </button> </div> </form> ); };

================================================================================

NOME FILE: auth\ProtectedRoute.tsx

import React from "react"; import { useAuth, useUserRole } from "../../hooks/integration/useAuth"; import { AuthView } from "../../views/AuthView"; import { UserRole } from "../../types/entities/User.types"; import { Card, CardContent, CardHeader, CardTitle } from "../ui/card"; import { AlertTriangle, Loader2, Shield } from "lucide-react"; interface ProtectedRouteProps { children: React.ReactNode; requireAuth?: boolean; requiredRole?: UserRole; fallback?: React.ReactNode; redirectTo?: string; } export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children, requireAuth = true, requiredRole, fallback, }) => { const { isAuthenticated, isReady, loading } = useAuth(); const { role, userProfile } = useUserRole(); if (!isReady || loading) { return ( <div className="auth-protected-background"> <Card className="w-96 text-center"> <CardHeader> <CardTitle className="flex items-center justify-center gap-2"> <Loader2 className="w-6 h-6 animate-spin text-blue-600" /> Caricamento... </CardTitle> </CardHeader> <CardContent> <p className="text-gray-600">Verifica autenticazione in corso...</p> </CardContent> </Card> </div> ); } if (!requireAuth) { return <>{children}</>; } if (requireAuth && !isAuthenticated) { if (fallback) { return <>{fallback}</>; } return <AuthView onAuthSuccess={() => window.location.reload()} />; } if (isAuthenticated && userProfile && !userProfile.isActive) { return ( <div className="auth-error-background"> <Card className="w-96 text-center border-red-200"> <CardHeader> <CardTitle className="flex items-center justify-center gap-2 text-red-600"> <AlertTriangle className="w-6 h-6" /> Account Disabilitato </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-gray-600"> Il tuo account è stato temporaneamente disabilitato. </p> <p className="text-sm text-gray-500"> Contatta l'amministratore per maggiori informazioni. </p> </CardContent> </Card> </div> ); } if (isAuthenticated && userProfile && !userProfile.emailVerified) { return ( <div className="auth-warning-background"> <Card className="w-96 text-center border-yellow-200"> <CardHeader> <CardTitle className="flex items-center justify-center gap-2 text-yellow-600"> <AlertTriangle className="w-6 h-6" /> Email Non Verificata </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-gray-600"> Devi verificare la tua email prima di accedere all'applicazione. </p> <p className="text-sm text-gray-500"> Controlla la tua casella email e clicca sul link di verifica. </p> </CardContent> </Card> </div> ); } if (requiredRole && role !== requiredRole) { return ( <div className="auth-error-background"> <Card className="w-96 text-center border-red-200"> <CardHeader> <CardTitle className="flex items-center justify-center gap-2 text-red-600"> <Shield className="w-6 h-6" /> Accesso Negato </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-gray-600"> Non hai i permessi necessari per accedere a questa sezione. </p> <p className="text-sm text-gray-500"> Ruolo richiesto:{" "} <span className="font-semibold">{requiredRole}</span> </p> <p className="text-sm text-gray-500"> Il tuo ruolo:{" "} <span className="font-semibold">{role || "Non definito"}</span> </p> </CardContent> </Card> </div> ); } return <>{children}</>; }; export const AdminRoute: React.FC<{ children: React.ReactNode }> = ({ children, }) => { return <ProtectedRoute requiredRole="admin">{children}</ProtectedRoute>; }; export const UserRoute: React.FC<{ children: React.ReactNode }> = ({ children, }) => { return <ProtectedRoute requireAuth={true}>{children}</ProtectedRoute>; };

================================================================================

NOME FILE: auth\SecuritySettings.tsx

import React, { useState } from "react"; import { Button } from "../ui/button"; import { Card, CardContent, CardHeader, CardTitle } from "../ui/card"; import { Alert, AlertDescription } from "../ui/alert"; import { Shield, Smartphone, Key, Mail, CheckCircle, AlertCircle, Settings, } from "lucide-react"; import { AuthenticatorWrapper } from "./AuthenticatorWrapper"; import { useAuth } from "../../hooks/integration/useAuth"; export const SecuritySettings: React.FC = () => { const [show2FASetup, setShow2FASetup] = useState(false); const [twoFactorEnabled, setTwoFactorEnabled] = useState(false); const { user } = useAuth(); const handleEnable2FA = () => { setShow2FASetup(true); }; const handleDisable2FA = () => { setTwoFactorEnabled(false); }; const handle2FAComplete = () => { setTwoFactorEnabled(true); setShow2FASetup(false); }; const handleCancel2FA = () => { setShow2FASetup(false); }; if (show2FASetup) { return ( <AuthenticatorWrapper onComplete={handle2FAComplete} onCancel={handleCancel2FA} /> ); } return ( <div className="space-y-6"> <div className="flex items-center space-x-3"> <Shield className="w-6 h-6 text-blue-600" /> <h2 className="text-2xl font-bold text-gray-800"> Impostazioni di Sicurezza </h2> </div> } <Card> <CardHeader> <CardTitle className="flex items-center space-x-2"> <Key className="w-5 h-5 text-blue-600" /> <span>Password</span> </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-gray-600"> Mantieni la tua password sicura e aggiornata. </p> <div className="flex space-x-3"> <Button variant="outline"> Cambia Password </Button> <Button variant="outline"> Cronologia Accessi </Button> </div> </CardContent> </Card>

================================================================================

NOME FILE: auth\SignUpForm.tsx

import React, { useState, useEffect } from "react"; import { Button } from "../ui/button"; import { Input } from "../ui/input"; import { Label } from "../ui/label"; import { Separator } from "../ui/separator"; import { Checkbox } from "../ui/checkbox"; import { Mail, Lock, Eye, EyeOff, User, UserPlus, Loader2, AlertCircle, CheckCircle, Info, } from "lucide-react"; import { useAuth } from "../../hooks/integration/useAuth"; import { useAppContext } from "../../contexts/AppContext"; import { Alert, AlertDescription } from "../ui/alert"; interface SignUpFormProps { onSwitchToLogin: () => void; onSignUpSuccess?: () => void; } interface FormData { email: string; password: string; confirmPassword: string; displayName: string; acceptTerms: boolean; acceptPrivacy: boolean; } interface ValidationErrors { email?: string; password?: string; confirmPassword?: string; displayName?: string; terms?: string; } export const SignUpForm: React.FC<SignUpFormProps> = ({ onSwitchToLogin, onSignUpSuccess = () => {}, }) => { const { dispatch, authReturnContext } = useAppContext(); const initialFormData = authReturnContext?.formData || { email: "", password: "", confirmPassword: "", displayName: "", acceptTerms: false, acceptPrivacy: false, }; const [formData, setFormData] = useState<FormData>(initialFormData); const [showPassword, setShowPassword] = useState<boolean>(false); const [showConfirmPassword, setShowConfirmPassword] = useState<boolean>(false); const [validationErrors, setValidationErrors] = useState<ValidationErrors>( {} ); const [isLoading, setIsLoading] = useState<boolean>(false); const [error, setError] = useState<string | null>(null); const { signUp, isSigningUp, error: authError, clearError, validateEmail, validatePassword, } = useAuth(); useEffect(() => { return () => { if (authReturnContext) { dispatch({ type: "CLEAR_AUTH_CONTEXT" }); } }; }, [authReturnContext, dispatch]); const validateForm = (): boolean => { const errors: ValidationErrors = {}; if (!formData.email) { errors.email = "Email è richiesta"; } else if (!validateEmail(formData.email)) { errors.email = "Formato email non valido"; } if (!formData.password) { errors.password = "Password è richiesta"; } else if (!validatePassword(formData.password)) { errors.password = "Password deve contenere almeno 8 caratteri"; } if (!formData.confirmPassword) { errors.confirmPassword = "Conferma password è richiesta"; } else if (formData.password !== formData.confirmPassword) { errors.confirmPassword = "Le password non corrispondono"; } if (!formData.displayName.trim()) { errors.displayName = "Nome è richiesto"; } if (!formData.acceptTerms) { errors.terms = "Devi accettare i termini di servizio"; } setValidationErrors(errors); return Object.keys(errors).length === 0; }; const handleInputChange = ( field: keyof FormData, value: string | boolean ) => { setFormData((prev) => ({ ...prev, [field]: value })); if (validationErrors[field as keyof ValidationErrors]) { setValidationErrors((prev) => ({ ...prev, [field]: undefined })); } if (authError || error) { clearError(); setError(null); } }; const handleSubmit = async (e: React.FormEvent) => { e.preventDefault(); if (!validateForm()) { return; } setIsLoading(true); setError(null); try { const success = await signUp({ email: formData.email, password: formData.password, displayName: formData.displayName, acceptTerms: formData.acceptTerms, }); if (success) { onSignUpSuccess(); } } catch (err) { setError("Errore durante la registrazione"); console.error("Sign up error:", err); } finally { setIsLoading(false); } }; const currentError = authError?.message || error; const currentLoading = isSigningUp || isLoading; return ( <form onSubmit={handleSubmit} className="space-y-6"> } {currentError && ( <Alert className="border-red-200 bg-red-50"> <AlertCircle className="h-4 w-4 text-red-600" /> <AlertDescription className="text-red-800"> {currentError} </AlertDescription> </Alert> )} } <div className="space-y-2"> <Label htmlFor="displayName" className="text-sm font-medium text-gray-700" > Nome completo </Label> <div className="relative"> <User className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" /> <Input id="displayName" type="text" placeholder="Il tuo nome completo" value={formData.displayName} onChange={(e) => handleInputChange("displayName", e.target.value)} className={`pl-10 ${ validationErrors.displayName ? "border-red-300 focus:border-red-500 focus:ring-red-500" : "" }`} required disabled={currentLoading} /> </div> {validationErrors.displayName && ( <p className="text-sm text-red-600"> {validationErrors.displayName} </p> )} </div> } <div className="space-y-2"> <Label htmlFor="password" className="text-sm font-medium text-gray-700" > Password </Label> <div className="relative"> <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" /> <Input id="password" type={showPassword ? "text" : "password"} placeholder="Crea una password sicura" value={formData.password} onChange={(e) => handleInputChange("password", e.target.value)} className={`pl-10 pr-10 ${ validationErrors.password ? "border-red-300 focus:border-red-500 focus:ring-red-500" : "" }`} required disabled={currentLoading} /> <button type="button" onClick={() => setShowPassword(!showPassword)} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600" disabled={currentLoading} > {showPassword ? ( <EyeOff className="w-4 h-4" /> ) : ( <Eye className="w-4 h-4" /> )} </button> </div> {validationErrors.password && ( <p className="text-sm text-red-600">{validationErrors.password}</p> )} </div> } <div className="space-y-3"> <div className="flex items-start space-x-2"> <Checkbox id="terms" checked={formData.acceptTerms} onCheckedChange={(checked: boolean) => handleInputChange("acceptTerms", checked) } className="mt-1" disabled={currentLoading} /> <div className="space-y-1"> <Label htmlFor="terms" className="text-sm text-gray-700 cursor-pointer" > Accetto i{" "} <button type="button" className="text-blue-600 hover:text-blue-800 underline bg-transparent border-none p-0 cursor-pointer" onClick={(e) => { e.preventDefault(); e.stopPropagation(); dispatch({ type: "SET_VIEW", payload: "terms", authContext: { view: "terms", source: "signup", formData: formData } }); }} > Termini di Servizio </button>{" "} e la{" "} <button type="button" className="text-blue-600 hover:text-blue-800 underline bg-transparent border-none p-0 cursor-pointer" onClick={(e) => { e.preventDefault(); e.stopPropagation(); dispatch({ type: "SET_VIEW", payload: "privacy", authContext: { view: "terms", source: "signup", formData: formData } }); }} > Privacy Policy </button> </Label> {validationErrors.terms && ( <p className="text-sm text-red-600">{validationErrors.terms}</p> )} </div> </div> <div className="flex items-start space-x-2"> <Checkbox id="privacy" checked={formData.acceptPrivacy} onCheckedChange={(checked: boolean) => handleInputChange("acceptPrivacy", checked) } className="mt-1" disabled={currentLoading} /> <Label htmlFor="privacy" className="text-sm text-gray-700 cursor-pointer" > Voglio ricevere aggiornamenti via email su nuove funzionalità e contenuti </Label> </div> </div> } <div className="text-center"> <span className="text-sm text-gray-600">Hai già un account? </span> <button type="button" onClick={onSwitchToLogin} className="text-sm text-purple-600 hover:text-purple-800 p-0 h-auto font-semibold bg-transparent border-none cursor-pointer" disabled={currentLoading} > Accedi ora </button> </div> </form> ); };

================================================================================

NOME FILE: layout\AppHeader.tsx

import React from 'react'; import { Card, CardHeader, CardTitle } from '../ui/card'; import { Brain, Sparkles } from 'lucide-react'; export const AppHeader: React.FC = React.memo(() => ( <div className="text-center relative"> <div className="app-header-blur"></div> <Card className="relative backdrop-blur-sm bg-white/80 dark:bg-gray-800/80 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="app-header-overlay"></div> <CardHeader className="relative py-8"> <CardTitle className="app-header-title"> <Brain className="w-10 h-10 text-blue-600" /> Vocabulary Master <Sparkles className="w-8 h-8 text-purple-600" /> </CardTitle> <p className="text-gray-600 dark:text-gray-400 text-lg mt-2">La tua app intelligente per imparare l'inglese</p> </CardHeader> </Card> </div> )); AppHeader.displayName = 'AppHeader';

================================================================================

NOME FILE: layout\AppNavigation.tsx

import React, { useState, useRef } from "react"; import { createPortal } from "react-dom"; import { useAppContext } from "../../contexts/AppContext"; import { useAuth, useUserRole } from "../../hooks/integration/useAuth"; import { Card, CardContent } from "../ui/card"; import { Button } from "../ui/button"; import { Brain, BarChart3, Shield, User, LogOut, Settings, ChevronDown, CheckCircle, } from "lucide-react"; export const AppNavigation = React.memo(() => { const { currentView, dispatch, testHistory } = useAppContext(); const { signOut: handleSignOut, loading: authLoading, user, authUser } = useAuth(); const { userProfile, isAdmin, role } = useUserRole(); const [showUserMenu, setShowUserMenu] = useState(false); const [dropdownPosition, setDropdownPosition] = useState({ top: 0, right: 0 }); const userButtonRef = useRef<HTMLButtonElement>(null); const navItems = [ { id: "main", label: "Studio & Vocabolario", icon: Brain, color: "from-blue-500 to-purple-600", requireAuth: true, }, { id: "stats", label: "Statistiche Complete", icon: BarChart3, color: "from-purple-500 to-pink-600", badge: testHistory.length > 0 ? testHistory.length : null, requireAuth: true, }, ...(isAdmin ? [ { id: "admin", label: "Pannello Admin", icon: Shield, color: "from-red-500 to-orange-600", requireAuth: true, requiredRole: "admin" as const, }, ] : []), ]; const handleSignOutClick = async () => { try { await handleSignOut(); } catch (error) { console.error("Errore durante il logout:", error); } }; const getDisplayName = () => { return ( userProfile?.displayName || user?.displayName || authUser?.displayName || userProfile?.email?.split("@")[0] || user?.email?.split("@")[0] || authUser?.email?.split("@")[0] || "Utente" ); }; const getEmail = () => { return ( userProfile?.email || user?.email || authUser?.email || "Caricamento..." ); }; const getRoleDisplay = () => { return role === "admin" ? "Amministratore" : "Utente"; }; const toggleUserMenu = () => { if (!showUserMenu && userButtonRef.current) { const rect = userButtonRef.current.getBoundingClientRect(); setDropdownPosition({ top: rect.bottom + 8, right: window.innerWidth - rect.right }); } setShowUserMenu(!showUserMenu); }; return ( <Card className="backdrop-blur-sm bg-white/90 dark:bg-gray-800/90 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardContent className="p-0"> <div className="flex items-center justify-between gap-2 px-4 py-3"> } <div className="relative"> <Button ref={userButtonRef} onClick={toggleUserMenu} variant="ghost" className="app-nav-user-button" disabled={authLoading} > <div className="app-nav-user-avatar"> {getDisplayName().charAt(0).toUpperCase()} </div> <div className="hidden md:flex flex-col items-start"> <span className="text-sm font-semibold text-gray-800 dark:text-gray-200"> {getDisplayName()} </span> <span className="text-xs text-gray-600 dark:text-gray-400"> {getRoleDisplay()} </span> </div> <ChevronDown className={`w-4 h-4 text-gray-600 dark:text-gray-400 transition-transform duration-200 ${ showUserMenu ? "rotate-180" : "" }`} /> </Button> } <div className="app-nav-dropdown-header"> <div className="flex items-center gap-4"> <div className="w-16 h-16 bg-white/20 rounded-full flex items-center justify-center text-white text-xl font-bold shadow-lg"> {getDisplayName().charAt(0).toUpperCase()} </div> <div className="flex-1"> <div className="font-bold text-lg text-white"> {getDisplayName()} </div> <div className="text-indigo-100 text-sm"> {getEmail()} </div> <div className="flex items-center gap-2 mt-2"> <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-white/20 text-white"> {role === "admin" ? ( <Shield className="w-3 h-3" /> ) : ( <User className="w-3 h-3" /> )} {getRoleDisplay()} </span> {(userProfile?.emailVerified || user?.emailVerified || authUser?.emailVerified) && ( <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-400/20 text-green-100"> <CheckCircle className="w-3 h-3" /> Verificato </span> )} </div> </div> </div> </div> } <div className="p-2"> <Button onClick={() => { setShowUserMenu(false); dispatch({ type: "SET_VIEW", payload: "profile" }); }} variant="ghost" className="w-full justify-start gap-3 py-3 px-3 rounded-xl font-medium text-gray-800 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-700" > <User className="w-4 h-4 text-gray-600 dark:text-gray-400" /> <span>Il mio profilo</span> </Button> <Button onClick={() => { setShowUserMenu(false); dispatch({ type: "SET_VIEW", payload: "settings" }); }} variant="ghost" className="w-full justify-start gap-3 py-3 px-3 rounded-xl font-medium text-gray-800 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-700" > <Settings className="w-4 h-4 text-gray-600 dark:text-gray-400" /> <span>Impostazioni</span> </Button> {isAdmin && ( <Button onClick={() => { setShowUserMenu(false); dispatch({ type: "SET_VIEW", payload: "admin" }); }} variant="ghost" className="w-full justify-start gap-3 py-3 px-3 rounded-xl font-medium text-purple-700 dark:text-purple-300 hover:bg-purple-50 dark:hover:bg-purple-900/30" > <Shield className="w-4 h-4 text-purple-500 dark:text-purple-400" /> <span>Gestione Utenti</span> </Button> )} <div className="border-t border-gray-100 dark:border-gray-700 mt-2 pt-2"> <Button onClick={() => { setShowUserMenu(false); handleSignOutClick(); }} variant="ghost" className="w-full justify-start gap-3 py-3 px-3 rounded-xl font-medium text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/30 hover:text-red-700 dark:hover:text-red-300" disabled={authLoading} > <LogOut className="w-4 h-4" /> <span> {authLoading ? "Disconnessione..." : "Esci"} </span> </Button> </div> </div> </div>, document.body )} </div> </div> </CardContent>

================================================================================

NOME FILE: layout\Footer.tsx

import React from 'react'; interface FooterProps { className?: string; } export const Footer: React.FC<FooterProps> = ({ className = '' }) => { const currentYear = new Date().getFullYear(); return ( <footer className={`footer-container ${className}`}> <div className="footer-content-compact"> <div className="footer-left"> <span className="footer-brand">Learn English VOC</span> <span className="footer-separator">•</span> <span className="footer-version">v1.0.0</span> </div> <div className="footer-center"> <a href="/" className="footer-link-compact">Home</a> <span className="footer-separator">•</span> <a href="/test" className="footer-link-compact">Test</a> <span className="footer-separator">•</span> <a href="/stats" className="footer-link-compact">Stats</a> </div> <div className="footer-right"> <span className="footer-copyright-compact">© {currentYear}</span> </div> </div> </footer> ); }; Footer.displayName = 'Footer';

================================================================================

NOME FILE: main\ControlPanel.tsx

import React from 'react'; import { Card, CardTitle } from '../ui/card'; import { Button } from '../ui/button'; import { Play, RefreshCw, BookOpen, AlertTriangle } from 'lucide-react'; import { Word, WordStats } from '../../types/entities/Word.types'; interface ControlPanelProps { onStartTest: () => void; onClearAllWords: () => void; words: Word[]; wordStats: WordStats; getAvailableChapters: () => string[]; } export const ControlPanel: React.FC<ControlPanelProps> = React.memo(({ onStartTest, onClearAllWords, words, wordStats, getAvailableChapters }) => { const availableWords = words.filter(word => !word.learned); const chapters = getAvailableChapters(); return ( <Card className="backdrop-blur-sm bg-white/90 dark:bg-gray-800/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="control-panel-container"> <div className="bg-white dark:bg-gray-800 rounded-3xl p-6"> <CardTitle className="control-panel-title"> <Play className="w-6 h-6 text-blue-600" /> Controlli di Studio </CardTitle> } {wordStats.difficult > 0 && ( <div className="control-panel-alert"> <div className="flex items-center gap-3 mb-2"> <AlertTriangle className="w-6 h-6 text-red-600" /> <h4 className="font-bold text-red-800 dark:text-red-200">Parole Difficili Disponibili</h4> </div> <p className="text-red-700 dark:text-red-300 text-sm"> Hai {wordStats.difficult} parole marcate come difficili. Usa la modalità "Solo Parole Difficili" per concentrarti su di esse! </p> </div> )} <div className="grid grid-cols-1 md:grid-cols-2 gap-4"> <Button onClick={onStartTest} disabled={availableWords.length === 0} className="control-panel-action-button" > <div className="flex flex-col items-center gap-2"> <BookOpen className="w-8 h-8" /> <span className="font-bold">Inizia Test</span> <span className="text-sm opacity-90"> ({availableWords.length} disponibili {wordStats.difficult > 0 && `, ${wordStats.difficult} difficili`}) </span> </div> </Button> <Button onClick={onClearAllWords} variant="outline" disabled={words.length === 0} className="border-2 border-red-300 dark:border-red-700 hover:border-red-400 dark:hover:border-red-600 p-6 h-auto rounded-2xl bg-red-50 dark:bg-red-900/30 hover:bg-red-100 dark:hover:bg-red-900/50 transition-all duration-200 disabled:opacity-50" > <div className="flex flex-col items-center gap-2 text-red-600 dark:text-red-400"> <RefreshCw className="w-8 h-8" /> <span className="font-bold">Pulisci Vocabolario</span> <span className="text-sm">Elimina tutte le parole</span> </div> </Button> </div> </div> </div> </Card> ); }); ControlPanel.displayName = 'ControlPanel';

================================================================================

NOME FILE: modals\GlobalModals.js

import React from 'react'; import { useAppContext } from '../../contexts/AppContext'; import { useNotification } from '../../contexts/NotificationContext'; import { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter } from '../ui/modal'; import { Button } from '../ui/button'; import TestSelector from '../TestSelector'; import { Trash2, RefreshCw } from 'lucide-react'; export const GlobalModals = React.memo(() => { const { confirmDelete, showConfirmClear, showChapterSelector, dispatch, words, removeWord, clearAllWords, startTest } = useAppContext(); const { showSuccess, showError } = useNotification(); const handleConfirmDelete = async () => { if (confirmDelete) { try { const result = await removeWord(confirmDelete.id); if (result.success) { showSuccess(`✅ Parola "${confirmDelete.english}" eliminata!`); dispatch({ type: 'SET_CONFIRM_DELETE', payload: null }); } else { console.error('❌ Failed to delete word:', result.error); showError(new Error(result.error?.message || 'Errore sconosciuto'), 'Eliminazione Parola'); } } catch (error) { console.error('❌ Exception during delete:', error); showError(error instanceof Error ? error : new Error(String(error)), 'Eliminazione Parola'); } } }; const handleConfirmClear = () => { clearAllWords(); dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false }); showSuccess('✅ Tutte le parole sono state eliminate!'); }; const handleTestStart = (config) => { let filteredWords = words.filter(word => { if (config.selectedChapters.includes('no-chapter')) { if (!word.chapter && !config.selectedChapters.some(ch => ch !== 'no-chapter' && ch === word.chapter)) { } else if (word.chapter && !config.selectedChapters.includes(word.chapter)) { return false; } } else if (word.chapter && !config.selectedChapters.includes(word.chapter)) { return false; } else if (!word.chapter && !config.selectedChapters.includes('no-chapter')) { return false; } if (config.testMode === 'difficult-only') { return word.difficult; } if (!config.includeLearnedWords && word.learned) { return false; } return true; }); const testConfig = { ...config, hints: { enabled: config.enableHints, maxPerWord: config.maxHintsPerWord, maxTotal: config.maxTotalHints }, timing: { enabled: config.enableTimer, maxTimePerWord: config.maxTimePerWord }, wordSelection: { unlearnedOnly: !config.includeLearnedWords, difficultOnly: config.testMode === 'difficult-only' } }; startTest(filteredWords, testConfig); dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: false }); }; return ( <> } <Modal isOpen={showConfirmClear} onClose={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })} > <ModalHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white rounded-t-2xl"> <ModalTitle className="text-white flex items-center gap-2"> <RefreshCw className="w-5 h-5" /> Eliminazione Completa </ModalTitle> </ModalHeader> <ModalContent> <div className="text-center py-4"> <div className="text-6xl mb-4">⚠️</div> <p className="text-gray-700 dark:text-gray-300 mb-4"> Sei sicuro di voler eliminare tutte le <strong>{words.length} parole</strong>? </p> <div className="bg-orange-50 dark:bg-orange-900/20 border border-orange-200 dark:border-orange-700 rounded-lg p-4 mb-4"> <p className="text-orange-800 dark:text-orange-300 text-sm"> Questa azione eliminerà permanentemente tutto il tuo vocabolario e non può essere annullata. </p> </div> </div> </ModalContent> <ModalFooter> <Button onClick={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })} variant="outline" > Annulla </Button> <Button onClick={handleConfirmClear} className="bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white" > Elimina Tutto </Button> </ModalFooter> </Modal>

================================================================================

NOME FILE: stats\DataManagementPanel.js

import React from 'react'; import { Card } from '../ui/card'; import { Button } from '../ui/button'; import { Shield, AlertTriangle, Download, Upload, RefreshCw } from 'lucide-react'; import { useDataManagement } from './hooks/useDataManagement'; const DataManagementPanel = () => { const { isExporting, isImporting, isProcessing, handleExport, handleImportClick, handleFileSelect, handleReset, fileInputRef } = useDataManagement(); return ( <Card className="mb-6 p-4 bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-900/30 dark:to-purple-900/30 border-2 border-indigo-200 dark:border-indigo-700 rounded-2xl animate-fade-in"> <div className="grid grid-cols-1 md:grid-cols-2 gap-6"> } <div className="mt-3 p-3 bg-white dark:bg-gray-800 rounded-lg border border-indigo-200 dark:border-indigo-700"> <p className="text-xs text-indigo-700 dark:text-indigo-300"> <strong>Include:</strong> Parole, Statistiche, Cronologia Test, Performance Parole </p> </div> </div> } <input ref={fileInputRef} type="file" accept=".json" onChange={handleFileSelect} style={{ display: 'none' }} /> </Card> ); }; export default DataManagementPanel;

================================================================================

NOME FILE: stats\StatsHeader.js

import React from 'react'; import { Card, CardTitle } from '../ui/card'; import { Button } from '../ui/button'; import { BarChart3, Database } from 'lucide-react'; import { useStatsData } from './hooks/useStatsData'; import StatisticCard from './components/StatisticCard'; const StatsHeader = ({ testHistory, showDataManagement, setShowDataManagement, onClearHistory }) => { const { advancedStats } = useStatsData(testHistory); const mainStats = [ { label: 'Test Completati', value: advancedStats.totalTests, color: 'blue' }, { label: '📚 Parole Studiate', value: advancedStats.totalWordsStudied, color: 'emerald' }, { label: 'Media', value: `${advancedStats.averageScore}%`, color: 'green' }, { label: 'Record', value: `${advancedStats.bestScore}%`, color: 'purple' }, { label: 'Aiuti', value: advancedStats.totalHints, color: 'yellow' }, { label: '% Aiuti', value: `${advancedStats.hintsPercentage}%`, color: 'indigo' } ]; return ( <Card className="backdrop-blur-sm bg-white/90 dark:bg-gray-800/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1"> <div className="bg-white dark:bg-gray-800 rounded-3xl p-6"> <div className="flex justify-between items-center mb-6"> <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent"> <BarChart3 className="w-8 h-8 text-purple-600" /> Analisi Avanzata dell'Apprendimento <span className="text-sm bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 px-2 py-1 rounded-full"> Live: {testHistory.length} test </span> </CardTitle> <div className="flex gap-2"> <Button onClick={() => setShowDataManagement(!showDataManagement)} className="bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white px-4 py-2 rounded-xl" > <Database className="w-4 h-4 mr-2" /> Gestione Dati </Button> <Button onClick={onClearHistory} variant="outline" className="border-red-300 dark:border-red-700 text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/30" > 🗑️ Pulisci Cronologia ({testHistory.length}) </Button> </div> </div> <div className="grid grid-cols-2 md:grid-cols-6 gap-4"> {mainStats.map((stat, index) => ( <StatisticCard key={index} label={stat.label} value={stat.value} color={stat.color} /> ))} </div> </div> </div> </Card> ); }; export default StatsHeader;

================================================================================

NOME FILE: stats\StatsNavigation.js

import React from 'react'; import { Button } from '../ui/button'; const StatsNavigation = ({ selectedView, setSelectedView }) => { const tabs = [ { id: 'overview', label: 'Panoramica', icon: '📈' }, { id: 'chapters', label: 'Per Capitoli', icon: '📚' }, { id: 'words', label: 'Per Parole', icon: '🔍' }, { id: 'performance', label: 'Performance', icon: '🎯' }, { id: 'trends', label: 'Tendenze', icon: '📊' } ]; return ( <div className="flex gap-2 mb-6"> {tabs.map(tab => ( <Button key={tab.id} onClick={() => setSelectedView(tab.id)} className={`px-6 py-3 rounded-xl transition-all ${ selectedView === tab.id ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg' : 'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600' }`} > <span className="mr-2">{tab.icon}</span> {tab.label} </Button> ))} </div> ); }; export default StatsNavigation;

================================================================================

NOME FILE: stats\StatsOverview.js

import React, { useState, useEffect } from 'react'; import StatsHeader from './StatsHeader'; import StatsNavigation from './StatsNavigation'; import DataManagementPanel from './DataManagementPanel'; import EmptyState from '../stats/components/EmptyState'; const OverviewSection = React.lazy(() => import('./sections/OverviewSection')); const ChaptersSection = React.lazy(() => import('./sections/ChaptersSection')); const WordsSection = React.lazy(() => import('./sections/WordsSection')); const PerformanceSection = React.lazy(() => import('./sections/PerformanceSection')); const TrendsSection = React.lazy(() => import('./sections/TrendsSection')); const StatsOverview = ({ testHistory, words, onClearHistory, onGoToMain, forceUpdate }) => { const [selectedView, setSelectedView] = useState('overview'); const [showDataManagement, setShowDataManagement] = useState(false); const [localRefresh, setLocalRefresh] = useState(0); useEffect(() => { setLocalRefresh(prev => prev + 1); }, [testHistory.length, forceUpdate]); if (testHistory.length === 0) { return ( <EmptyState onGoToMain={onGoToMain} showDataManagement={showDataManagement} setShowDataManagement={setShowDataManagement} /> ); } const renderSelectedSection = () => { const commonProps = { testHistory, words, localRefresh, onClearHistory }; switch (selectedView) { case 'overview': return <OverviewSection {...commonProps} />; case 'chapters': return <ChaptersSection {...commonProps} />; case 'words': return <WordsSection {...commonProps} />; case 'performance': return <PerformanceSection {...commonProps} />; case 'trends': return <TrendsSection {...commonProps} />; default: return <OverviewSection {...commonProps} />; } }; return ( <div className="space-y-8 animate-fade-in"> <StatsHeader testHistory={testHistory} showDataManagement={showDataManagement} setShowDataManagement={setShowDataManagement} onClearHistory={onClearHistory} /> <StatsNavigation selectedView={selectedView} setSelectedView={setSelectedView} /> {showDataManagement && <DataManagementPanel />} <React.Suspense fallback={<div className="text-center py-8 text-gray-600 dark:text-gray-400">Caricamento...</div>}> {renderSelectedSection()} </React.Suspense> </div> ); }; export default StatsOverview;

================================================================================

NOME FILE: stats\components\EmptyState.js

import React from 'react'; import { Card, CardTitle } from '../../ui/card'; import { Button } from '../../ui/button'; import { Play, Database } from 'lucide-react'; import DataManagementPanel from '../DataManagementPanel'; const EmptyState = ({ onGoToMain, showDataManagement, setShowDataManagement }) => { return ( <Card className="backdrop-blur-sm bg-white/90 dark:bg-gray-800/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1"> <div className="bg-white dark:bg-gray-800 rounded-3xl p-6"> <div className="flex justify-between items-center mb-6"> <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent"> Statistiche e Analisi <span className="text-sm bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 px-2 py-1 rounded-full"> 0 test </span> </CardTitle> <Button onClick={() => setShowDataManagement(!showDataManagement)} className="bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white px-4 py-2 rounded-xl" > <Database className="w-4 h-4 mr-2" /> Gestione Dati </Button> </div> {showDataManagement && <DataManagementPanel />} <div className="text-center py-16"> <div className="text-8xl mb-6">📊</div> <h3 className="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-4">Nessun test completato</h3> <p className="text-gray-600 dark:text-gray-400 text-lg mb-8">Completa il tuo primo test per vedere le statistiche dettagliate!</p> <Button onClick={onGoToMain} className="bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl" > <Play className="w-5 h-5 mr-2" /> Inizia il Primo Test </Button> </div> </div> </div> </Card> ); }; export default EmptyState;

================================================================================

NOME FILE: stats\components\StatisticCard.js

import React from 'react'; const StatisticCard = ({ label, value, color = 'blue' }) => { const colorClasses = { blue: 'from-blue-500 to-cyan-500 dark:from-blue-600 dark:to-cyan-600 text-blue-100', emerald: 'from-emerald-500 to-green-500 dark:from-emerald-600 dark:to-green-600 text-emerald-100', green: 'from-green-500 to-emerald-500 dark:from-green-600 dark:to-emerald-600 text-green-100', purple: 'from-purple-500 to-pink-500 dark:from-purple-600 dark:to-pink-600 text-purple-100', yellow: 'from-yellow-500 to-orange-500 dark:from-yellow-600 dark:to-orange-600 text-yellow-100', indigo: 'from-indigo-500 to-blue-500 dark:from-indigo-600 dark:to-blue-600 text-indigo-100' }; return ( <div className={`bg-gradient-to-br ${colorClasses[color]} p-4 rounded-2xl text-white text-center shadow-xl`}> <div className="text-2xl font-bold">{value}</div> <div className="text-sm">{label}</div> </div> ); }; export default StatisticCard;

================================================================================

NOME FILE: stats\components\WordDetailSection.js

import React from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, ComposedChart, Bar } from 'recharts'; import { Award, TrendingUp, Target } from 'lucide-react'; const WordDetailSection = ({ wordId, getWordAnalysis, testHistory, wordInfo, localRefresh }) => { const wordAnalysis = getWordAnalysis ? getWordAnalysis(wordId) : null; if (!wordAnalysis) { return ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardContent className="text-center py-16"> <div className="text-6xl mb-4">📊</div> <p className="text-gray-600">Nessun dato performance disponibile per questa parola</p> </CardContent> </Card> ); } const getWordInfoFromProps = () => { if (wordInfo) { return { english: wordInfo.english || 'N/A', italian: wordInfo.italian || 'N/A', chapter: wordInfo.chapter || null }; } if (wordAnalysis?.english) { return { english: wordAnalysis.english, italian: wordAnalysis.italian, chapter: wordAnalysis.chapter }; } return { english: 'N/A', italian: 'N/A', chapter: null }; }; const finalWordInfo = getWordInfoFromProps(); const buildTimelineFromHistory = () => { const attempts = []; const allTests = testHistory || []; const sortedTests = [...allTests].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); sortedTests.forEach((test, testIndex) => { let wasInTest = false; let wasCorrect = false; let usedHint = false; let timeSpent = 0; if (test.wrongWords && Array.isArray(test.wrongWords)) { const wrongWord = test.wrongWords.find(w => w.id === wordId); if (wrongWord) { wasInTest = true; wasCorrect = false; usedHint = (test.hintsUsed > 0) && Math.random() > 0.7; timeSpent = test.totalTime ? Math.floor((test.totalTime * 1000) / test.totalWords) : 0; } } if (!wasInTest && test.wordTimes && Array.isArray(test.wordTimes)) { const wordTime = test.wordTimes.find(wt => wt.wordId === wordId); if (wordTime) { wasInTest = true; wasCorrect = wordTime.isCorrect; usedHint = wordTime.usedHint || false; timeSpent = wordTime.timeSpent || 0; } } if (!wasInTest && test.testParameters?.selectedChapters && finalWordInfo.chapter) { if (test.testParameters.selectedChapters.includes(finalWordInfo.chapter)) { wasInTest = true; wasCorrect = true; const totalWordsInTest = test.totalWords || 1; const avgTimePerWord = test.totalTime ? (test.totalTime * 1000) / totalWordsInTest : 0; timeSpent = avgTimePerWord + (Math.random() * 2000 - 1000); if (test.hintsUsed > 0) { const correctWordsInTest = test.correctWords || 1; const hintProbability = Math.min(test.hintsUsed / correctWordsInTest, 1); usedHint = Math.random() < hintProbability; } } } if (wasInTest) { attempts.push({ timestamp: test.timestamp, correct: wasCorrect, usedHint: usedHint, timeSpent: Math.max(timeSpent, 0), testId: test.id }); } }); return attempts; }; const actualAttempts = buildTimelineFromHistory(); if (actualAttempts.length === 0) { return ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardContent className="text-center py-16"> <div className="text-6xl mb-4">📊</div> <h3 className="text-xl font-bold text-gray-700 mb-2">Nessun tentativo trovato</h3> <p className="text-gray-600"> La parola "{finalWordInfo.english}" non è ancora stata testata o non è stata trovata nella cronologia test. </p> <div className="mt-4 p-3 bg-gray-50 rounded-lg text-sm text-gray-500"> <div>ID Parola: {wordId}</div> <div>Capitolo: {finalWordInfo.chapter || 'Nessuno'}</div> <div>Cronologia disponibile: {testHistory.length} test</div> <div>WordAnalysis attempts: {wordAnalysis?.attempts?.length || 0}</div> </div> </CardContent> </Card> ); } const timelineData = actualAttempts.map((attempt, index) => { const attemptsUpToHere = actualAttempts.slice(0, index + 1); const correctUpToHere = attemptsUpToHere.filter(a => a.correct).length; const cumulativePrecision = Math.round((correctUpToHere / attemptsUpToHere.length) * 100); const attemptDate = new Date(attempt.timestamp); const shortDate = attemptDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit' }); return { attempt: shortDate, attemptNumber: index + 1, success: attempt.correct ? 100 : 0, globalPrecision: cumulativePrecision, hint: attempt.usedHint ? 50 : 0, time: Math.round((attempt.timeSpent || 0) / 1000), fullDate: attemptDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }), isCorrect: attempt.correct, usedHint: attempt.usedHint, timestamp: attempt.timestamp }; }); const chartData = timelineData.slice(-10).map((data, index, array) => ({ ...data, globalPrecision: (() => { const visibleAttempts = array.slice(0, index + 1); const correctInVisible = visibleAttempts.filter(a => a.isCorrect).length; return Math.round((correctInVisible / visibleAttempts.length) * 100); })() })); const recalculatedStats = { totalAttempts: actualAttempts.length, correctAttempts: actualAttempts.filter(a => a.correct).length, accuracy: actualAttempts.length > 0 ? Math.round((actualAttempts.filter(a => a.correct).length / actualAttempts.length) * 100) : 0, hintsUsed: actualAttempts.filter(a => a.usedHint).length, hintsPercentage: actualAttempts.length > 0 ? Math.round((actualAttempts.filter(a => a.usedHint).length / actualAttempts.length) * 100) : 0, avgTime: actualAttempts.length > 0 ? Math.round(actualAttempts.reduce((sum, a) => sum + (a.timeSpent || 0), 0) / actualAttempts.length / 1000) : 0, currentStreak: (() => { let streak = 0; for (let i = actualAttempts.length - 1; i >= 0; i--) { if (actualAttempts[i].correct) { streak++; } else { break; } } return streak; })() }; const recentStats = { totalAttempts: recalculatedStats.totalAttempts, recentAttempts: chartData.length, currentAccuracy: recalculatedStats.accuracy, trend: chartData.length >= 2 ? chartData[chartData.length - 1].globalPrecision - chartData[0].globalPrecision : 0, recentHints: chartData.filter(d => d.usedHint).length, avgRecentTime: chartData.length > 0 ? Math.round(chartData.reduce((sum, d) => sum + d.time, 0) / chartData.length) : 0 }; const CustomTooltip = ({ active, payload, label }) => { if (active && payload && payload.length) { const data = payload[0].payload; return ( <div className="bg-white p-4 border border-gray-200 rounded-lg shadow-lg"> <p className="font-bold text-gray-800">{`Data: ${label}`}</p> <p className="text-sm text-gray-600">{`Dettaglio: ${data.fullDate}`}</p> <div className="mt-2 space-y-1"> <p className={`text-sm font-medium ${data.isCorrect ? 'text-green-600' : 'text-red-600'}`}> {`Risultato: ${data.isCorrect ? '✅ Corretto' : '❌ Sbagliato'}`} </p> <p className="text-sm text-blue-600 font-bold"> {`Precisione Globale: ${data.globalPrecision}%`} </p> {data.usedHint && ( <p className="text-sm text-orange-600">💡 Aiuto utilizzato</p> )} <p className="text-sm text-purple-600"> {`Tempo: ${data.time}s`} </p> <p className="text-xs text-gray-500"> {`Tentativo #${data.attemptNumber} di ${actualAttempts.length}`} </p> <p className="text-xs text-gray-400"> {`Test ID: ${data.timestamp}`} </p> </div> </div> ); } return null; }; return ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden" key={`detail-${wordId}-${localRefresh}`}> <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <Award className="w-6 h-6" /> Andamento Temporale: "{finalWordInfo.english}" </CardTitle> <p className="text-green-100 text-sm"> Ultimi {chartData.length} tentativi • Precisione ricostruita: {Math.round((actualAttempts.filter(a => a.correct).length / actualAttempts.length) * 100)}% • Totale tentativi: {actualAttempts.length} </p> </CardHeader> <CardContent className="p-6"> } <div> <h4 className="font-bold text-lg text-gray-800 mb-4 flex items-center gap-2"> <TrendingUp className="w-5 h-5" /> Andamento Temporale ({chartData.length} tentativi recenti) </h4> {chartData.length > 0 ? ( <ResponsiveContainer width="100%" height={300}> <ComposedChart data={chartData} key={`word-chart-${wordId}-${localRefresh}`}> <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" /> <XAxis dataKey="attempt" tick={{ fontSize: 11 }} interval={0} angle={-45} textAnchor="end" height={70} label={{ value: 'Date (DD/MM)', position: 'insideBottom', offset: -5, style: { fontSize: '12px' } }} /> <YAxis yAxisId="left" domain={[0, 100]} tick={{ fontSize: 12 }} label={{ value: 'Percentuale (%)', angle: -90, position: 'insideLeft' }} /> <YAxis yAxisId="right" orientation="right" domain={[0, 'dataMax + 10']} tick={{ fontSize: 12 }} label={{ value: 'Tempo (s)', angle: 90, position: 'insideRight' }} /> <Tooltip content={<CustomTooltip />} /> } <Line yAxisId="left" type="monotone" dataKey="success" stroke="#10b981" strokeWidth={2} strokeDasharray="5 5" name="Risultato Singolo" dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }} connectNulls={false} /> } <Line yAxisId="right" type="monotone" dataKey="time" stroke="#8b5cf6" strokeWidth={2} strokeDasharray="10 5" name="Tempo (s)" dot={{ fill: '#8b5cf6', strokeWidth: 1, r: 3 }} /> </ComposedChart> </ResponsiveContainer> ) : ( <div className="text-center py-8 text-gray-500"> <p>Nessun tentativo disponibile per il grafico</p> <p className="text-sm mt-2">Completare alcuni test per vedere l'andamento</p> </div> )} } <div className="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200"> <h5 className="font-semibold text-sm text-blue-800 mb-2">📋 Informazioni Timeline</h5> <div className="text-xs text-blue-700 space-y-1"> <div>Parola: <span className="font-medium">"{finalWordInfo.english}" → "{finalWordInfo.italian}" (ID: {wordId})</span></div> <div>Capitolo: <span className="font-medium">{finalWordInfo.chapter || 'Nessun capitolo'}</span></div> <div>Tentativi ricostruiti: <span className="font-medium">{actualAttempts.length}</span></div> <div>Tentativi corretti: <span className="font-medium text-green-600">{recalculatedStats.correctAttempts}</span></div> <div>Precisione ricostruita: <span className="font-medium text-blue-600">{recalculatedStats.accuracy}%</span></div> <div>Punti mostrati nel grafico: <span className="font-medium">{chartData.length}</span></div> <div>Test totali caricati: <span className="font-medium">{testHistory.length}</span></div> <div>LocalRefresh: <span className="font-medium">{localRefresh}</span></div> <div>WordAnalysis originale - Tentativi: <span className="font-medium">{wordAnalysis?.attempts?.length || 0}</span>, Accuratezza: <span className="font-medium">{wordAnalysis?.accuracy || 0}%</span></div> {actualAttempts.length > 0 && ( <> <div>Primo tentativo: <span className="font-medium"> {new Date(actualAttempts[0].timestamp).toLocaleDateString('it-IT')} </span></div> <div>Ultimo tentativo: <span className="font-medium"> {new Date(actualAttempts[actualAttempts.length - 1].timestamp).toLocaleDateString('it-IT')} </span></div> </> )} <div className="flex gap-2 mt-2"> </div> {testHistory.length > 0 && ( <div className="mt-2 p-2 bg-gray-100 rounded text-xs"> <div className="font-semibold">Ultimi 3 test ID:</div> {testHistory.slice(0, 3).map((test, index) => ( <div key={test.id} className="truncate"> {index + 1}. {test.id} ({new Date(test.timestamp).toLocaleDateString('it-IT')}) </div> ))} </div> )} </div> </div> } <div> <h4 className="font-bold text-lg text-gray-800 mb-4 flex items-center gap-2"> <Target className="w-5 h-5" /> Statistiche Dettagliate </h4> <div className="space-y-4"> } <div className="p-4 bg-blue-50 rounded-xl"> <h5 className="font-bold text-blue-800 mb-3">🎯 Analisi Performance</h5> <div className="space-y-2 text-sm"> <div className="flex justify-between"> <span className="text-gray-700">Tentativi totali:</span> <span className="font-bold">{recalculatedStats.totalAttempts}</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Risposte corrette:</span> <span className="font-bold text-green-600">{recalculatedStats.correctAttempts}</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Aiuti utilizzati:</span> <span className="font-bold text-orange-600">{recalculatedStats.hintsUsed}</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Precisione ricostruita:</span> <span className="font-bold text-blue-600">{recalculatedStats.accuracy}%</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Streak corrente:</span> <span className="font-bold text-green-600">{recalculatedStats.currentStreak}</span> </div> </div> </div> } <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200"> <h5 className="font-bold text-yellow-800 mb-2">💡 Raccomandazioni</h5> <div className="text-sm text-yellow-700 space-y-1"> {recalculatedStats.accuracy < 60 && ( <p>• 📚 Rivedi questa parola più spesso - precisione {recalculatedStats.accuracy}% sotto il 60%</p> )} {recalculatedStats.hintsPercentage > 50 && ( <p>• 💭 Cerca di rispondere senza aiuti - uso eccessivo di suggerimenti ({recalculatedStats.hintsPercentage}%)</p> )} {recalculatedStats.avgTime > 20 && ( <p>• ⚡ Pratica per migliorare i tempi di risposta (attuale: {recalculatedStats.avgTime}s)</p> )} {recalculatedStats.currentStreak >= 5 && ( <p>• 🏆 Ottimo! Continua così - streak di {recalculatedStats.currentStreak}</p> )} {recentStats.trend > 20 && ( <p>• 📈 Tendenza molto positiva - stai migliorando rapidamente! (+{recentStats.trend}%)</p> )} {recalculatedStats.accuracy >= 80 && recalculatedStats.currentStreak >= 3 && ( <p>• ✨ Parola ben consolidata - potresti concentrarti su altre parole difficili</p> )} {actualAttempts.length === 0 && ( <p>• 🎯 Inizia a praticare questa parola per vedere l'andamento!</p> )} {actualAttempts.length > 0 && recalculatedStats.accuracy === 0 && ( <p>• 🔥 Parola molto difficile - continua a praticare, migliorerai!</p> )} </div> </div> </div> </div> </div> </CardContent> </Card> ); }; export default WordDetailSection;

================================================================================

NOME FILE: stats\components\WordPerformanceCard.js

import React from 'react'; import { Button } from '../../ui/button'; import { BookOpen, TrendingUp, Clock, Lightbulb, Target, AlertTriangle, CheckCircle, Circle, Edit3, Eye } from 'lucide-react'; import { getCategoryStyle } from '../../../utils/categoryUtils'; const WordPerformanceCard = ({ word, isSelected, onClick, onToggleLearned, onToggleDifficult, onEdit, showActions = false }) => { const getStatusColor = (status) => { const colors = { critical: 'bg-red-500', inconsistent: 'bg-orange-500', struggling: 'bg-yellow-500', promising: 'bg-blue-500', improving: 'bg-green-500', consolidated: 'bg-emerald-500', new: 'bg-gray-500' }; return colors[status] || 'bg-gray-500'; }; const getStatusLabel = (status) => { const labels = { critical: '🔴 Critica', inconsistent: '🟠 Instabile', struggling: '🟡 In difficoltà', promising: '🔵 Promettente', improving: '🟢 Migliorando', consolidated: '🟢 Consolidata', new: '⚪ Nuova' }; return labels[status] || '⚪ Sconosciuto'; }; const getPerformanceInsight = (word) => { if (!word.totalAttempts || word.totalAttempts === 0) { return { text: 'Nessun test completato', color: 'text-gray-500', icon: '📊' }; } if (word.accuracy >= 90 && word.currentStreak >= 3) { return { text: 'Performance eccellente!', color: 'text-green-600', icon: '🏆' }; } if (word.accuracy >= 70 && word.hintsPercentage <= 30) { return { text: 'Buona padronanza', color: 'text-blue-600', icon: '👍' }; } if (word.hintsPercentage > 50) { return { text: 'Troppi aiuti utilizzati', color: 'text-orange-600', icon: '💡' }; } if (word.accuracy < 50) { return { text: 'Necessita più studio', color: 'text-red-600', icon: '📚' }; } return { text: 'In fase di apprendimento', color: 'text-blue-500', icon: '📈' }; }; const insight = getPerformanceInsight(word); return ( <div onClick={onClick} className={`p-6 rounded-2xl border-2 cursor-pointer transition-all duration-300 hover:shadow-lg ${ isSelected ? 'border-blue-500 bg-blue-50 shadow-lg' : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md' }`} > <div className="flex items-center justify-between mb-4"> } <div className="flex flex-wrap gap-2 text-sm"> {word.chapter && ( <span className="flex items-center gap-1 text-blue-600"> <BookOpen className="w-3 h-3" /> Cap. {word.chapter} </span> )} {word.group && ( <span className="flex items-center gap-1 text-purple-600"> {getCategoryStyle(word.group).icon} {word.group} </span> )} {word.learned && ( <span className="flex items-center gap-1 text-green-600"> <CheckCircle className="w-3 h-3" /> Appresa </span> )} {word.difficult && ( <span className="flex items-center gap-1 text-red-600"> <AlertTriangle className="w-3 h-3" /> Difficile </span> )} </div> </div> } <div className="flex items-center gap-6"> } {word.totalAttempts > 0 && ( <div className={`px-3 py-1 rounded-full text-white text-sm font-medium ${getStatusColor(word.status)}`}> {getStatusLabel(word.status)} </div> )} } <div className="flex items-center justify-between"> <div className="flex items-center gap-2"> <span className="text-lg">{insight.icon}</span> <span className={`text-sm font-medium ${insight.color}`}> {insight.text} </span> </div> } {word.totalAttempts > 0 && ( <div className="mt-4 grid grid-cols-4 gap-2"> } <div className="text-center p-2 bg-orange-50 rounded-lg"> <div className="w-full h-2 rounded-full bg-gray-200"> <div className={`h-full rounded-full transition-all duration-500 ${ word.hintsPercentage <= 20 ? 'bg-green-500' : word.hintsPercentage <= 40 ? 'bg-blue-500' : word.hintsPercentage <= 60 ? 'bg-orange-500' : 'bg-red-500' }`} style={{ width: `${Math.min(100, word.hintsPercentage)}%` }} /> </div> <div className="text-xs text-orange-600 mt-1">Aiuti</div> </div> } <div className="text-center p-2 bg-purple-50 rounded-lg"> <div className="flex justify-center items-center h-2"> <Clock className={`w-3 h-3 ${ word.avgTime <= 10 ? 'text-green-500' : word.avgTime <= 20 ? 'text-blue-500' : word.avgTime <= 30 ? 'text-orange-500' : 'text-red-500' }`} /> </div> <div className="text-xs text-purple-600 mt-1">Velocità</div> </div> </div> )}

================================================================================

NOME FILE: stats\hooks\useDataManagement.js

import { useState, useRef } from 'react'; import { useAppContext } from '../../../contexts/AppContext'; export const useDataManagement = () => { const [isImporting, setIsImporting] = useState(false); const [isExporting, setIsExporting] = useState(false); const fileInputRef = useRef(null); const { exportStats, importStats, resetStats, refreshData, isProcessing } = useAppContext(); const handleExport = async () => { if (isExporting || isProcessing) return; try { setIsExporting(true); console.log('🔄 Starting export...'); await new Promise(resolve => setTimeout(resolve, 100)); if (typeof exportStats === 'function') { exportStats(); console.log('✅ Export completed'); } else { throw new Error('exportStats is not available'); } } catch (error) { console.error('❌ Errore export:', error); alert(`Errore durante l'esportazione: ${error.message}`); } finally { setIsExporting(false); } }; const handleImportClick = () => { if (isImporting || isProcessing) return; console.log('📂 Opening file dialog...'); fileInputRef.current?.click(); }; const handleFileSelect = async (event) => { const file = event.target.files[0]; if (!file) return; console.log('📁 File selected:', file.name, 'Type:', file.type); if (file.type !== 'application/json') { alert('Per favore seleziona un file JSON valido'); return; } setIsImporting(true); try { console.log('🔍 Reading file content...'); const fileContent = await new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => { console.log('✅ File read successfully'); resolve(e.target.result); }; reader.onerror = () => { console.error('❌ File reading failed'); reject(new Error('Errore nella lettura del file')); }; reader.readAsText(file); }); if (typeof importStats !== 'function') { throw new Error(`importStats is not a function. Available type: ${typeof importStats}`); } console.log('🔄 Starting import with content length:', fileContent.length); await importStats(fileContent); console.log('✅ Import completed successfully'); setTimeout(() => { if (typeof refreshData === 'function') { console.log('🔄 Refreshing data after import...'); refreshData(); } }, 200); } catch (error) { console.error('❌ Errore importazione:', error); alert(`Errore durante l'importazione: ${error.message}`); } finally { setIsImporting(false); if (event.target) { event.target.value = ''; } } }; const handleReset = async () => { if (isProcessing) return; const confirmation = window.confirm( '⚠️ ATTENZIONE: Questa operazione cancellerà TUTTI i dati (parole, test, statistiche).\n\n' + 'Sei sicuro di voler continuare?' ); if (!confirmation) return; try { console.log('🗑️ Starting data reset...'); if (typeof resetStats === 'function') { await resetStats(); console.log('✅ Reset completed'); setTimeout(() => { if (typeof refreshData === 'function') { console.log('🔄 Refreshing data after reset...'); refreshData(); } }, 200); } else { throw new Error('resetStats is not available'); } } catch (error) { console.error('❌ Errore reset:', error); alert(`Errore durante il reset: ${error.message}`); } }; console.log('🔍 useDataManagement - Available functions:', { exportStats: typeof exportStats, importStats: typeof importStats, resetStats: typeof resetStats, refreshData: typeof refreshData, isProcessing }); return { isExporting, isImporting, isProcessing, handleExport, handleImportClick, handleFileSelect, handleReset, fileInputRef }; };

================================================================================

NOME FILE: stats\hooks\useStatsData.js

import { useMemo } from 'react'; export const useStatsData = (testHistory) => { const advancedStats = useMemo(() => { if (testHistory.length === 0) { return { totalTests: 0, averageScore: 0, bestScore: 0, worstScore: 0, totalWordsStudied: 0, totalCorrect: 0, totalIncorrect: 0, totalHints: 0, hintsPercentage: 0, chaptersAnalyzed: 0, chapterPerformance: {} }; } const totalTests = testHistory.length; const totalCorrect = testHistory.reduce((sum, test) => sum + (test.correctWords || 0), 0); const totalIncorrect = testHistory.reduce((sum, test) => sum + (test.incorrectWords || 0), 0); const totalHints = testHistory.reduce((sum, test) => sum + (test.hintsUsed || 0), 0); const totalWordsStudied = totalCorrect + totalIncorrect; const hintsPercentage = totalWordsStudied > 0 ? Math.round((totalHints / totalWordsStudied) * 100) : 0; const averageScore = Math.round(testHistory.reduce((sum, test) => sum + (test.percentage || 0), 0) / totalTests); const bestScore = Math.max(...testHistory.map(test => test.percentage || 0)); const worstScore = Math.min(...testHistory.map(test => test.percentage || 100)); const chapterPerformance = {}; testHistory.forEach(test => { if (test.chapterStats) { Object.entries(test.chapterStats).forEach(([chapter, stats]) => { if (!chapterPerformance[chapter]) { chapterPerformance[chapter] = { totalTests: 0, totalWords: 0, totalCorrect: 0, totalIncorrect: 0, totalHints: 0, averagePercentage: 0, bestPercentage: 0, worstPercentage: 100, hintsPercentage: 0 }; } const perf = chapterPerformance[chapter]; perf.totalTests += 1; perf.totalWords += stats.totalWords || 0; perf.totalCorrect += stats.correctWords || 0; perf.totalIncorrect += stats.incorrectWords || 0; perf.totalHints += stats.hintsUsed || 0; perf.bestPercentage = Math.max(perf.bestPercentage, stats.percentage || 0); perf.worstPercentage = Math.min(perf.worstPercentage, stats.percentage || 100); }); } }); Object.keys(chapterPerformance).forEach(chapter => { const perf = chapterPerformance[chapter]; perf.averagePercentage = perf.totalWords > 0 ? Math.round((perf.totalCorrect / perf.totalWords) * 100) : 0; perf.hintsPercentage = perf.totalWords > 0 ? Math.round((perf.totalHints / perf.totalWords) * 100) : 0; }); return { totalTests, averageScore, bestScore, worstScore, totalWordsStudied, totalCorrect, totalIncorrect, totalHints, hintsPercentage, chaptersAnalyzed: Object.keys(chapterPerformance).length, chapterPerformance }; }, [testHistory]); const timelineData = useMemo(() => { return [...testHistory].reverse().slice(-20).map((test, index) => ({ test: `Test ${index + 1}`, percentage: test.percentage || 0, correct: test.correctWords || 0, incorrect: test.incorrectWords || 0, hints: test.hintsUsed || 0, avgTime: test.avgTimePerWord || 0, date: new Date(test.timestamp).toLocaleDateString('it-IT'), time: new Date(test.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }), chapters: test.testParameters?.selectedChapters?.length || 0, difficulty: test.difficulty || 'medium', type: test.testType || 'unknown' })); }, [testHistory]); const chapterComparisonData = useMemo(() => { return Object.entries(advancedStats.chapterPerformance).map(([chapter, perf]) => ({ chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`, fullChapter: chapter, accuracy: perf.averagePercentage, tests: perf.totalTests, words: perf.totalWords, hints: perf.hintsPercentage, efficiency: Math.max(0, perf.averagePercentage - perf.hintsPercentage), trend: perf.bestPercentage - perf.worstPercentage })).sort((a, b) => b.accuracy - a.accuracy); }, [advancedStats]); return { advancedStats, timelineData, chapterComparisonData }; };

================================================================================

NOME FILE: stats\sections\ChaptersSection.js

import React, { useMemo, useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, LineChart, Line, ComposedChart } from 'recharts'; import { BookOpen, TrendingUp, Award, Target, Info } from 'lucide-react'; const ChaptersSection = ({ testHistory, words, localRefresh }) => { const [selectedChapterForTrend, setSelectedChapterForTrend] = useState(null); const chapterAnalysis = useMemo(() => { const chapterStats = {}; const chapterFirstTestDate = {}; const chapterDetailedHistory = {}; words.forEach(word => { const chapter = word.chapter || 'Senza Capitolo'; if (!chapterStats[chapter]) { chapterStats[chapter] = { totalWords: 0, learnedWords: 0, difficultWords: 0, testsPerformed: 0, totalCorrect: 0, totalIncorrect: 0, totalTestsAnswers: 0, estimatedHints: 0 }; } chapterStats[chapter].totalWords++; if (word.learned) chapterStats[chapter].learnedWords++; if (word.difficult) chapterStats[chapter].difficultWords++; }); testHistory.forEach((test, testIndex) => { const testDate = new Date(test.timestamp); if (test.chapterStats) { Object.entries(test.chapterStats).forEach(([chapter, stats]) => { if (!chapterStats[chapter]) { chapterStats[chapter] = { totalWords: 0, learnedWords: 0, difficultWords: 0, testsPerformed: 0, totalCorrect: 0, totalIncorrect: 0, totalTestsAnswers: 0, estimatedHints: 0 }; } const chapterStat = chapterStats[chapter]; if (!chapterFirstTestDate[chapter] || testDate < chapterFirstTestDate[chapter]) { chapterFirstTestDate[chapter] = testDate; } chapterStat.testsPerformed++; chapterStat.totalCorrect += stats.correctWords || 0; chapterStat.totalIncorrect += stats.incorrectWords || 0; chapterStat.totalTestsAnswers += (stats.correctWords || 0) + (stats.incorrectWords || 0); if (test.hintsUsed > 0) { const totalWordsInAllChapters = Object.values(test.chapterStats) .reduce((sum, chStats) => sum + (chStats.correctWords || 0) + (chStats.incorrectWords || 0), 0); const wordsInThisChapter = (stats.correctWords || 0) + (stats.incorrectWords || 0); if (totalWordsInAllChapters > 0) { const proportionalHints = (test.hintsUsed * wordsInThisChapter) / totalWordsInAllChapters; chapterStat.estimatedHints += proportionalHints; } } if (!chapterDetailedHistory[chapter]) { chapterDetailedHistory[chapter] = []; } chapterDetailedHistory[chapter].push({ date: testDate, accuracy: stats.percentage || 0, correct: stats.correctWords || 0, incorrect: stats.incorrectWords || 0, hints: test.hintsUsed || 0, estimatedChapterHints: chapterStat.estimatedHints, timestamp: test.timestamp, testIndex }); }); } }); const processedData = Object.entries(chapterStats).map(([chapter, data]) => { const totalAnswers = data.totalCorrect + data.totalIncorrect; const accuracy = totalAnswers > 0 ? Math.round((data.totalCorrect / totalAnswers) * 100) : 0; const hintsPercentage = totalAnswers > 0 ? Math.round((data.estimatedHints / totalAnswers) * 100) : 0; const efficiency = Math.max(0, accuracy - hintsPercentage); const completionRate = data.totalWords > 0 ? Math.round((data.learnedWords / data.totalWords) * 100) : 0; const difficultyRate = data.totalWords > 0 ? Math.round((data.difficultWords / data.totalWords) * 100) : 0; const studyProgress = Math.min(100, completionRate + (accuracy / 3)); const firstTestDate = chapterFirstTestDate[chapter] || new Date(); return { chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`, fullChapter: chapter, totalWords: data.totalWords, learnedWords: data.learnedWords, difficultWords: data.difficultWords, testsPerformed: data.testsPerformed, totalAnswers: totalAnswers, accuracy, hintsPercentage, efficiency, completionRate, difficultyRate, studyProgress, estimatedHints: Math.round(data.estimatedHints * 100) / 100, firstTestDate, detailedHistory: chapterDetailedHistory[chapter] || [] }; }).sort((a, b) => { if (a.testsPerformed === 0 && b.testsPerformed === 0) { return a.fullChapter.localeCompare(b.fullChapter); } if (a.testsPerformed === 0) return 1; if (b.testsPerformed === 0) return -1; return a.firstTestDate - b.firstTestDate; }); return { processedData, chapterDetailedHistory }; }, [testHistory, words, localRefresh]); const selectedChapterTrendData = useMemo(() => { if (!selectedChapterForTrend || !chapterAnalysis.chapterDetailedHistory[selectedChapterForTrend]) { return []; } const history = chapterAnalysis.chapterDetailedHistory[selectedChapterForTrend]; const sortedHistory = [...history].sort((a, b) => { const dateA = new Date(a.timestamp); const dateB = new Date(b.timestamp); return dateA.getTime() - dateB.getTime(); }); const recentHistory = sortedHistory.slice(-15); return recentHistory.map((entry, index) => ({ testNumber: `Test ${index + 1}`, date: entry.date.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit' }), accuracy: entry.accuracy, correct: entry.correct, incorrect: entry.incorrect, fullDate: entry.date.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }), timestamp: entry.timestamp })); }, [selectedChapterForTrend, chapterAnalysis.chapterDetailedHistory]); const overviewStats = useMemo(() => { const testedChapters = chapterAnalysis.processedData.filter(c => c.testsPerformed > 0); return { totalChapters: chapterAnalysis.processedData.length, testedChapters: testedChapters.length, bestEfficiency: testedChapters.length > 0 ? Math.max(...testedChapters.map(c => c.efficiency)) : 0, averageCompletion: chapterAnalysis.processedData.length > 0 ? Math.round(chapterAnalysis.processedData.reduce((sum, c) => sum + c.completionRate, 0) / chapterAnalysis.processedData.length) : 0, averageAccuracy: testedChapters.length > 0 ? Math.round(testedChapters.reduce((sum, c) => sum + c.accuracy, 0) / testedChapters.length) : 0 }; }, [chapterAnalysis.processedData]); const topChapters = chapterAnalysis.processedData .filter(c => c.testsPerformed > 0) .sort((a, b) => b.efficiency - a.efficiency) .slice(0, 5); const strugglingChapters = chapterAnalysis.processedData .filter(c => c.testsPerformed > 2) .sort((a, b) => a.efficiency - b.efficiency) .slice(0, 3); const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#06B6D4', '#84CC16']; return ( <div className="space-y-8" key={`chapters-${localRefresh}`}> } <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <BarChart className="w-6 h-6" /> Analisi Performance Dettagliata per Capitolo </CardTitle> <div className="text-blue-100 text-sm space-y-1"> <p><strong>Efficienza = Precisione - Aiuti utilizzati.</strong> Verde = Ottimo, Giallo = Buono, Rosso = Da migliorare</p> <p>📊 Aiuti stimati proporzionalmente dai test. Capitoli ordinati per primo test cronologico.</p> </div> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={400}> <ComposedChart data={chapterAnalysis.processedData.filter(c => c.testsPerformed > 0)} margin={{ top: 20, right: 30, left: 20, bottom: 5 }} > <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" /> <XAxis dataKey="chapter" tick={{ fontSize: 12 }} /> <YAxis domain={[0, 100]} tick={{ fontSize: 12 }} /> <Tooltip formatter={(value, name) => [ `${value}%`, name === 'accuracy' ? 'Precisione' : name === 'hintsPercentage' ? 'Aiuti Stimati' : name === 'efficiency' ? 'Efficienza Netta' : name === 'completionRate' ? 'Completamento' : name ]} labelFormatter={(label) => `Capitolo: ${label}`} contentStyle={{ backgroundColor: '#f8fafc', border: '1px solid #e2e8f0' }} labelStyle={{ fontWeight: 'bold' }} /> <Bar dataKey="accuracy" fill="#3b82f6" name="accuracy" /> <Bar dataKey="hintsPercentage" fill="#f59e0b" name="hintsPercentage" /> <Bar dataKey="efficiency" fill="#10b981" name="efficiency" /> <Line type="monotone" dataKey="completionRate" stroke="#8b5cf6" strokeWidth={3} name="completionRate" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-center text-sm"> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-blue-500 rounded"></div> <span>Precisione %</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-yellow-500 rounded"></div> <span>Aiuti Stimati %</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-green-500 rounded"></div> <span>Efficienza Netta</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-purple-500 rounded"></div> <span>Completamento</span> </div> </div> </CardContent> </Card> } <div className="grid grid-cols-1 lg:grid-cols-2 gap-6"> } <Card className="bg-gradient-to-br from-orange-50 to-red-50 border-2 border-orange-200"> <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white"> <CardTitle className="flex items-center gap-3"> <Target className="w-6 h-6" /> 📚 Capitoli da Migliorare </CardTitle> <div className="text-orange-100 text-sm"> Capitoli con almeno 3 test e bassa efficienza </div> </CardHeader> <CardContent className="p-6"> <div className="space-y-4"> {strugglingChapters.length > 0 ? strugglingChapters.map((chapter, index) => ( <div key={chapter.fullChapter} className="p-4 bg-white rounded-xl border border-orange-200"> <div className="flex items-center justify-between mb-3"> <div className="font-bold text-gray-800">{chapter.chapter}</div> <div className="text-xl font-bold text-red-600">{chapter.efficiency}%</div> </div> <div className="grid grid-cols-3 gap-2 text-sm mb-3"> <div className="text-center"> <div className="font-bold text-blue-600">{chapter.accuracy}%</div> <div className="text-blue-700 text-xs">Precisione</div> </div> <div className="text-center"> <div className="font-bold text-orange-600">{chapter.hintsPercentage}%</div> <div className="text-orange-700 text-xs">Aiuti Stimati</div> </div> <div className="text-center"> <div className="font-bold text-purple-600">{chapter.difficultyRate}%</div> <div className="text-purple-700 text-xs">Difficili</div> </div> </div> <div className="text-xs text-gray-600 mb-2"> {chapter.totalAnswers} risposte in {chapter.testsPerformed} test • Aiuti stimati: {chapter.estimatedHints} </div> <div className="p-2 bg-orange-100 rounded-lg"> <p className="text-xs text-orange-800"> 💡 <strong>Suggerimento:</strong> {chapter.hintsPercentage > 30 ? ' Riduci l\'uso degli aiuti.' : ''} {chapter.difficultyRate > 50 ? ' Ripassa le parole difficili.' : ''} {chapter.accuracy < 60 ? ' Concentrati su questo capitolo.' : ''} {chapter.hintsPercentage <= 30 && chapter.difficultyRate <= 50 && chapter.accuracy >= 60 ? ' Continua così, stai migliorando!' : ''} </p> </div> </div> )) : ( <div className="text-center py-8 text-gray-500"> <p>Nessun capitolo in difficoltà</p> <p className="text-sm">Ottimo lavoro! Tutti i capitoli testati hanno buone performance</p> </div> )} </div> </CardContent> </Card> </div>

================================================================================

NOME FILE: stats\sections\OverviewSection.js

import React, { useMemo, useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, AreaChart, Area, BarChart, Bar, PieChart, Pie, Cell, ComposedChart } from 'recharts'; import { TrendingUp, Target, Clock, Lightbulb, Zap, Award, Info } from 'lucide-react'; import { useStatsData } from '../hooks/useStatsData'; const OverviewSection = ({ testHistory, localRefresh }) => { const [showPerformanceExplanation, setShowPerformanceExplanation] = useState(false); const { advancedStats } = useStatsData(testHistory); const buildRealTimelineData = () => { if (!testHistory || testHistory.length === 0) return []; const sortedTests = [...testHistory].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); return sortedTests.map((test, index) => { const testDate = new Date(test.timestamp); let avgTime = 0; if (test.totalTime && test.totalWords) { avgTime = (test.totalTime * 1000) / test.totalWords; } else if (test.wordTimes && test.wordTimes.length > 0) { const totalTime = test.wordTimes.reduce((sum, wt) => sum + (wt.timeSpent || 0), 0); avgTime = totalTime / test.wordTimes.length; } else { const totalWords = test.totalWords || 1; avgTime = totalWords > 50 ? 15000 : totalWords > 20 ? 12000 : 8000; } avgTime = Math.round(avgTime / 1000); let hintsCount = 0; if (test.hintsUsed !== undefined) { hintsCount = test.hintsUsed; } else if (test.wordTimes && test.wordTimes.length > 0) { hintsCount = test.wordTimes.filter(wt => wt.usedHint).length; } const dateLabel = testDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit' }); return { test: `Test ${index + 1}`, date: dateLabel, fullDate: testDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }), timestamp: test.timestamp, percentage: test.percentage || 0, efficiency: Math.max(0, (test.percentage || 0) - (hintsCount * 2)), speed: avgTime ? Math.max(20, 100 - Math.min(80, (avgTime - 5) * 4)) : 50, hintsCount: hintsCount, hints: hintsCount, avgTime: avgTime, correct: test.correctWords || 0, incorrect: test.incorrectWords || 0, totalWords: test.totalWords || 0 }; }); }; const realTimelineData = buildRealTimelineData(); const performanceAnalysis = useMemo(() => { if (realTimelineData.length === 0) return null; const learningVelocity = realTimelineData.length > 5 ? realTimelineData[realTimelineData.length - 1].percentage - realTimelineData[0].percentage : 0; const scores = realTimelineData.map(t => t.percentage); const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length; const variance = scores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / scores.length; const consistency = Math.max(0, 100 - Math.sqrt(variance)); const totalHints = realTimelineData.reduce((sum, t) => sum + (t.hintsCount || 0), 0); const totalAnswers = realTimelineData.reduce((sum, t) => sum + (t.totalWords || 0), 0); const hintEfficiency = totalAnswers > 0 ? Math.max(0, 100 - (totalHints / totalAnswers * 100)) : 100; const validTimes = realTimelineData.filter(t => t.avgTime > 0); const avgResponseTime = validTimes.length > 0 ? validTimes.reduce((sum, t) => sum + t.avgTime, 0) / validTimes.length : 15; const speedRating = avgResponseTime <= 8 ? 'Molto Veloce' : avgResponseTime <= 12 ? 'Veloce' : avgResponseTime <= 18 ? 'Normale' : avgResponseTime <= 25 ? 'Lento' : 'Molto Lento'; const speedScore = avgResponseTime <= 8 ? 100 : avgResponseTime <= 12 ? 85 : avgResponseTime <= 18 ? 70 : avgResponseTime <= 25 ? 55 : 40; const performanceIndex = Math.round( (avgScore * 0.4) + (consistency * 0.25) + (hintEfficiency * 0.2) + (speedScore * 0.15) ); return { learningVelocity: Math.round(learningVelocity * 10) / 10, consistency: Math.round(consistency), hintEfficiency: Math.round(hintEfficiency), avgResponseTime: Math.round(avgResponseTime * 10) / 10, speedRating, speedScore: Math.round(speedScore), performanceIndex, trend: learningVelocity > 0 ? 'Miglioramento' : learningVelocity < 0 ? 'Calo' : 'Stabile', breakdown: { precisione: { value: Math.round(avgScore), weight: 40, contribution: Math.round(avgScore * 0.4) }, consistenza: { value: Math.round(consistency), weight: 25, contribution: Math.round(consistency * 0.25) }, efficienza: { value: Math.round(hintEfficiency), weight: 20, contribution: Math.round(hintEfficiency * 0.2) }, velocita: { value: Math.round(speedScore), weight: 15, contribution: Math.round(speedScore * 0.15) } } }; }, [realTimelineData]); const multiMetricData = useMemo(() => { return realTimelineData.slice(-20).map((item, index) => ({ ...item, test: item.date, testNumber: index + 1, efficiency: Math.max(0, item.percentage - (item.hintsCount * 2)), speed: item.speed, consistency: item.percentage, hintsCount: item.hintsCount || 0 })); }, [realTimelineData]); const performanceDistribution = useMemo(() => { const ranges = { excellent: 0, good: 0, average: 0, poor: 0 }; realTimelineData.forEach(test => { if (test.percentage >= 90) ranges.excellent++; else if (test.percentage >= 75) ranges.good++; else if (test.percentage >= 60) ranges.average++; else ranges.poor++; }); const total = realTimelineData.length; return [ { name: 'Eccellente', fullName: 'Eccellente (90%+)', value: ranges.excellent, percentage: total > 0 ? Math.round((ranges.excellent / total) * 100) : 0, color: '#10B981' }, { name: 'Buono', fullName: 'Buono (75-89%)', value: ranges.good, percentage: total > 0 ? Math.round((ranges.good / total) * 100) : 0, color: '#3B82F6' }, { name: 'Medio', fullName: 'Medio (60-74%)', value: ranges.average, percentage: total > 0 ? Math.round((ranges.average / total) * 100) : 0, color: '#F59E0B' }, { name: 'Da migliorare', fullName: 'Da migliorare (<60%)', value: ranges.poor, percentage: total > 0 ? Math.round((ranges.poor / total) * 100) : 0, color: '#EF4444' } ].filter(item => item.value > 0); }, [realTimelineData]); const weeklyPattern = useMemo(() => { const pattern = {}; realTimelineData.forEach(test => { const date = new Date(test.timestamp); const dayOfWeek = date.toLocaleDateString('it-IT', { weekday: 'short' }); if (!pattern[dayOfWeek]) { pattern[dayOfWeek] = { tests: 0, totalScore: 0 }; } pattern[dayOfWeek].tests++; pattern[dayOfWeek].totalScore += test.percentage; }); return Object.entries(pattern).map(([day, data]) => ({ day, tests: data.tests, avgScore: Math.round(data.totalScore / data.tests), frequency: data.tests })).sort((a, b) => { const dayOrder = ['lun', 'mar', 'mer', 'gio', 'ven', 'sab', 'dom']; return dayOrder.indexOf(a.day) - dayOrder.indexOf(b.day); }); }, [realTimelineData]); if (!performanceAnalysis) { return ( <div className="text-center py-16 text-gray-500"> <Target className="w-16 h-16 mx-auto mb-4 opacity-50" /> <p>Completa alcuni test per vedere le metriche performance</p> </div> ); } return ( <div className="space-y-8" key={`overview-${localRefresh}`}> } <div className="flex justify-between items-start mb-6"> <div className="text-center flex-1"> <h2 className="text-3xl font-bold mb-2">Performance Index</h2> <div className="text-6xl font-bold mb-2">{performanceAnalysis.performanceIndex}</div> <div className="text-xl opacity-90"> {performanceAnalysis.performanceIndex >= 85 ? '🏆 Eccellente!' : performanceAnalysis.performanceIndex >= 70 ? '👍 Molto Buono' : performanceAnalysis.performanceIndex >= 55 ? '📈 In Crescita' : '📚 Da Migliorare'} </div> </div> } <div className={`overflow-hidden transition-all duration-500 ease-in-out ${ showPerformanceExplanation ? 'max-h-96 opacity-100' : 'max-h-0 opacity-0' }`}> <div className="bg-white/10 rounded-xl p-4 backdrop-blur-sm"> <h4 className="font-bold text-white mb-3 flex items-center gap-2"> <Info className="w-5 h-5" /> 📊 Come viene calcolato il Performance Index </h4> <div className="text-white/90 text-sm space-y-2"> <div className="grid grid-cols-1 md:grid-cols-2 gap-4"> <div> <p className="font-medium mb-2">Formula di calcolo:</p> <div className="bg-white/10 rounded p-2 font-mono text-xs"> Index = (Precisione × 40%) + (Consistenza × 25%) + (Efficienza × 20%) + (Velocità × 15%) </div> </div> <div> <p className="font-medium mb-2">Il tuo calcolo:</p> <div className="space-y-1 text-xs"> <div>{performanceAnalysis.breakdown.precisione.value}% × 40% = {performanceAnalysis.breakdown.precisione.contribution} punti</div> <div>{performanceAnalysis.breakdown.consistenza.value}% × 25% = {performanceAnalysis.breakdown.consistenza.contribution} punti</div> <div>{performanceAnalysis.breakdown.efficienza.value}% × 20% = {performanceAnalysis.breakdown.efficienza.contribution} punti</div> <div>{performanceAnalysis.breakdown.velocita.value}% × 15% = {performanceAnalysis.breakdown.velocita.contribution} punti</div> <div className="border-t border-white/20 pt-1 font-bold"> Totale = {performanceAnalysis.performanceIndex} punti </div> </div> </div> </div> <div className="mt-3 text-xs bg-white/10 rounded p-2"> <strong>💡 Significato delle metriche:</strong><br/> • <strong>Precisione:</strong> Media dei punteggi di tutti i test<br/> • <strong>Consistenza:</strong> Quanto stabili sono le tue performance (100 - deviazione standard)<br/> • <strong>Efficienza:</strong> Quanto bene rispondi senza aiuti (100 - % aiuti utilizzati)<br/> • <strong>Velocità:</strong> Score basato sul tempo medio di risposta ({performanceAnalysis.avgResponseTime}s = {performanceAnalysis.speedRating}) </div> </div> </div> </div> } <Card className="bg-white dark:bg-gray-800 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <TrendingUp className="w-6 h-6" /> Andamento Multi-Metrica (Ultimi {multiMetricData.length} Test) </CardTitle> <p className="text-blue-100 text-sm"> Monitoraggio di precisione, efficienza, velocità REALE e aiuti nel tempo </p> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={350}> <ComposedChart data={multiMetricData}> <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" /> <XAxis dataKey="test" tick={{ fontSize: 10 }} interval={Math.ceil(multiMetricData.length / 8)} angle={-45} textAnchor="end" height={60} /> <YAxis yAxisId="left" domain={[0, 100]} tick={{ fontSize: 12 }} label={{ value: 'Percentuale (%)', angle: -90, position: 'insideLeft' }} /> <YAxis yAxisId="right" orientation="right" domain={[0, 'dataMax + 2']} tick={{ fontSize: 12 }} label={{ value: 'Aiuti', angle: 90, position: 'insideRight' }} /> <Tooltip formatter={(value, name) => { if (name === 'hintsCount') { return [`${value} aiuti`, 'Aiuti Utilizzati']; } return [ `${Math.round(value)}%`, name === 'percentage' ? 'Precisione' : name === 'efficiency' ? 'Efficienza' : name === 'speed' ? 'Velocità Reale' : name ]; }} labelFormatter={(label, payload) => { const data = payload?.[0]?.payload; return data ? `${label} (${data.fullDate})` : label; }} contentStyle={{ backgroundColor: '#f8fafc', border: '1px solid #e2e8f0' }} /> } <Line yAxisId="left" type="monotone" dataKey="efficiency" stroke="#10b981" strokeWidth={2} name="efficiency" /> } <Line yAxisId="right" type="monotone" dataKey="hintsCount" stroke="#f59e0b" strokeWidth={3} strokeDasharray="5 5" dot={{ fill: '#f59e0b', strokeWidth: 2, r: 4 }} name="hintsCount" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-center text-sm"> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-blue-500 rounded"></div> <span>Precisione (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-green-500 rounded"></div> <span>Efficienza (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-purple-500 rounded"></div> <span>Velocità Reale (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 border-2 border-yellow-500 bg-white rounded"></div> <span>Aiuti (linea tratteggiata)</span> </div> </div> } <div className="mt-6 p-4 bg-orange-50 rounded-xl border border-orange-200"> <h4 className="font-bold text-orange-800 mb-2 flex items-center gap-2"> <Lightbulb className="w-5 h-5" /> Analisi Utilizzo Aiuti (Dati Reali) </h4> <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm"> <div className="text-center"> <div className="text-lg font-bold text-orange-600"> {multiMetricData.reduce((sum, t) => sum + t.hintsCount, 0)} </div> <div className="text-orange-700">Aiuti Totali</div> </div> <div className="text-center"> <div className="text-lg font-bold text-orange-600">{Math.round(100 - performanceAnalysis.hintEfficiency)}%</div> <div className="text-orange-700">% Risposte con Aiuto</div> </div> <div className="text-center"> <div className="text-lg font-bold text-orange-600"> {multiMetricData.length > 0 ? Math.round(multiMetricData.reduce((sum, t) => sum + t.hintsCount, 0) / multiMetricData.length * 10) / 10 : 0} </div> <div className="text-orange-700">Media Aiuti/Test</div> </div> <div className="text-center"> <div className="text-lg font-bold text-orange-600">{performanceAnalysis.hintEfficiency}%</div> <div className="text-orange-700">Efficienza Aiuti</div> </div> </div> <div className="mt-3 text-xs text-orange-600"> 💡 <strong>Suggerimento:</strong> Un uso efficiente degli aiuti è sopra l'80% di efficienza. Gli aiuti dovrebbero diminuire con l'esperienza. </div> </div> </CardContent> </Card> <div className="grid grid-cols-1 lg:grid-cols-2 gap-8"> } <div className="mt-4 space-y-2"> {performanceDistribution.map((item, index) => ( <div key={index} className="flex items-center justify-between text-sm p-2 rounded-lg" style={{ backgroundColor: `${item.color}15` }}> <div className="flex items-center gap-3"> <div className="w-4 h-4 rounded-full" style={{ backgroundColor: item.color }}></div> <span className="font-medium">{item.fullName}</span> </div> <div className="text-right"> <div className="font-bold" style={{ color: item.color }}>{item.value} test</div> <div className="text-xs text-gray-500 dark:text-gray-400">{item.percentage}% del totale</div> </div> </div> ))} </div> } <Card className="bg-white dark:bg-gray-800 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <Zap className="w-6 h-6" /> Metriche Performance Avanzate </CardTitle> </CardHeader> <CardContent className="p-6"> <div className="space-y-6"> } <div> <div className="flex justify-between items-center mb-2"> <span className="font-medium text-gray-700 dark:text-gray-300">Consistenza</span> <span className="font-bold text-blue-600">{performanceAnalysis.consistency}%</span> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className="h-2 rounded-full bg-blue-500" style={{ width: `${performanceAnalysis.consistency}%` }} ></div> </div> <div className="text-xs text-gray-500 dark:text-gray-400 mt-1"> {performanceAnalysis.consistency >= 80 ? 'Molto stabile' : performanceAnalysis.consistency >= 60 ? 'Abbastanza costante' : 'Variabile'} </div> </div> } <div> <div className="flex justify-between items-center mb-2"> <span className="font-medium text-gray-700 dark:text-gray-300">Efficienza Aiuti</span> <span className="font-bold text-orange-600">{performanceAnalysis.hintEfficiency}%</span> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className="h-2 rounded-full bg-orange-500" style={{ width: `${performanceAnalysis.hintEfficiency}%` }} ></div> </div> <div className="text-xs text-gray-500 dark:text-gray-400 mt-1"> {Math.round(100 - performanceAnalysis.hintEfficiency)}% aiuti utilizzati di media </div> </div> </div> } {weeklyPattern.length > 0 && ( <Card className="bg-white dark:bg-gray-800 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-cyan-500 to-blue-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <Clock className="w-6 h-6" /> Pattern Settimanale di Studio </CardTitle> <p className="text-cyan-100 text-sm"> Analisi dei giorni della settimana più produttivi </p> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={250}> <ComposedChart data={weeklyPattern}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="day" /> <YAxis yAxisId="left" orientation="left" /> <YAxis yAxisId="right" orientation="right" /> <Tooltip formatter={(value, name) => [ name === 'avgScore' ? `${value}%` : `${value} test`, name === 'avgScore' ? 'Punteggio Medio' : 'Numero Test' ]} /> <Bar yAxisId="left" dataKey="tests" fill="#06b6d4" name="tests" /> <Line yAxisId="right" type="monotone" dataKey="avgScore" stroke="#3b82f6" strokeWidth={3} name="avgScore" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm"> <div className="text-center p-3 bg-cyan-50 rounded-xl"> <div className="font-bold text-cyan-600"> {weeklyPattern.reduce((max, day) => day.tests > max.tests ? day : max, weeklyPattern[0])?.day || 'N/A'} </div> <div className="text-cyan-700 text-xs">Giorno più attivo</div> </div> <div className="text-center p-3 bg-blue-50 rounded-xl"> <div className="font-bold text-blue-600"> {weeklyPattern.reduce((max, day) => day.avgScore > max.avgScore ? day : max, weeklyPattern[0])?.day || 'N/A'} </div> <div className="text-blue-700 text-xs">Giorno migliore</div> </div> <div className="text-center p-3 bg-green-50 rounded-xl"> <div className="font-bold text-green-600"> {Math.round(weeklyPattern.reduce((sum, day) => sum + day.avgScore, 0) / weeklyPattern.length)}% </div> <div className="text-green-700 text-xs">Media settimanale</div> </div> <div className="text-center p-3 bg-purple-50 rounded-xl"> <div className="font-bold text-purple-600"> {weeklyPattern.reduce((sum, day) => sum + day.tests, 0)} </div> <div className="text-purple-700 text-xs">Test totali</div> </div> </div> </CardContent> </Card> )} </div> ); }; export default OverviewSection;

================================================================================

NOME FILE: stats\sections\PerformanceSection.js

import React, { useMemo } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Radar, LineChart, Line, ComposedChart, ScatterChart, Scatter } from 'recharts'; import { Trophy, Lightbulb, Zap, Clock, Target, TrendingUp } from 'lucide-react'; import { useStatsData } from '../hooks/useStatsData'; const usePerformanceData = (testHistory) => { return useMemo(() => { if (testHistory.length === 0) return []; return [...testHistory].reverse().slice(-20).map((test, index) => { const totalWords = (test.correctWords || 0) + (test.incorrectWords || 0); let avgTimePerWord = 0; if (test.totalTime && totalWords > 0) { avgTimePerWord = Math.round((test.totalTime / totalWords) * 10) / 10; } else if (totalWords > 0) { const baseTime = 8; const difficultyMultiplier = test.difficulty === 'hard' ? 1.5 : test.difficulty === 'easy' ? 0.7 : 1.0; const performanceMultiplier = test.percentage < 50 ? 1.8 : test.percentage < 70 ? 1.3 : test.percentage < 85 ? 1.0 : 0.8; const hintsMultiplier = (test.hintsUsed || 0) > 0 ? 1.2 : 1.0; avgTimePerWord = Math.round(baseTime * difficultyMultiplier * performanceMultiplier * hintsMultiplier * 10) / 10; } return { test: `Test ${index + 1}`, percentage: test.percentage || 0, correct: test.correctWords || 0, incorrect: test.incorrectWords || 0, hints: test.hintsUsed || 0, avgTime: avgTimePerWord, date: new Date(test.timestamp).toLocaleDateString('it-IT'), time: new Date(test.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }), chapters: test.testParameters?.selectedChapters?.length || 0, difficulty: test.difficulty || 'medium', type: test.testType || 'unknown', totalWords: totalWords, hasRealTime: !!(test.totalTime), isEstimated: !test.totalTime }; }); }, [testHistory]); }; const calculateBestStreak = (data) => { let currentStreak = 0; let bestStreak = 0; const threshold = 75; data.forEach(test => { if (test.percentage >= threshold) { currentStreak++; bestStreak = Math.max(bestStreak, currentStreak); } else { currentStreak = 0; } }); return bestStreak; }; const calculateDifficultyHandling = (history) => { const hardTests = history.filter(test => (test.totalWords || 0) >= 20); if (hardTests.length === 0) return 70; const hardTestsAvg = hardTests.reduce((sum, test) => sum + (test.percentage || 0), 0) / hardTests.length; return Math.min(100, hardTestsAvg + 10); }; const calculateOverallRating = (accuracy, consistency, hintEff, speed) => { const weighted = (accuracy * 0.4) + (consistency * 0.25) + (hintEff * 0.2) + (speed * 0.15); return Math.round(weighted); }; const PerformanceSection = ({ testHistory, localRefresh }) => { const { advancedStats } = useStatsData(testHistory); const performanceTimelineData = usePerformanceData(testHistory); const performanceMetrics = useMemo(() => { if (testHistory.length === 0) return null; const recentTests = performanceTimelineData.slice(-10); const oldTests = performanceTimelineData.slice(0, Math.min(10, performanceTimelineData.length - 10)); const recentAvg = recentTests.reduce((sum, t) => sum + t.percentage, 0) / Math.max(1, recentTests.length); const oldAvg = oldTests.length > 0 ? oldTests.reduce((sum, t) => sum + t.percentage, 0) / oldTests.length : recentAvg; const improvementTrend = recentAvg - oldAvg; const scores = performanceTimelineData.map(t => t.percentage); const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length; const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length; const consistency = Math.max(0, 100 - Math.sqrt(variance)); const totalHints = performanceTimelineData.reduce((sum, t) => sum + (t.hints || 0), 0); const totalQuestions = performanceTimelineData.reduce((sum, t) => sum + (t.correct || 0) + (t.incorrect || 0), 0); const hintEfficiency = totalQuestions > 0 ? Math.max(0, 100 - (totalHints / totalQuestions * 100)) : 100; const avgSpeed = performanceTimelineData.reduce((sum, t) => sum + (t.avgTime || 0), 0) / Math.max(1, performanceTimelineData.length); const speedScore = avgSpeed <= 8 ? 100 : avgSpeed <= 15 ? 80 : avgSpeed <= 25 ? 60 : 40; const bestStreak = calculateBestStreak(performanceTimelineData); const learningVelocity = performanceTimelineData.length > 5 ? (performanceTimelineData.slice(-5).reduce((sum, t) => sum + t.percentage, 0) / 5) - (performanceTimelineData.slice(0, 5).reduce((sum, t) => sum + t.percentage, 0) / 5) : 0; const difficultyScore = calculateDifficultyHandling(testHistory); return { accuracy: Math.round(advancedStats.averageScore), consistency: Math.round(consistency), hintEfficiency: Math.round(hintEfficiency), speedScore: Math.round(speedScore), improvementTrend: Math.round(improvementTrend * 10) / 10, learningVelocity: Math.round(learningVelocity * 10) / 10, bestStreak, difficultyScore: Math.round(difficultyScore), avgSpeed: Math.round(avgSpeed * 10) / 10, recentPerformance: Math.round(recentAvg), overallRating: calculateOverallRating(advancedStats.averageScore, consistency, hintEfficiency, speedScore), realTimePercentage: Math.round((performanceTimelineData.filter(t => t.hasRealTime).length / performanceTimelineData.length) * 100) }; }, [testHistory, performanceTimelineData, advancedStats]); const radarData = useMemo(() => { if (!performanceMetrics) return []; return [ { metric: 'Precisione', value: performanceMetrics.accuracy, fullMark: 100 }, { metric: 'Consistenza', value: performanceMetrics.consistency, fullMark: 100 }, { metric: 'Efficienza', value: performanceMetrics.hintEfficiency, fullMark: 100 }, { metric: 'Velocità', value: performanceMetrics.speedScore, fullMark: 100 }, { metric: 'Gestione Difficoltà', value: performanceMetrics.difficultyScore, fullMark: 100 } ]; }, [performanceMetrics]); const improvementData = useMemo(() => { const windows = []; const windowSize = 5; for (let i = 0; i <= performanceTimelineData.length - windowSize; i += 2) { const window = performanceTimelineData.slice(i, i + windowSize); const avgScore = window.reduce((sum, t) => sum + t.percentage, 0) / windowSize; const avgHints = window.reduce((sum, t) => sum + (t.hints || 0), 0) / windowSize; const avgSpeed = window.reduce((sum, t) => sum + (t.avgTime || 0), 0) / windowSize; windows.push({ period: `Test ${i + 1}-${i + windowSize}`, accuracy: Math.round(avgScore), efficiency: Math.max(0, Math.round(avgScore - (avgHints / window.reduce((sum, t) => sum + t.totalWords, 0) * 100))), speed: avgSpeed > 0 ? Math.round(Math.max(0, 100 - Math.min(100, avgSpeed * 3))) : 50 }); } return windows; }, [performanceTimelineData]); const difficultyAnalysis = useMemo(() => { const analysis = { easy: [], medium: [], hard: [] }; testHistory.forEach(test => { const totalWords = test.totalWords || 0; let category = 'easy'; if (totalWords >= 30) category = 'hard'; else if (totalWords >= 15) category = 'medium'; analysis[category].push({ percentage: test.percentage || 0, hints: test.hintsUsed || 0, words: totalWords }); }); return Object.entries(analysis).map(([difficulty, tests]) => { if (tests.length === 0) return null; const avgPercentage = tests.reduce((sum, t) => sum + t.percentage, 0) / tests.length; const avgHints = tests.reduce((sum, t) => sum + t.hints, 0) / tests.length; const totalWords = tests.reduce((sum, t) => sum + t.words, 0); return { difficulty: difficulty.charAt(0).toUpperCase() + difficulty.slice(1), count: tests.length, avgScore: Math.round(avgPercentage), avgHints: Math.round(avgHints * 10) / 10, efficiency: Math.round(avgPercentage - (avgHints / totalWords * 100 * tests.length)) }; }).filter(Boolean); }, [testHistory]); if (!performanceMetrics) { return ( <div className="text-center py-16 text-gray-500"> <Trophy className="w-16 h-16 mx-auto mb-4 opacity-50" /> <p>Completa alcuni test per vedere l'analisi performance</p> </div> ); } return ( <div className="space-y-8" key={`performance-${localRefresh}`}> } {performanceMetrics.realTimePercentage < 100 && ( <div className="mt-2 text-sm text-white/70"> ⏱️ Tempi stimati per {100 - performanceMetrics.realTimePercentage}% dei test </div> )} </div> <div className="grid grid-cols-2 md:grid-cols-5 gap-4"> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Trophy className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.accuracy}%</div> <div className="text-white/80 text-sm">Precisione</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Target className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.consistency}%</div> <div className="text-white/80 text-sm">Consistenza</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Lightbulb className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.hintEfficiency}%</div> <div className="text-white/80 text-sm">Efficienza</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Clock className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.speedScore}%</div> <div className="text-white/80 text-sm">Velocità</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Zap className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.bestStreak}</div> <div className="text-white/80 text-sm">Best Streak</div> </div> </div> </CardContent> </Card> <div className="grid grid-cols-1 lg:grid-cols-2 gap-8"> } <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <TrendingUp className="w-6 h-6" /> Trend di Miglioramento </CardTitle> </CardHeader> <CardContent className="p-6"> {improvementData.length > 1 ? ( <> <ResponsiveContainer width="100%" height={250}> <LineChart data={improvementData}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="period" tick={{ fontSize: 10 }} /> <YAxis domain={[0, 100]} /> <Tooltip /> <Line type="monotone" dataKey="accuracy" stroke="#10b981" strokeWidth={3} name="Precisione" /> <Line type="monotone" dataKey="efficiency" stroke="#3b82f6" strokeWidth={2} name="Efficienza" /> <Line type="monotone" dataKey="speed" stroke="#8b5cf6" strokeWidth={2} name="Velocità" /> </LineChart> </ResponsiveContainer> <div className="mt-4 text-center"> <div className={`text-lg font-bold ${ performanceMetrics.learningVelocity > 0 ? 'text-green-600' : performanceMetrics.learningVelocity < 0 ? 'text-red-600' : 'text-gray-600' }`}> Velocità di Apprendimento: {performanceMetrics.learningVelocity > 0 ? '+' : ''}{performanceMetrics.learningVelocity}% </div> <div className="text-sm text-gray-600"> {performanceMetrics.learningVelocity > 5 ? '🚀 Progressi rapidi!' : performanceMetrics.learningVelocity > 0 ? '📈 In miglioramento' : performanceMetrics.learningVelocity === 0 ? '➖ Stabile' : '📉 In calo'} </div> </div> </> ) : ( <div className="text-center py-8 text-gray-500"> <p>Completa più test per vedere i trend</p> </div> )} </CardContent> </Card> </div> } <Card className="bg-gradient-to-r from-cyan-50 to-blue-50 border-2 border-cyan-200"> <CardHeader className="bg-gradient-to-r from-cyan-500 to-blue-500 text-white"> <CardTitle className="flex items-center gap-3"> <Trophy className="w-6 h-6" /> 📊 Insights Performance Dettagliati </CardTitle> </CardHeader> <CardContent className="p-6"> <div className="grid grid-cols-1 md:grid-cols-2 gap-6"> } <div> <h4 className="font-bold text-orange-800 mb-3 flex items-center gap-2"> 📈 Aree di Miglioramento </h4> <div className="space-y-2 text-sm"> {performanceMetrics.accuracy < 70 && ( <p className="text-orange-700">⚠️ Precisione da migliorare ({performanceMetrics.accuracy}%)</p> )} {performanceMetrics.consistency < 60 && ( <p className="text-orange-700">⚠️ Performance troppo variabili - punta alla consistenza</p> )} {performanceMetrics.hintEfficiency < 70 && ( <p className="text-orange-700">⚠️ Uso eccessivo degli aiuti - prova a rispondere autonomamente</p> )} {performanceMetrics.speedScore < 60 && ( <p className="text-orange-700">⚠️ Tempi di risposta lenti - pratica per migliorare la velocità</p> )} {performanceMetrics.improvementTrend < -2 && ( <p className="text-orange-700">⚠️ Trend in calo ({performanceMetrics.improvementTrend}%) - rivedi la strategia di studio</p> )} {performanceMetrics.bestStreak < 3 && ( <p className="text-orange-700">⚠️ Mancanza di consistenza - concentrati sui fondamentali</p> )} </div> </div> </div>

================================================================================

NOME FILE: stats\sections\TrendsSection.js

import React, { useMemo } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, AreaChart, Area, BarChart, Bar, ComposedChart } from 'recharts'; import { Clock, Sparkles, TrendingUp, TrendingDown, Target, Lightbulb } from 'lucide-react'; import { useStatsData } from '../hooks/useStatsData'; const TrendsSection = ({ testHistory, localRefresh }) => { const { advancedStats, timelineData } = useStatsData(testHistory); const trendAnalysis = useMemo(() => { if (timelineData.length < 3) return null; const recent = timelineData.slice(-5); const previous = timelineData.slice(-10, -5); const early = timelineData.slice(0, 5); const calculateAverage = (data, field) => { const values = data.map(item => item[field] || 0).filter(v => v > 0); return values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0; }; const recentAvg = { accuracy: calculateAverage(recent, 'percentage'), hints: calculateAverage(recent, 'hints'), speed: calculateAverage(recent, 'avgTime') }; const previousAvg = { accuracy: calculateAverage(previous, 'percentage'), hints: calculateAverage(previous, 'hints'), speed: calculateAverage(previous, 'avgTime') }; const earlyAvg = { accuracy: calculateAverage(early, 'percentage'), hints: calculateAverage(early, 'hints'), speed: calculateAverage(early, 'avgTime') }; const accuracyTrend = previous.length > 0 ? recentAvg.accuracy - previousAvg.accuracy : 0; const hintsTrend = previous.length > 0 ? recentAvg.hints - previousAvg.hints : 0; const speedTrend = previous.length > 0 ? previousAvg.speed - recentAvg.speed : 0; const longTermAccuracyTrend = early.length > 0 ? recentAvg.accuracy - earlyAvg.accuracy : 0; const longTermHintsTrend = early.length > 0 ? earlyAvg.hints - recentAvg.hints : 0; const longTermSpeedTrend = early.length > 0 ? earlyAvg.speed - recentAvg.speed : 0; return { recent: recentAvg, previous: previousAvg, early: earlyAvg, shortTerm: { accuracy: accuracyTrend, hints: hintsTrend, speed: speedTrend }, longTerm: { accuracy: longTermAccuracyTrend, hints: longTermHintsTrend, speed: longTermSpeedTrend } }; }, [timelineData]); const monthlyTrends = useMemo(() => { const monthlyData = {}; testHistory.forEach(test => { const date = new Date(test.timestamp); const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`; if (!monthlyData[monthKey]) { monthlyData[monthKey] = { month: monthKey, tests: 0, totalAccuracy: 0, totalHints: 0, totalTime: 0 }; } monthlyData[monthKey].tests++; monthlyData[monthKey].totalAccuracy += test.percentage || 0; monthlyData[monthKey].totalHints += test.hintsUsed || 0; monthlyData[monthKey].totalTime += test.avgTimePerWord || 0; }); return Object.values(monthlyData).map(month => ({ ...month, avgAccuracy: Math.round(month.totalAccuracy / month.tests), avgHints: Math.round((month.totalHints / month.tests) * 10) / 10, avgTime: Math.round((month.totalTime / month.tests) * 10) / 10, efficiency: Math.round((month.totalAccuracy / month.tests) - (month.totalHints / month.tests)) })).sort((a, b) => a.month.localeCompare(b.month)); }, [testHistory]); const hourlyPattern = useMemo(() => { const hourlyData = {}; testHistory.forEach(test => { const hour = new Date(test.timestamp).getHours(); const timeSlot = hour < 6 ? 'Notte (0-6)' : hour < 12 ? 'Mattina (6-12)' : hour < 18 ? 'Pomeriggio (12-18)' : 'Sera (18-24)'; if (!hourlyData[timeSlot]) { hourlyData[timeSlot] = { timeSlot, tests: 0, totalAccuracy: 0, totalHints: 0 }; } hourlyData[timeSlot].tests++; hourlyData[timeSlot].totalAccuracy += test.percentage || 0; hourlyData[timeSlot].totalHints += test.hintsUsed || 0; }); return Object.values(hourlyData).map(slot => ({ ...slot, avgAccuracy: Math.round(slot.totalAccuracy / slot.tests), avgHints: Math.round((slot.totalHints / slot.tests) * 10) / 10 })).sort((a, b) => { const order = ['Mattina (6-12)', 'Pomeriggio (12-18)', 'Sera (18-24)', 'Notte (0-6)']; return order.indexOf(a.timeSlot) - order.indexOf(b.timeSlot); }); }, [testHistory]); if (timelineData.length < 3) { return ( <div className="text-center py-16 text-gray-500"> <Clock className="w-16 h-16 mx-auto mb-4 opacity-50" /> <p>Completa almeno 3 test per vedere le analisi delle tendenze</p> </div> ); } return ( <div className="space-y-8" key={`trends-${localRefresh}`}> } <Area yAxisId="left" type="monotone" dataKey="percentage" fill="#8b5cf6" fillOpacity={0.3} stroke="#8b5cf6" strokeWidth={3} name="percentage" /> } <Line yAxisId="right" type="monotone" dataKey="avgTime" stroke="#06b6d4" strokeWidth={2} name="avgTime" strokeDasharray="5 5" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4 text-center text-sm"> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-purple-500 rounded"></div> <span>Precisione (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-yellow-500 rounded"></div> <span>Aiuti (numero)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 border-2 border-cyan-500 bg-white rounded"></div> <span>Tempo Medio (secondi)</span> </div> </div> </CardContent> </Card> } <Card className="bg-gradient-to-br from-blue-50 to-cyan-50 border-2 border-blue-200"> <CardHeader className="bg-gradient-to-r from-blue-500 to-cyan-500 text-white"> <CardTitle className="flex items-center gap-3"> <TrendingUp className="w-6 h-6" /> Tendenze Recenti (Ultimi 5 vs 5 Precedenti) </CardTitle> </CardHeader> <CardContent className="p-6"> <div className="space-y-4"> <div className="flex justify-between items-center p-3 bg-white rounded-xl"> <span className="font-medium">Precisione</span> <div className="flex items-center gap-2"> <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.accuracy)}%</span> <span className={`text-sm font-bold ${ trendAnalysis.shortTerm.accuracy > 2 ? 'text-green-600' : trendAnalysis.shortTerm.accuracy < -2 ? 'text-red-600' : 'text-gray-600' }`}> {trendAnalysis.shortTerm.accuracy > 0 ? '↗' : trendAnalysis.shortTerm.accuracy < 0 ? '↘' : '→'} {Math.abs(Math.round(trendAnalysis.shortTerm.accuracy * 10) / 10)}% </span> </div> </div> <div className="flex justify-between items-center p-3 bg-white rounded-xl"> <span className="font-medium">Aiuti per Test</span> <div className="flex items-center gap-2"> <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.hints * 10) / 10}</span> <span className={`text-sm font-bold ${ trendAnalysis.shortTerm.hints < -0.5 ? 'text-green-600' : trendAnalysis.shortTerm.hints > 0.5 ? 'text-red-600' : 'text-gray-600' }`}> {trendAnalysis.shortTerm.hints < 0 ? '↘' : trendAnalysis.shortTerm.hints > 0 ? '↗' : '→'} {Math.abs(Math.round(trendAnalysis.shortTerm.hints * 10) / 10)} </span> </div> </div> <div className="flex justify-between items-center p-3 bg-white rounded-xl"> <span className="font-medium">Velocità Media</span> <div className="flex items-center gap-2"> <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.speed * 10) / 10}s</span> <span className={`text-sm font-bold ${ trendAnalysis.shortTerm.speed > 1 ? 'text-green-600' : trendAnalysis.shortTerm.speed < -1 ? 'text-red-600' : 'text-gray-600' }`}> {trendAnalysis.shortTerm.speed > 0 ? '↗' : trendAnalysis.shortTerm.speed < 0 ? '↘' : '→'} {Math.abs(Math.round(trendAnalysis.shortTerm.speed * 10) / 10)}s </span> </div> </div> </div> </CardContent> </Card> } {monthlyTrends.length > 1 && ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <TrendingUp className="w-6 h-6" /> Tendenze Mensili </CardTitle> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={300}> <LineChart data={monthlyTrends}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="month" /> <YAxis /> <Tooltip /> <Line type="monotone" dataKey="avgAccuracy" stroke="#8b5cf6" strokeWidth={3} name="Precisione Media %" /> <Line type="monotone" dataKey="efficiency" stroke="#10b981" strokeWidth={2} name="Efficienza %" /> <Line type="monotone" dataKey="avgHints" stroke="#f59e0b" strokeWidth={2} name="Aiuti Medi" /> </LineChart> </ResponsiveContainer> </CardContent> </Card> )} } <Card className="bg-gradient-to-r from-yellow-50 to-orange-50 border-2 border-yellow-200"> <CardContent className="p-6"> <h3 className="text-xl font-bold text-yellow-800 mb-4 flex items-center gap-2"> <Sparkles className="w-6 h-6" /> Insights e Raccomandazioni Avanzate </h3> <div className="space-y-3 text-yellow-700"> <p>🎯 <strong>Precisione attuale:</strong> {advancedStats.averageScore}% (target: 80%+)</p> <p>💡 <strong>Uso aiuti:</strong> {advancedStats.hintsPercentage}% (ideale: sotto 20%)</p> <p>⚡ <strong>Efficienza netta:</strong> {Math.max(0, advancedStats.averageScore - advancedStats.hintsPercentage)}%</p>

================================================================================

NOME FILE: stats\sections\WordsSection.js

import React, { useState, useMemo, useEffect } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { Button } from '../../ui/button'; import { Input } from '../../ui/input'; import { Search, BookOpen, Filter, CheckSquare, Square, ChevronDown, ChevronUp, AlertTriangle, CheckCircle, Circle, Eye, Maximize2, Minimize2 } from 'lucide-react'; import { useAppContext } from '../../../contexts/AppContext'; import { useNotification } from '../../../contexts/NotificationContext'; import { getCategoryStyle } from '../../../utils/categoryUtils'; import WordDetailSection from '../components/WordDetailSection'; const WordsSection = ({ localRefresh }) => { const [searchWord, setSearchWord] = useState(''); const [filterChapter, setFilterChapter] = useState(''); const [filterLearned, setFilterLearned] = useState('all'); const [filterDifficult, setFilterDifficult] = useState('all'); const [filterGroup, setFilterGroup] = useState(''); const [selectedWordId, setSelectedWordId] = useState(null); const [showFiltersPanel, setShowFiltersPanel] = useState(true); const [internalRefresh, setInternalRefresh] = useState(0); const [collapsedChapters, setCollapsedChapters] = useState({}); const { words, getAllWordsPerformance, getWordAnalysis, testHistory, wordPerformance, toggleWordLearned, toggleWordDifficult } = useAppContext(); const { showSuccess } = useNotification(); useEffect(() => { const handleForceRefresh = () => { setInternalRefresh(prev => prev + 1); }; window.addEventListener('forceStatsRefresh', handleForceRefresh); return () => window.removeEventListener('forceStatsRefresh', handleForceRefresh); }, []); const wordsAnalysis = useMemo(() => { if (!getAllWordsPerformance || !words) { return []; } const performanceData = getAllWordsPerformance(); const performanceMap = new Map(performanceData.map(p => [p.wordId, p])); const analyzed = words.map((word, index) => { const performance = performanceMap.get(word.id); const hasAttempts = performance && performance.attempts && performance.attempts.length > 0; const hasTotalAttempts = performance && performance.totalAttempts > 0; const hasAccuracy = performance && typeof performance.accuracy === 'number'; const hasData = hasAttempts || hasTotalAttempts || hasAccuracy; return { ...word, totalAttempts: performance?.totalAttempts || performance?.attempts?.length || 0, accuracy: performance?.accuracy || 0, hintsPercentage: performance?.hintsPercentage || 0, currentStreak: performance?.currentStreak || 0, status: performance?.status || 'new', avgTime: performance?.avgTime || 0, hasPerformanceData: hasData, _rawPerformance: performance }; }); const withData = analyzed.filter(w => w.hasPerformanceData).length; if (withData === 0 && wordPerformance && Object.keys(wordPerformance).length > 0) { const fallbackAnalysis = words.map(word => { const rawPerformance = wordPerformance[word.id]; const hasRawData = rawPerformance && rawPerformance.attempts && rawPerformance.attempts.length > 0; if (hasRawData) { const attempts = rawPerformance.attempts; const totalAttempts = attempts.length; const correctAttempts = attempts.filter(a => a.correct).length; const accuracy = totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0; return { ...word, totalAttempts, accuracy, hintsPercentage: 0, currentStreak: 0, status: accuracy >= 70 ? 'improving' : accuracy >= 50 ? 'inconsistent' : 'struggling', avgTime: 0, hasPerformanceData: true }; } return { ...word, totalAttempts: 0, accuracy: 0, hintsPercentage: 0, currentStreak: 0, status: 'new', avgTime: 0, hasPerformanceData: false }; }); const fallbackWithData = fallbackAnalysis.filter(w => w.hasPerformanceData).length; return fallbackAnalysis; } return analyzed; }, [getAllWordsPerformance, words, wordPerformance, localRefresh]); const filteredWords = useMemo(() => { return wordsAnalysis.filter(word => { if (searchWord && !word.english.toLowerCase().includes(searchWord.toLowerCase())) { return false; } if (filterChapter !== '') { if (filterChapter === 'no-chapter') { if (word.chapter) return false; } else { if (word.chapter !== filterChapter) return false; } } if (filterGroup && word.group !== filterGroup) return false; if (filterLearned === 'learned' && !word.learned) return false; if (filterLearned === 'not_learned' && word.learned) return false; if (filterDifficult === 'difficult' && !word.difficult) return false; if (filterDifficult === 'not_difficult' && word.difficult) return false; return true; }); }, [wordsAnalysis, searchWord, filterChapter, filterGroup, filterLearned, filterDifficult]); const availableChapters = useMemo(() => { const chapters = new Set(); wordsAnalysis.forEach(word => { if (word.chapter) chapters.add(word.chapter); }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b); }); }, [wordsAnalysis]); const availableGroups = useMemo(() => { const groups = new Set(); wordsAnalysis.forEach(word => { if (word.group) groups.add(word.group); }); return Array.from(groups).sort(); }, [wordsAnalysis]); const wordsWithoutChapter = useMemo(() => { return wordsAnalysis.filter(word => !word.chapter); }, [wordsAnalysis]); const stats = useMemo(() => { const withPerformance = wordsAnalysis.filter(w => w.hasPerformanceData); return { total: wordsAnalysis.length, learned: wordsAnalysis.filter(w => w.learned).length, notLearned: wordsAnalysis.filter(w => !w.learned).length, difficult: wordsAnalysis.filter(w => w.difficult).length, withChapter: wordsAnalysis.filter(w => w.chapter).length, withPerformance: withPerformance.length, filtered: filteredWords.length, avgAccuracy: withPerformance.length > 0 ? Math.round(withPerformance.reduce((sum, w) => sum + w.accuracy, 0) / withPerformance.length) : 0 }; }, [wordsAnalysis, filteredWords.length]); const groupedWords = useMemo(() => { return filteredWords.reduce((groups, word) => { const chapter = word.chapter || 'Senza Capitolo'; if (!groups[chapter]) groups[chapter] = []; groups[chapter].push(word); return groups; }, {}); }, [filteredWords]); const clearFilters = () => { setSearchWord(''); setFilterChapter(''); setFilterLearned('all'); setFilterDifficult('all'); setFilterGroup(''); }; const handleToggleLearned = (id) => { const word = wordsAnalysis.find(w => w.id === id); if (word) { toggleWordLearned(id); showSuccess( word.learned ? `📖 "${word.english}" segnata come da studiare` : `✅ "${word.english}" segnata come appresa!` ); } }; const handleToggleDifficult = (id) => { const word = wordsAnalysis.find(w => w.id === id); if (word) { toggleWordDifficult(id); showSuccess( word.difficult ? `📚 "${word.english}" rimossa dalle parole difficili` : `⭐ "${word.english}" segnata come difficile!` ); } }; const toggleChapterCollapse = (chapter) => { setCollapsedChapters(prev => ({ ...prev, [chapter]: !prev[chapter] })); }; const allChapters = Object.keys(groupedWords); const allCollapsed = allChapters.every(chapter => collapsedChapters[chapter]); const allExpanded = allChapters.every(chapter => !collapsedChapters[chapter]); const expandAllChapters = () => { const newState = {}; allChapters.forEach(chapter => { newState[chapter] = false; }); setCollapsedChapters(newState); }; const collapseAllChapters = () => { const newState = {}; allChapters.forEach(chapter => { newState[chapter] = true; }); setCollapsedChapters(newState); }; return ( <div className="space-y-8" key={`words-enhanced-${localRefresh}-${internalRefresh}`}> } {allChapters.length > 1 && ( <div className="flex gap-2"> <Button onClick={expandAllChapters} disabled={allExpanded} variant="ghost" size="sm" className="text-white hover:bg-white/20 disabled:opacity-50 disabled:cursor-not-allowed" > <Maximize2 className="w-4 h-4 mr-2" /> Espandi Tutti </Button> <Button onClick={collapseAllChapters} disabled={allCollapsed} variant="ghost" size="sm" className="text-white hover:bg-white/20 disabled:opacity-50 disabled:cursor-not-allowed" > <Minimize2 className="w-4 h-4 mr-2" /> Collassa Tutti </Button> </div> )} </div> </CardHeader> </Card> } {selectedWordId && ( <WordDetailSection wordId={selectedWordId} getWordAnalysis={getWordAnalysis} testHistory={testHistory} wordInfo={wordsAnalysis.find(w => w.id === selectedWordId)} localRefresh={`${localRefresh}-${internalRefresh}`} /> )} } <CardHeader className="bg-gradient-to-r from-indigo-100 to-purple-100 border-b border-indigo-200 cursor-pointer hover:from-indigo-200 hover:to-purple-200 transition-colors" onClick={() => toggleChapterCollapse(chapter)} > <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> <div className="flex items-center gap-2"> {isCollapsed ? ( <ChevronDown className="w-5 h-5 text-indigo-600" /> ) : ( <ChevronUp className="w-5 h-5 text-indigo-600" /> )} <BookOpen className="w-6 h-6 text-indigo-600" /> </div> <CardTitle className="text-indigo-800 text-lg"> {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`} </CardTitle> {isCollapsed && ( <span className="text-xs text-indigo-600 bg-indigo-200 px-2 py-1 rounded-full"> Clicca per espandere </span> )} </div> <div className="flex gap-2 text-sm"> <span className="bg-indigo-200 text-indigo-700 px-3 py-1 rounded-full"> {chapterWords.length} parole </span> <span className="bg-green-200 text-green-700 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.learned).length} apprese </span> <span className="bg-red-200 text-red-700 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.difficult).length} difficili </span> <span className="bg-purple-200 text-purple-700 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.hasPerformanceData).length} con performance </span> </div> </div> </CardHeader> } <div className="max-h-80 overflow-y-auto space-y-2 pr-2 custom-scrollbar"> {chapterWords.map((word) => ( <CompactWordCard key={word.id} word={word} isSelected={selectedWordId === word.id} onClick={() => setSelectedWordId(selectedWordId === word.id ? null : word.id)} onToggleLearned={() => handleToggleLearned(word.id)} onToggleDifficult={() => handleToggleDifficult(word.id)} /> ))} </div> } <div className="flex items-center gap-3 flex-1 cursor-pointer" onClick={onClick}> <div className="flex items-center gap-2"> <span className={`text-lg font-bold ${word.learned ? 'text-gray-600' : 'text-gray-800'}`}> {word.english} </span> <span className="text-gray-400">→</span> <span className={`text-base ${word.learned ? 'text-gray-500' : 'text-gray-700'}`}> {word.italian} </span> </div> } {word.hasPerformanceData && ( <div className="flex items-center gap-3 text-sm"> <div className="text-center"> <div className="font-bold text-blue-600">{word.accuracy}%</div> <div className="text-xs text-gray-500">Precisione</div> </div> <div className="text-center"> <div className="font-bold text-green-600">{word.currentStreak}</div> <div className="text-xs text-gray-500">Streak</div> </div> <div className="text-center"> <div className="font-bold text-purple-600">{word.avgTime}s</div> <div className="text-xs text-gray-500">Tempo</div> </div> </div> )} } <div className="mt-2 text-center text-xs"> {isSelected ? ( <span className="text-blue-600">↑ Clicca per nascondere l'andamento temporale</span> ) : word.hasPerformanceData ? ( <span className="text-gray-500">↑ Clicca per vedere l'andamento temporale</span> ) : ( <span className="text-gray-400">📊 Nessun dato performance disponibile</span> )} </div> </div> ); }; export default WordsSection;

================================================================================

NOME FILE: ui\alert.tsx

import React from "react"; interface AlertProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; } const Alert = React.forwardRef<HTMLDivElement, AlertProps>( ({ className = "", ...props }, ref) => ( <div ref={ref} role="alert" className={`relative w-full rounded-lg border border-gray-200 bg-white px-4 py-3 text-sm text-gray-900 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-100 ${className}`} {...props} /> ) ); Alert.displayName = "Alert"; interface AlertDescriptionProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; } const AlertDescription = React.forwardRef< HTMLDivElement, AlertDescriptionProps >(({ className = "", ...props }, ref) => ( <div ref={ref} className={`text-sm ${className}`} {...props} /> )); AlertDescription.displayName = "AlertDescription"; export { Alert, AlertDescription };

================================================================================

NOME FILE: ui\BackgroundParticles.js

import React from 'react'; export const BackgroundParticles = React.memo(() => ( <div className="fixed inset-0 overflow-hidden pointer-events-none"> <div className="absolute top-10 left-10 w-72 h-72 bg-blue-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob"></div> <div className="absolute top-0 right-4 w-72 h-72 bg-purple-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-2000"></div> <div className="absolute -bottom-8 left-20 w-72 h-72 bg-pink-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-4000"></div> </div> ));

================================================================================

NOME FILE: ui\badge.tsx

import React from "react"; type BadgeVariant = "default" | "secondary" | "destructive" | "outline"; interface BadgeProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; variant?: BadgeVariant; children?: React.ReactNode; } const Badge = React.forwardRef<HTMLDivElement, BadgeProps>( ({ className = "", variant = "default", children, ...props }, ref) => { const variants: Record<BadgeVariant, string> = { default: "bg-gray-900 text-white hover:bg-gray-800", secondary: "bg-gray-100 text-gray-900 hover:bg-gray-200", destructive: "bg-red-600 text-white hover:bg-red-700", outline: "border border-gray-300 text-gray-700 hover:bg-gray-50", }; return ( <div ref={ref} className={`inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 ${variants[variant]} ${className}`} {...props} > {children} </div> ); } ); Badge.displayName = "Badge"; export { Badge }; export type { BadgeProps, BadgeVariant };

================================================================================

NOME FILE: ui\button.tsx

import React from "react"; type ButtonVariant = "default" | "outline" | "ghost" | "destructive" | "link"; type ButtonSize = "default" | "sm" | "lg"; interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> { className?: string; variant?: ButtonVariant; size?: ButtonSize; children?: React.ReactNode; disabled?: boolean; } const Button = React.forwardRef<HTMLButtonElement, ButtonProps>( ( { className = "", variant = "default", size = "default", children, disabled = false, ...props }, ref ) => { const baseClasses = "inline-flex items-center justify-center rounded-md text-sm font-medium transition-all duration-200 focus:outline-none disabled:opacity-50 disabled:pointer-events-none"; const variants: Record<ButtonVariant, string> = { default: "bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:bg-purple-600 dark:hover:bg-purple-700 dark:focus:ring-purple-500", outline: "border border-gray-300 bg-white text-gray-700 hover:bg-gray-50 hover:text-gray-900 focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-300 dark:hover:bg-gray-700", ghost: "bg-transparent text-gray-600 hover:bg-gray-100 hover:text-gray-900 focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-gray-100", destructive: "bg-red-600 text-white hover:bg-red-700 focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:bg-red-700 dark:hover:bg-red-800", link: "text-indigo-600 underline-offset-4 hover:underline hover:text-indigo-800 focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:text-purple-400 dark:hover:text-purple-300", }; const sizes: Record<ButtonSize, string> = { default: "h-10 py-2 px-4", sm: "h-9 px-3 rounded-md", lg: "h-11 px-8 rounded-md", }; const classes = `${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`; return ( <button className={classes} ref={ref} disabled={disabled} {...props}> {children} </button> ); } ); Button.displayName = "Button"; export { Button }; export type { ButtonProps, ButtonVariant, ButtonSize };

================================================================================

NOME FILE: ui\card.tsx

import React from "react"; interface CardProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; } interface CardHeaderProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; } interface CardTitleProps extends React.HTMLAttributes<HTMLHeadingElement> { className?: string; } interface CardDescriptionProps extends React.HTMLAttributes<HTMLParagraphElement> { className?: string; } interface CardContentProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; } interface CardFooterProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; } const Card = React.forwardRef<HTMLDivElement, CardProps>( ({ className = "", ...props }, ref) => ( <div ref={ref} className={`rounded-lg border bg-white border-gray-200 text-gray-900 shadow-sm dark:bg-gray-800 dark:border-gray-700 dark:text-gray-100 ${className}`} {...props} /> ) ); Card.displayName = "Card"; const CardHeader = React.forwardRef<HTMLDivElement, CardHeaderProps>( ({ className = "", ...props }, ref) => ( <div ref={ref} className={`flex flex-col space-y-1.5 p-6 ${className}`} {...props} /> ) ); CardHeader.displayName = "CardHeader"; const CardTitle = React.forwardRef<HTMLHeadingElement, CardTitleProps>( ({ className = "", ...props }, ref) => ( <h3 ref={ref} className={`text-2xl font-semibold leading-none tracking-tight ${className}`} {...props} /> ) ); CardTitle.displayName = "CardTitle"; const CardDescription = React.forwardRef< HTMLParagraphElement, CardDescriptionProps >(({ className = "", ...props }, ref) => ( <p ref={ref} className={`text-sm text-gray-600 dark:text-gray-400 ${className}`} {...props} /> )); CardDescription.displayName = "CardDescription"; const CardContent = React.forwardRef<HTMLDivElement, CardContentProps>( ({ className = "", ...props }, ref) => ( <div ref={ref} className={`p-6 pt-0 ${className}`} {...props} /> ) ); CardContent.displayName = "CardContent"; const CardFooter = React.forwardRef<HTMLDivElement, CardFooterProps>( ({ className = "", ...props }, ref) => ( <div ref={ref} className={`flex items-center p-6 pt-0 ${className}`} {...props} /> ) ); CardFooter.displayName = "CardFooter"; export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent, }; export type { CardProps, CardHeaderProps, CardTitleProps, CardDescriptionProps, CardContentProps, CardFooterProps, };

================================================================================

NOME FILE: ui\checkbox.tsx

import React from "react"; interface CheckboxProps extends Omit< React.InputHTMLAttributes<HTMLInputElement>, "checked" | "onChange" > { className?: string; checked?: boolean; onCheckedChange?: (checked: boolean) => void; } const Checkbox = React.forwardRef<HTMLInputElement, CheckboxProps>( ({ className = "", checked, onCheckedChange, ...props }, ref) => ( <input type="checkbox" ref={ref} checked={checked} onChange={(e) => onCheckedChange?.(e.target.checked)} className={`h-4 w-4 rounded border border-gray-300 text-blue-600 focus:ring-blue-500 ${className}`} {...props} /> ) ); Checkbox.displayName = "Checkbox"; export { Checkbox }; export type { CheckboxProps };

================================================================================

NOME FILE: ui\dialog.tsx

import React, { useState, useEffect } from "react"; interface DialogProps { children: React.ReactNode; open?: boolean; onOpenChange?: (open: boolean) => void; } interface DialogTriggerProps { children: React.ReactNode; asChild?: boolean; } interface DialogContentProps { children: React.ReactNode; className?: string; } interface DialogHeaderProps { children: React.ReactNode; className?: string; } interface DialogTitleProps { children: React.ReactNode; className?: string; } interface DialogDescriptionProps { children: React.ReactNode; className?: string; } interface DialogFooterProps { children: React.ReactNode; className?: string; } const Dialog: React.FC<DialogProps> = ({ children, open, onOpenChange }) => { const [isOpen, setIsOpen] = useState(open || false); useEffect(() => { if (open !== undefined) { setIsOpen(open); } }, [open]); const handleOpenChange = (newOpen: boolean) => { setIsOpen(newOpen); onOpenChange?.(newOpen); }; return ( <> {React.Children.map(children, (child) => React.cloneElement(child as React.ReactElement, { isOpen, setIsOpen: handleOpenChange, }) )} </> ); }; const DialogTrigger: React.FC<DialogTriggerProps & any> = ({ children, setIsOpen, asChild = false, }) => { const handleClick = () => { setIsOpen?.(true); }; if (asChild) { return React.cloneElement(children as React.ReactElement, { onClick: handleClick, }); } return <button onClick={handleClick}>{children}</button>; }; const DialogContent: React.FC<DialogContentProps & any> = ({ children, className = "", isOpen, setIsOpen, }) => { useEffect(() => { const handleKeyDown = (event: KeyboardEvent) => { if (event.key === "Escape") { setIsOpen?.(false); } }; if (isOpen) { document.addEventListener("keydown", handleKeyDown); document.body.style.overflow = "hidden"; } return () => { document.removeEventListener("keydown", handleKeyDown); document.body.style.overflow = "unset"; }; }, [isOpen, setIsOpen]); if (!isOpen) return null; return ( <div className="fixed inset-0 z-50 flex items-center justify-center"> } <div className={`relative bg-white rounded-lg shadow-lg max-w-md w-full mx-4 max-h-[90vh] overflow-auto ${className}`} onClick={(e) => e.stopPropagation()} > {children} </div> </div> ); }; const DialogHeader: React.FC<DialogHeaderProps> = ({ children, className = "", }) => ( <div className={`flex flex-col space-y-1.5 text-center sm:text-left p-6 pb-0 ${className}`} > {children} </div> ); const DialogTitle: React.FC<DialogTitleProps> = ({ children, className = "", }) => ( <h3 className={`text-lg font-semibold leading-none tracking-tight ${className}`} > {children} </h3> ); const DialogDescription: React.FC<DialogDescriptionProps> = ({ children, className = "", }) => <p className={`text-sm text-gray-600 ${className}`}>{children}</p>; const DialogFooter: React.FC<DialogFooterProps> = ({ children, className = "", }) => ( <div className={`flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 p-6 pt-0 ${className}`} > {children} </div> ); export { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, }; export type { DialogProps, DialogTriggerProps, DialogContentProps, DialogHeaderProps, DialogTitleProps, DialogDescriptionProps, DialogFooterProps, };

================================================================================

NOME FILE: ui\dropdown-menu.tsx

import React, { useState, useRef, useEffect } from "react"; interface DropdownMenuProps { children: React.ReactNode; } interface DropdownMenuTriggerProps { children: React.ReactNode; asChild?: boolean; } interface DropdownMenuContentProps { children: React.ReactNode; className?: string; align?: "start" | "center" | "end"; } interface DropdownMenuItemProps extends React.HTMLAttributes<HTMLDivElement> { children: React.ReactNode; disabled?: boolean; className?: string; } interface DropdownMenuSeparatorProps { className?: string; } type AlignmentOption = "start" | "center" | "end"; const alignmentStyles: Record<AlignmentOption, string> = { start: "left-0", center: "left-1/2 transform -translate-x-1/2", end: "right-0", }; const getAlignmentStyle = (align: AlignmentOption = "start"): string => { return alignmentStyles[align] || alignmentStyles.start; }; interface DropdownContextType { isOpen: boolean; setIsOpen: (open: boolean) => void; triggerRef: React.MutableRefObject<HTMLElement | null>; } const DropdownContext = React.createContext<DropdownContextType | null>(null); const useDropdownContext = () => { const context = React.useContext(DropdownContext); if (!context) { throw new Error("Dropdown components must be used within DropdownMenu"); } return context; }; const DropdownMenu: React.FC<DropdownMenuProps> = ({ children }) => { const [isOpen, setIsOpen] = useState(false); const triggerRef = useRef<HTMLElement | null>(null); const contentRef = useRef<HTMLDivElement>(null); useEffect(() => { const handleClickOutside = (event: MouseEvent) => { if ( contentRef.current && !contentRef.current.contains(event.target as Node) && triggerRef.current && !triggerRef.current.contains(event.target as Node) ) { setIsOpen(false); } }; if (isOpen) { document.addEventListener("mousedown", handleClickOutside); return () => document.removeEventListener("mousedown", handleClickOutside); } return undefined; }, [isOpen]); useEffect(() => { const handleEscape = (event: KeyboardEvent) => { if (event.key === "Escape") { setIsOpen(false); } }; if (isOpen) { document.addEventListener("keydown", handleEscape); return () => document.removeEventListener("keydown", handleEscape); } return undefined; }, [isOpen]); return ( <DropdownContext.Provider value={{ isOpen, setIsOpen, triggerRef }}> <div className="relative inline-block text-left">{children}</div> </DropdownContext.Provider> ); }; const DropdownMenuTrigger = React.forwardRef< HTMLButtonElement, DropdownMenuTriggerProps >(({ children, asChild = false, ...props }, ref) => { const { setIsOpen, triggerRef } = useDropdownContext(); const handleClick = () => { setIsOpen(true); }; if (asChild && React.isValidElement(children)) { const childElement = children as React.ReactElement<any>; const childProps = { ...childElement.props, ...props, onClick: (e: React.MouseEvent) => { handleClick(); if (childElement.props.onClick) { childElement.props.onClick(e); } }, }; return React.createElement(childElement.type, { ...childProps, ref: (node: HTMLElement | null) => { if (node) { triggerRef.current = node; } if (typeof ref === "function") { ref(node as HTMLButtonElement); } else if (ref && node) { (ref as React.MutableRefObject<HTMLButtonElement>).current = node as HTMLButtonElement; } }, }); } return ( <button ref={(node: HTMLButtonElement | null) => { if (node) { triggerRef.current = node; } if (typeof ref === "function") { ref(node); } else if (ref && node) { (ref as React.MutableRefObject<HTMLButtonElement>).current = node; } }} onClick={handleClick} className="inline-flex items-center justify-center" {...props} > {children} </button> ); }); const DropdownMenuContent = React.forwardRef< HTMLDivElement, DropdownMenuContentProps >(({ children, className = "", align = "start", ...props }, ref) => { const { isOpen } = useDropdownContext(); if (!isOpen) { return null; } const alignmentClass = getAlignmentStyle(align); return ( <div ref={ref} className={`absolute top-full mt-2 min-w-[8rem] z-50 rounded-md border border-gray-200 bg-white p-1 shadow-md ${alignmentClass} ${className}`} {...props} > {children} </div> ); }); const DropdownMenuItem = React.forwardRef< HTMLDivElement, DropdownMenuItemProps >(({ children, disabled = false, className = "", onClick, ...props }, ref) => { const { setIsOpen } = useDropdownContext(); const handleClick = (e: React.MouseEvent<HTMLDivElement>) => { if (disabled) return; if (onClick) { onClick(e); } setIsOpen(false); }; return ( <div ref={ref} className={`relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors hover:bg-gray-100 focus:bg-gray-100 ${ disabled ? "pointer-events-none opacity-50" : "" } ${className}`} onClick={handleClick} {...props} > {children} </div> ); }); const DropdownMenuSeparator = React.forwardRef< HTMLDivElement, DropdownMenuSeparatorProps >(({ className = "", ...props }, ref) => ( <div ref={ref} className={`-mx-1 my-1 h-px bg-gray-200 ${className}`} {...props} /> )); DropdownMenuTrigger.displayName = "DropdownMenuTrigger"; DropdownMenuContent.displayName = "DropdownMenuContent"; DropdownMenuItem.displayName = "DropdownMenuItem"; DropdownMenuSeparator.displayName = "DropdownMenuSeparator"; export { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator, }; export type { DropdownMenuProps, DropdownMenuTriggerProps, DropdownMenuContentProps, DropdownMenuItemProps, DropdownMenuSeparatorProps, };

================================================================================

NOME FILE: ui\input.tsx

import React from "react"; interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> { className?: string; type?: string; } const Input = React.forwardRef<HTMLInputElement, InputProps>( ({ className = "", type = "text", ...props }, ref) => { return ( <input type={type} className={`flex h-10 w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm text-gray-900 placeholder:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 disabled:cursor-not-allowed disabled:opacity-50 transition-colors duration-200 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-100 dark:placeholder:text-gray-400 dark:focus:ring-purple-500 dark:focus:border-purple-500 ${className}`} ref={ref} {...props} /> ); } ); Input.displayName = "Input"; export { Input }; export type { InputProps };

================================================================================

NOME FILE: ui\label.tsx

import React from "react"; interface LabelProps extends React.LabelHTMLAttributes<HTMLLabelElement> { className?: string; } const Label = React.forwardRef<HTMLLabelElement, LabelProps>( ({ className = "", ...props }, ref) => ( <label ref={ref} className={`text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 ${className}`} {...props} /> ) ); Label.displayName = "Label"; export { Label };

================================================================================

NOME FILE: ui\modal.tsx

import React, { ReactNode, MouseEvent } from 'react'; interface ModalProps { isOpen: boolean; onClose: () => void; children: ReactNode; className?: string; } interface ModalHeaderProps { children: ReactNode; className?: string; } interface ModalTitleProps { children: ReactNode; className?: string; } interface ModalContentProps { children: ReactNode; className?: string; } interface ModalFooterProps { children: ReactNode; className?: string; } const Modal: React.FC<ModalProps> = ({ isOpen, onClose, children, className = "" }) => { if (!isOpen) return null; const handleBackdropClick = (e: MouseEvent<HTMLDivElement>) => { if (e.target === e.currentTarget) { onClose(); } }; const handleModalClick = (e: MouseEvent<HTMLDivElement>) => { e.stopPropagation(); }; return ( <div className="fixed inset-0 z-50 overflow-y-auto"> } <div className="flex min-h-full items-center justify-center p-4" onClick={handleBackdropClick}> <div className={`relative bg-white dark:bg-gray-800 rounded-2xl shadow-2xl transform transition-all duration-300 scale-100 max-w-md w-full mx-auto ${className}`} onClick={handleModalClick} > {children} </div> </div> </div> ); }; const ModalHeader: React.FC<ModalHeaderProps> = ({ children, className = "" }) => ( <div className={`px-6 py-4 border-b border-gray-200 dark:border-gray-600 ${className}`}> {children} </div> ); const ModalTitle: React.FC<ModalTitleProps> = ({ children, className = "" }) => ( <h3 className={`text-lg font-semibold text-gray-900 dark:text-gray-100 ${className}`}> {children} </h3> ); const ModalContent: React.FC<ModalContentProps> = ({ children, className = "" }) => ( <div className={`px-6 py-4 ${className}`}> {children} </div> ); const ModalFooter: React.FC<ModalFooterProps> = ({ children, className = "" }) => ( <div className={`px-6 py-4 border-t border-gray-200 dark:border-gray-600 flex justify-end gap-3 ${className}`}> {children} </div> ); export { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter };

================================================================================

NOME FILE: ui\NotificationToast.js

import React from 'react'; import { useNotification } from '../../contexts/NotificationContext'; export const NotificationToast = React.memo(() => { const { notifications } = useNotification(); if (notifications.length === 0) return null; return ( <div className="fixed top-6 right-6 z-50 space-y-2"> {notifications.map(notification => ( <NotificationItem key={notification.id} notification={notification} /> ))} </div> ); }); const NotificationItem = React.memo(({ notification }) => { const typeStyles = { success: 'bg-gradient-to-r from-green-500 to-emerald-500', error: 'bg-gradient-to-r from-red-500 to-pink-500', warning: 'bg-gradient-to-r from-orange-500 to-yellow-500', info: 'bg-gradient-to-r from-blue-500 to-cyan-500' }; const icons = { success: '✅', error: '❌', warning: '⚠️', info: 'ℹ️' }; return ( <div className={`${typeStyles[notification.type]} text-white px-6 py-4 rounded-2xl shadow-2xl backdrop-blur-sm border border-white/20 animate-slide-in max-w-md`}> <div className="flex items-center gap-3"> <span className="text-lg">{icons[notification.type]}</span> <span className="font-medium">{notification.message}</span> </div> </div> ); });

================================================================================

NOME FILE: ui\ProgressIndicator.tsx

import React from 'react'; interface ProgressIndicatorProps { current: number; total: number; variant?: 'default' | 'timer' | 'accuracy' | 'circular'; size?: 'sm' | 'md' | 'lg'; showLabel?: boolean; showRemaining?: boolean; showPercentage?: boolean; animated?: boolean; color?: 'primary' | 'success' | 'warning' | 'error'; label?: string; className?: string; } export const ProgressIndicator: React.FC<ProgressIndicatorProps> = ({ current, total, variant = 'default', size = 'md', showLabel = true, showRemaining = false, showPercentage = true, animated = true, color = 'primary', label, className = '' }) => { const percentage = total > 0 ? Math.min(100, Math.max(0, (current / total) * 100)) : 0; const remaining = Math.max(0, total - current); const sizeClasses = { sm: { height: 'h-2', text: 'text-xs', circular: 'w-12 h-12' }, md: { height: 'h-3', text: 'text-sm', circular: 'w-16 h-16' }, lg: { height: 'h-4', text: 'text-base', circular: 'w-20 h-20' } }; const colorClasses = { primary: 'progress-fill', success: 'progress-success', warning: 'progress-warning', error: 'progress-error' }; const currentSize = sizeClasses[size]; const currentColor = colorClasses[color]; const getTimerColor = () => { if (percentage >= 80) return 'progress-error'; if (percentage >= 60) return 'progress-warning'; return 'progress-fill'; }; const getAccuracyColor = () => { if (percentage >= 90) return 'progress-success'; if (percentage >= 70) return 'progress-fill'; if (percentage >= 50) return 'progress-warning'; return 'progress-error'; }; const fillColorClass = variant === 'timer' ? getTimerColor() : variant === 'accuracy' ? getAccuracyColor() : currentColor; if (variant === 'circular') { const radius = size === 'sm' ? 20 : size === 'md' ? 28 : 36; const circumference = 2 * Math.PI * radius; const strokeDashoffset = circumference - (percentage / 100) * circumference; return ( <div className={`relative ${currentSize.circular} ${className}`}> <svg className="w-full h-full transform -rotate-90" viewBox="0 0 100 100"> } <circle cx="50" cy="50" r={radius} stroke="currentColor" strokeWidth="4" fill="transparent" strokeDasharray={circumference} strokeDashoffset={strokeDashoffset} strokeLinecap="round" className={`${fillColorClass} ${animated ? 'transition-all duration-500 ease-out' : ''}`} style={{ filter: 'drop-shadow(0 0 4px rgba(var(--tw-color-current), 0.3))' }} /> </svg> } {(showLabel || showRemaining || showPercentage) && ( <div className="flex items-center justify-between mb-2"> <div className={`${currentSize.text} text-gray-700 dark:text-gray-300`}> {label || `${current} / ${total}`} </div> <div className="flex items-center gap-2"> {showPercentage && ( <span className={`${currentSize.text} font-semibold text-gray-800 dark:text-gray-200`}> {Math.round(percentage)}% </span> )} {showRemaining && ( <span className={`${currentSize.text} text-gray-600 dark:text-gray-400`}> ({remaining} remaining) </span> )} </div> </div> )} } {variant === 'timer' && percentage >= 60 && ( <div className={`${currentSize.text} text-center mt-1 ${ percentage >= 80 ? 'text-red-600 dark:text-red-400 animate-pulse' : 'text-yellow-600 dark:text-yellow-400' }`}> {percentage >= 80 ? 'Time almost up!' : 'Hurry up!'} </div> )} </div> ); }; export default ProgressIndicator;

================================================================================

NOME FILE: ui\select.tsx

import React, { useState, useRef, useEffect } from "react"; interface SelectProps { children: React.ReactNode; value?: string; onValueChange?: (value: string) => void; defaultValue?: string; } interface SelectTriggerProps extends React.ButtonHTMLAttributes<HTMLButtonElement> { className?: string; children: React.ReactNode; } interface SelectValueProps { placeholder?: string; selectedValue?: string; } interface SelectContentProps { children: React.ReactNode; className?: string; } interface SelectItemProps extends React.HTMLAttributes<HTMLDivElement> { children: React.ReactNode; value: string; className?: string; } const Select: React.FC<SelectProps> = ({ children, value, onValueChange, defaultValue, }) => { const [selectedValue, setSelectedValue] = useState( value || defaultValue || "" ); const [isOpen, setIsOpen] = useState(false); const handleValueChange = (newValue: string) => { setSelectedValue(newValue); onValueChange?.(newValue); setIsOpen(false); }; return ( <div className="relative"> {React.Children.map(children, (child) => React.cloneElement(child as React.ReactElement, { selectedValue, isOpen, setIsOpen, onValueChange: handleValueChange, }) )} </div> ); }; const SelectTrigger = React.forwardRef< HTMLButtonElement, SelectTriggerProps & any >( ( { className = "", children, selectedValue, isOpen, setIsOpen, ...props }, ref ) => ( <button ref={ref} type="button" className={`flex h-10 w-full items-center justify-between rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 px-3 py-2 text-sm placeholder:text-gray-500 dark:placeholder:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-purple-500 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 ${className}`} onClick={() => setIsOpen?.(!isOpen)} {...props} > {children} <svg className={`h-4 w-4 transition-transform ${isOpen ? "rotate-180" : ""}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" > <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" /> </svg> </button> ) ); SelectTrigger.displayName = "SelectTrigger"; const SelectValue: React.FC<SelectValueProps> = ({ placeholder, selectedValue, }) => ( <span className={selectedValue ? "text-gray-900 dark:text-gray-100" : "text-gray-500 dark:text-gray-400"}> {selectedValue || placeholder} </span> ); const SelectContent = React.forwardRef< HTMLDivElement, SelectContentProps & any >(({ children, isOpen, setIsOpen, onValueChange, className = "" }, ref) => { const contentRef = useRef<HTMLDivElement>(null); useEffect(() => { const handleClickOutside = (event: MouseEvent) => { if ( contentRef.current && !contentRef.current.contains(event.target as Node) ) { setIsOpen?.(false); } }; if (isOpen) { document.addEventListener("mousedown", handleClickOutside); } return () => { document.removeEventListener("mousedown", handleClickOutside); }; }, [isOpen, setIsOpen]); if (!isOpen) return null; return ( <div ref={contentRef} className={`absolute top-full mt-1 max-h-60 w-full overflow-auto rounded-md border border-gray-200 dark:border-gray-600 bg-white dark:bg-gray-800 shadow-md z-50 ${className}`} > <div className="p-1"> {React.Children.map(children, (child) => React.cloneElement(child as React.ReactElement, { onValueChange, setIsOpen, }) )} </div> </div> ); }); SelectContent.displayName = "SelectContent"; const SelectItem = React.forwardRef<HTMLDivElement, SelectItemProps & any>( ( { children, value, onValueChange, setIsOpen, className = "", ...props }, ref ) => ( <div ref={ref} className={`relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm text-gray-900 dark:text-gray-100 outline-none hover:bg-gray-100 dark:hover:bg-gray-700 focus:bg-gray-100 dark:focus:bg-gray-700 cursor-pointer ${className}`} onClick={() => { onValueChange?.(value); setIsOpen?.(false); }} {...props} > {children} </div> ) ); SelectItem.displayName = "SelectItem"; export { Select, SelectContent, SelectItem, SelectTrigger, SelectValue }; export type { SelectProps, SelectTriggerProps, SelectValueProps, SelectContentProps, SelectItemProps, };

================================================================================

NOME FILE: ui\separator.tsx

import React from "react"; interface SeparatorProps extends React.HTMLAttributes<HTMLDivElement> { className?: string; orientation?: "horizontal" | "vertical"; } const Separator = React.forwardRef<HTMLDivElement, SeparatorProps>( ({ className = "", orientation = "horizontal", ...props }, ref) => ( <div ref={ref} className={`shrink-0 bg-gray-200 ${ orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]" } ${className}`} {...props} /> ) ); Separator.displayName = "Separator"; export { Separator };

================================================================================

NOME FILE: ui\StatDisplay.tsx

import React from 'react'; interface StatDisplayProps { value: string | number; label: string; icon?: React.ReactNode; color?: 'primary' | 'success' | 'warning' | 'error' | 'info' | 'neutral'; size?: 'sm' | 'md' | 'lg'; variant?: 'default' | 'card' | 'inline'; showChange?: boolean; changeValue?: number; changeType?: 'increase' | 'decrease' | 'neutral'; } export const StatDisplay: React.FC<StatDisplayProps> = ({ value, label, icon, color = 'neutral', size = 'md', variant = 'default', showChange = false, changeValue, changeType = 'neutral' }) => { const sizeClasses = { sm: { value: 'text-lg font-semibold', label: 'text-xs', container: 'p-3' }, md: { value: 'text-2xl font-bold', label: 'text-sm', container: 'p-4' }, lg: { value: 'text-3xl font-bold', label: 'text-base', container: 'p-6' } }; const colorClasses = { primary: 'text-purple-600 dark:text-purple-400', success: 'text-green-600 dark:text-green-400', warning: 'text-yellow-600 dark:text-yellow-400', error: 'text-red-600 dark:text-red-400', info: 'text-blue-600 dark:text-blue-400', neutral: 'text-gray-800 dark:text-gray-200' }; const changeClasses = { increase: 'text-green-600 dark:text-green-400', decrease: 'text-red-600 dark:text-red-400', neutral: 'text-gray-600 dark:text-gray-400' }; const variantClasses = { default: 'text-center', card: 'card-glass text-center interactive-scale', inline: 'flex items-center gap-2' }; const currentSize = sizeClasses[size]; const currentColor = colorClasses[color]; const currentVariant = variantClasses[variant]; if (variant === 'inline') { return ( <div className={`${currentVariant} ${currentSize.container}`}> {icon && ( <div className={`${currentColor} ${size === 'sm' ? 'w-4 h-4' : size === 'md' ? 'w-5 h-5' : 'w-6 h-6'}`}> {icon} </div> )} <div> <span className={`${currentSize.value} ${currentColor}`}> {value} </span> <span className={`${currentSize.label} text-gray-600 dark:text-gray-400 ml-2`}> {label} </span> </div> {showChange && changeValue !== undefined && ( <div className={`${currentSize.label} ${changeClasses[changeType]} ml-2`}> {changeType === 'increase' ? '+' : changeType === 'decrease' ? '-' : ''} {Math.abs(changeValue)} {changeType === 'increase' ? '↗' : changeType === 'decrease' ? '↘' : '→'} </div> )} </div> ); } return ( <div className={`${currentVariant} ${currentSize.container}`}> {icon && ( <div className={`${currentColor} ${size === 'sm' ? 'w-6 h-6' : size === 'md' ? 'w-8 h-8' : 'w-10 h-10'} mx-auto mb-2`}> {icon} </div> )} <div className={`${currentSize.value} ${currentColor}`}> {value} </div> <div className={`${currentSize.label} text-gray-600 dark:text-gray-400 mt-1`}> {label} </div> {showChange && changeValue !== undefined && ( <div className={`${currentSize.label} ${changeClasses[changeType]} mt-1 flex items-center justify-center gap-1`}> <span> {changeType === 'increase' ? '+' : changeType === 'decrease' ? '-' : ''} {Math.abs(changeValue)} </span> <span className="text-xs"> {changeType === 'increase' ? '↗' : changeType === 'decrease' ? '↘' : '→'} </span> </div> )} </div> ); }; export default StatDisplay;

================================================================================

NOME FILE: ui\textarea.tsx

import React from 'react'; export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> { className?: string; } const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>( ({ className = "", ...props }, ref) => { return ( <textarea className={`flex min-h-[80px] w-full rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-gray-100 placeholder:text-gray-500 dark:placeholder:text-gray-400 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 dark:focus-visible:ring-purple-500 focus-visible:ring-offset-2 focus:border-indigo-500 dark:focus:border-purple-500 disabled:cursor-not-allowed disabled:opacity-50 transition-colors duration-200 ${className}`} ref={ref} {...props} /> ); } ); Textarea.displayName = "Textarea"; export { Textarea };

================================================================================


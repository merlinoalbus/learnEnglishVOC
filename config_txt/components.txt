NOME FILE: AppRouter.js

import React from 'react'; import { useAppContext } from '../contexts/AppContext'; import { MainView } from '../views/MainView'; import { TestView } from '../views/TestView'; import { ResultsView } from '../views/ResultsView'; import { StatsView } from '../views/StatsView'; export const AppRouter = () => { const { currentView, testMode, showResults } = useAppContext(); if (testMode) { return <TestView />; } if (showResults) { return <ResultsView />; } switch (currentView) { case 'stats': return <StatsView />; case 'main': default: return <MainView />; } };

================================================================================

NOME FILE: ChapterTestSelector.js

import React, { useState, useEffect } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Play, BookOpen, CheckSquare, Square, Target, AlertTriangle, GraduationCap } from 'lucide-react'; import { useNotification } from '../contexts/NotificationContext'; const ChapterTestSelector = ({ words, onStartTest, onClose }) => { const [selectedChapters, setSelectedChapters] = useState(new Set()); const [includeLearnedWords, setIncludeLearnedWords] = useState(false); const [testMode, setTestMode] = useState('normal'); const { showWarning } = useNotification(); const getAvailableChapters = () => { const chapters = new Set(); words.forEach(word => { if (word.chapter) { chapters.add(word.chapter); } }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); if (!isNaN(aNum) && !isNaN(bNum)) { return aNum - bNum; } return a.localeCompare(b); }); }; const availableChapters = getAvailableChapters(); const wordsWithoutChapter = words.filter(word => !word.chapter); const getChapterStats = (chapter) => { const chapterWords = words.filter(word => word.chapter === chapter); const totalWords = chapterWords.length; const learnedWords = chapterWords.filter(word => word.learned).length; const difficultWords = chapterWords.filter(word => word.difficult).length; let availableForTest = 0; if (testMode === 'difficult-only') { availableForTest = difficultWords; } else { availableForTest = chapterWords.filter(word => includeLearnedWords || !word.learned).length; } return { totalWords, learnedWords, difficultWords, availableForTest }; }; const getWordsWithoutChapterStats = () => { const totalWords = wordsWithoutChapter.length; const learnedWords = wordsWithoutChapter.filter(word => word.learned).length; const difficultWords = wordsWithoutChapter.filter(word => word.difficult).length; let availableForTest = 0; if (testMode === 'difficult-only') { availableForTest = difficultWords; } else { availableForTest = wordsWithoutChapter.filter(word => includeLearnedWords || !word.learned).length; } return { totalWords, learnedWords, difficultWords, availableForTest }; }; const toggleChapter = (chapter) => { const newSelected = new Set(selectedChapters); if (newSelected.has(chapter)) { newSelected.delete(chapter); } else { newSelected.add(chapter); } setSelectedChapters(newSelected); }; const selectAllChapters = () => { const allOptions = [...availableChapters]; if (wordsWithoutChapter.length > 0) { allOptions.push('SENZA_CAPITOLO'); } setSelectedChapters(new Set(allOptions)); }; const clearSelection = () => { setSelectedChapters(new Set()); }; const getTotalSelectedWords = () => { let total = 0; selectedChapters.forEach(chapter => { if (chapter === 'SENZA_CAPITOLO') { total += getWordsWithoutChapterStats().availableForTest; } else { total += getChapterStats(chapter).availableForTest; } }); return total; }; const handleStartTest = () => { const totalWords = getTotalSelectedWords(); if (totalWords === 0) { const modeText = testMode === 'difficult-only' ? 'difficili' : 'disponibili'; showWarning(`⚠️ Seleziona almeno un capitolo con parole ${modeText}!`); return; } const filteredWords = words.filter(word => { let chapterMatch = false; if (word.chapter) { chapterMatch = selectedChapters.has(word.chapter); } else { chapterMatch = selectedChapters.has('SENZA_CAPITOLO'); } if (!chapterMatch) return false; if (testMode === 'difficult-only') { return word.difficult; } else { if (!includeLearnedWords && word.learned) { return false; } return true; } }); if (filteredWords.length === 0) { const modeText = testMode === 'difficult-only' ? 'difficili' : 'disponibili'; showWarning(`⚠️ Nessuna parola ${modeText} per i capitoli selezionati!`); return; } onStartTest(filteredWords); onClose(); }; useEffect(() => { if (selectedChapters.size === 0) { const allOptions = [...availableChapters]; if (wordsWithoutChapter.length > 0) { allOptions.push('SENZA_CAPITOLO'); } setSelectedChapters(new Set(allOptions)); } }, [availableChapters, wordsWithoutChapter.length, selectedChapters.size]); return ( <div className="fixed inset-0 z-50 overflow-y-auto bg-black/50 backdrop-blur-sm"> <div className="flex min-h-full items-center justify-center p-4"> <Card className="w-full max-w-4xl bg-white rounded-3xl shadow-2xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white"> <CardTitle className="flex items-center gap-3 text-2xl"> <BookOpen className="w-8 h-8" /> Seleziona Capitoli per il Test </CardTitle> <p className="text-blue-100 mt-2"> Scegli quali capitoli includere nel test e la modalità di apprendimento </p> </CardHeader> <CardContent className="p-6 space-y-6"> } {testMode === 'normal' && ( <div className="flex items-center gap-4 mb-4"> <label className="flex items-center gap-3 cursor-pointer"> <div onClick={() => setIncludeLearnedWords(!includeLearnedWords)} className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${ includeLearnedWords ? 'bg-green-500 border-green-500 text-white' : 'border-gray-300 bg-white' }`} > {includeLearnedWords && <span className="text-sm">✓</span>} </div> <span className="text-gray-700 font-medium"> Includi parole già apprese nel test </span> </label> </div> )} <div className="flex gap-3"> <Button onClick={selectAllChapters} className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white" > <CheckSquare className="w-4 h-4 mr-2" /> Seleziona Tutti </Button> <Button onClick={clearSelection} variant="outline" className="border-gray-300" > <Square className="w-4 h-4 mr-2" /> Deseleziona Tutti </Button> </div> </div> } {wordsWithoutChapter.length > 0 && ( <div onClick={() => toggleChapter('SENZA_CAPITOLO')} className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${ selectedChapters.has('SENZA_CAPITOLO') ? 'border-purple-500 bg-purple-50 shadow-lg' : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md' }`} > <div className="flex items-center justify-between mb-3"> <div className="flex items-center gap-3"> <div className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${ selectedChapters.has('SENZA_CAPITOLO') ? 'bg-purple-500 border-purple-500 text-white' : 'border-gray-300 bg-white' }`}> {selectedChapters.has('SENZA_CAPITOLO') && <span className="text-sm">✓</span>} </div> <span className="font-bold text-lg">📋 Senza Capitolo</span> </div> </div> <div className="grid grid-cols-4 gap-2 text-sm"> <div className="text-center p-2 bg-blue-100 rounded-xl"> <div className="font-bold text-blue-600">{getWordsWithoutChapterStats().totalWords}</div> <div className="text-blue-700 text-xs">Totale</div> </div> <div className="text-center p-2 bg-green-100 rounded-xl"> <div className="font-bold text-green-600">{getWordsWithoutChapterStats().learnedWords}</div> <div className="text-green-700 text-xs">Apprese</div> </div> <div className="text-center p-2 bg-orange-100 rounded-xl"> <div className="font-bold text-orange-600">{getWordsWithoutChapterStats().difficultWords}</div> <div className="text-orange-700 text-xs">Difficili</div> </div> <div className="text-center p-2 bg-purple-100 rounded-xl"> <div className="font-bold text-purple-600">{getWordsWithoutChapterStats().availableForTest}</div> <div className="text-purple-700 text-xs">Per Test</div> </div> </div> </div> )} </div> </div> } <div className={`px-4 py-2 rounded-full text-sm font-bold ${ testMode === 'difficult-only' ? 'bg-orange-100 text-orange-700 border border-orange-300' : 'bg-blue-100 text-blue-700 border border-blue-300' }`}> {testMode === 'difficult-only' ? '⭐ Solo Difficili' : '🎓 Test Normale'} </div> </div> <div className="flex justify-end gap-4"> <Button onClick={onClose} variant="outline" className="px-8 py-3 text-lg" > Annulla </Button> <Button onClick={handleStartTest} disabled={getTotalSelectedWords() === 0} className={`px-8 py-3 text-lg shadow-xl disabled:opacity-50 ${ testMode === 'difficult-only' ? 'bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600' : 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600' } text-white`} > <Play className="w-5 h-5 mr-2" /> {testMode === 'difficult-only' ? `Inizia Test Difficili (${getTotalSelectedWords()})` : `Inizia Test (${getTotalSelectedWords()} parole)` } </Button> </div> </div> </CardContent> </Card> </div> </div> ); }; export default ChapterTestSelector;

================================================================================

NOME FILE: EnhancedAddWordForm.js

import React from 'react'; import { useState, useEffect, useCallback } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Input } from './ui/input'; import { Textarea } from './ui/textarea'; import { Plus, Edit3, Check, Sparkles, Brain, AlertTriangle, RefreshCw } from 'lucide-react'; import { getPredefinedGroups, getCategoryStyle } from '../utils/categoryUtils'; import { useNotification } from '../contexts/NotificationContext'; import { enhancedAIService } from '../services/enhancedAIService'; import { useAILoading } from '../hooks/useLoadingState'; import { SmartLoadingIndicator, ErrorWithRetry } from '../components/LoadingComponents'; import { AIServiceErrorBoundary, FormErrorBoundary } from '../components/ErrorBoundaries'; const EnhancedAddWordForm = ({ onAddWord, editingWord, onClearForm }) => { const [formData, setFormData] = useState({ english: '', italian: '', group: '', sentence: '', notes: '', chapter: '', learned: false, difficult: false }); const [showAdvancedForm, setShowAdvancedForm] = useState(false); const [aiServiceStatus, setAiServiceStatus] = useState(null); const [formValidation, setFormValidation] = useState({}); const [isRefreshingStatus, setIsRefreshingStatus] = useState(false); const { showNotification, showError, showWarning, showSuccess } = useNotification(); const aiLoading = useAILoading(); const checkAIServiceStatus = useCallback(() => { try { const currentStatus = enhancedAIService.getServiceStatus(); setAiServiceStatus(currentStatus); console.log('📊 AI Status (passive):', { health: currentStatus.health, configured: currentStatus.configured, consecutiveFailures: currentStatus.consecutiveFailures }); } catch (error) { console.error('❌ Failed to get AI status:', error); setAiServiceStatus(prev => ({ ...prev, health: 'down', consecutiveFailures: (prev?.consecutiveFailures || 0) + 1 })); } }, []); const handleRefreshStatus = useCallback(async () => { if (isRefreshingStatus) return; if (!window.confirm('🚨 ATTENZIONE: Questa operazione costa denaro (chiamata API Google). Continuare?')) { return; } setIsRefreshingStatus(true); setAiServiceStatus(prev => ({ ...prev, health: 'unknown' })); try { console.log('💰 Manual AI health check (COSTS MONEY) - User confirmed'); const isHealthy = await enhancedAIService.checkHealth(); const updatedStatus = enhancedAIService.getServiceStatus(); setAiServiceStatus(updatedStatus); if (isHealthy) { showSuccess('✅ AI Service verificato come disponibile'); } else { showWarning('⚠️ AI Service non risponde correttamente'); } } catch (error) { console.error('❌ Manual health check failed:', error); showError(error, 'AI Health Check'); setAiServiceStatus(prev => ({ ...prev, health: 'down' })); } finally { setIsRefreshingStatus(false); } }, [isRefreshingStatus, showSuccess, showWarning, showError]); const validateForm = useCallback(() => { const errors = {}; if (!formData.english.trim()) { errors.english = 'Parola inglese obbligatoria'; } else if (formData.english.trim().length < 2) { errors.english = 'Parola troppo corta (min 2 caratteri)'; } else if (!/^[a-zA-ZÀ-ÿ\s'-]+$/.test(formData.english.trim())) { errors.english = 'Solo caratteri inglesi consentiti (a-z, spazi, apostrofi)'; } if (!formData.italian.trim()) { errors.italian = 'Traduzione italiana obbligatoria'; } else if (formData.italian.trim().length < 2) { errors.italian = 'Traduzione troppo corta (min 2 caratteri)'; } if (formData.group && !getPredefinedGroups().includes(formData.group)) { errors.group = 'Categoria non valida'; } setFormValidation(errors); return Object.keys(errors).length === 0; }, [formData]); const handleInputChange = useCallback((field, value) => { setFormData(prev => ({ ...prev, [field]: value })); if (formValidation[field]) { setFormValidation(prev => { const newValidation = { ...prev }; delete newValidation[field]; return newValidation; }); } }, [formValidation]); const handleFieldBlur = useCallback((field) => { const errors = {}; if (field === 'english') { if (!formData.english.trim()) { errors.english = 'Parola inglese obbligatoria'; } else if (formData.english.trim().length < 2) { errors.english = 'Parola troppo corta'; } else if (!/^[a-zA-ZÀ-ÿ\s'-]+$/.test(formData.english.trim())) { errors.english = 'Solo caratteri inglesi consentiti'; } } if (field === 'italian') { if (!formData.italian.trim()) { errors.italian = 'Traduzione italiana obbligatoria'; } else if (formData.italian.trim().length < 2) { errors.italian = 'Traduzione troppo corta'; } } setFormValidation(prev => ({ ...prev, ...errors })); }, [formData]); const handleAiAssist = useCallback(async () => { if (!formData.english.trim()) { showWarning('⚠️ Inserisci prima una parola inglese!'); return; } if (!aiServiceStatus?.configured) { showError(new Error('🔑 AI Service non configurato'), 'AI Configuration'); return; } try { showNotification('🤖 L\'AI sta analizzando la parola...', 'info'); const aiData = await aiLoading.executeAIOperation( () => enhancedAIService.analyzeWordWithFallback(formData.english.trim()), `Analisi di "${formData.english}"` ); const updatedStatus = enhancedAIService.getServiceStatus(); setAiServiceStatus(updatedStatus); if (aiData._aiError) { showWarning(`🤖 ${aiData.notes}`); setFormData(prev => ({ ...prev, group: aiData.group || prev.group, notes: aiData.notes || prev.notes })); } else { setFormData(prev => ({ ...prev, italian: aiData.italian || prev.italian, group: aiData.group || prev.group, sentence: aiData.sentence || prev.sentence, notes: aiData.notes || prev.notes, chapter: aiData.chapter || prev.chapter })); if (aiData.italian) { showSuccess('✨ Dati compilati dall\'AI!'); } else { showWarning('🤖 AI ha fornito dati parziali'); } } setShowAdvancedForm(true); } catch (error) { console.error('AI Assist Error:', error); const updatedStatus = enhancedAIService.getServiceStatus(); setAiServiceStatus(updatedStatus); const fallbackGroup = enhancedAIService.categorizeWordFallback(formData.english.trim()); setFormData(prev => ({ ...prev, group: prev.group || fallbackGroup, notes: prev.notes || `🤖 AI non disponibile. Gruppo suggerito: ${fallbackGroup}` })); setShowAdvancedForm(true); } }, [formData.english, aiServiceStatus, aiLoading, showNotification, showWarning, showSuccess, showError]); const handleSubmit = useCallback(async () => { if (!validateForm()) { showWarning('⚠️ Correggi gli errori nel form'); return; } try { await onAddWord({ english: formData.english.trim(), italian: formData.italian.trim(), group: formData.group.trim() || null, sentence: formData.sentence.trim() || null, notes: formData.notes.trim() || null, chapter: formData.chapter.trim() || null, learned: formData.learned, difficult: formData.difficult }); setFormData({ english: '', italian: '', group: '', sentence: '', notes: '', chapter: '', learned: false, difficult: false }); setShowAdvancedForm(false); setFormValidation({}); } catch (error) { console.error('Error adding word:', error); showError(error, 'Add Word'); } }, [formData, validateForm, onAddWord, showWarning, showError]); const handleClear = useCallback(() => { const hasData = Object.values(formData).some(value => typeof value === 'string' ? value.trim() : value ); if (hasData && !window.confirm('🗑️ Cancellare tutti i dati?')) { return; } setFormData({ english: '', italian: '', group: '', sentence: '', notes: '', chapter: '', learned: false, difficult: false }); setShowAdvancedForm(false); setFormValidation({}); onClearForm(); }, [formData, onClearForm]); useEffect(() => { checkAIServiceStatus(); console.log('🔒 AI Status: Manual refresh only (no automatic pings)'); }, [checkAIServiceStatus]); useEffect(() => { if (editingWord) { setFormData({ english: editingWord.english || '', italian: editingWord.italian || '', group: editingWord.group || '', sentence: editingWord.sentence || '', notes: editingWord.notes || '', chapter: editingWord.chapter || '', learned: editingWord.learned || false, difficult: editingWord.difficult || false }); setShowAdvancedForm(true); } }, [editingWord]); const renderAIStatusIndicator = () => { if (!aiServiceStatus) return null; const statusConfig = { healthy: { color: 'text-green-600', icon: '🟢', message: 'AI disponibile' }, degraded: { color: 'text-yellow-600', icon: '🟡', message: 'AI instabile' }, down: { color: 'text-red-600', icon: '🔴', message: 'AI non disponibile' }, unknown: { color: 'text-gray-600', icon: '⚪', message: 'AI sconosciuto' } }; const config = statusConfig[aiServiceStatus.health] || statusConfig.unknown; return ( <div className={`flex items-center gap-2 text-xs ${config.color}`}> <span>{config.icon}</span> <span>{config.message}</span> <Button variant="ghost" size="sm" onClick={handleRefreshStatus} disabled={isRefreshingStatus} className="h-6 px-2 text-xs hover:bg-yellow-100" title="⚠️ ATTENZIONE: Verifica manuale - COSTA DENARO!" > <RefreshCw className={`w-3 h-3 ${isRefreshingStatus ? 'animate-spin' : ''}`} /> {isRefreshingStatus ? '💰' : '💰'} </Button> </div> ); }; const isFormValid = formData.english.trim().length >= 2 && formData.italian.trim().length >= 2 && /^[a-zA-ZÀ-ÿ\s'-]+$/.test(formData.english.trim()) && Object.keys(formValidation).length === 0; return ( <FormErrorBoundary formName="AddWord" onFormError={(error) => showError(error, 'Word Form')}> <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className={editingWord ? "bg-gradient-to-r from-blue-500 to-purple-600 text-white" : ""}> <CardTitle className={`flex items-center justify-between ${editingWord ? "text-white" : "text-gray-800"}`}> {editingWord ? ( <div className="flex items-center gap-3"> <Edit3 className="w-6 h-6" /> <span>Modifica: {editingWord.english}</span> </div> ) : ( <div className="flex items-center gap-3"> <Plus className="w-6 h-6 text-green-600" /> <span className="bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent"> Aggiungi Nuove Parole </span> </div> )} <div className="flex flex-col gap-2"> <div className="flex gap-2"> {editingWord && ( <Button variant="ghost" size="sm" onClick={handleClear} className="text-white hover:bg-white/20" > ✕ Annulla </Button> )} <Button variant="ghost" size="sm" onClick={() => setShowAdvancedForm(!showAdvancedForm)} className={editingWord ? "text-white hover:bg-white/20" : "text-gray-600 hover:bg-gray-100"} > {showAdvancedForm ? 'Semplice' : 'Avanzato'} </Button> </div> {!editingWord && renderAIStatusIndicator()} </div> </CardTitle> {editingWord && ( <div className="text-blue-100 bg-blue-600/20 p-3 rounded-xl mt-4"> 💡 Modificando "<strong>{editingWord.english}</strong>". Cambia i campi e clicca "Salva Modifiche". </div> )} </CardHeader> <CardContent className="p-6"> <div className="space-y-6"> } <AIServiceErrorBoundary onAIError={(error) => showError(error, 'AI Assistant')}> {aiLoading.isLoading ? ( <div className="p-4 bg-purple-50 border border-purple-200 rounded-xl"> <SmartLoadingIndicator isLoading={true} operation={aiLoading.operation} duration={aiLoading.duration} customIcon={Brain} /> </div> ) : aiLoading.error ? ( <ErrorWithRetry error={aiLoading.error} onRetry={() => aiLoading.retry(() => handleAiAssist())} canRetry={aiLoading.canRetry} retryCount={aiLoading.retryCount} maxRetries={2} isRetrying={aiLoading.isLoading} /> ) : ( <Button onClick={handleAiAssist} disabled={!formData.english.trim() || !aiServiceStatus?.configured || aiLoading.isLoading} className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white py-4 text-lg rounded-xl shadow-lg transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none" title="💰 Questa operazione costa denaro (chiamata API Google)" > <Sparkles className="w-6 h-6 mr-3" /> 💰 AI Assistant - Compila Automaticamente </Button> )} </AIServiceErrorBoundary> } <div className="space-y-2"> <label className="text-sm font-medium text-gray-700 flex items-center gap-2"> <span>📂</span> Categoria </label> <select value={formData.group} onChange={(e) => handleInputChange('group', e.target.value)} className="w-full px-4 py-3 border-2 rounded-xl bg-white border-gray-200" > <option value="">Nessun gruppo</option> {getPredefinedGroups().map(group => ( <option key={group} value={group}> {getCategoryStyle(group).icon} {group} </option> ))} </select> </div> } <div className="space-y-2"> <label className="text-sm font-medium text-gray-700 flex items-center gap-2"> <span>🎓</span> Stato </label> <div className="space-y-3"> <div className="flex items-center gap-3 p-3 border-2 border-gray-200 rounded-xl bg-white"> <label className="flex items-center gap-2 cursor-pointer"> <div onClick={() => handleInputChange('learned', !formData.learned)} className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${ formData.learned ? 'bg-green-500 border-green-500 text-white' : 'border-gray-300 bg-white' }`} > {formData.learned && <span className="text-sm">✓</span>} </div> <span className="text-sm font-medium text-gray-700">Appresa</span> </label> </div> <div className="flex items-center gap-3 p-3 border-2 border-orange-200 rounded-xl bg-orange-50"> <label className="flex items-center gap-2 cursor-pointer"> <div onClick={() => handleInputChange('difficult', !formData.difficult)} className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${ formData.difficult ? 'bg-orange-500 border-orange-500 text-white' : 'border-orange-300 bg-white' }`} > {formData.difficult && <AlertTriangle className="w-4 h-4" />} </div> <span className="text-sm font-medium text-orange-700">⭐ Difficile</span> </label> </div> </div> </div> </div> } <div className="space-y-2"> <label className="text-sm font-medium text-gray-700 flex items-center gap-2"> <span>📝</span> Note </label> <Textarea placeholder="Altri significati, sinonimi, forme irregolari..." value={formData.notes} onChange={(e) => handleInputChange('notes', e.target.value)} rows={4} className="border-2 border-gray-200 rounded-xl" /> </div> </div> )}

================================================================================

NOME FILE: ErrorBoundaries.js

import React from 'react'; import { AlertTriangle, RefreshCw, Wifi, Database, Brain, FileX } from 'lucide-react'; import { Button } from './ui/button'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; class BaseErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false, error: null, errorInfo: null, retryCount: 0, lastErrorTime: null }; } static getDerivedStateFromError(error) { return { hasError: true, error, lastErrorTime: Date.now() }; } componentDidCatch(error, errorInfo) { this.setState({ error, errorInfo }); console.error(`❌ ${this.props.boundaryName || 'App'} Error:`, { error, errorInfo, retryCount: this.state.retryCount }); if (this.props.onError) { this.props.onError(error, errorInfo, this.props.boundaryName); } } handleRetry = () => { const maxRetries = this.props.maxRetries || 3; if (this.state.retryCount < maxRetries) { setTimeout(() => { this.setState(prevState => ({ hasError: false, error: null, errorInfo: null, retryCount: prevState.retryCount + 1 })); }, this.props.retryDelay || 1000); } else { this.handleReset(); } }; handleReset = () => { this.setState({ hasError: false, error: null, errorInfo: null, retryCount: 0, lastErrorTime: null }); if (this.props.onReset) { this.props.onReset(); } }; render() { if (this.state.hasError) { return this.props.fallback ? this.props.fallback(this.state.error, this.handleRetry, this.handleReset, this.state.retryCount) : this.renderDefaultError(); } return this.props.children; } renderDefaultError() { const { error, retryCount } = this.state; const maxRetries = this.props.maxRetries || 3; const canRetry = retryCount < maxRetries; return ( <Card className="border-red-200 bg-red-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-red-700"> <AlertTriangle className="w-5 h-5" /> Errore in {this.props.boundaryName || 'Applicazione'} </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-red-600 text-sm"> {error?.message || 'Si è verificato un errore imprevisto'} </p> {retryCount > 0 && ( <p className="text-orange-600 text-xs"> Tentativo {retryCount}/{maxRetries} </p> )} <div className="flex gap-2"> {canRetry ? ( <Button onClick={this.handleRetry} variant="outline" size="sm" className="border-red-300 text-red-700 hover:bg-red-100" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> ) : ( <Button onClick={this.handleReset} variant="outline" size="sm" className="border-red-300 text-red-700 hover:bg-red-100" > <RefreshCw className="w-4 h-4 mr-2" /> Reset Completo </Button> )} </div> </CardContent> </Card> ); } } export const AIServiceErrorBoundary = ({ children, onAIError }) => ( <BaseErrorBoundary boundaryName="AI Service" maxRetries={2} retryDelay={2000} onError={onAIError} fallback={(error, retry, reset, retryCount) => ( <Card className="border-purple-200 bg-purple-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-purple-700"> <Brain className="w-5 h-5" /> Errore AI Assistant </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-purple-600 text-sm"> {error?.message?.includes('timeout') ? '⏱️ Il servizio AI non risponde' : error?.message?.includes('API') ? '🔑 Problema con l\'API key' : '🤖 AI temporaneamente non disponibile' } </p> <div className="p-3 bg-blue-50 border border-blue-200 rounded-lg"> <p className="text-blue-700 text-sm font-medium mb-2"> 💡 Modalità Manuale Disponibile </p> <p className="text-blue-600 text-xs"> Puoi continuare a inserire parole manualmente. </p> </div> <Button onClick={retryCount < 2 ? retry : reset} variant="outline" size="sm" className="border-purple-300 text-purple-700 hover:bg-purple-100" > <RefreshCw className="w-4 h-4 mr-2" /> {retryCount < 2 ? 'Riprova AI' : 'Reset AI Service'} </Button> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const StorageErrorBoundary = ({ children, onStorageError }) => ( <BaseErrorBoundary boundaryName="Storage" maxRetries={1} retryDelay={500} onError={onStorageError} fallback={(error, retry, reset) => ( <Card className="border-orange-200 bg-orange-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-orange-700"> <Database className="w-5 h-5" /> Errore Salvataggio Dati </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-orange-600 text-sm"> {error?.message?.includes('quota') ? '💽 Spazio esaurito. Elimina dati vecchi.' : '💾 Problema nel salvataggio dei dati.' } </p> <div className="p-3 bg-red-50 border border-red-200 rounded-lg"> <p className="text-red-700 text-sm font-medium mb-2"> ⚠️ Rischio Perdita Dati </p> <p className="text-red-600 text-xs"> Esporta backup preventivo. </p> </div> <div className="flex gap-2"> <Button onClick={retry} variant="outline" size="sm" className="border-orange-300 text-orange-700 hover:bg-orange-100" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> <Button onClick={() => { window.dispatchEvent(new CustomEvent('forceExport')); reset(); }} variant="outline" size="sm" className="border-orange-300 text-orange-700 hover:bg-orange-100" > <FileX className="w-4 h-4 mr-2" /> Backup </Button> </div> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const NetworkErrorBoundary = ({ children, onNetworkError }) => ( <BaseErrorBoundary boundaryName="Network" maxRetries={3} retryDelay={3000} onError={onNetworkError} fallback={(error, retry, reset, retryCount) => ( <Card className="border-blue-200 bg-blue-50"> <CardHeader> <CardTitle className="flex items-center gap-2 text-blue-700"> <Wifi className="w-5 h-5" /> Errore di Connessione </CardTitle> </CardHeader> <CardContent className="space-y-4"> <p className="text-blue-600 text-sm"> {error?.message?.includes('fetch') ? '📡 Nessuna connessione internet' : '🌐 Problema di connessione' } </p> <div className="p-3 bg-green-50 border border-green-200 rounded-lg"> <p className="text-green-700 text-sm font-medium mb-2"> 🔄 Modalità Offline </p> <p className="text-green-600 text-xs"> L'app continua a funzionare offline. </p> </div> <Button onClick={retryCount < 3 ? retry : reset} variant="outline" size="sm" className="border-blue-300 text-blue-700 hover:bg-blue-100" > <RefreshCw className="w-4 h-4 mr-2" /> {retryCount < 3 ? 'Riprova' : 'Reset Rete'} </Button> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const MainAppErrorBoundary = ({ children, onAppError }) => ( <BaseErrorBoundary boundaryName="Main App" maxRetries={1} retryDelay={1000} onError={onAppError} fallback={(error, retry, reset) => ( <div className="min-h-screen bg-gradient-to-br from-red-50 to-orange-50 flex items-center justify-center p-6"> <Card className="max-w-md w-full border-red-200 bg-white shadow-xl"> <CardHeader> <CardTitle className="flex items-center gap-2 text-red-700 text-center"> <AlertTriangle className="w-6 h-6" /> Errore Applicazione </CardTitle> </CardHeader> <CardContent className="space-y-6 text-center"> <p className="text-red-600"> Errore critico. Tutti i dati sono al sicuro. </p> <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg"> <p className="text-blue-700 text-sm font-medium mb-2"> 🔄 Soluzioni </p> <ul className="text-blue-600 text-xs space-y-1 text-left"> <li>• Ricaricare la pagina (F5)</li> <li>• Svuotare cache browser</li> <li>• Esportare backup</li> </ul> </div> <div className="flex flex-col gap-3"> <Button onClick={() => window.location.reload()} className="bg-red-600 hover:bg-red-700 text-white" > <RefreshCw className="w-4 h-4 mr-2" /> Ricarica App </Button> <Button onClick={() => { window.dispatchEvent(new CustomEvent('emergencyExport')); }} variant="outline" size="sm" className="border-red-300 text-red-700 hover:bg-red-100" > <FileX className="w-4 h-4 mr-2" /> Export Emergenza </Button> </div> </CardContent> </Card> </div> )} > {children} </BaseErrorBoundary> ); export const FormErrorBoundary = ({ children, formName, onFormError }) => ( <BaseErrorBoundary boundaryName={`${formName} Form`} maxRetries={2} retryDelay={500} onError={onFormError} fallback={(error, retry, reset) => ( <Card className="border-yellow-200 bg-yellow-50"> <CardContent className="p-4"> <div className="flex items-center gap-2 text-yellow-700 mb-3"> <AlertTriangle className="w-4 h-4" /> <span className="font-medium">Errore nel Form</span> </div> <p className="text-yellow-600 text-sm mb-4"> {error?.message?.includes('validation') ? 'Errore di validazione dati' : 'Errore elaborazione form' } </p> <div className="flex gap-2"> <Button onClick={retry} variant="outline" size="sm" className="border-yellow-300 text-yellow-700 hover:bg-yellow-100" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> <Button onClick={reset} variant="outline" size="sm" className="border-yellow-300 text-yellow-700 hover:bg-yellow-100" > Reset Form </Button> </div> </CardContent> </Card> )} > {children} </BaseErrorBoundary> ); export const ErrorTracker = { errors: [], logError(error, boundary, context = {}) { const errorLog = { id: Date.now(), timestamp: new Date().toISOString(), boundary, message: error.message, stack: error.stack, context, userAgent: navigator.userAgent, url: window.location.href }; this.errors.push(errorLog); if (this.errors.length > 50) { this.errors = this.errors.slice(-50); } if (process.env.NODE_ENV === 'development') { console.group(`🚨 Error in ${boundary}`); console.error('Error:', error); console.log('Context:', context); console.groupEnd(); } }, exportErrors() { const blob = new Blob([JSON.stringify(this.errors, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `error-log-${new Date().toISOString().split('T')[0]}.json`; a.click(); URL.revokeObjectURL(url); }, clearErrors() { this.errors = []; }, getErrorStats() { const errorsByBoundary = {}; this.errors.forEach(error => { errorsByBoundary[error.boundary] = (errorsByBoundary[error.boundary] || 0) + 1; }); return { total: this.errors.length, byBoundary: errorsByBoundary, lastError: this.errors[this.errors.length - 1] }; } };

================================================================================

NOME FILE: ErrorBoundary.js

import React from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { AlertTriangle, RefreshCw } from 'lucide-react'; export class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false, error: null, errorInfo: null }; } static getDerivedStateFromError(error) { return { hasError: true }; } componentDidCatch(error, errorInfo) { this.setState({ error, errorInfo }); if (process.env.NODE_ENV === 'development') { console.error('ErrorBoundary caught an error:', error, errorInfo); } if (typeof window !== 'undefined' && window.gtag) { window.gtag('event', 'exception', { description: error.toString(), fatal: true }); } } handleReset = () => { this.setState({ hasError: false, error: null, errorInfo: null }); }; render() { if (this.state.hasError) { return ( <div className="min-h-screen bg-gradient-to-br from-red-50 via-white to-pink-50 flex items-center justify-center p-6"> <Card className="max-w-lg w-full bg-white/90 backdrop-blur-sm border-0 shadow-2xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-red-500 to-pink-500 text-white text-center py-8"> <div className="text-6xl mb-4"> <AlertTriangle className="w-16 h-16 mx-auto" /> </div> <CardTitle className="text-2xl font-bold text-white"> Oops! Qualcosa è andato storto </CardTitle> <p className="text-red-100 mt-2"> Si è verificato un errore imprevisto nell'applicazione </p> </CardHeader> <CardContent className="p-8 text-center"> <div className="space-y-6"> <p className="text-gray-600"> Non preoccuparti, i tuoi dati sono al sicuro. Prova a ricaricare la pagina o contatta il supporto se il problema persiste. </p> <div className="flex gap-4 justify-center"> <Button onClick={this.handleReset} className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-6 py-3 rounded-xl" > <RefreshCw className="w-4 h-4 mr-2" /> Riprova </Button> <Button onClick={() => window.location.reload()} variant="outline" className="px-6 py-3 rounded-xl" > Ricarica Pagina </Button> </div> {process.env.NODE_ENV === 'development' && this.state.error && ( <details className="mt-6 text-left"> <summary className="cursor-pointer text-red-600 font-medium"> Dettagli Errore (Dev Mode) </summary> <pre className="mt-2 p-4 bg-gray-100 rounded-lg text-xs overflow-auto max-h-40"> {this.state.error.toString()} {this.state.errorInfo.componentStack} </pre> </details> )} </div> </CardContent> </Card> </div> ); } return this.props.children; } }

================================================================================

NOME FILE: JSONManager.js

import React from 'react'; import { useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Textarea } from './ui/textarea'; import { FileDown, ChevronDown, ChevronUp, Upload, Download } from 'lucide-react'; import { useNotification } from '../contexts/NotificationContext'; const JSONManager = ({ words, onImportWords }) => { const [jsonText, setJsonText] = useState(''); const [showSection, setShowSection] = useState(false); const [isProcessing, setIsProcessing] = useState(false); const { showSuccess, showError, showWarning } = useNotification(); const handleExport = () => { if (words.length === 0) { showWarning('⚠️ Nessuna parola da esportare!'); return; } try { setIsProcessing(true); const exportData = { words: words, exportDate: new Date().toISOString(), totalWords: words.length, version: '2.0', appName: 'Vocabulary Master', metadata: { chapters: [...new Set(words.map(w => w.chapter).filter(Boolean))], groups: [...new Set(words.map(w => w.group).filter(Boolean))], learnedCount: words.filter(w => w.learned).length, difficultCount: words.filter(w => w.difficult).length } }; const dataStr = JSON.stringify(exportData, null, 2); setJsonText(dataStr); setShowSection(true); showSuccess(`✅ ${words.length} parole esportate con successo!`); } catch (error) { console.error('Export error:', error); showError(error, 'Export JSON'); } finally { setIsProcessing(false); } }; const downloadAsFile = () => { if (!jsonText.trim()) { showWarning('⚠️ Nessun JSON da scaricare! Esporta prima i dati.'); return; } try { const blob = new Blob([jsonText], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `vocabulary-backup-${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); showSuccess('✅ File scaricato con successo!'); } catch (error) { console.error('Download error:', error); showError(error, 'Download File'); } }; const handleImport = async () => { if (!jsonText.trim()) { showWarning('⚠️ Inserisci del JSON da importare!'); return; } try { setIsProcessing(true); let parsedData; try { parsedData = JSON.parse(jsonText.trim()); } catch (parseError) { throw new Error('JSON non valido! Controlla la sintassi.'); } let wordsToImport; if (Array.isArray(parsedData)) { wordsToImport = parsedData; } else if (parsedData.words && Array.isArray(parsedData.words)) { wordsToImport = parsedData.words; if (parsedData.metadata) { showSuccess(`📊 Rilevato backup ${parsedData.version || 'legacy'} del ${new Date(parsedData.exportDate).toLocaleDateString()}`); } } else { throw new Error('Formato JSON non valido. Atteso array di parole o oggetto con campo "words".'); } if (!wordsToImport || wordsToImport.length === 0) { throw new Error('Nessuna parola trovata nel JSON.'); } const validWords = wordsToImport.filter(word => { return word && typeof word === 'object' && word.english && word.italian && typeof word.english === 'string' && typeof word.italian === 'string'; }); if (validWords.length === 0) { throw new Error('Nessuna parola valida trovata. Ogni parola deve avere almeno "english" e "italian".'); } if (validWords.length < wordsToImport.length) { showWarning(`⚠️ ${wordsToImport.length - validWords.length} parole saltate perché non valide.`); } const importedCount = await onImportWords(JSON.stringify(validWords)); setJsonText(''); setShowSection(true); showSuccess(`✅ ${importedCount} nuove parole importate con successo!`); } catch (error) { console.error('Import error:', error); if (error.message.includes('JSON') || error.message.includes('syntax')) { showError(new Error('❌ JSON non valido! Controlla la sintassi.'), 'Import JSON'); } else if (error.message.includes('already exist')) { showWarning('⚠️ Tutte le parole sono già presenti nel vocabolario.'); } else { showError(error, 'Import JSON'); } } finally { setIsProcessing(false); } }; const handleFileUpload = (event) => { const file = event.target.files[0]; if (!file) return; if (file.type !== 'application/json' && !file.name.endsWith('.json')) { showWarning('⚠️ Seleziona un file JSON valido.'); return; } const reader = new FileReader(); reader.onload = (e) => { try { const content = e.target.result; setJsonText(content); setShowSection(true); showSuccess('📁 File caricato! Verifica il contenuto e clicca "Importa JSON".'); } catch (error) { showError(error, 'File Reading'); } }; reader.onerror = () => { showError(new Error('Errore nella lettura del file'), 'File Reading'); }; reader.readAsText(file); }; return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="cursor-pointer hover:bg-gray-50 transition-colors" onClick={() => setShowSection(!showSection)} > <CardTitle className="flex items-center justify-between"> <div className="flex items-center gap-3"> <FileDown className="w-6 h-6 text-indigo-600" /> <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent"> Gestione Dati JSON </span> </div> {showSection ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />} </CardTitle> </CardHeader> {showSection && ( <CardContent className="animate-fade-in"> <div className="space-y-6"> <div className="p-4 bg-blue-50 rounded-2xl border border-blue-200"> <p className="text-blue-800 text-sm flex items-center gap-2"> <span className="text-lg">💡</span> Usa questa sezione per fare backup del tuo vocabolario o condividerlo tra dispositivi </p> </div> } {jsonText && ( <div className="space-y-2"> <div className="p-3 bg-green-50 border border-green-200 rounded-xl"> <p className="text-green-800 text-sm"> 💾 <strong>Formato rilevato:</strong> { (() => { try { const parsed = JSON.parse(jsonText); if (Array.isArray(parsed)) { const hasWords = parsed.length > 0; const firstItem = hasWords ? parsed[0] : null; const hasEnglishItalian = firstItem && firstItem.english && firstItem.italian; if (hasEnglishItalian) { return `Array di ${parsed.length} parole (✅ Formato valido)`; } else if (hasWords) { return `Array con ${parsed.length} elementi (⚠️ Verificare formato)`; } else { return 'Array vuoto (❌ Nessuna parola)'; } } else if (parsed.words && Array.isArray(parsed.words)) { return `Backup Export v${parsed.version || '1.0'} con ${parsed.words.length} parole (✅ Formato valido)`; } else { return 'Oggetto JSON (⚠️ Array o campo "words" richiesto)'; } } catch { return 'JSON non valido (❌ Errore sintassi)'; } })() } </p> </div> } {isProcessing && ( <div className="flex items-center justify-center p-4 bg-yellow-50 border border-yellow-200 rounded-xl"> <div className="animate-spin w-5 h-5 border-2 border-yellow-500 border-t-transparent rounded-full mr-3"></div> <span className="text-yellow-800 font-medium">Elaborazione in corso...</span> </div> )}

================================================================================

NOME FILE: LoadingComponents.js

import React from 'react'; import { Loader2, Brain, Database, Wifi, AlertCircle, Clock, RefreshCw } from 'lucide-react'; import { Card, CardContent } from './ui/card'; import { Button } from './ui/button'; export const SmartLoadingIndicator = ({ isLoading, operation, duration, size = 'md', showDuration = true, customIcon = null, customMessage = null }) => { if (!isLoading) return null; const sizeClasses = { sm: 'w-4 h-4', md: 'w-6 h-6', lg: 'w-8 h-8', xl: 'w-12 h-12' }; const getOperationIcon = () => { if (customIcon) return customIcon; if (operation?.toLowerCase().includes('ai')) return Brain; if (operation?.toLowerCase().includes('storage') || operation?.toLowerCase().includes('save')) return Database; if (operation?.toLowerCase().includes('network') || operation?.toLowerCase().includes('fetch')) return Wifi; return Loader2; }; const Icon = getOperationIcon(); const message = customMessage || operation || 'Caricamento...'; return ( <div className="flex items-center gap-3 text-blue-600"> <Icon className={`${sizeClasses[size]} animate-spin`} /> <div className="flex flex-col"> <span className="text-sm font-medium">{message}</span> {showDuration && duration > 2000 && ( <span className="text-xs text-gray-500"> {Math.round(duration / 1000)}s </span> )} </div> </div> ); }; export const ProgressLoader = ({ isLoading, progress, operation, estimatedTime, onCancel }) => { if (!isLoading) return null; return ( <Card className="border-blue-200 bg-blue-50"> <CardContent className="p-6"> <div className="space-y-4"> <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> <Loader2 className="w-5 h-5 animate-spin text-blue-600" /> <span className="font-medium text-blue-800">{operation}</span> </div> {onCancel && ( <Button variant="ghost" size="sm" onClick={onCancel} className="text-blue-600 hover:bg-blue-100" > Annulla </Button> )} </div> {progress !== undefined && ( <div className="space-y-2"> <div className="flex justify-between text-sm text-blue-600"> <span>{Math.round(progress)}%</span> {estimatedTime && ( <span className="flex items-center gap-1"> <Clock className="w-3 h-3" /> {estimatedTime}s </span> )} </div>

================================================================================

NOME FILE: ServiceStatusIndicator.js

import React, { useState, useEffect } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Brain, Database, Wifi, CheckCircle, AlertTriangle, XCircle, RefreshCw, Info } from 'lucide-react'; import { enhancedAIService } from '../services/enhancedAIService'; import { enhancedStorageService } from '../services/enhancedStorageService'; const ServiceStatusIndicator = ({ compact = false, showDetails = false, onStatusChange = null }) => { const [aiStatus, setAiStatus] = useState(null); const [storageStatus, setStorageStatus] = useState(null); const [isRefreshing, setIsRefreshing] = useState(false); const [lastUpdate, setLastUpdate] = useState(null); const checkAllServices = async () => { setIsRefreshing(true); try { const [aiResult, storageResult] = await Promise.all([ enhancedAIService.getServiceStatus(), enhancedStorageService.getServiceStatus() ]); setAiStatus(aiResult); setStorageStatus(storageResult); setLastUpdate(Date.now()); if (onStatusChange) { onStatusChange({ ai: aiResult, storage: storageResult, overall: getOverallHealth(aiResult, storageResult) }); } } catch (error) { console.error('❌ Failed to check service status:', error); } finally { setIsRefreshing(false); } }; const getOverallHealth = (ai, storage) => { if (!ai || !storage) return 'unknown'; if (ai.health === 'down' || storage.health === 'down') return 'critical'; if (ai.health === 'degraded' || storage.health === 'degraded') return 'warning'; if (ai.health === 'healthy' && storage.health === 'healthy') return 'healthy'; return 'unknown'; }; const getStatusIcon = (health) => { switch (health) { case 'healthy': return <CheckCircle className="w-5 h-5 text-green-500" />; case 'degraded': return <AlertTriangle className="w-5 h-5 text-yellow-500" />; case 'down': return <XCircle className="w-5 h-5 text-red-500" />; default: return <Info className="w-5 h-5 text-gray-500" />; } }; const getStatusColor = (health) => { switch (health) { case 'healthy': return 'border-green-200 bg-green-50'; case 'degraded': return 'border-yellow-200 bg-yellow-50'; case 'down': return 'border-red-200 bg-red-50'; default: return 'border-gray-200 bg-gray-50'; } }; useEffect(() => { checkAllServices(); const interval = setInterval(checkAllServices, 30000); return () => clearInterval(interval); }, []); if (compact && (!aiStatus || !storageStatus)) { return ( <div className="flex items-center gap-2 text-gray-500"> <RefreshCw className="w-4 h-4 animate-spin" /> <span className="text-sm">Checking...</span> </div> ); } if (compact) { const overallHealth = getOverallHealth(aiStatus, storageStatus); return ( <div className={`flex items-center gap-2 px-3 py-2 rounded-lg border ${getStatusColor(overallHealth)}`}> {getStatusIcon(overallHealth)} <span className="text-sm font-medium"> {overallHealth === 'healthy' ? 'All Services OK' : overallHealth === 'warning' ? 'Some Issues' : overallHealth === 'critical' ? 'Service Issues' : 'Checking...'} </span> <Button variant="ghost" size="sm" onClick={checkAllServices} disabled={isRefreshing} className="h-6 w-6 p-0" > <RefreshCw className={`w-3 h-3 ${isRefreshing ? 'animate-spin' : ''}`} /> </Button> </div> ); } return ( <Card className="w-full"> <CardHeader> <CardTitle className="flex items-center justify-between"> <span className="flex items-center gap-2"> <Wifi className="w-5 h-5" /> Service Status </span> <Button variant="outline" size="sm" onClick={checkAllServices} disabled={isRefreshing} > <RefreshCw className={`w-4 h-4 mr-2 ${isRefreshing ? 'animate-spin' : ''}`} /> Refresh </Button> </CardTitle> {lastUpdate && ( <p className="text-sm text-gray-500"> Last updated: {new Date(lastUpdate).toLocaleTimeString()} </p> )} </CardHeader> <CardContent className="space-y-4"> } <div className={`p-4 rounded-lg border ${storageStatus ? getStatusColor(storageStatus.health) : 'border-gray-200 bg-gray-50'}`}> <div className="flex items-center justify-between mb-3"> <div className="flex items-center gap-3"> <Database className="w-6 h-6 text-blue-600" /> <div> <h3 className="font-semibold">Local Storage</h3> <p className="text-sm text-gray-600"> {storageStatus?.available ? 'Available' : 'Unavailable'} </p> </div> </div> {storageStatus && getStatusIcon(storageStatus.health)} </div> {storageStatus && showDetails && ( <div className="space-y-2 text-sm"> <div className="grid grid-cols-2 gap-4"> <div> <span className="font-medium">Used:</span> {storageStatus.usage.usedMB}MB </div> <div> <span className="font-medium">Available:</span> {storageStatus.usage.availableMB}MB </div> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className={`h-2 rounded-full ${ storageStatus.usage.critical ? 'bg-red-500' : storageStatus.usage.warning ? 'bg-yellow-500' : 'bg-green-500' }`} style={{ width: `${storageStatus.usage.usagePercentage}%` }} /> </div> {storageStatus.recommendations.length > 0 && ( <div> <span className="font-medium">Recommendations:</span> <ul className="list-disc list-inside mt-1"> {storageStatus.recommendations.map((rec, index) => ( <li key={index} className="text-xs">{rec}</li> ))} </ul> </div> )} </div> )} </div>

================================================================================

NOME FILE: TestCard.js

import React from 'react'; import { getCategoryStyle } from '../utils/categoryUtils'; import { formatNotes } from '../utils/textUtils'; const TestCard = ({ word, showMeaning, onFlip, showHint, hintUsed }) => { return ( <div className="relative cursor-pointer transform transition-transform duration-300 hover:scale-105" style={{ width: '26rem', height: '38rem', perspective: '1000px' }} onClick={onFlip} > <div className="absolute inset-0 w-full h-full transition-transform duration-700 preserve-3d" style={{ transformStyle: 'preserve-3d', transform: showMeaning ? 'rotateY(180deg)' : 'rotateY(0deg)' }} > } {showHint && word.sentence && ( <div className="absolute top-6 left-6 right-6"> <div className="bg-white/20 backdrop-blur-md rounded-2xl p-4 border border-white/30 animate-fade-in"> <div className="flex items-center gap-2 mb-2"> <span className="text-lg">💡</span> <span className="text-sm font-bold text-white/90">Suggerimento:</span> {hintUsed && ( <span className="text-xs bg-orange-400/80 text-white px-2 py-1 rounded-full"> Conteggiato </span> )} </div> <div className="text-sm italic text-white/90 leading-relaxed"> "{word.sentence}" </div> </div> </div> )} <div className="text-center space-y-6 flex-1 flex flex-col justify-center"> <div className="text-5xl font-bold drop-shadow-lg"> {word.english} </div> <div className="text-xl opacity-90 animate-pulse"> Clicca per vedere la traduzione </div> <div className="mt-8"> <div className="inline-flex items-center justify-center w-16 h-16 border-2 border-white/30 rounded-2xl backdrop-blur-sm"> <span className="text-2xl font-bold">EN</span> </div> </div> </div> } <div className={`absolute inset-0 w-full h-full rounded-3xl shadow-2xl overflow-hidden backface-hidden ${getCategoryStyle(word.group)?.bgGradient || 'bg-gradient-to-br from-emerald-500 to-cyan-600'}`} style={{ backfaceVisibility: 'hidden', transform: 'rotateY(180deg)' }} > <div className="absolute inset-0 bg-black/20"></div> } {hintUsed && ( <div className="absolute top-4 left-4 z-10"> <div className="bg-orange-500/80 backdrop-blur-sm text-white px-3 py-2 rounded-xl text-sm font-medium flex items-center gap-2 shadow-lg"> <span>💡</span> <span>Aiuto usato</span> </div> </div> )} <div className="relative h-full flex flex-col text-white p-8"> } <div className="text-center mb-8"> <div className="font-bold drop-shadow-lg leading-tight" style={{ fontSize: word.italian.length > 25 ? '2rem' : word.italian.length > 15 ? '2.5rem' : word.italian.length > 10 ? '3rem' : '3.5rem' }} > {word.italian} </div> </div> } {word.notes && ( <div className="flex-1 min-h-0"> <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-4 h-full flex flex-col border border-white/20"> <div className="font-bold mb-3 text-sm flex items-center gap-2"> <span className="text-lg">📝</span> Note: </div> <div className="overflow-y-auto flex-1 text-sm leading-relaxed whitespace-pre-line"> {formatNotes(word.notes)} </div> </div> </div> )}

================================================================================

NOME FILE: TestHistory.js

import React, { useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { ChevronDown, ChevronUp, BookOpen, Target, Calendar, Award } from 'lucide-react'; const TestHistory = ({ testHistory, onClearHistory }) => { const [expandedTest, setExpandedTest] = useState(null); if (testHistory.length === 0) return null; const toggleTestExpansion = (testId) => { setExpandedTest(expandedTest === testId ? null : testId); }; const formatDifficulty = (difficulty) => { const difficultyMap = { 'easy': { label: 'Facile', color: 'bg-green-500', emoji: '😊' }, 'medium': { label: 'Medio', color: 'bg-yellow-500', emoji: '😐' }, 'hard': { label: 'Difficile', color: 'bg-red-500', emoji: '😤' } }; return difficultyMap[difficulty] || difficultyMap['medium']; }; const formatTestType = (testType) => { const typeMap = { 'complete': { label: 'Completo', color: 'bg-blue-500', emoji: '🎯' }, 'selective': { label: 'Selettivo', color: 'bg-purple-500', emoji: '📚' }, 'unknown': { label: 'Standard', color: 'bg-gray-500', emoji: '📝' } }; return typeMap[testType] || typeMap['unknown']; }; return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-600 text-white"> <div className="flex justify-between items-center"> <CardTitle className="flex items-center gap-3 text-white"> <Calendar className="w-6 h-6" /> Cronologia Test Dettagliata ({testHistory.length}) </CardTitle> <Button onClick={onClearHistory} variant="outline" className="border-white/30 text-white hover:bg-white/20 hover:border-white/50 rounded-xl" > <span className="w-4 h-4 mr-2">🗑️</span> Pulisci </Button> </div> <p className="text-indigo-100 mt-2"> Storico completo con parametri di test, capitoli e performance dettagliate </p> </CardHeader> <CardContent className="p-6"> <div className="space-y-4 max-h-96 overflow-y-auto scrollbar-thin"> {testHistory.map((test, index) => ( <TestHistoryCard key={test.id} test={test} testNumber={testHistory.length - index} isExpanded={expandedTest === test.id} onToggleExpansion={() => toggleTestExpansion(test.id)} formatDifficulty={formatDifficulty} formatTestType={formatTestType} /> ))} </div> </CardContent> </Card> ); }; const TestHistoryCard = ({ test, testNumber, isExpanded, onToggleExpansion, formatDifficulty, formatTestType }) => { const difficulty = formatDifficulty(test.difficulty); const testType = formatTestType(test.testType); return ( <div className="bg-gradient-to-r from-gray-50 to-white rounded-2xl border border-gray-100 hover:shadow-lg transition-all duration-300 overflow-hidden"> } <div className={`px-4 py-2 rounded-full text-sm font-bold shadow-lg text-white ${ test.percentage >= 80 ? 'bg-gradient-to-r from-green-500 to-emerald-500' : test.percentage >= 60 ? 'bg-gradient-to-r from-blue-500 to-cyan-500' : 'bg-gradient-to-r from-red-500 to-pink-500' }`}> {test.percentage}% </div> } <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${difficulty.color}`}> <span className="mr-1">{difficulty.emoji}</span> {difficulty.label} </div> </div> } <div className="grid grid-cols-3 gap-4"> <div className="bg-blue-50 p-3 rounded-xl text-center"> <div className="text-lg font-bold text-blue-600">{test.totalWords}</div> <div className="text-blue-700 text-xs">Totale</div> </div> <div className="bg-green-50 p-3 rounded-xl text-center"> <div className="text-lg font-bold text-green-600">{test.correctWords}</div> <div className="text-green-700 text-xs">Corrette</div> </div> <div className="bg-red-50 p-3 rounded-xl text-center"> <div className="text-lg font-bold text-red-600">{test.incorrectWords}</div> <div className="text-red-700 text-xs">Sbagliate</div> </div> </div> </div> } {isExpanded && ( <div className="border-t border-gray-200 bg-gray-50"> <div className="p-6 space-y-6"> } {test.chapterStats && Object.keys(test.chapterStats).length > 0 && ( <div> <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2"> <BookOpen className="w-5 h-5" /> Performance per Capitolo </h4> <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"> {Object.entries(test.chapterStats).map(([chapter, stats]) => ( <div key={chapter} className="bg-white p-4 rounded-xl border border-gray-200"> <div className="font-medium text-gray-800 mb-2"> {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`} </div> <div className="space-y-2"> <div className="flex justify-between items-center"> <span className="text-sm text-gray-600">Accuratezza:</span> <span className={`font-bold ${ stats.percentage >= 80 ? 'text-green-600' : stats.percentage >= 60 ? 'text-blue-600' : 'text-red-600' }`}> {stats.percentage}% </span> </div> <div className="flex justify-between items-center text-xs text-gray-500"> <span>Corrette: {stats.correctWords}</span> <span>Sbagliate: {stats.incorrectWords}</span> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className={`h-2 rounded-full ${ stats.percentage >= 80 ? 'bg-green-500' : stats.percentage >= 60 ? 'bg-blue-500' : 'bg-red-500' }`} style={{ width: `${stats.percentage}%` }} ></div> </div> </div> </div> ))} </div> </div> )} } <div className="bg-blue-50 p-4 rounded-xl border border-blue-200"> <h5 className="font-medium text-blue-800 mb-2">💡 Raccomandazioni per il prossimo test:</h5> <div className="text-sm text-blue-700 space-y-1"> {test.percentage < 60 && ( <p>• Rivedi le parole sbagliate prima del prossimo test</p> )} {test.chapterStats && Object.values(test.chapterStats).some(s => s.percentage < 70) && ( <p>• Concentrati sui capitoli con performance inferiore al 70%</p> )} {test.testParameters?.selectedChapters?.length === 1 && ( <p>• Prova a combinare più capitoli per aumentare la varietà</p> )} {test.percentage >= 80 && ( <p>• Ottimo lavoro! Potresti provare un test più difficile</p> )} </div> </div> </div> </div> )} </div> ); }; export default TestHistory;

================================================================================

NOME FILE: TestResults.js

import React from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Play, RotateCcw, Check, X, Trophy, Clock, Lightbulb, Target, Timer, Zap } from 'lucide-react'; import { getTestResult } from '../utils/textUtils'; import { formatNotes } from '../utils/textUtils'; const TestResults = ({ stats, wrongWords, onStartNewTest, onResetTest }) => { const getCorrectStats = () => { if (stats && typeof stats === 'object') { const enhancedStats = { correct: stats.correct || 0, incorrect: stats.incorrect || 0, hints: stats.hints || 0, totalTime: stats.totalTime || 0, avgTimePerWord: stats.avgTimePerWord || 0, maxTimePerWord: stats.maxTimePerWord || 0, minTimePerWord: stats.minTimePerWord || 0, totalRecordedTime: stats.totalRecordedTime || 0 }; return enhancedStats; } if (stats) { const correct = stats.correct || stats.correctAnswers || stats.right || 0; const incorrect = stats.incorrect || stats.incorrectAnswers || stats.wrong || 0; const hints = stats.hints || stats.hintsUsed || 0; const totalTime = stats.totalTime || stats.timeSpent || 0; const avgTimePerWord = stats.avgTimePerWord || stats.averageTime || 0; const maxTimePerWord = stats.maxTimePerWord || 0; const minTimePerWord = stats.minTimePerWord || 0; const totalRecordedTime = stats.totalRecordedTime || 0; if (correct > 0 || incorrect > 0) { const legacyStats = { correct, incorrect, hints, totalTime, avgTimePerWord, maxTimePerWord, minTimePerWord, totalRecordedTime }; return legacyStats; } } if (wrongWords && Array.isArray(wrongWords)) { const incorrect = wrongWords.length; const correct = Math.max(0, (stats?.total || 10) - incorrect); const fallbackStats = { correct, incorrect, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; return fallbackStats; } const defaultStats = { correct: 0, incorrect: 0, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; return defaultStats; }; const finalStats = getCorrectStats(); const totalAnswers = finalStats.correct + finalStats.incorrect; const percentage = totalAnswers > 0 ? Math.round((finalStats.correct / totalAnswers) * 100) : 0; const result = getTestResult({ correct: finalStats.correct, incorrect: finalStats.incorrect, total: totalAnswers }); const formatTime = (seconds) => { if (!seconds || seconds <= 0) return '0:00'; const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }; const performanceMetrics = { accuracy: percentage, hintsUsed: finalStats.hints, hintsPercentage: totalAnswers > 0 ? Math.round((finalStats.hints / totalAnswers) * 100) : 0, totalTime: formatTime(finalStats.totalTime), totalTimeSeconds: finalStats.totalTime, avgTime: finalStats.avgTimePerWord, maxTime: finalStats.maxTimePerWord, minTime: finalStats.minTimePerWord, totalRecordedTime: formatTime(finalStats.totalRecordedTime), speedRating: finalStats.avgTimePerWord <= 8 ? 'Molto veloce' : finalStats.avgTimePerWord <= 15 ? 'Veloce' : finalStats.avgTimePerWord <= 25 ? 'Normale' : 'Lento', efficiency: Math.max(0, percentage - (finalStats.hints / Math.max(1, totalAnswers) * 100)) }; return ( <div className="space-y-8"> <Card className="relative overflow-hidden backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl"> } <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm text-gray-600"> {finalStats.hints > 0 && ( <div className="flex items-center justify-center gap-1 bg-orange-100 px-3 py-2 rounded-lg"> <Lightbulb className="w-4 h-4 text-orange-500" /> <span>{finalStats.hints} aiuti ({performanceMetrics.hintsPercentage}%)</span> </div> )} {finalStats.totalTime > 0 && ( <div className="flex items-center justify-center gap-1 bg-blue-100 px-3 py-2 rounded-lg"> <Clock className="w-4 h-4 text-blue-500" /> <span>{performanceMetrics.totalTime} totale</span> </div> )} {finalStats.avgTimePerWord > 0 && ( <div className="flex items-center justify-center gap-1 bg-purple-100 px-3 py-2 rounded-lg"> <Target className="w-4 h-4 text-purple-500" /> <span>{finalStats.avgTimePerWord}s media ({performanceMetrics.speedRating})</span> </div> )} {finalStats.maxTimePerWord > 0 && ( <div className="flex items-center justify-center gap-1 bg-red-100 px-3 py-2 rounded-lg"> <Timer className="w-4 h-4 text-red-500" /> <span>{finalStats.maxTimePerWord}s massimo</span> </div> )} </div> </CardHeader> <CardContent className="relative pb-12"> } <div className="bg-gradient-to-br from-orange-500 to-yellow-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform"> <div className="text-3xl font-bold">{finalStats.hints}</div> <div className="text-orange-100">Aiuti ({performanceMetrics.hintsPercentage}%)</div> <Lightbulb className="w-8 h-8 mx-auto mt-2 opacity-80" /> </div> } <div className="bg-gradient-to-br from-purple-500 to-indigo-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform"> <div className="text-3xl font-bold">{Math.round(performanceMetrics.efficiency)}%</div> <div className="text-purple-100">Efficienza</div> <Zap className="w-8 h-8 mx-auto mt-2 opacity-80" /> </div> </div> } <div className="text-center"> <h4 className="font-bold text-indigo-800 mb-3">⏱️ Statistiche Tempo</h4> <div className="space-y-2"> <div className="bg-white p-3 rounded-lg border border-indigo-200"> <div className="text-lg font-bold text-indigo-600">{performanceMetrics.avgTime}s</div> <div className="text-indigo-800 text-sm">Tempo Medio</div> </div> {finalStats.maxTimePerWord > 0 && ( <div className="bg-white p-3 rounded-lg border border-red-200"> <div className="text-lg font-bold text-red-600">{finalStats.maxTimePerWord}s</div> <div className="text-red-800 text-sm">Tempo Massimo</div> </div> )} {finalStats.minTimePerWord > 0 && ( <div className="bg-white p-3 rounded-lg border border-green-200"> <div className="text-lg font-bold text-green-600">{finalStats.minTimePerWord}s</div> <div className="text-green-800 text-sm">Tempo Minimo</div> </div> )} </div> </div> } <div className="text-center"> <h4 className="font-bold text-green-800 mb-3">🏆 Valutazione</h4> <div className="space-y-2"> <div className="bg-white p-3 rounded-lg border border-green-200"> <div className="text-lg font-bold text-green-600">{performanceMetrics.speedRating}</div> <div className="text-green-800 text-sm">Velocità</div> </div> <div className="bg-white p-3 rounded-lg border border-blue-200"> <div className="text-lg font-bold text-blue-600"> {performanceMetrics.accuracy >= 80 && performanceMetrics.hintsPercentage <= 20 ? 'Eccellente' : performanceMetrics.accuracy >= 70 ? 'Molto Buono' : performanceMetrics.accuracy >= 60 ? 'Buono' : 'Da Migliorare'} </div> <div className="text-blue-800 text-sm">Performance</div> </div> </div> </div> </div> } <div className="flex flex-col sm:flex-row gap-4 justify-center"> <Button onClick={onStartNewTest} className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200" > <Play className="w-5 h-5 mr-2" /> Nuovo Test </Button> <Button onClick={onResetTest} variant="outline" className="border-2 border-gray-300 hover:border-gray-400 px-8 py-4 text-lg rounded-2xl bg-white/80 backdrop-blur-sm shadow-lg hover:shadow-xl transition-all duration-200" > <RotateCcw className="w-5 h-5 mr-2" /> Torna al Menu </Button> </div> } {word.usedHint && ( <span className="inline-flex items-center gap-1 bg-orange-100 text-orange-700 px-2 py-1 rounded-full text-xs font-medium"> <Lightbulb className="w-3 h-3" /> Aiuto usato </span> )} </div> {word.group && ( <div className="mb-3"> <span className="inline-flex items-center gap-1 bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-sm font-medium"> 📂 {word.group} </span> </div> )} {word.sentence && ( <div className="mb-3 p-4 bg-green-50 rounded-xl border border-green-200"> <div className="text-green-600 font-semibold text-sm mb-1 flex items-center gap-2"> <span>💬</span> Esempio: </div> <div className="text-green-800 italic">"{word.sentence}"</div> </div> )} {word.notes && ( <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200"> <div className="text-yellow-600 font-semibold text-sm mb-1 flex items-center gap-2"> <span>📝</span> Note: </div> <div className="text-yellow-800 text-sm whitespace-pre-line"> {formatNotes(word.notes)} </div> </div> )} </div> <div className="text-3xl text-orange-500 ml-4">❌</div> </div> </div> ))} </div> </CardContent> </Card> </div> )} </CardContent> </Card> </div> ); }; export default TestResults;

================================================================================

NOME FILE: WordsList.js

import React, { useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from './ui/card'; import { Button } from './ui/button'; import { Plus, Trash2, Edit3, ChevronDown, ChevronUp, BookOpen, CheckCircle, Circle, Filter, AlertTriangle } from 'lucide-react'; const getCategoryStyle = (group) => { const categoryMap = { 'VERBI': { icon: '⚡', bgColor: 'bg-red-500' }, 'VERBI_IRREGOLARI': { icon: '🔄', bgColor: 'bg-red-600' }, 'SOSTANTIVI': { icon: '🏷️', bgColor: 'bg-blue-500' }, 'AGGETTIVI': { icon: '🎨', bgColor: 'bg-green-500' }, 'FAMIGLIA': { icon: '👨‍👩‍👧‍👦', bgColor: 'bg-pink-400' }, 'TECNOLOGIA': { icon: '💻', bgColor: 'bg-cyan-500' }, 'LAVORO': { icon: '💼', bgColor: 'bg-indigo-500' }, 'DEFAULT': { icon: '📚', bgColor: 'bg-gray-500' } }; return categoryMap[group?.toUpperCase()] || categoryMap['DEFAULT']; }; const formatNotes = (notes) => { if (!notes) return null; const keywords = ['Altri Significati', 'Sinonimi', 'Verbo Irregolare', 'Pronuncia', 'Esempi']; let formattedText = notes; keywords.forEach(keyword => { const regex = new RegExp(`(${keyword})\\s*:`, 'gi'); formattedText = formattedText.replace(regex, `**$1:**`); }); return formattedText.split(/(\*\*[^*]+\*\*)/).map((part, index) => { if (part.startsWith('**') && part.endsWith('**')) { return React.createElement('span', { key: index, className: 'font-bold' }, part.slice(2, -2)); } return part; }); }; const WordsList = ({ words, onEditWord, onRemoveWord, onToggleLearned, onToggleDifficult, showWordsList, setShowWordsList }) => { const [filterChapter, setFilterChapter] = useState(''); const [filterLearned, setFilterLearned] = useState('all'); const [filterDifficult, setFilterDifficult] = useState('all'); const [filterGroup, setFilterGroup] = useState(''); const availableChapters = React.useMemo(() => { const chapters = new Set(); words.forEach(word => { if (word.chapter) chapters.add(word.chapter); }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b); }); }, [words]); const availableGroups = React.useMemo(() => { const groups = new Set(); words.forEach(word => { if (word.group) groups.add(word.group); }); return Array.from(groups).sort(); }, [words]); const wordsWithoutChapter = React.useMemo(() => { return words.filter(word => !word.chapter); }, [words]); const filteredWords = words.filter(word => { if (filterChapter !== '') { if (filterChapter === 'no-chapter') { if (word.chapter) return false; } else { if (word.chapter !== filterChapter) return false; } } if (filterGroup && word.group !== filterGroup) return false; if (filterLearned === 'learned' && !word.learned) return false; if (filterLearned === 'not_learned' && word.learned) return false; if (filterDifficult === 'difficult' && !word.difficult) return false; if (filterDifficult === 'not_difficult' && word.difficult) return false; return true; }); const groupedWords = filteredWords.reduce((groups, word) => { const chapter = word.chapter || 'Senza Capitolo'; if (!groups[chapter]) groups[chapter] = []; groups[chapter].push(word); return groups; }, {}); const stats = { total: words.length, learned: words.filter(w => w.learned).length, notLearned: words.filter(w => !w.learned).length, difficult: words.filter(w => w.difficult).length, withChapter: words.filter(w => w.chapter).length, filtered: filteredWords.length }; const clearFilters = () => { setFilterChapter(''); setFilterLearned('all'); setFilterDifficult('all'); setFilterGroup(''); }; return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="cursor-pointer hover:bg-gray-50 transition-colors" onClick={() => setShowWordsList(!showWordsList)} > <CardTitle className="flex items-center justify-between"> <div className="flex items-center gap-3"> <span className="text-2xl">📚</span> <div className="flex flex-col"> <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent"> Il Tuo Vocabolario ({stats.total} parole) </span> <div className="flex gap-4 text-sm text-gray-600 mt-1"> <span>✅ {stats.learned} apprese</span> <span>📖 {stats.notLearned} da studiare</span> } <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200"> <CardHeader className="pb-3"> <CardTitle className="flex items-center gap-2 text-lg"> <Filter className="w-5 h-5 text-blue-600" /> Filtri ({stats.filtered} parole mostrate) </CardTitle> </CardHeader> <CardContent> <div className="grid grid-cols-1 md:grid-cols-5 gap-4"> <div> <label className="text-sm font-medium text-gray-700 mb-2 block">Capitolo</label> <select value={filterChapter} onChange={(e) => setFilterChapter(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white" > <option value="">Tutti i capitoli</option> {availableChapters.map(chapter => ( <option key={chapter} value={chapter}>📖 {chapter}</option> ))} {wordsWithoutChapter.length > 0 && ( <option value="no-chapter">📋 Senza capitolo</option> )} </select> </div> <div> <label className="text-sm font-medium text-gray-700 mb-2 block">Stato Apprendimento</label> <select value={filterLearned} onChange={(e) => setFilterLearned(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white" > <option value="all">Tutte le parole</option> <option value="learned">✅ Solo apprese</option> <option value="not_learned">📖 Solo da studiare</option> </select> </div> } <div className="grid grid-cols-2 md:grid-cols-5 gap-4"> <div className="text-center p-4 bg-blue-50 rounded-2xl border border-blue-200"> <div className="text-2xl font-bold text-blue-600">{stats.total}</div> <div className="text-blue-700 text-sm">Totale Parole</div> </div> <div className="text-center p-4 bg-green-50 rounded-2xl border border-green-200"> <div className="text-2xl font-bold text-green-600">{stats.learned}</div> <div className="text-green-700 text-sm">Apprese</div> </div> <div className="text-center p-4 bg-orange-50 rounded-2xl border border-orange-200"> <div className="text-2xl font-bold text-orange-600">{stats.notLearned}</div> <div className="text-orange-700 text-sm">Da Studiare</div> </div> <div className="text-center p-4 bg-red-50 rounded-2xl border border-red-200"> <div className="text-2xl font-bold text-red-600">{stats.difficult}</div> <div className="text-red-700 text-sm">⭐ Difficili</div> </div> <div className="text-center p-4 bg-purple-50 rounded-2xl border border-purple-200"> <div className="text-2xl font-bold text-purple-600">{availableChapters.length}</div> <div className="text-purple-700 text-sm">Capitoli</div> </div> </div> } <div className="flex items-center gap-3 p-3 bg-gradient-to-r from-indigo-100 to-purple-100 rounded-2xl border border-indigo-200"> <BookOpen className="w-5 h-5 text-indigo-600" /> <h3 className="font-bold text-indigo-800 text-lg"> {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`} </h3> <span className="text-sm text-indigo-600 bg-indigo-200 px-3 py-1 rounded-full"> {chapterWords.length} parole </span> <span className="text-sm text-green-600 bg-green-200 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.learned).length} apprese </span> } <div className="space-y-3"> {chapterWords.map((word) => ( <WordCard key={word.id} word={word} onEdit={() => onEditWord(word)} onRemove={() => onRemoveWord(word.id)} onToggleLearned={() => onToggleLearned(word.id)} onToggleDifficult={() => onToggleDifficult(word.id)} /> ))} </div> </div> ))} </div> </div> )} </CardContent> )} </Card> ); }; const WordCard = ({ word, onEdit, onRemove, onToggleLearned, onToggleDifficult }) => ( <div className={`p-6 rounded-2xl border-2 hover:shadow-lg transition-all duration-300 hover-lift ${ word.learned ? 'bg-gradient-to-r from-green-50 to-emerald-50 border-green-200' : word.difficult ? 'bg-gradient-to-r from-red-50 to-orange-50 border-red-200' : 'bg-gradient-to-r from-white to-gray-50 border-gray-100 hover:border-gray-200' }`}> <div className="flex justify-between items-start"> <div className="flex-1"> <div className="flex items-center gap-3 mb-3"> <span className={`text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent ${ word.learned ? 'opacity-75' : '' }`}> {word.english} </span> <span className="text-gray-400 text-xl">→</span> <span className={`text-xl font-medium ${ word.learned ? 'text-gray-600' : 'text-gray-700' }`}> {word.italian} </span> } <div onClick={onToggleDifficult} className="cursor-pointer" title={word.difficult ? "Rimuovi da parole difficili" : "Segna come difficile"} > {word.difficult ? ( <AlertTriangle className="w-6 h-6 text-red-500 hover:text-red-600 transition-colors fill-current" /> ) : ( <AlertTriangle className="w-6 h-6 text-gray-400 hover:text-red-500 transition-colors" /> )} </div> </div> <div className="flex flex-wrap gap-2 mb-3"> {word.group && ( <span className={`inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium text-white shadow-lg ${getCategoryStyle(word.group).bgColor}`}> <span>{getCategoryStyle(word.group).icon}</span> {word.group} </span> )} {word.chapter && ( <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-700"> <BookOpen className="w-4 h-4" /> Cap. {word.chapter} </span> )} {word.learned && ( <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-700"> <CheckCircle className="w-4 h-4" /> Appresa </span> )}

================================================================================

NOME FILE: layout\AppHeader.js

import React from 'react'; import { Card, CardHeader, CardTitle } from '../ui/card'; import { Brain, Sparkles } from 'lucide-react'; export const AppHeader = React.memo(() => ( <div className="text-center relative"> <div className="absolute inset-0 bg-gradient-to-r from-blue-600 to-purple-600 rounded-3xl blur-3xl opacity-20"></div> <Card className="relative backdrop-blur-sm bg-white/80 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10"></div> <CardHeader className="relative py-8"> <CardTitle className="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center justify-center gap-3"> <Brain className="w-10 h-10 text-blue-600" /> Vocabulary Master <Sparkles className="w-8 h-8 text-purple-600" /> </CardTitle> <p className="text-gray-600 text-lg mt-2">La tua app intelligente per imparare l'inglese</p> </CardHeader> </Card> </div> ));

================================================================================

NOME FILE: layout\AppNavigation.js

import React from 'react'; import { useAppContext } from '../../contexts/AppContext'; import { Card, CardContent } from '../ui/card'; import { Button } from '../ui/button'; import { Brain, BarChart3 } from 'lucide-react'; export const AppNavigation = React.memo(() => { const { currentView, dispatch, testHistory } = useAppContext(); const navItems = [ { id: 'main', label: 'Studio & Vocabolario', icon: Brain, color: 'from-blue-500 to-purple-600' }, { id: 'stats', label: 'Statistiche Complete', icon: BarChart3, color: 'from-purple-500 to-pink-600', badge: testHistory.length > 0 ? testHistory.length : null } ]; return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden"> <CardContent className="p-2"> <div className="flex gap-2 p-2"> {navItems.map(item => ( <Button key={item.id} onClick={() => dispatch({ type: 'SET_VIEW', payload: item.id })} className={`flex-1 py-4 px-6 rounded-2xl text-lg font-semibold transition-all duration-300 ${ currentView === item.id ? `bg-gradient-to-r ${item.color} text-white shadow-lg transform scale-105` : 'bg-gray-100 text-gray-600 hover:bg-gray-200' }`} > <item.icon className="w-6 h-6 mr-3" /> {item.label} {item.badge && ( <span className="ml-2 bg-white/20 text-white px-2 py-1 rounded-full text-sm"> {item.badge} </span> )} </Button> ))} </div> </CardContent> </Card> ); });

================================================================================

NOME FILE: main\ControlPanel.js

import React from 'react'; import { Card, CardTitle } from '../ui/card'; import { Button } from '../ui/button'; import { Play, RefreshCw, BookOpen, AlertTriangle } from 'lucide-react'; export const ControlPanel = React.memo(({ onStartTest, onClearAllWords, words, wordStats, getAvailableChapters }) => { const availableWords = words.filter(word => !word.learned); const chapters = getAvailableChapters(); return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-1"> <div className="bg-white rounded-3xl p-6"> <CardTitle className="flex items-center gap-3 text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-6"> <Play className="w-6 h-6 text-blue-600" /> Controlli di Studio </CardTitle> } {wordStats.difficult > 0 && ( <div className="mb-6 p-4 bg-gradient-to-r from-red-50 to-orange-50 border-2 border-red-200 rounded-2xl"> <div className="flex items-center gap-3 mb-2"> <AlertTriangle className="w-6 h-6 text-red-600" /> <h4 className="font-bold text-red-800">Parole Difficili Disponibili</h4> </div> <p className="text-red-700 text-sm"> Hai {wordStats.difficult} parole marcate come difficili. Usa la modalità "Solo Parole Difficili" per concentrarti su di esse! </p> </div> )} <div className="grid grid-cols-1 md:grid-cols-2 gap-4"> <Button onClick={onStartTest} disabled={availableWords.length === 0} className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white p-6 h-auto rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none" > <div className="flex flex-col items-center gap-2"> <BookOpen className="w-8 h-8" /> <span className="font-bold">Inizia Test</span> <span className="text-sm opacity-90"> ({availableWords.length} disponibili {wordStats.difficult > 0 && `, ${wordStats.difficult} difficili`}) </span> </div> </Button> <Button onClick={onClearAllWords} variant="outline" disabled={words.length === 0} className="border-2 border-red-300 hover:border-red-400 p-6 h-auto rounded-2xl bg-red-50 hover:bg-red-100 transition-all duration-200 disabled:opacity-50" > <div className="flex flex-col items-center gap-2 text-red-600"> <RefreshCw className="w-8 h-8" /> <span className="font-bold">Pulisci Vocabolario</span> <span className="text-sm">Elimina tutte le parole</span> </div> </Button> </div> </div> </div> </Card> ); });

================================================================================

NOME FILE: modals\GlobalModals.js

import React from 'react'; import { useAppContext } from '../../contexts/AppContext'; import { useNotification } from '../../contexts/NotificationContext'; import { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter } from '../ui/modal'; import { Button } from '../ui/button'; import ChapterTestSelector from '../ChapterTestSelector'; import { Trash2, RefreshCw } from 'lucide-react'; export const GlobalModals = React.memo(() => { const { confirmDelete, showConfirmClear, showChapterSelector, dispatch, words, removeWord, clearAllWords, startTest } = useAppContext(); const { showSuccess } = useNotification(); const handleConfirmDelete = () => { if (confirmDelete) { removeWord(confirmDelete.id); showSuccess(`✅ Parola "${confirmDelete.english}" eliminata!`); dispatch({ type: 'SET_CONFIRM_DELETE', payload: null }); } }; const handleConfirmClear = () => { clearAllWords(); dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false }); showSuccess('✅ Tutte le parole sono state eliminate!'); }; const handleTestStart = (filteredWords) => { startTest(filteredWords); dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: false }); }; return ( <> } <Modal isOpen={showConfirmClear} onClose={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })} > <ModalHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white rounded-t-2xl"> <ModalTitle className="text-white flex items-center gap-2"> <RefreshCw className="w-5 h-5" /> Eliminazione Completa </ModalTitle> </ModalHeader> <ModalContent> <div className="text-center py-4"> <div className="text-6xl mb-4">⚠️</div> <p className="text-gray-700 mb-4"> Sei sicuro di voler eliminare tutte le <strong>{words.length} parole</strong>? </p> <div className="bg-orange-50 border border-orange-200 rounded-lg p-4 mb-4"> <p className="text-orange-800 text-sm"> Questa azione eliminerà permanentemente tutto il tuo vocabolario e non può essere annullata. </p> </div> </div> </ModalContent> <ModalFooter> <Button onClick={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })} variant="outline" > Annulla </Button> <Button onClick={handleConfirmClear} className="bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white" > Elimina Tutto </Button> </ModalFooter> </Modal>

================================================================================

NOME FILE: stats\DataManagementPanel.js

import React from 'react'; import { Card } from '../ui/card'; import { Button } from '../ui/button'; import { Shield, AlertTriangle, Download, Upload, RefreshCw } from 'lucide-react'; import { useDataManagement } from './hooks/useDataManagement'; const DataManagementPanel = () => { const { isExporting, isImporting, isProcessing, handleExport, handleImportClick, handleFileSelect, handleReset, fileInputRef } = useDataManagement(); return ( <Card className="mb-6 p-4 bg-gradient-to-r from-indigo-50 to-purple-50 border-2 border-indigo-200 rounded-2xl animate-fade-in"> <div className="grid grid-cols-1 md:grid-cols-2 gap-6"> } <div className="mt-3 p-3 bg-white rounded-lg border border-indigo-200"> <p className="text-xs text-indigo-700"> <strong>Include:</strong> Parole, Statistiche, Cronologia Test, Performance Parole </p> </div> </div> } <input ref={fileInputRef} type="file" accept=".json" onChange={handleFileSelect} style={{ display: 'none' }} /> </Card> ); }; export default DataManagementPanel;

================================================================================

NOME FILE: stats\StatsHeader.js

import React from 'react'; import { Card, CardTitle } from '../ui/card'; import { Button } from '../ui/button'; import { BarChart3, Database } from 'lucide-react'; import { useStatsData } from './hooks/useStatsData'; import StatisticCard from './components/StatisticCard'; const StatsHeader = ({ testHistory, showDataManagement, setShowDataManagement, onClearHistory }) => { const { advancedStats } = useStatsData(testHistory); const mainStats = [ { label: 'Test Completati', value: advancedStats.totalTests, color: 'blue' }, { label: '📚 Parole Studiate', value: advancedStats.totalWordsStudied, color: 'emerald' }, { label: 'Media', value: `${advancedStats.averageScore}%`, color: 'green' }, { label: 'Record', value: `${advancedStats.bestScore}%`, color: 'purple' }, { label: 'Aiuti', value: advancedStats.totalHints, color: 'yellow' }, { label: '% Aiuti', value: `${advancedStats.hintsPercentage}%`, color: 'indigo' } ]; return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1"> <div className="bg-white rounded-3xl p-6"> <div className="flex justify-between items-center mb-6"> <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent"> <BarChart3 className="w-8 h-8 text-purple-600" /> Analisi Avanzata dell'Apprendimento <span className="text-sm bg-green-100 text-green-700 px-2 py-1 rounded-full"> Live: {testHistory.length} test </span> </CardTitle> <div className="flex gap-2"> <Button onClick={() => setShowDataManagement(!showDataManagement)} className="bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white px-4 py-2 rounded-xl" > <Database className="w-4 h-4 mr-2" /> Gestione Dati </Button> <Button onClick={onClearHistory} variant="outline" className="border-red-300 text-red-600 hover:bg-red-50" > 🗑️ Pulisci Cronologia ({testHistory.length}) </Button> </div> </div> <div className="grid grid-cols-2 md:grid-cols-6 gap-4"> {mainStats.map((stat, index) => ( <StatisticCard key={index} label={stat.label} value={stat.value} color={stat.color} /> ))} </div> </div> </div> </Card> ); }; export default StatsHeader;

================================================================================

NOME FILE: stats\StatsNavigation.js

import React from 'react'; import { Button } from '../ui/button'; const StatsNavigation = ({ selectedView, setSelectedView }) => { const tabs = [ { id: 'overview', label: 'Panoramica', icon: '📈' }, { id: 'chapters', label: 'Per Capitoli', icon: '📚' }, { id: 'words', label: 'Per Parole', icon: '🔍' }, { id: 'performance', label: 'Performance', icon: '🎯' }, { id: 'trends', label: 'Tendenze', icon: '📊' } ]; return ( <div className="flex gap-2 mb-6"> {tabs.map(tab => ( <Button key={tab.id} onClick={() => setSelectedView(tab.id)} className={`px-6 py-3 rounded-xl transition-all ${ selectedView === tab.id ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg' : 'bg-gray-100 text-gray-600 hover:bg-gray-200' }`} > <span className="mr-2">{tab.icon}</span> {tab.label} </Button> ))} </div> ); }; export default StatsNavigation;

================================================================================

NOME FILE: stats\StatsOverview.js

import React, { useState, useEffect } from 'react'; import StatsHeader from './StatsHeader'; import StatsNavigation from './StatsNavigation'; import DataManagementPanel from './DataManagementPanel'; import EmptyState from '../stats/components/EmptyState'; const OverviewSection = React.lazy(() => import('./sections/OverviewSection')); const ChaptersSection = React.lazy(() => import('./sections/ChaptersSection')); const WordsSection = React.lazy(() => import('./sections/WordsSection')); const PerformanceSection = React.lazy(() => import('./sections/PerformanceSection')); const TrendsSection = React.lazy(() => import('./sections/TrendsSection')); const StatsOverview = ({ testHistory, words, onClearHistory, onGoToMain, forceUpdate }) => { const [selectedView, setSelectedView] = useState('overview'); const [showDataManagement, setShowDataManagement] = useState(false); const [localRefresh, setLocalRefresh] = useState(0); useEffect(() => { setLocalRefresh(prev => prev + 1); }, [testHistory.length, forceUpdate]); if (testHistory.length === 0) { return ( <EmptyState onGoToMain={onGoToMain} showDataManagement={showDataManagement} setShowDataManagement={setShowDataManagement} /> ); } const renderSelectedSection = () => { const commonProps = { testHistory, words, localRefresh, onClearHistory }; switch (selectedView) { case 'overview': return <OverviewSection {...commonProps} />; case 'chapters': return <ChaptersSection {...commonProps} />; case 'words': return <WordsSection {...commonProps} />; case 'performance': return <PerformanceSection {...commonProps} />; case 'trends': return <TrendsSection {...commonProps} />; default: return <OverviewSection {...commonProps} />; } }; return ( <div className="space-y-8 animate-fade-in"> <StatsHeader testHistory={testHistory} showDataManagement={showDataManagement} setShowDataManagement={setShowDataManagement} onClearHistory={onClearHistory} /> <StatsNavigation selectedView={selectedView} setSelectedView={setSelectedView} /> {showDataManagement && <DataManagementPanel />} <React.Suspense fallback={<div className="text-center py-8">Caricamento...</div>}> {renderSelectedSection()} </React.Suspense> </div> ); }; export default StatsOverview;

================================================================================

NOME FILE: stats\components\EmptyState.js

import React from 'react'; import { Card, CardTitle } from '../../ui/card'; import { Button } from '../../ui/button'; import { Play, Database } from 'lucide-react'; import DataManagementPanel from '../DataManagementPanel'; const EmptyState = ({ onGoToMain, showDataManagement, setShowDataManagement }) => { return ( <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden"> <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1"> <div className="bg-white rounded-3xl p-6"> <div className="flex justify-between items-center mb-6"> <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent"> Statistiche e Analisi <span className="text-sm bg-gray-100 text-gray-700 px-2 py-1 rounded-full"> 0 test </span> </CardTitle> <Button onClick={() => setShowDataManagement(!showDataManagement)} className="bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white px-4 py-2 rounded-xl" > <Database className="w-4 h-4 mr-2" /> Gestione Dati </Button> </div> {showDataManagement && <DataManagementPanel />} <div className="text-center py-16"> <div className="text-8xl mb-6">📊</div> <h3 className="text-2xl font-bold text-gray-700 mb-4">Nessun test completato</h3> <p className="text-gray-600 text-lg mb-8">Completa il tuo primo test per vedere le statistiche dettagliate!</p> <Button onClick={onGoToMain} className="bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl" > <Play className="w-5 h-5 mr-2" /> Inizia il Primo Test </Button> </div> </div> </div> </Card> ); }; export default EmptyState;

================================================================================

NOME FILE: stats\components\StatisticCard.js

import React from 'react'; const StatisticCard = ({ label, value, color = 'blue' }) => { const colorClasses = { blue: 'from-blue-500 to-cyan-500 text-blue-100', emerald: 'from-emerald-500 to-green-500 text-emerald-100', green: 'from-green-500 to-emerald-500 text-green-100', purple: 'from-purple-500 to-pink-500 text-purple-100', yellow: 'from-yellow-500 to-orange-500 text-yellow-100', indigo: 'from-indigo-500 to-blue-500 text-indigo-100' }; return ( <div className={`bg-gradient-to-br ${colorClasses[color]} p-4 rounded-2xl text-white text-center shadow-xl`}> <div className="text-2xl font-bold">{value}</div> <div className="text-sm">{label}</div> </div> ); }; export default StatisticCard;

================================================================================

NOME FILE: stats\components\WordDetailSection.js

import React from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, ComposedChart, Bar } from 'recharts'; import { Award, TrendingUp, Target } from 'lucide-react'; const WordDetailSection = ({ wordId, getWordAnalysis, testHistory, wordInfo, localRefresh }) => { const wordAnalysis = getWordAnalysis ? getWordAnalysis(wordId) : null; if (!wordAnalysis) { return ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardContent className="text-center py-16"> <div className="text-6xl mb-4">📊</div> <p className="text-gray-600">Nessun dato performance disponibile per questa parola</p> </CardContent> </Card> ); } const getWordInfoFromProps = () => { if (wordInfo) { return { english: wordInfo.english || 'N/A', italian: wordInfo.italian || 'N/A', chapter: wordInfo.chapter || null }; } if (wordAnalysis?.english) { return { english: wordAnalysis.english, italian: wordAnalysis.italian, chapter: wordAnalysis.chapter }; } return { english: 'N/A', italian: 'N/A', chapter: null }; }; const finalWordInfo = getWordInfoFromProps(); const buildTimelineFromHistory = () => { const attempts = []; const allTests = testHistory || []; const sortedTests = [...allTests].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); sortedTests.forEach((test, testIndex) => { let wasInTest = false; let wasCorrect = false; let usedHint = false; let timeSpent = 0; if (test.wrongWords && Array.isArray(test.wrongWords)) { const wrongWord = test.wrongWords.find(w => w.id === wordId); if (wrongWord) { wasInTest = true; wasCorrect = false; usedHint = (test.hintsUsed > 0) && Math.random() > 0.7; timeSpent = test.totalTime ? Math.floor((test.totalTime * 1000) / test.totalWords) : 0; } } if (!wasInTest && test.wordTimes && Array.isArray(test.wordTimes)) { const wordTime = test.wordTimes.find(wt => wt.wordId === wordId); if (wordTime) { wasInTest = true; wasCorrect = wordTime.isCorrect; usedHint = wordTime.usedHint || false; timeSpent = wordTime.timeSpent || 0; } } if (!wasInTest && test.testParameters?.selectedChapters && finalWordInfo.chapter) { if (test.testParameters.selectedChapters.includes(finalWordInfo.chapter)) { wasInTest = true; wasCorrect = true; const totalWordsInTest = test.totalWords || 1; const avgTimePerWord = test.totalTime ? (test.totalTime * 1000) / totalWordsInTest : 0; timeSpent = avgTimePerWord + (Math.random() * 2000 - 1000); if (test.hintsUsed > 0) { const correctWordsInTest = test.correctWords || 1; const hintProbability = Math.min(test.hintsUsed / correctWordsInTest, 1); usedHint = Math.random() < hintProbability; } } } if (wasInTest) { attempts.push({ timestamp: test.timestamp, correct: wasCorrect, usedHint: usedHint, timeSpent: Math.max(timeSpent, 0), testId: test.id }); } }); return attempts; }; const actualAttempts = buildTimelineFromHistory(); if (actualAttempts.length === 0) { return ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardContent className="text-center py-16"> <div className="text-6xl mb-4">📊</div> <h3 className="text-xl font-bold text-gray-700 mb-2">Nessun tentativo trovato</h3> <p className="text-gray-600"> La parola "{finalWordInfo.english}" non è ancora stata testata o non è stata trovata nella cronologia test. </p> <div className="mt-4 p-3 bg-gray-50 rounded-lg text-sm text-gray-500"> <div>ID Parola: {wordId}</div> <div>Capitolo: {finalWordInfo.chapter || 'Nessuno'}</div> <div>Cronologia disponibile: {testHistory.length} test</div> <div>WordAnalysis attempts: {wordAnalysis?.attempts?.length || 0}</div> </div> </CardContent> </Card> ); } const timelineData = actualAttempts.map((attempt, index) => { const attemptsUpToHere = actualAttempts.slice(0, index + 1); const correctUpToHere = attemptsUpToHere.filter(a => a.correct).length; const cumulativePrecision = Math.round((correctUpToHere / attemptsUpToHere.length) * 100); const attemptDate = new Date(attempt.timestamp); const shortDate = attemptDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit' }); return { attempt: shortDate, attemptNumber: index + 1, success: attempt.correct ? 100 : 0, globalPrecision: cumulativePrecision, hint: attempt.usedHint ? 50 : 0, time: Math.round((attempt.timeSpent || 0) / 1000), fullDate: attemptDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }), isCorrect: attempt.correct, usedHint: attempt.usedHint, timestamp: attempt.timestamp }; }); const chartData = timelineData.slice(-10).map((data, index, array) => ({ ...data, globalPrecision: (() => { const visibleAttempts = array.slice(0, index + 1); const correctInVisible = visibleAttempts.filter(a => a.isCorrect).length; return Math.round((correctInVisible / visibleAttempts.length) * 100); })() })); const recalculatedStats = { totalAttempts: actualAttempts.length, correctAttempts: actualAttempts.filter(a => a.correct).length, accuracy: actualAttempts.length > 0 ? Math.round((actualAttempts.filter(a => a.correct).length / actualAttempts.length) * 100) : 0, hintsUsed: actualAttempts.filter(a => a.usedHint).length, hintsPercentage: actualAttempts.length > 0 ? Math.round((actualAttempts.filter(a => a.usedHint).length / actualAttempts.length) * 100) : 0, avgTime: actualAttempts.length > 0 ? Math.round(actualAttempts.reduce((sum, a) => sum + (a.timeSpent || 0), 0) / actualAttempts.length / 1000) : 0, currentStreak: (() => { let streak = 0; for (let i = actualAttempts.length - 1; i >= 0; i--) { if (actualAttempts[i].correct) { streak++; } else { break; } } return streak; })() }; const recentStats = { totalAttempts: recalculatedStats.totalAttempts, recentAttempts: chartData.length, currentAccuracy: recalculatedStats.accuracy, trend: chartData.length >= 2 ? chartData[chartData.length - 1].globalPrecision - chartData[0].globalPrecision : 0, recentHints: chartData.filter(d => d.usedHint).length, avgRecentTime: chartData.length > 0 ? Math.round(chartData.reduce((sum, d) => sum + d.time, 0) / chartData.length) : 0 }; const CustomTooltip = ({ active, payload, label }) => { if (active && payload && payload.length) { const data = payload[0].payload; return ( <div className="bg-white p-4 border border-gray-200 rounded-lg shadow-lg"> <p className="font-bold text-gray-800">{`Data: ${label}`}</p> <p className="text-sm text-gray-600">{`Dettaglio: ${data.fullDate}`}</p> <div className="mt-2 space-y-1"> <p className={`text-sm font-medium ${data.isCorrect ? 'text-green-600' : 'text-red-600'}`}> {`Risultato: ${data.isCorrect ? '✅ Corretto' : '❌ Sbagliato'}`} </p> <p className="text-sm text-blue-600 font-bold"> {`Precisione Globale: ${data.globalPrecision}%`} </p> {data.usedHint && ( <p className="text-sm text-orange-600">💡 Aiuto utilizzato</p> )} <p className="text-sm text-purple-600"> {`Tempo: ${data.time}s`} </p> <p className="text-xs text-gray-500"> {`Tentativo #${data.attemptNumber} di ${actualAttempts.length}`} </p> <p className="text-xs text-gray-400"> {`Test ID: ${data.timestamp}`} </p> </div> </div> ); } return null; }; return ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden" key={`detail-${wordId}-${localRefresh}`}> <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <Award className="w-6 h-6" /> Andamento Temporale: "{finalWordInfo.english}" </CardTitle> <p className="text-green-100 text-sm"> Ultimi {chartData.length} tentativi • Precisione ricostruita: {Math.round((actualAttempts.filter(a => a.correct).length / actualAttempts.length) * 100)}% • Totale tentativi: {actualAttempts.length} </p> </CardHeader> <CardContent className="p-6"> } <div> <h4 className="font-bold text-lg text-gray-800 mb-4 flex items-center gap-2"> <TrendingUp className="w-5 h-5" /> Andamento Temporale ({chartData.length} tentativi recenti) </h4> {chartData.length > 0 ? ( <ResponsiveContainer width="100%" height={300}> <ComposedChart data={chartData} key={`word-chart-${wordId}-${localRefresh}`}> <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" /> <XAxis dataKey="attempt" tick={{ fontSize: 11 }} interval={0} angle={-45} textAnchor="end" height={70} label={{ value: 'Date (DD/MM)', position: 'insideBottom', offset: -5, style: { fontSize: '12px' } }} /> <YAxis yAxisId="left" domain={[0, 100]} tick={{ fontSize: 12 }} label={{ value: 'Percentuale (%)', angle: -90, position: 'insideLeft' }} /> <YAxis yAxisId="right" orientation="right" domain={[0, 'dataMax + 10']} tick={{ fontSize: 12 }} label={{ value: 'Tempo (s)', angle: 90, position: 'insideRight' }} /> <Tooltip content={<CustomTooltip />} /> } <Line yAxisId="left" type="monotone" dataKey="success" stroke="#10b981" strokeWidth={2} strokeDasharray="5 5" name="Risultato Singolo" dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }} connectNulls={false} /> } <Line yAxisId="right" type="monotone" dataKey="time" stroke="#8b5cf6" strokeWidth={2} strokeDasharray="10 5" name="Tempo (s)" dot={{ fill: '#8b5cf6', strokeWidth: 1, r: 3 }} /> </ComposedChart> </ResponsiveContainer> ) : ( <div className="text-center py-8 text-gray-500"> <p>Nessun tentativo disponibile per il grafico</p> <p className="text-sm mt-2">Completare alcuni test per vedere l'andamento</p> </div> )} } <div className="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200"> <h5 className="font-semibold text-sm text-blue-800 mb-2">📋 Informazioni Timeline</h5> <div className="text-xs text-blue-700 space-y-1"> <div>Parola: <span className="font-medium">"{finalWordInfo.english}" → "{finalWordInfo.italian}" (ID: {wordId})</span></div> <div>Capitolo: <span className="font-medium">{finalWordInfo.chapter || 'Nessun capitolo'}</span></div> <div>Tentativi ricostruiti: <span className="font-medium">{actualAttempts.length}</span></div> <div>Tentativi corretti: <span className="font-medium text-green-600">{recalculatedStats.correctAttempts}</span></div> <div>Precisione ricostruita: <span className="font-medium text-blue-600">{recalculatedStats.accuracy}%</span></div> <div>Punti mostrati nel grafico: <span className="font-medium">{chartData.length}</span></div> <div>Test totali caricati: <span className="font-medium">{testHistory.length}</span></div> <div>LocalRefresh: <span className="font-medium">{localRefresh}</span></div> <div>WordAnalysis originale - Tentativi: <span className="font-medium">{wordAnalysis?.attempts?.length || 0}</span>, Accuratezza: <span className="font-medium">{wordAnalysis?.accuracy || 0}%</span></div> {actualAttempts.length > 0 && ( <> <div>Primo tentativo: <span className="font-medium"> {new Date(actualAttempts[0].timestamp).toLocaleDateString('it-IT')} </span></div> <div>Ultimo tentativo: <span className="font-medium"> {new Date(actualAttempts[actualAttempts.length - 1].timestamp).toLocaleDateString('it-IT')} </span></div> </> )} <div className="flex gap-2 mt-2"> </div> {testHistory.length > 0 && ( <div className="mt-2 p-2 bg-gray-100 rounded text-xs"> <div className="font-semibold">Ultimi 3 test ID:</div> {testHistory.slice(0, 3).map((test, index) => ( <div key={test.id} className="truncate"> {index + 1}. {test.id} ({new Date(test.timestamp).toLocaleDateString('it-IT')}) </div> ))} </div> )} </div> </div> } <div> <h4 className="font-bold text-lg text-gray-800 mb-4 flex items-center gap-2"> <Target className="w-5 h-5" /> Statistiche Dettagliate </h4> <div className="space-y-4"> } <div className="p-4 bg-blue-50 rounded-xl"> <h5 className="font-bold text-blue-800 mb-3">🎯 Analisi Performance</h5> <div className="space-y-2 text-sm"> <div className="flex justify-between"> <span className="text-gray-700">Tentativi totali:</span> <span className="font-bold">{recalculatedStats.totalAttempts}</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Risposte corrette:</span> <span className="font-bold text-green-600">{recalculatedStats.correctAttempts}</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Aiuti utilizzati:</span> <span className="font-bold text-orange-600">{recalculatedStats.hintsUsed}</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Precisione ricostruita:</span> <span className="font-bold text-blue-600">{recalculatedStats.accuracy}%</span> </div> <div className="flex justify-between"> <span className="text-gray-700">Streak corrente:</span> <span className="font-bold text-green-600">{recalculatedStats.currentStreak}</span> </div> </div> </div> } <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200"> <h5 className="font-bold text-yellow-800 mb-2">💡 Raccomandazioni</h5> <div className="text-sm text-yellow-700 space-y-1"> {recalculatedStats.accuracy < 60 && ( <p>• 📚 Rivedi questa parola più spesso - precisione {recalculatedStats.accuracy}% sotto il 60%</p> )} {recalculatedStats.hintsPercentage > 50 && ( <p>• 💭 Cerca di rispondere senza aiuti - uso eccessivo di suggerimenti ({recalculatedStats.hintsPercentage}%)</p> )} {recalculatedStats.avgTime > 20 && ( <p>• ⚡ Pratica per migliorare i tempi di risposta (attuale: {recalculatedStats.avgTime}s)</p> )} {recalculatedStats.currentStreak >= 5 && ( <p>• 🏆 Ottimo! Continua così - streak di {recalculatedStats.currentStreak}</p> )} {recentStats.trend > 20 && ( <p>• 📈 Tendenza molto positiva - stai migliorando rapidamente! (+{recentStats.trend}%)</p> )} {recalculatedStats.accuracy >= 80 && recalculatedStats.currentStreak >= 3 && ( <p>• ✨ Parola ben consolidata - potresti concentrarti su altre parole difficili</p> )} {actualAttempts.length === 0 && ( <p>• 🎯 Inizia a praticare questa parola per vedere l'andamento!</p> )} {actualAttempts.length > 0 && recalculatedStats.accuracy === 0 && ( <p>• 🔥 Parola molto difficile - continua a praticare, migliorerai!</p> )} </div> </div> </div> </div> </div> </CardContent> </Card> ); }; export default WordDetailSection;

================================================================================

NOME FILE: stats\components\WordPerformanceCard.js

import React from 'react'; import { Button } from '../../ui/button'; import { BookOpen, TrendingUp, Clock, Lightbulb, Target, AlertTriangle, CheckCircle, Circle, Edit3, Eye } from 'lucide-react'; import { getCategoryStyle } from '../../../utils/categoryUtils'; const WordPerformanceCard = ({ word, isSelected, onClick, onToggleLearned, onToggleDifficult, onEdit, showActions = false }) => { const getStatusColor = (status) => { const colors = { critical: 'bg-red-500', inconsistent: 'bg-orange-500', struggling: 'bg-yellow-500', promising: 'bg-blue-500', improving: 'bg-green-500', consolidated: 'bg-emerald-500', new: 'bg-gray-500' }; return colors[status] || 'bg-gray-500'; }; const getStatusLabel = (status) => { const labels = { critical: '🔴 Critica', inconsistent: '🟠 Instabile', struggling: '🟡 In difficoltà', promising: '🔵 Promettente', improving: '🟢 Migliorando', consolidated: '🟢 Consolidata', new: '⚪ Nuova' }; return labels[status] || '⚪ Sconosciuto'; }; const getPerformanceInsight = (word) => { if (!word.totalAttempts || word.totalAttempts === 0) { return { text: 'Nessun test completato', color: 'text-gray-500', icon: '📊' }; } if (word.accuracy >= 90 && word.currentStreak >= 3) { return { text: 'Performance eccellente!', color: 'text-green-600', icon: '🏆' }; } if (word.accuracy >= 70 && word.hintsPercentage <= 30) { return { text: 'Buona padronanza', color: 'text-blue-600', icon: '👍' }; } if (word.hintsPercentage > 50) { return { text: 'Troppi aiuti utilizzati', color: 'text-orange-600', icon: '💡' }; } if (word.accuracy < 50) { return { text: 'Necessita più studio', color: 'text-red-600', icon: '📚' }; } return { text: 'In fase di apprendimento', color: 'text-blue-500', icon: '📈' }; }; const insight = getPerformanceInsight(word); return ( <div onClick={onClick} className={`p-6 rounded-2xl border-2 cursor-pointer transition-all duration-300 hover:shadow-lg ${ isSelected ? 'border-blue-500 bg-blue-50 shadow-lg' : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md' }`} > <div className="flex items-center justify-between mb-4"> } <div className="flex flex-wrap gap-2 text-sm"> {word.chapter && ( <span className="flex items-center gap-1 text-blue-600"> <BookOpen className="w-3 h-3" /> Cap. {word.chapter} </span> )} {word.group && ( <span className="flex items-center gap-1 text-purple-600"> {getCategoryStyle(word.group).icon} {word.group} </span> )} {word.learned && ( <span className="flex items-center gap-1 text-green-600"> <CheckCircle className="w-3 h-3" /> Appresa </span> )} {word.difficult && ( <span className="flex items-center gap-1 text-red-600"> <AlertTriangle className="w-3 h-3" /> Difficile </span> )} </div> </div> } <div className="flex items-center gap-6"> } {word.totalAttempts > 0 && ( <div className={`px-3 py-1 rounded-full text-white text-sm font-medium ${getStatusColor(word.status)}`}> {getStatusLabel(word.status)} </div> )} } <div className="flex items-center justify-between"> <div className="flex items-center gap-2"> <span className="text-lg">{insight.icon}</span> <span className={`text-sm font-medium ${insight.color}`}> {insight.text} </span> </div> } {word.totalAttempts > 0 && ( <div className="mt-4 grid grid-cols-4 gap-2"> } <div className="text-center p-2 bg-orange-50 rounded-lg"> <div className="w-full h-2 rounded-full bg-gray-200"> <div className={`h-full rounded-full transition-all duration-500 ${ word.hintsPercentage <= 20 ? 'bg-green-500' : word.hintsPercentage <= 40 ? 'bg-blue-500' : word.hintsPercentage <= 60 ? 'bg-orange-500' : 'bg-red-500' }`} style={{ width: `${Math.min(100, word.hintsPercentage)}%` }} /> </div> <div className="text-xs text-orange-600 mt-1">Aiuti</div> </div> } <div className="text-center p-2 bg-purple-50 rounded-lg"> <div className="flex justify-center items-center h-2"> <Clock className={`w-3 h-3 ${ word.avgTime <= 10 ? 'text-green-500' : word.avgTime <= 20 ? 'text-blue-500' : word.avgTime <= 30 ? 'text-orange-500' : 'text-red-500' }`} /> </div> <div className="text-xs text-purple-600 mt-1">Velocità</div> </div> </div> )}

================================================================================

NOME FILE: stats\hooks\useDataManagement.js

import { useState, useRef } from 'react'; import { useAppContext } from '../../../contexts/AppContext'; export const useDataManagement = () => { const [isImporting, setIsImporting] = useState(false); const [isExporting, setIsExporting] = useState(false); const fileInputRef = useRef(null); const { exportStats, importStats, resetStats, refreshData, isProcessing } = useAppContext(); const handleExport = async () => { if (isExporting || isProcessing) return; try { setIsExporting(true); console.log('🔄 Starting export...'); await new Promise(resolve => setTimeout(resolve, 100)); if (typeof exportStats === 'function') { exportStats(); console.log('✅ Export completed'); } else { throw new Error('exportStats is not available'); } } catch (error) { console.error('❌ Errore export:', error); alert(`Errore durante l'esportazione: ${error.message}`); } finally { setIsExporting(false); } }; const handleImportClick = () => { if (isImporting || isProcessing) return; console.log('📂 Opening file dialog...'); fileInputRef.current?.click(); }; const handleFileSelect = async (event) => { const file = event.target.files[0]; if (!file) return; console.log('📁 File selected:', file.name, 'Type:', file.type); if (file.type !== 'application/json') { alert('Per favore seleziona un file JSON valido'); return; } setIsImporting(true); try { console.log('🔍 Reading file content...'); const fileContent = await new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => { console.log('✅ File read successfully'); resolve(e.target.result); }; reader.onerror = () => { console.error('❌ File reading failed'); reject(new Error('Errore nella lettura del file')); }; reader.readAsText(file); }); if (typeof importStats !== 'function') { throw new Error(`importStats is not a function. Available type: ${typeof importStats}`); } console.log('🔄 Starting import with content length:', fileContent.length); await importStats(fileContent); console.log('✅ Import completed successfully'); setTimeout(() => { if (typeof refreshData === 'function') { console.log('🔄 Refreshing data after import...'); refreshData(); } }, 200); } catch (error) { console.error('❌ Errore importazione:', error); alert(`Errore durante l'importazione: ${error.message}`); } finally { setIsImporting(false); if (event.target) { event.target.value = ''; } } }; const handleReset = async () => { if (isProcessing) return; const confirmation = window.confirm( '⚠️ ATTENZIONE: Questa operazione cancellerà TUTTI i dati (parole, test, statistiche).\n\n' + 'Sei sicuro di voler continuare?' ); if (!confirmation) return; try { console.log('🗑️ Starting data reset...'); if (typeof resetStats === 'function') { await resetStats(); console.log('✅ Reset completed'); setTimeout(() => { if (typeof refreshData === 'function') { console.log('🔄 Refreshing data after reset...'); refreshData(); } }, 200); } else { throw new Error('resetStats is not available'); } } catch (error) { console.error('❌ Errore reset:', error); alert(`Errore durante il reset: ${error.message}`); } }; console.log('🔍 useDataManagement - Available functions:', { exportStats: typeof exportStats, importStats: typeof importStats, resetStats: typeof resetStats, refreshData: typeof refreshData, isProcessing }); return { isExporting, isImporting, isProcessing, handleExport, handleImportClick, handleFileSelect, handleReset, fileInputRef }; };

================================================================================

NOME FILE: stats\hooks\useStatsData.js

import { useMemo } from 'react'; export const useStatsData = (testHistory) => { const advancedStats = useMemo(() => { if (testHistory.length === 0) { return { totalTests: 0, averageScore: 0, bestScore: 0, worstScore: 0, totalWordsStudied: 0, totalCorrect: 0, totalIncorrect: 0, totalHints: 0, hintsPercentage: 0, chaptersAnalyzed: 0, chapterPerformance: {} }; } const totalTests = testHistory.length; const totalCorrect = testHistory.reduce((sum, test) => sum + (test.correctWords || 0), 0); const totalIncorrect = testHistory.reduce((sum, test) => sum + (test.incorrectWords || 0), 0); const totalHints = testHistory.reduce((sum, test) => sum + (test.hintsUsed || 0), 0); const totalWordsStudied = totalCorrect + totalIncorrect; const hintsPercentage = totalWordsStudied > 0 ? Math.round((totalHints / totalWordsStudied) * 100) : 0; const averageScore = Math.round(testHistory.reduce((sum, test) => sum + (test.percentage || 0), 0) / totalTests); const bestScore = Math.max(...testHistory.map(test => test.percentage || 0)); const worstScore = Math.min(...testHistory.map(test => test.percentage || 100)); const chapterPerformance = {}; testHistory.forEach(test => { if (test.chapterStats) { Object.entries(test.chapterStats).forEach(([chapter, stats]) => { if (!chapterPerformance[chapter]) { chapterPerformance[chapter] = { totalTests: 0, totalWords: 0, totalCorrect: 0, totalIncorrect: 0, totalHints: 0, averagePercentage: 0, bestPercentage: 0, worstPercentage: 100, hintsPercentage: 0 }; } const perf = chapterPerformance[chapter]; perf.totalTests += 1; perf.totalWords += stats.totalWords || 0; perf.totalCorrect += stats.correctWords || 0; perf.totalIncorrect += stats.incorrectWords || 0; perf.totalHints += stats.hintsUsed || 0; perf.bestPercentage = Math.max(perf.bestPercentage, stats.percentage || 0); perf.worstPercentage = Math.min(perf.worstPercentage, stats.percentage || 100); }); } }); Object.keys(chapterPerformance).forEach(chapter => { const perf = chapterPerformance[chapter]; perf.averagePercentage = perf.totalWords > 0 ? Math.round((perf.totalCorrect / perf.totalWords) * 100) : 0; perf.hintsPercentage = perf.totalWords > 0 ? Math.round((perf.totalHints / perf.totalWords) * 100) : 0; }); return { totalTests, averageScore, bestScore, worstScore, totalWordsStudied, totalCorrect, totalIncorrect, totalHints, hintsPercentage, chaptersAnalyzed: Object.keys(chapterPerformance).length, chapterPerformance }; }, [testHistory]); const timelineData = useMemo(() => { return [...testHistory].reverse().slice(-20).map((test, index) => ({ test: `Test ${index + 1}`, percentage: test.percentage || 0, correct: test.correctWords || 0, incorrect: test.incorrectWords || 0, hints: test.hintsUsed || 0, avgTime: test.avgTimePerWord || 0, date: new Date(test.timestamp).toLocaleDateString('it-IT'), time: new Date(test.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }), chapters: test.testParameters?.selectedChapters?.length || 0, difficulty: test.difficulty || 'medium', type: test.testType || 'unknown' })); }, [testHistory]); const chapterComparisonData = useMemo(() => { return Object.entries(advancedStats.chapterPerformance).map(([chapter, perf]) => ({ chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`, fullChapter: chapter, accuracy: perf.averagePercentage, tests: perf.totalTests, words: perf.totalWords, hints: perf.hintsPercentage, efficiency: Math.max(0, perf.averagePercentage - perf.hintsPercentage), trend: perf.bestPercentage - perf.worstPercentage })).sort((a, b) => b.accuracy - a.accuracy); }, [advancedStats]); return { advancedStats, timelineData, chapterComparisonData }; };

================================================================================

NOME FILE: stats\sections\ChaptersSection.js

import React, { useMemo, useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, LineChart, Line, ComposedChart } from 'recharts'; import { BookOpen, TrendingUp, Award, Target, Info } from 'lucide-react'; const ChaptersSection = ({ testHistory, words, localRefresh }) => { const [selectedChapterForTrend, setSelectedChapterForTrend] = useState(null); const enhancedChapterData = useMemo(() => { const chapterStats = {}; const chapterFirstTestDate = {}; const chapterDetailedHistory = {}; words.forEach(word => { const chapter = word.chapter || 'Senza Capitolo'; if (!chapterStats[chapter]) { chapterStats[chapter] = { totalWords: 0, learnedWords: 0, difficultWords: 0, testsPerformed: 0, totalCorrect: 0, totalIncorrect: 0, totalTestsAnswers: 0, estimatedHints: 0 }; } chapterStats[chapter].totalWords++; if (word.learned) chapterStats[chapter].learnedWords++; if (word.difficult) chapterStats[chapter].difficultWords++; }); testHistory.forEach((test, testIndex) => { const testDate = new Date(test.timestamp); if (test.chapterStats) { Object.entries(test.chapterStats).forEach(([chapter, stats]) => { if (!chapterStats[chapter]) { chapterStats[chapter] = { totalWords: 0, learnedWords: 0, difficultWords: 0, testsPerformed: 0, totalCorrect: 0, totalIncorrect: 0, totalTestsAnswers: 0, estimatedHints: 0 }; } const chapterStat = chapterStats[chapter]; if (!chapterFirstTestDate[chapter] || testDate < chapterFirstTestDate[chapter]) { chapterFirstTestDate[chapter] = testDate; } chapterStat.testsPerformed++; chapterStat.totalCorrect += stats.correctWords || 0; chapterStat.totalIncorrect += stats.incorrectWords || 0; chapterStat.totalTestsAnswers += (stats.correctWords || 0) + (stats.incorrectWords || 0); if (test.hintsUsed > 0) { const totalWordsInAllChapters = Object.values(test.chapterStats) .reduce((sum, chStats) => sum + (chStats.correctWords || 0) + (chStats.incorrectWords || 0), 0); const wordsInThisChapter = (stats.correctWords || 0) + (stats.incorrectWords || 0); if (totalWordsInAllChapters > 0) { const proportionalHints = (test.hintsUsed * wordsInThisChapter) / totalWordsInAllChapters; chapterStat.estimatedHints += proportionalHints; } } if (!chapterDetailedHistory[chapter]) { chapterDetailedHistory[chapter] = []; } chapterDetailedHistory[chapter].push({ date: testDate, accuracy: stats.percentage || 0, correct: stats.correctWords || 0, incorrect: stats.incorrectWords || 0, hints: test.hintsUsed || 0, estimatedChapterHints: chapterStat.estimatedHints, timestamp: test.timestamp, testIndex }); }); } }); const processedData = Object.entries(chapterStats).map(([chapter, data]) => { const totalAnswers = data.totalCorrect + data.totalIncorrect; const accuracy = totalAnswers > 0 ? Math.round((data.totalCorrect / totalAnswers) * 100) : 0; const hintsPercentage = totalAnswers > 0 ? Math.round((data.estimatedHints / totalAnswers) * 100) : 0; const efficiency = Math.max(0, accuracy - hintsPercentage); const completionRate = data.totalWords > 0 ? Math.round((data.learnedWords / data.totalWords) * 100) : 0; const difficultyRate = data.totalWords > 0 ? Math.round((data.difficultWords / data.totalWords) * 100) : 0; const studyProgress = Math.min(100, completionRate + (accuracy / 3)); const firstTestDate = chapterFirstTestDate[chapter] || new Date(); return { chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`, fullChapter: chapter, totalWords: data.totalWords, learnedWords: data.learnedWords, difficultWords: data.difficultWords, testsPerformed: data.testsPerformed, totalAnswers: totalAnswers, accuracy, hintsPercentage, efficiency, completionRate, difficultyRate, studyProgress, estimatedHints: Math.round(data.estimatedHints * 100) / 100, firstTestDate, detailedHistory: chapterDetailedHistory[chapter] || [] }; }).sort((a, b) => { if (a.testsPerformed === 0 && b.testsPerformed === 0) { return a.fullChapter.localeCompare(b.fullChapter); } if (a.testsPerformed === 0) return 1; if (b.testsPerformed === 0) return -1; return a.firstTestDate - b.firstTestDate; }); return { processedData, chapterDetailedHistory }; }, [testHistory, words, localRefresh]); const selectedChapterTrendData = useMemo(() => { if (!selectedChapterForTrend || !enhancedChapterData.chapterDetailedHistory[selectedChapterForTrend]) { return []; } const history = enhancedChapterData.chapterDetailedHistory[selectedChapterForTrend]; const sortedHistory = [...history].sort((a, b) => { const dateA = new Date(a.timestamp); const dateB = new Date(b.timestamp); return dateA.getTime() - dateB.getTime(); }); const recentHistory = sortedHistory.slice(-15); return recentHistory.map((entry, index) => ({ testNumber: `Test ${index + 1}`, date: entry.date.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit' }), accuracy: entry.accuracy, correct: entry.correct, incorrect: entry.incorrect, fullDate: entry.date.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }), timestamp: entry.timestamp })); }, [selectedChapterForTrend, enhancedChapterData.chapterDetailedHistory]); const overviewStats = useMemo(() => { const testedChapters = enhancedChapterData.processedData.filter(c => c.testsPerformed > 0); return { totalChapters: enhancedChapterData.processedData.length, testedChapters: testedChapters.length, bestEfficiency: testedChapters.length > 0 ? Math.max(...testedChapters.map(c => c.efficiency)) : 0, averageCompletion: enhancedChapterData.processedData.length > 0 ? Math.round(enhancedChapterData.processedData.reduce((sum, c) => sum + c.completionRate, 0) / enhancedChapterData.processedData.length) : 0, averageAccuracy: testedChapters.length > 0 ? Math.round(testedChapters.reduce((sum, c) => sum + c.accuracy, 0) / testedChapters.length) : 0 }; }, [enhancedChapterData.processedData]); const topChapters = enhancedChapterData.processedData .filter(c => c.testsPerformed > 0) .sort((a, b) => b.efficiency - a.efficiency) .slice(0, 5); const strugglingChapters = enhancedChapterData.processedData .filter(c => c.testsPerformed > 2) .sort((a, b) => a.efficiency - b.efficiency) .slice(0, 3); const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#06B6D4', '#84CC16']; return ( <div className="space-y-8" key={`chapters-${localRefresh}`}> } <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <BarChart className="w-6 h-6" /> Analisi Performance Dettagliata per Capitolo </CardTitle> <div className="text-blue-100 text-sm space-y-1"> <p><strong>Efficienza = Precisione - Aiuti utilizzati.</strong> Verde = Ottimo, Giallo = Buono, Rosso = Da migliorare</p> <p>📊 Aiuti stimati proporzionalmente dai test. Capitoli ordinati per primo test cronologico.</p> </div> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={400}> <ComposedChart data={enhancedChapterData.processedData.filter(c => c.testsPerformed > 0)} margin={{ top: 20, right: 30, left: 20, bottom: 5 }} > <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" /> <XAxis dataKey="chapter" tick={{ fontSize: 12 }} /> <YAxis domain={[0, 100]} tick={{ fontSize: 12 }} /> <Tooltip formatter={(value, name) => [ `${value}%`, name === 'accuracy' ? 'Precisione' : name === 'hintsPercentage' ? 'Aiuti Stimati' : name === 'efficiency' ? 'Efficienza Netta' : name === 'completionRate' ? 'Completamento' : name ]} labelFormatter={(label) => `Capitolo: ${label}`} contentStyle={{ backgroundColor: '#f8fafc', border: '1px solid #e2e8f0' }} labelStyle={{ fontWeight: 'bold' }} /> <Bar dataKey="accuracy" fill="#3b82f6" name="accuracy" /> <Bar dataKey="hintsPercentage" fill="#f59e0b" name="hintsPercentage" /> <Bar dataKey="efficiency" fill="#10b981" name="efficiency" /> <Line type="monotone" dataKey="completionRate" stroke="#8b5cf6" strokeWidth={3} name="completionRate" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-center text-sm"> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-blue-500 rounded"></div> <span>Precisione %</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-yellow-500 rounded"></div> <span>Aiuti Stimati %</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-green-500 rounded"></div> <span>Efficienza Netta</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-purple-500 rounded"></div> <span>Completamento</span> </div> </div> </CardContent> </Card> } <div className="grid grid-cols-1 lg:grid-cols-2 gap-6"> } <Card className="bg-gradient-to-br from-orange-50 to-red-50 border-2 border-orange-200"> <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white"> <CardTitle className="flex items-center gap-3"> <Target className="w-6 h-6" /> 📚 Capitoli da Migliorare </CardTitle> <div className="text-orange-100 text-sm"> Capitoli con almeno 3 test e bassa efficienza </div> </CardHeader> <CardContent className="p-6"> <div className="space-y-4"> {strugglingChapters.length > 0 ? strugglingChapters.map((chapter, index) => ( <div key={chapter.fullChapter} className="p-4 bg-white rounded-xl border border-orange-200"> <div className="flex items-center justify-between mb-3"> <div className="font-bold text-gray-800">{chapter.chapter}</div> <div className="text-xl font-bold text-red-600">{chapter.efficiency}%</div> </div> <div className="grid grid-cols-3 gap-2 text-sm mb-3"> <div className="text-center"> <div className="font-bold text-blue-600">{chapter.accuracy}%</div> <div className="text-blue-700 text-xs">Precisione</div> </div> <div className="text-center"> <div className="font-bold text-orange-600">{chapter.hintsPercentage}%</div> <div className="text-orange-700 text-xs">Aiuti Stimati</div> </div> <div className="text-center"> <div className="font-bold text-purple-600">{chapter.difficultyRate}%</div> <div className="text-purple-700 text-xs">Difficili</div> </div> </div> <div className="text-xs text-gray-600 mb-2"> {chapter.totalAnswers} risposte in {chapter.testsPerformed} test • Aiuti stimati: {chapter.estimatedHints} </div> <div className="p-2 bg-orange-100 rounded-lg"> <p className="text-xs text-orange-800"> 💡 <strong>Suggerimento:</strong> {chapter.hintsPercentage > 30 ? ' Riduci l\'uso degli aiuti.' : ''} {chapter.difficultyRate > 50 ? ' Ripassa le parole difficili.' : ''} {chapter.accuracy < 60 ? ' Concentrati su questo capitolo.' : ''} {chapter.hintsPercentage <= 30 && chapter.difficultyRate <= 50 && chapter.accuracy >= 60 ? ' Continua così, stai migliorando!' : ''} </p> </div> </div> )) : ( <div className="text-center py-8 text-gray-500"> <p>Nessun capitolo in difficoltà</p> <p className="text-sm">Ottimo lavoro! Tutti i capitoli testati hanno buone performance</p> </div> )} </div> </CardContent> </Card> </div>

================================================================================

NOME FILE: stats\sections\OverviewSection.js

import React, { useMemo, useState } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, AreaChart, Area, BarChart, Bar, PieChart, Pie, Cell, ComposedChart } from 'recharts'; import { TrendingUp, Target, Clock, Lightbulb, Zap, Award, Info } from 'lucide-react'; import { useStatsData } from '../hooks/useStatsData'; const OverviewSection = ({ testHistory, localRefresh }) => { const [showPerformanceExplanation, setShowPerformanceExplanation] = useState(false); const { advancedStats } = useStatsData(testHistory); const buildRealTimelineData = () => { if (!testHistory || testHistory.length === 0) return []; const sortedTests = [...testHistory].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); return sortedTests.map((test, index) => { const testDate = new Date(test.timestamp); let avgTime = 0; if (test.totalTime && test.totalWords) { avgTime = (test.totalTime * 1000) / test.totalWords; } else if (test.wordTimes && test.wordTimes.length > 0) { const totalTime = test.wordTimes.reduce((sum, wt) => sum + (wt.timeSpent || 0), 0); avgTime = totalTime / test.wordTimes.length; } else { const totalWords = test.totalWords || 1; avgTime = totalWords > 50 ? 15000 : totalWords > 20 ? 12000 : 8000; } avgTime = Math.round(avgTime / 1000); let hintsCount = 0; if (test.hintsUsed !== undefined) { hintsCount = test.hintsUsed; } else if (test.wordTimes && test.wordTimes.length > 0) { hintsCount = test.wordTimes.filter(wt => wt.usedHint).length; } const dateLabel = testDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit' }); return { test: `Test ${index + 1}`, date: dateLabel, fullDate: testDate.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }), timestamp: test.timestamp, percentage: test.percentage || 0, efficiency: Math.max(0, (test.percentage || 0) - (hintsCount * 2)), speed: avgTime ? Math.max(20, 100 - Math.min(80, (avgTime - 5) * 4)) : 50, hintsCount: hintsCount, hints: hintsCount, avgTime: avgTime, correct: test.correctWords || 0, incorrect: test.incorrectWords || 0, totalWords: test.totalWords || 0 }; }); }; const realTimelineData = buildRealTimelineData(); const performanceAnalysis = useMemo(() => { if (realTimelineData.length === 0) return null; const learningVelocity = realTimelineData.length > 5 ? realTimelineData[realTimelineData.length - 1].percentage - realTimelineData[0].percentage : 0; const scores = realTimelineData.map(t => t.percentage); const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length; const variance = scores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / scores.length; const consistency = Math.max(0, 100 - Math.sqrt(variance)); const totalHints = realTimelineData.reduce((sum, t) => sum + (t.hintsCount || 0), 0); const totalAnswers = realTimelineData.reduce((sum, t) => sum + (t.totalWords || 0), 0); const hintEfficiency = totalAnswers > 0 ? Math.max(0, 100 - (totalHints / totalAnswers * 100)) : 100; const validTimes = realTimelineData.filter(t => t.avgTime > 0); const avgResponseTime = validTimes.length > 0 ? validTimes.reduce((sum, t) => sum + t.avgTime, 0) / validTimes.length : 15; const speedRating = avgResponseTime <= 8 ? 'Molto Veloce' : avgResponseTime <= 12 ? 'Veloce' : avgResponseTime <= 18 ? 'Normale' : avgResponseTime <= 25 ? 'Lento' : 'Molto Lento'; const speedScore = avgResponseTime <= 8 ? 100 : avgResponseTime <= 12 ? 85 : avgResponseTime <= 18 ? 70 : avgResponseTime <= 25 ? 55 : 40; const performanceIndex = Math.round( (avgScore * 0.4) + (consistency * 0.25) + (hintEfficiency * 0.2) + (speedScore * 0.15) ); return { learningVelocity: Math.round(learningVelocity * 10) / 10, consistency: Math.round(consistency), hintEfficiency: Math.round(hintEfficiency), avgResponseTime: Math.round(avgResponseTime * 10) / 10, speedRating, speedScore: Math.round(speedScore), performanceIndex, trend: learningVelocity > 0 ? 'Miglioramento' : learningVelocity < 0 ? 'Calo' : 'Stabile', breakdown: { precisione: { value: Math.round(avgScore), weight: 40, contribution: Math.round(avgScore * 0.4) }, consistenza: { value: Math.round(consistency), weight: 25, contribution: Math.round(consistency * 0.25) }, efficienza: { value: Math.round(hintEfficiency), weight: 20, contribution: Math.round(hintEfficiency * 0.2) }, velocita: { value: Math.round(speedScore), weight: 15, contribution: Math.round(speedScore * 0.15) } } }; }, [realTimelineData]); const multiMetricData = useMemo(() => { return realTimelineData.slice(-20).map((item, index) => ({ ...item, test: item.date, testNumber: index + 1, efficiency: Math.max(0, item.percentage - (item.hintsCount * 2)), speed: item.speed, consistency: item.percentage, hintsCount: item.hintsCount || 0 })); }, [realTimelineData]); const performanceDistribution = useMemo(() => { const ranges = { excellent: 0, good: 0, average: 0, poor: 0 }; realTimelineData.forEach(test => { if (test.percentage >= 90) ranges.excellent++; else if (test.percentage >= 75) ranges.good++; else if (test.percentage >= 60) ranges.average++; else ranges.poor++; }); const total = realTimelineData.length; return [ { name: 'Eccellente', fullName: 'Eccellente (90%+)', value: ranges.excellent, percentage: total > 0 ? Math.round((ranges.excellent / total) * 100) : 0, color: '#10B981' }, { name: 'Buono', fullName: 'Buono (75-89%)', value: ranges.good, percentage: total > 0 ? Math.round((ranges.good / total) * 100) : 0, color: '#3B82F6' }, { name: 'Medio', fullName: 'Medio (60-74%)', value: ranges.average, percentage: total > 0 ? Math.round((ranges.average / total) * 100) : 0, color: '#F59E0B' }, { name: 'Da migliorare', fullName: 'Da migliorare (<60%)', value: ranges.poor, percentage: total > 0 ? Math.round((ranges.poor / total) * 100) : 0, color: '#EF4444' } ].filter(item => item.value > 0); }, [realTimelineData]); const weeklyPattern = useMemo(() => { const pattern = {}; realTimelineData.forEach(test => { const date = new Date(test.timestamp); const dayOfWeek = date.toLocaleDateString('it-IT', { weekday: 'short' }); if (!pattern[dayOfWeek]) { pattern[dayOfWeek] = { tests: 0, totalScore: 0 }; } pattern[dayOfWeek].tests++; pattern[dayOfWeek].totalScore += test.percentage; }); return Object.entries(pattern).map(([day, data]) => ({ day, tests: data.tests, avgScore: Math.round(data.totalScore / data.tests), frequency: data.tests })).sort((a, b) => { const dayOrder = ['lun', 'mar', 'mer', 'gio', 'ven', 'sab', 'dom']; return dayOrder.indexOf(a.day) - dayOrder.indexOf(b.day); }); }, [realTimelineData]); if (!performanceAnalysis) { return ( <div className="text-center py-16 text-gray-500"> <Target className="w-16 h-16 mx-auto mb-4 opacity-50" /> <p>Completa alcuni test per vedere le metriche performance</p> </div> ); } return ( <div className="space-y-8" key={`overview-${localRefresh}`}> } <div className="flex justify-between items-start mb-6"> <div className="text-center flex-1"> <h2 className="text-3xl font-bold mb-2">Performance Index</h2> <div className="text-6xl font-bold mb-2">{performanceAnalysis.performanceIndex}</div> <div className="text-xl opacity-90"> {performanceAnalysis.performanceIndex >= 85 ? '🏆 Eccellente!' : performanceAnalysis.performanceIndex >= 70 ? '👍 Molto Buono' : performanceAnalysis.performanceIndex >= 55 ? '📈 In Crescita' : '📚 Da Migliorare'} </div> </div> } <div className={`overflow-hidden transition-all duration-500 ease-in-out ${ showPerformanceExplanation ? 'max-h-96 opacity-100' : 'max-h-0 opacity-0' }`}> <div className="bg-white/10 rounded-xl p-4 backdrop-blur-sm"> <h4 className="font-bold text-white mb-3 flex items-center gap-2"> <Info className="w-5 h-5" /> 📊 Come viene calcolato il Performance Index </h4> <div className="text-white/90 text-sm space-y-2"> <div className="grid grid-cols-1 md:grid-cols-2 gap-4"> <div> <p className="font-medium mb-2">Formula di calcolo:</p> <div className="bg-white/10 rounded p-2 font-mono text-xs"> Index = (Precisione × 40%) + (Consistenza × 25%) + (Efficienza × 20%) + (Velocità × 15%) </div> </div> <div> <p className="font-medium mb-2">Il tuo calcolo:</p> <div className="space-y-1 text-xs"> <div>{performanceAnalysis.breakdown.precisione.value}% × 40% = {performanceAnalysis.breakdown.precisione.contribution} punti</div> <div>{performanceAnalysis.breakdown.consistenza.value}% × 25% = {performanceAnalysis.breakdown.consistenza.contribution} punti</div> <div>{performanceAnalysis.breakdown.efficienza.value}% × 20% = {performanceAnalysis.breakdown.efficienza.contribution} punti</div> <div>{performanceAnalysis.breakdown.velocita.value}% × 15% = {performanceAnalysis.breakdown.velocita.contribution} punti</div> <div className="border-t border-white/20 pt-1 font-bold"> Totale = {performanceAnalysis.performanceIndex} punti </div> </div> </div> </div> <div className="mt-3 text-xs bg-white/10 rounded p-2"> <strong>💡 Significato delle metriche:</strong><br/> • <strong>Precisione:</strong> Media dei punteggi di tutti i test<br/> • <strong>Consistenza:</strong> Quanto stabili sono le tue performance (100 - deviazione standard)<br/> • <strong>Efficienza:</strong> Quanto bene rispondi senza aiuti (100 - % aiuti utilizzati)<br/> • <strong>Velocità:</strong> Score basato sul tempo medio di risposta ({performanceAnalysis.avgResponseTime}s = {performanceAnalysis.speedRating}) </div> </div> </div> </div> } <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <TrendingUp className="w-6 h-6" /> Andamento Multi-Metrica (Ultimi {multiMetricData.length} Test) </CardTitle> <p className="text-blue-100 text-sm"> Monitoraggio di precisione, efficienza, velocità REALE e aiuti nel tempo </p> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={350}> <ComposedChart data={multiMetricData}> <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" /> <XAxis dataKey="test" tick={{ fontSize: 10 }} interval={Math.ceil(multiMetricData.length / 8)} angle={-45} textAnchor="end" height={60} /> <YAxis yAxisId="left" domain={[0, 100]} tick={{ fontSize: 12 }} label={{ value: 'Percentuale (%)', angle: -90, position: 'insideLeft' }} /> <YAxis yAxisId="right" orientation="right" domain={[0, 'dataMax + 2']} tick={{ fontSize: 12 }} label={{ value: 'Aiuti', angle: 90, position: 'insideRight' }} /> <Tooltip formatter={(value, name) => { if (name === 'hintsCount') { return [`${value} aiuti`, 'Aiuti Utilizzati']; } return [ `${Math.round(value)}%`, name === 'percentage' ? 'Precisione' : name === 'efficiency' ? 'Efficienza' : name === 'speed' ? 'Velocità Reale' : name ]; }} labelFormatter={(label, payload) => { const data = payload?.[0]?.payload; return data ? `${label} (${data.fullDate})` : label; }} contentStyle={{ backgroundColor: '#f8fafc', border: '1px solid #e2e8f0' }} /> } <Line yAxisId="left" type="monotone" dataKey="efficiency" stroke="#10b981" strokeWidth={2} name="efficiency" /> } <Line yAxisId="right" type="monotone" dataKey="hintsCount" stroke="#f59e0b" strokeWidth={3} strokeDasharray="5 5" dot={{ fill: '#f59e0b', strokeWidth: 2, r: 4 }} name="hintsCount" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-center text-sm"> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-blue-500 rounded"></div> <span>Precisione (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-green-500 rounded"></div> <span>Efficienza (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-purple-500 rounded"></div> <span>Velocità Reale (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 border-2 border-yellow-500 bg-white rounded"></div> <span>Aiuti (linea tratteggiata)</span> </div> </div> } <div className="mt-6 p-4 bg-orange-50 rounded-xl border border-orange-200"> <h4 className="font-bold text-orange-800 mb-2 flex items-center gap-2"> <Lightbulb className="w-5 h-5" /> Analisi Utilizzo Aiuti (Dati Reali) </h4> <div className="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm"> <div className="text-center"> <div className="text-lg font-bold text-orange-600"> {multiMetricData.reduce((sum, t) => sum + t.hintsCount, 0)} </div> <div className="text-orange-700">Aiuti Totali</div> </div> <div className="text-center"> <div className="text-lg font-bold text-orange-600">{Math.round(100 - performanceAnalysis.hintEfficiency)}%</div> <div className="text-orange-700">% Risposte con Aiuto</div> </div> <div className="text-center"> <div className="text-lg font-bold text-orange-600"> {multiMetricData.length > 0 ? Math.round(multiMetricData.reduce((sum, t) => sum + t.hintsCount, 0) / multiMetricData.length * 10) / 10 : 0} </div> <div className="text-orange-700">Media Aiuti/Test</div> </div> <div className="text-center"> <div className="text-lg font-bold text-orange-600">{performanceAnalysis.hintEfficiency}%</div> <div className="text-orange-700">Efficienza Aiuti</div> </div> </div> <div className="mt-3 text-xs text-orange-600"> 💡 <strong>Suggerimento:</strong> Un uso efficiente degli aiuti è sopra l'80% di efficienza. Gli aiuti dovrebbero diminuire con l'esperienza. </div> </div> </CardContent> </Card> <div className="grid grid-cols-1 lg:grid-cols-2 gap-8"> } <div className="mt-4 space-y-2"> {performanceDistribution.map((item, index) => ( <div key={index} className="flex items-center justify-between text-sm p-2 rounded-lg" style={{ backgroundColor: `${item.color}15` }}> <div className="flex items-center gap-3"> <div className="w-4 h-4 rounded-full" style={{ backgroundColor: item.color }}></div> <span className="font-medium">{item.fullName}</span> </div> <div className="text-right"> <div className="font-bold" style={{ color: item.color }}>{item.value} test</div> <div className="text-xs text-gray-500">{item.percentage}% del totale</div> </div> </div> ))} </div> } <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <Zap className="w-6 h-6" /> Metriche Performance Avanzate </CardTitle> </CardHeader> <CardContent className="p-6"> <div className="space-y-6"> } <div> <div className="flex justify-between items-center mb-2"> <span className="font-medium text-gray-700">Consistenza</span> <span className="font-bold text-blue-600">{performanceAnalysis.consistency}%</span> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className="h-2 rounded-full bg-blue-500" style={{ width: `${performanceAnalysis.consistency}%` }} ></div> </div> <div className="text-xs text-gray-500 mt-1"> {performanceAnalysis.consistency >= 80 ? 'Molto stabile' : performanceAnalysis.consistency >= 60 ? 'Abbastanza costante' : 'Variabile'} </div> </div> } <div> <div className="flex justify-between items-center mb-2"> <span className="font-medium text-gray-700">Efficienza Aiuti</span> <span className="font-bold text-orange-600">{performanceAnalysis.hintEfficiency}%</span> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className="h-2 rounded-full bg-orange-500" style={{ width: `${performanceAnalysis.hintEfficiency}%` }} ></div> </div> <div className="text-xs text-gray-500 mt-1"> {Math.round(100 - performanceAnalysis.hintEfficiency)}% aiuti utilizzati di media </div> </div> </div> } {weeklyPattern.length > 0 && ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-cyan-500 to-blue-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <Clock className="w-6 h-6" /> Pattern Settimanale di Studio </CardTitle> <p className="text-cyan-100 text-sm"> Analisi dei giorni della settimana più produttivi </p> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={250}> <ComposedChart data={weeklyPattern}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="day" /> <YAxis yAxisId="left" orientation="left" /> <YAxis yAxisId="right" orientation="right" /> <Tooltip formatter={(value, name) => [ name === 'avgScore' ? `${value}%` : `${value} test`, name === 'avgScore' ? 'Punteggio Medio' : 'Numero Test' ]} /> <Bar yAxisId="left" dataKey="tests" fill="#06b6d4" name="tests" /> <Line yAxisId="right" type="monotone" dataKey="avgScore" stroke="#3b82f6" strokeWidth={3} name="avgScore" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm"> <div className="text-center p-3 bg-cyan-50 rounded-xl"> <div className="font-bold text-cyan-600"> {weeklyPattern.reduce((max, day) => day.tests > max.tests ? day : max, weeklyPattern[0])?.day || 'N/A'} </div> <div className="text-cyan-700 text-xs">Giorno più attivo</div> </div> <div className="text-center p-3 bg-blue-50 rounded-xl"> <div className="font-bold text-blue-600"> {weeklyPattern.reduce((max, day) => day.avgScore > max.avgScore ? day : max, weeklyPattern[0])?.day || 'N/A'} </div> <div className="text-blue-700 text-xs">Giorno migliore</div> </div> <div className="text-center p-3 bg-green-50 rounded-xl"> <div className="font-bold text-green-600"> {Math.round(weeklyPattern.reduce((sum, day) => sum + day.avgScore, 0) / weeklyPattern.length)}% </div> <div className="text-green-700 text-xs">Media settimanale</div> </div> <div className="text-center p-3 bg-purple-50 rounded-xl"> <div className="font-bold text-purple-600"> {weeklyPattern.reduce((sum, day) => sum + day.tests, 0)} </div> <div className="text-purple-700 text-xs">Test totali</div> </div> </div> </CardContent> </Card> )} </div> ); }; export default OverviewSection;

================================================================================

NOME FILE: stats\sections\PerformanceSection.js

import React, { useMemo } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, Radar, LineChart, Line, ComposedChart, ScatterChart, Scatter } from 'recharts'; import { Trophy, Lightbulb, Zap, Clock, Target, TrendingUp } from 'lucide-react'; import { useStatsData } from '../hooks/useStatsData'; const usePerformanceData = (testHistory) => { return useMemo(() => { if (testHistory.length === 0) return []; return [...testHistory].reverse().slice(-20).map((test, index) => { const totalWords = (test.correctWords || 0) + (test.incorrectWords || 0); let avgTimePerWord = 0; if (test.totalTime && totalWords > 0) { avgTimePerWord = Math.round((test.totalTime / totalWords) * 10) / 10; } else if (totalWords > 0) { const baseTime = 8; const difficultyMultiplier = test.difficulty === 'hard' ? 1.5 : test.difficulty === 'easy' ? 0.7 : 1.0; const performanceMultiplier = test.percentage < 50 ? 1.8 : test.percentage < 70 ? 1.3 : test.percentage < 85 ? 1.0 : 0.8; const hintsMultiplier = (test.hintsUsed || 0) > 0 ? 1.2 : 1.0; avgTimePerWord = Math.round(baseTime * difficultyMultiplier * performanceMultiplier * hintsMultiplier * 10) / 10; } return { test: `Test ${index + 1}`, percentage: test.percentage || 0, correct: test.correctWords || 0, incorrect: test.incorrectWords || 0, hints: test.hintsUsed || 0, avgTime: avgTimePerWord, date: new Date(test.timestamp).toLocaleDateString('it-IT'), time: new Date(test.timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }), chapters: test.testParameters?.selectedChapters?.length || 0, difficulty: test.difficulty || 'medium', type: test.testType || 'unknown', totalWords: totalWords, hasRealTime: !!(test.totalTime), isEstimated: !test.totalTime }; }); }, [testHistory]); }; const calculateBestStreak = (data) => { let currentStreak = 0; let bestStreak = 0; const threshold = 75; data.forEach(test => { if (test.percentage >= threshold) { currentStreak++; bestStreak = Math.max(bestStreak, currentStreak); } else { currentStreak = 0; } }); return bestStreak; }; const calculateDifficultyHandling = (history) => { const hardTests = history.filter(test => (test.totalWords || 0) >= 20); if (hardTests.length === 0) return 70; const hardTestsAvg = hardTests.reduce((sum, test) => sum + (test.percentage || 0), 0) / hardTests.length; return Math.min(100, hardTestsAvg + 10); }; const calculateOverallRating = (accuracy, consistency, hintEff, speed) => { const weighted = (accuracy * 0.4) + (consistency * 0.25) + (hintEff * 0.2) + (speed * 0.15); return Math.round(weighted); }; const PerformanceSection = ({ testHistory, localRefresh }) => { const { advancedStats } = useStatsData(testHistory); const performanceTimelineData = usePerformanceData(testHistory); const performanceMetrics = useMemo(() => { if (testHistory.length === 0) return null; const recentTests = performanceTimelineData.slice(-10); const oldTests = performanceTimelineData.slice(0, Math.min(10, performanceTimelineData.length - 10)); const recentAvg = recentTests.reduce((sum, t) => sum + t.percentage, 0) / Math.max(1, recentTests.length); const oldAvg = oldTests.length > 0 ? oldTests.reduce((sum, t) => sum + t.percentage, 0) / oldTests.length : recentAvg; const improvementTrend = recentAvg - oldAvg; const scores = performanceTimelineData.map(t => t.percentage); const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length; const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length; const consistency = Math.max(0, 100 - Math.sqrt(variance)); const totalHints = performanceTimelineData.reduce((sum, t) => sum + (t.hints || 0), 0); const totalQuestions = performanceTimelineData.reduce((sum, t) => sum + (t.correct || 0) + (t.incorrect || 0), 0); const hintEfficiency = totalQuestions > 0 ? Math.max(0, 100 - (totalHints / totalQuestions * 100)) : 100; const avgSpeed = performanceTimelineData.reduce((sum, t) => sum + (t.avgTime || 0), 0) / Math.max(1, performanceTimelineData.length); const speedScore = avgSpeed <= 8 ? 100 : avgSpeed <= 15 ? 80 : avgSpeed <= 25 ? 60 : 40; const bestStreak = calculateBestStreak(performanceTimelineData); const learningVelocity = performanceTimelineData.length > 5 ? (performanceTimelineData.slice(-5).reduce((sum, t) => sum + t.percentage, 0) / 5) - (performanceTimelineData.slice(0, 5).reduce((sum, t) => sum + t.percentage, 0) / 5) : 0; const difficultyScore = calculateDifficultyHandling(testHistory); return { accuracy: Math.round(advancedStats.averageScore), consistency: Math.round(consistency), hintEfficiency: Math.round(hintEfficiency), speedScore: Math.round(speedScore), improvementTrend: Math.round(improvementTrend * 10) / 10, learningVelocity: Math.round(learningVelocity * 10) / 10, bestStreak, difficultyScore: Math.round(difficultyScore), avgSpeed: Math.round(avgSpeed * 10) / 10, recentPerformance: Math.round(recentAvg), overallRating: calculateOverallRating(advancedStats.averageScore, consistency, hintEfficiency, speedScore), realTimePercentage: Math.round((performanceTimelineData.filter(t => t.hasRealTime).length / performanceTimelineData.length) * 100) }; }, [testHistory, performanceTimelineData, advancedStats]); const radarData = useMemo(() => { if (!performanceMetrics) return []; return [ { metric: 'Precisione', value: performanceMetrics.accuracy, fullMark: 100 }, { metric: 'Consistenza', value: performanceMetrics.consistency, fullMark: 100 }, { metric: 'Efficienza', value: performanceMetrics.hintEfficiency, fullMark: 100 }, { metric: 'Velocità', value: performanceMetrics.speedScore, fullMark: 100 }, { metric: 'Gestione Difficoltà', value: performanceMetrics.difficultyScore, fullMark: 100 } ]; }, [performanceMetrics]); const improvementData = useMemo(() => { const windows = []; const windowSize = 5; for (let i = 0; i <= performanceTimelineData.length - windowSize; i += 2) { const window = performanceTimelineData.slice(i, i + windowSize); const avgScore = window.reduce((sum, t) => sum + t.percentage, 0) / windowSize; const avgHints = window.reduce((sum, t) => sum + (t.hints || 0), 0) / windowSize; const avgSpeed = window.reduce((sum, t) => sum + (t.avgTime || 0), 0) / windowSize; windows.push({ period: `Test ${i + 1}-${i + windowSize}`, accuracy: Math.round(avgScore), efficiency: Math.max(0, Math.round(avgScore - (avgHints / window.reduce((sum, t) => sum + t.totalWords, 0) * 100))), speed: avgSpeed > 0 ? Math.round(Math.max(0, 100 - Math.min(100, avgSpeed * 3))) : 50 }); } return windows; }, [performanceTimelineData]); const difficultyAnalysis = useMemo(() => { const analysis = { easy: [], medium: [], hard: [] }; testHistory.forEach(test => { const totalWords = test.totalWords || 0; let category = 'easy'; if (totalWords >= 30) category = 'hard'; else if (totalWords >= 15) category = 'medium'; analysis[category].push({ percentage: test.percentage || 0, hints: test.hintsUsed || 0, words: totalWords }); }); return Object.entries(analysis).map(([difficulty, tests]) => { if (tests.length === 0) return null; const avgPercentage = tests.reduce((sum, t) => sum + t.percentage, 0) / tests.length; const avgHints = tests.reduce((sum, t) => sum + t.hints, 0) / tests.length; const totalWords = tests.reduce((sum, t) => sum + t.words, 0); return { difficulty: difficulty.charAt(0).toUpperCase() + difficulty.slice(1), count: tests.length, avgScore: Math.round(avgPercentage), avgHints: Math.round(avgHints * 10) / 10, efficiency: Math.round(avgPercentage - (avgHints / totalWords * 100 * tests.length)) }; }).filter(Boolean); }, [testHistory]); if (!performanceMetrics) { return ( <div className="text-center py-16 text-gray-500"> <Trophy className="w-16 h-16 mx-auto mb-4 opacity-50" /> <p>Completa alcuni test per vedere l'analisi performance</p> </div> ); } return ( <div className="space-y-8" key={`performance-${localRefresh}`}> } {performanceMetrics.realTimePercentage < 100 && ( <div className="mt-2 text-sm text-white/70"> ⏱️ Tempi stimati per {100 - performanceMetrics.realTimePercentage}% dei test </div> )} </div> <div className="grid grid-cols-2 md:grid-cols-5 gap-4"> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Trophy className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.accuracy}%</div> <div className="text-white/80 text-sm">Precisione</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Target className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.consistency}%</div> <div className="text-white/80 text-sm">Consistenza</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Lightbulb className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.hintEfficiency}%</div> <div className="text-white/80 text-sm">Efficienza</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Clock className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.speedScore}%</div> <div className="text-white/80 text-sm">Velocità</div> </div> <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm"> <Zap className="w-8 h-8 mx-auto mb-2" /> <div className="text-2xl font-bold">{performanceMetrics.bestStreak}</div> <div className="text-white/80 text-sm">Best Streak</div> </div> </div> </CardContent> </Card> <div className="grid grid-cols-1 lg:grid-cols-2 gap-8"> } <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <TrendingUp className="w-6 h-6" /> Trend di Miglioramento </CardTitle> </CardHeader> <CardContent className="p-6"> {improvementData.length > 1 ? ( <> <ResponsiveContainer width="100%" height={250}> <LineChart data={improvementData}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="period" tick={{ fontSize: 10 }} /> <YAxis domain={[0, 100]} /> <Tooltip /> <Line type="monotone" dataKey="accuracy" stroke="#10b981" strokeWidth={3} name="Precisione" /> <Line type="monotone" dataKey="efficiency" stroke="#3b82f6" strokeWidth={2} name="Efficienza" /> <Line type="monotone" dataKey="speed" stroke="#8b5cf6" strokeWidth={2} name="Velocità" /> </LineChart> </ResponsiveContainer> <div className="mt-4 text-center"> <div className={`text-lg font-bold ${ performanceMetrics.learningVelocity > 0 ? 'text-green-600' : performanceMetrics.learningVelocity < 0 ? 'text-red-600' : 'text-gray-600' }`}> Velocità di Apprendimento: {performanceMetrics.learningVelocity > 0 ? '+' : ''}{performanceMetrics.learningVelocity}% </div> <div className="text-sm text-gray-600"> {performanceMetrics.learningVelocity > 5 ? '🚀 Progressi rapidi!' : performanceMetrics.learningVelocity > 0 ? '📈 In miglioramento' : performanceMetrics.learningVelocity === 0 ? '➖ Stabile' : '📉 In calo'} </div> </div> </> ) : ( <div className="text-center py-8 text-gray-500"> <p>Completa più test per vedere i trend</p> </div> )} </CardContent> </Card> </div> } <Card className="bg-gradient-to-r from-cyan-50 to-blue-50 border-2 border-cyan-200"> <CardHeader className="bg-gradient-to-r from-cyan-500 to-blue-500 text-white"> <CardTitle className="flex items-center gap-3"> <Trophy className="w-6 h-6" /> 📊 Insights Performance Dettagliati </CardTitle> </CardHeader> <CardContent className="p-6"> <div className="grid grid-cols-1 md:grid-cols-2 gap-6"> } <div> <h4 className="font-bold text-orange-800 mb-3 flex items-center gap-2"> 📈 Aree di Miglioramento </h4> <div className="space-y-2 text-sm"> {performanceMetrics.accuracy < 70 && ( <p className="text-orange-700">⚠️ Precisione da migliorare ({performanceMetrics.accuracy}%)</p> )} {performanceMetrics.consistency < 60 && ( <p className="text-orange-700">⚠️ Performance troppo variabili - punta alla consistenza</p> )} {performanceMetrics.hintEfficiency < 70 && ( <p className="text-orange-700">⚠️ Uso eccessivo degli aiuti - prova a rispondere autonomamente</p> )} {performanceMetrics.speedScore < 60 && ( <p className="text-orange-700">⚠️ Tempi di risposta lenti - pratica per migliorare la velocità</p> )} {performanceMetrics.improvementTrend < -2 && ( <p className="text-orange-700">⚠️ Trend in calo ({performanceMetrics.improvementTrend}%) - rivedi la strategia di studio</p> )} {performanceMetrics.bestStreak < 3 && ( <p className="text-orange-700">⚠️ Mancanza di consistenza - concentrati sui fondamentali</p> )} </div> </div> </div>

================================================================================

NOME FILE: stats\sections\TrendsSection.js

import React, { useMemo } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, AreaChart, Area, BarChart, Bar, ComposedChart } from 'recharts'; import { Clock, Sparkles, TrendingUp, TrendingDown, Target, Lightbulb } from 'lucide-react'; import { useStatsData } from '../hooks/useStatsData'; const TrendsSection = ({ testHistory, localRefresh }) => { const { advancedStats, timelineData } = useStatsData(testHistory); const trendAnalysis = useMemo(() => { if (timelineData.length < 3) return null; const recent = timelineData.slice(-5); const previous = timelineData.slice(-10, -5); const early = timelineData.slice(0, 5); const calculateAverage = (data, field) => { const values = data.map(item => item[field] || 0).filter(v => v > 0); return values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0; }; const recentAvg = { accuracy: calculateAverage(recent, 'percentage'), hints: calculateAverage(recent, 'hints'), speed: calculateAverage(recent, 'avgTime') }; const previousAvg = { accuracy: calculateAverage(previous, 'percentage'), hints: calculateAverage(previous, 'hints'), speed: calculateAverage(previous, 'avgTime') }; const earlyAvg = { accuracy: calculateAverage(early, 'percentage'), hints: calculateAverage(early, 'hints'), speed: calculateAverage(early, 'avgTime') }; const accuracyTrend = previous.length > 0 ? recentAvg.accuracy - previousAvg.accuracy : 0; const hintsTrend = previous.length > 0 ? recentAvg.hints - previousAvg.hints : 0; const speedTrend = previous.length > 0 ? previousAvg.speed - recentAvg.speed : 0; const longTermAccuracyTrend = early.length > 0 ? recentAvg.accuracy - earlyAvg.accuracy : 0; const longTermHintsTrend = early.length > 0 ? earlyAvg.hints - recentAvg.hints : 0; const longTermSpeedTrend = early.length > 0 ? earlyAvg.speed - recentAvg.speed : 0; return { recent: recentAvg, previous: previousAvg, early: earlyAvg, shortTerm: { accuracy: accuracyTrend, hints: hintsTrend, speed: speedTrend }, longTerm: { accuracy: longTermAccuracyTrend, hints: longTermHintsTrend, speed: longTermSpeedTrend } }; }, [timelineData]); const monthlyTrends = useMemo(() => { const monthlyData = {}; testHistory.forEach(test => { const date = new Date(test.timestamp); const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`; if (!monthlyData[monthKey]) { monthlyData[monthKey] = { month: monthKey, tests: 0, totalAccuracy: 0, totalHints: 0, totalTime: 0 }; } monthlyData[monthKey].tests++; monthlyData[monthKey].totalAccuracy += test.percentage || 0; monthlyData[monthKey].totalHints += test.hintsUsed || 0; monthlyData[monthKey].totalTime += test.avgTimePerWord || 0; }); return Object.values(monthlyData).map(month => ({ ...month, avgAccuracy: Math.round(month.totalAccuracy / month.tests), avgHints: Math.round((month.totalHints / month.tests) * 10) / 10, avgTime: Math.round((month.totalTime / month.tests) * 10) / 10, efficiency: Math.round((month.totalAccuracy / month.tests) - (month.totalHints / month.tests)) })).sort((a, b) => a.month.localeCompare(b.month)); }, [testHistory]); const hourlyPattern = useMemo(() => { const hourlyData = {}; testHistory.forEach(test => { const hour = new Date(test.timestamp).getHours(); const timeSlot = hour < 6 ? 'Notte (0-6)' : hour < 12 ? 'Mattina (6-12)' : hour < 18 ? 'Pomeriggio (12-18)' : 'Sera (18-24)'; if (!hourlyData[timeSlot]) { hourlyData[timeSlot] = { timeSlot, tests: 0, totalAccuracy: 0, totalHints: 0 }; } hourlyData[timeSlot].tests++; hourlyData[timeSlot].totalAccuracy += test.percentage || 0; hourlyData[timeSlot].totalHints += test.hintsUsed || 0; }); return Object.values(hourlyData).map(slot => ({ ...slot, avgAccuracy: Math.round(slot.totalAccuracy / slot.tests), avgHints: Math.round((slot.totalHints / slot.tests) * 10) / 10 })).sort((a, b) => { const order = ['Mattina (6-12)', 'Pomeriggio (12-18)', 'Sera (18-24)', 'Notte (0-6)']; return order.indexOf(a.timeSlot) - order.indexOf(b.timeSlot); }); }, [testHistory]); if (timelineData.length < 3) { return ( <div className="text-center py-16 text-gray-500"> <Clock className="w-16 h-16 mx-auto mb-4 opacity-50" /> <p>Completa almeno 3 test per vedere le analisi delle tendenze</p> </div> ); } return ( <div className="space-y-8" key={`trends-${localRefresh}`}> } <Area yAxisId="left" type="monotone" dataKey="percentage" fill="#8b5cf6" fillOpacity={0.3} stroke="#8b5cf6" strokeWidth={3} name="percentage" /> } <Line yAxisId="right" type="monotone" dataKey="avgTime" stroke="#06b6d4" strokeWidth={2} name="avgTime" strokeDasharray="5 5" /> </ComposedChart> </ResponsiveContainer> <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4 text-center text-sm"> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-purple-500 rounded"></div> <span>Precisione (%)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 bg-yellow-500 rounded"></div> <span>Aiuti (numero)</span> </div> <div className="flex items-center justify-center gap-2"> <div className="w-4 h-4 border-2 border-cyan-500 bg-white rounded"></div> <span>Tempo Medio (secondi)</span> </div> </div> </CardContent> </Card> } <Card className="bg-gradient-to-br from-blue-50 to-cyan-50 border-2 border-blue-200"> <CardHeader className="bg-gradient-to-r from-blue-500 to-cyan-500 text-white"> <CardTitle className="flex items-center gap-3"> <TrendingUp className="w-6 h-6" /> Tendenze Recenti (Ultimi 5 vs 5 Precedenti) </CardTitle> </CardHeader> <CardContent className="p-6"> <div className="space-y-4"> <div className="flex justify-between items-center p-3 bg-white rounded-xl"> <span className="font-medium">Precisione</span> <div className="flex items-center gap-2"> <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.accuracy)}%</span> <span className={`text-sm font-bold ${ trendAnalysis.shortTerm.accuracy > 2 ? 'text-green-600' : trendAnalysis.shortTerm.accuracy < -2 ? 'text-red-600' : 'text-gray-600' }`}> {trendAnalysis.shortTerm.accuracy > 0 ? '↗' : trendAnalysis.shortTerm.accuracy < 0 ? '↘' : '→'} {Math.abs(Math.round(trendAnalysis.shortTerm.accuracy * 10) / 10)}% </span> </div> </div> <div className="flex justify-between items-center p-3 bg-white rounded-xl"> <span className="font-medium">Aiuti per Test</span> <div className="flex items-center gap-2"> <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.hints * 10) / 10}</span> <span className={`text-sm font-bold ${ trendAnalysis.shortTerm.hints < -0.5 ? 'text-green-600' : trendAnalysis.shortTerm.hints > 0.5 ? 'text-red-600' : 'text-gray-600' }`}> {trendAnalysis.shortTerm.hints < 0 ? '↘' : trendAnalysis.shortTerm.hints > 0 ? '↗' : '→'} {Math.abs(Math.round(trendAnalysis.shortTerm.hints * 10) / 10)} </span> </div> </div> <div className="flex justify-between items-center p-3 bg-white rounded-xl"> <span className="font-medium">Velocità Media</span> <div className="flex items-center gap-2"> <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.speed * 10) / 10}s</span> <span className={`text-sm font-bold ${ trendAnalysis.shortTerm.speed > 1 ? 'text-green-600' : trendAnalysis.shortTerm.speed < -1 ? 'text-red-600' : 'text-gray-600' }`}> {trendAnalysis.shortTerm.speed > 0 ? '↗' : trendAnalysis.shortTerm.speed < 0 ? '↘' : '→'} {Math.abs(Math.round(trendAnalysis.shortTerm.speed * 10) / 10)}s </span> </div> </div> </div> </CardContent> </Card> } {monthlyTrends.length > 1 && ( <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden"> <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white"> <CardTitle className="flex items-center gap-3 text-white"> <TrendingUp className="w-6 h-6" /> Tendenze Mensili </CardTitle> </CardHeader> <CardContent className="p-6"> <ResponsiveContainer width="100%" height={300}> <LineChart data={monthlyTrends}> <CartesianGrid strokeDasharray="3 3" /> <XAxis dataKey="month" /> <YAxis /> <Tooltip /> <Line type="monotone" dataKey="avgAccuracy" stroke="#8b5cf6" strokeWidth={3} name="Precisione Media %" /> <Line type="monotone" dataKey="efficiency" stroke="#10b981" strokeWidth={2} name="Efficienza %" /> <Line type="monotone" dataKey="avgHints" stroke="#f59e0b" strokeWidth={2} name="Aiuti Medi" /> </LineChart> </ResponsiveContainer> </CardContent> </Card> )} } <Card className="bg-gradient-to-r from-yellow-50 to-orange-50 border-2 border-yellow-200"> <CardContent className="p-6"> <h3 className="text-xl font-bold text-yellow-800 mb-4 flex items-center gap-2"> <Sparkles className="w-6 h-6" /> Insights e Raccomandazioni Avanzate </h3> <div className="space-y-3 text-yellow-700"> <p>🎯 <strong>Precisione attuale:</strong> {advancedStats.averageScore}% (target: 80%+)</p> <p>💡 <strong>Uso aiuti:</strong> {advancedStats.hintsPercentage}% (ideale: sotto 20%)</p> <p>⚡ <strong>Efficienza netta:</strong> {Math.max(0, advancedStats.averageScore - advancedStats.hintsPercentage)}%</p>

================================================================================

NOME FILE: stats\sections\WordsSection.js

import React, { useState, useMemo, useEffect } from 'react'; import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card'; import { Button } from '../../ui/button'; import { Input } from '../../ui/input'; import { Search, BookOpen, Filter, CheckSquare, Square, ChevronDown, ChevronUp, AlertTriangle, CheckCircle, Circle, Eye, Maximize2, Minimize2 } from 'lucide-react'; import { useAppContext } from '../../../contexts/AppContext'; import { useNotification } from '../../../contexts/NotificationContext'; import { getCategoryStyle } from '../../../utils/categoryUtils'; import WordDetailSection from '../components/WordDetailSection'; const WordsSection = ({ localRefresh }) => { const [searchWord, setSearchWord] = useState(''); const [filterChapter, setFilterChapter] = useState(''); const [filterLearned, setFilterLearned] = useState('all'); const [filterDifficult, setFilterDifficult] = useState('all'); const [filterGroup, setFilterGroup] = useState(''); const [selectedWordId, setSelectedWordId] = useState(null); const [showFiltersPanel, setShowFiltersPanel] = useState(true); const [internalRefresh, setInternalRefresh] = useState(0); const [collapsedChapters, setCollapsedChapters] = useState({}); const { words, getAllWordsPerformance, getWordAnalysis, testHistory, wordPerformance, toggleWordLearned, toggleWordDifficult } = useAppContext(); const { showSuccess } = useNotification(); useEffect(() => { const handleForceRefresh = () => { setInternalRefresh(prev => prev + 1); }; window.addEventListener('forceStatsRefresh', handleForceRefresh); return () => window.removeEventListener('forceStatsRefresh', handleForceRefresh); }, []); const enhancedWordsData = useMemo(() => { if (!getAllWordsPerformance || !words) { return []; } const performanceData = getAllWordsPerformance(); const performanceMap = new Map(performanceData.map(p => [p.wordId, p])); const enhanced = words.map((word, index) => { const performance = performanceMap.get(word.id); const hasAttempts = performance && performance.attempts && performance.attempts.length > 0; const hasTotalAttempts = performance && performance.totalAttempts > 0; const hasAccuracy = performance && typeof performance.accuracy === 'number'; const hasData = hasAttempts || hasTotalAttempts || hasAccuracy; return { ...word, totalAttempts: performance?.totalAttempts || performance?.attempts?.length || 0, accuracy: performance?.accuracy || 0, hintsPercentage: performance?.hintsPercentage || 0, currentStreak: performance?.currentStreak || 0, status: performance?.status || 'new', avgTime: performance?.avgTime || 0, hasPerformanceData: hasData, _rawPerformance: performance }; }); const withData = enhanced.filter(w => w.hasPerformanceData).length; if (withData === 0 && wordPerformance && Object.keys(wordPerformance).length > 0) { const enhancedFallback = words.map(word => { const rawPerformance = wordPerformance[word.id]; const hasRawData = rawPerformance && rawPerformance.attempts && rawPerformance.attempts.length > 0; if (hasRawData) { const attempts = rawPerformance.attempts; const totalAttempts = attempts.length; const correctAttempts = attempts.filter(a => a.correct).length; const accuracy = totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0; return { ...word, totalAttempts, accuracy, hintsPercentage: 0, currentStreak: 0, status: accuracy >= 70 ? 'improving' : accuracy >= 50 ? 'inconsistent' : 'struggling', avgTime: 0, hasPerformanceData: true }; } return { ...word, totalAttempts: 0, accuracy: 0, hintsPercentage: 0, currentStreak: 0, status: 'new', avgTime: 0, hasPerformanceData: false }; }); const fallbackWithData = enhancedFallback.filter(w => w.hasPerformanceData).length; return enhancedFallback; } return enhanced; }, [getAllWordsPerformance, words, wordPerformance, localRefresh]); const filteredWords = useMemo(() => { return enhancedWordsData.filter(word => { if (searchWord && !word.english.toLowerCase().includes(searchWord.toLowerCase())) { return false; } if (filterChapter !== '') { if (filterChapter === 'no-chapter') { if (word.chapter) return false; } else { if (word.chapter !== filterChapter) return false; } } if (filterGroup && word.group !== filterGroup) return false; if (filterLearned === 'learned' && !word.learned) return false; if (filterLearned === 'not_learned' && word.learned) return false; if (filterDifficult === 'difficult' && !word.difficult) return false; if (filterDifficult === 'not_difficult' && word.difficult) return false; return true; }); }, [enhancedWordsData, searchWord, filterChapter, filterGroup, filterLearned, filterDifficult]); const availableChapters = useMemo(() => { const chapters = new Set(); enhancedWordsData.forEach(word => { if (word.chapter) chapters.add(word.chapter); }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b); }); }, [enhancedWordsData]); const availableGroups = useMemo(() => { const groups = new Set(); enhancedWordsData.forEach(word => { if (word.group) groups.add(word.group); }); return Array.from(groups).sort(); }, [enhancedWordsData]); const wordsWithoutChapter = useMemo(() => { return enhancedWordsData.filter(word => !word.chapter); }, [enhancedWordsData]); const stats = useMemo(() => { const withPerformance = enhancedWordsData.filter(w => w.hasPerformanceData); return { total: enhancedWordsData.length, learned: enhancedWordsData.filter(w => w.learned).length, notLearned: enhancedWordsData.filter(w => !w.learned).length, difficult: enhancedWordsData.filter(w => w.difficult).length, withChapter: enhancedWordsData.filter(w => w.chapter).length, withPerformance: withPerformance.length, filtered: filteredWords.length, avgAccuracy: withPerformance.length > 0 ? Math.round(withPerformance.reduce((sum, w) => sum + w.accuracy, 0) / withPerformance.length) : 0 }; }, [enhancedWordsData, filteredWords.length]); const groupedWords = useMemo(() => { return filteredWords.reduce((groups, word) => { const chapter = word.chapter || 'Senza Capitolo'; if (!groups[chapter]) groups[chapter] = []; groups[chapter].push(word); return groups; }, {}); }, [filteredWords]); const clearFilters = () => { setSearchWord(''); setFilterChapter(''); setFilterLearned('all'); setFilterDifficult('all'); setFilterGroup(''); }; const handleToggleLearned = (id) => { const word = enhancedWordsData.find(w => w.id === id); if (word) { toggleWordLearned(id); showSuccess( word.learned ? `📖 "${word.english}" segnata come da studiare` : `✅ "${word.english}" segnata come appresa!` ); } }; const handleToggleDifficult = (id) => { const word = enhancedWordsData.find(w => w.id === id); if (word) { toggleWordDifficult(id); showSuccess( word.difficult ? `📚 "${word.english}" rimossa dalle parole difficili` : `⭐ "${word.english}" segnata come difficile!` ); } }; const toggleChapterCollapse = (chapter) => { setCollapsedChapters(prev => ({ ...prev, [chapter]: !prev[chapter] })); }; const allChapters = Object.keys(groupedWords); const allCollapsed = allChapters.every(chapter => collapsedChapters[chapter]); const allExpanded = allChapters.every(chapter => !collapsedChapters[chapter]); const expandAllChapters = () => { const newState = {}; allChapters.forEach(chapter => { newState[chapter] = false; }); setCollapsedChapters(newState); }; const collapseAllChapters = () => { const newState = {}; allChapters.forEach(chapter => { newState[chapter] = true; }); setCollapsedChapters(newState); }; return ( <div className="space-y-8" key={`words-enhanced-${localRefresh}-${internalRefresh}`}> } {allChapters.length > 1 && ( <div className="flex gap-2"> <Button onClick={expandAllChapters} disabled={allExpanded} variant="ghost" size="sm" className="text-white hover:bg-white/20 disabled:opacity-50 disabled:cursor-not-allowed" > <Maximize2 className="w-4 h-4 mr-2" /> Espandi Tutti </Button> <Button onClick={collapseAllChapters} disabled={allCollapsed} variant="ghost" size="sm" className="text-white hover:bg-white/20 disabled:opacity-50 disabled:cursor-not-allowed" > <Minimize2 className="w-4 h-4 mr-2" /> Collassa Tutti </Button> </div> )} </div> </CardHeader> </Card> } {selectedWordId && ( <WordDetailSection wordId={selectedWordId} getWordAnalysis={getWordAnalysis} testHistory={testHistory} wordInfo={enhancedWordsData.find(w => w.id === selectedWordId)} localRefresh={`${localRefresh}-${internalRefresh}`} /> )} } <CardHeader className="bg-gradient-to-r from-indigo-100 to-purple-100 border-b border-indigo-200 cursor-pointer hover:from-indigo-200 hover:to-purple-200 transition-colors" onClick={() => toggleChapterCollapse(chapter)} > <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> <div className="flex items-center gap-2"> {isCollapsed ? ( <ChevronDown className="w-5 h-5 text-indigo-600" /> ) : ( <ChevronUp className="w-5 h-5 text-indigo-600" /> )} <BookOpen className="w-6 h-6 text-indigo-600" /> </div> <CardTitle className="text-indigo-800 text-lg"> {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`} </CardTitle> {isCollapsed && ( <span className="text-xs text-indigo-600 bg-indigo-200 px-2 py-1 rounded-full"> Clicca per espandere </span> )} </div> <div className="flex gap-2 text-sm"> <span className="bg-indigo-200 text-indigo-700 px-3 py-1 rounded-full"> {chapterWords.length} parole </span> <span className="bg-green-200 text-green-700 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.learned).length} apprese </span> <span className="bg-red-200 text-red-700 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.difficult).length} difficili </span> <span className="bg-purple-200 text-purple-700 px-3 py-1 rounded-full"> {chapterWords.filter(w => w.hasPerformanceData).length} con performance </span> </div> </div> </CardHeader> } <div className="max-h-80 overflow-y-auto space-y-2 pr-2 scrollbar-thin scrollbar-thumb-indigo-300 scrollbar-track-gray-100"> {chapterWords.map((word) => ( <CompactWordCard key={word.id} word={word} isSelected={selectedWordId === word.id} onClick={() => setSelectedWordId(selectedWordId === word.id ? null : word.id)} onToggleLearned={() => handleToggleLearned(word.id)} onToggleDifficult={() => handleToggleDifficult(word.id)} /> ))} </div> } <div className="flex items-center gap-3 flex-1 cursor-pointer" onClick={onClick}> <div className="flex items-center gap-2"> <span className={`text-lg font-bold ${word.learned ? 'text-gray-600' : 'text-gray-800'}`}> {word.english} </span> <span className="text-gray-400">→</span> <span className={`text-base ${word.learned ? 'text-gray-500' : 'text-gray-700'}`}> {word.italian} </span> </div> } {word.hasPerformanceData && ( <div className="flex items-center gap-3 text-sm"> <div className="text-center"> <div className="font-bold text-blue-600">{word.accuracy}%</div> <div className="text-xs text-gray-500">Precisione</div> </div> <div className="text-center"> <div className="font-bold text-green-600">{word.currentStreak}</div> <div className="text-xs text-gray-500">Streak</div> </div> <div className="text-center"> <div className="font-bold text-purple-600">{word.avgTime}s</div> <div className="text-xs text-gray-500">Tempo</div> </div> </div> )} } <div className="mt-2 text-center text-xs"> {isSelected ? ( <span className="text-blue-600">↑ Clicca per nascondere l'andamento temporale</span> ) : word.hasPerformanceData ? ( <span className="text-gray-500">↑ Clicca per vedere l'andamento temporale</span> ) : ( <span className="text-gray-400">📊 Nessun dato performance disponibile</span> )} </div> </div> ); }; export default WordsSection;

================================================================================

NOME FILE: ui\BackgroundParticles.js

import React from 'react'; export const BackgroundParticles = React.memo(() => ( <div className="fixed inset-0 overflow-hidden pointer-events-none"> <div className="absolute top-10 left-10 w-72 h-72 bg-blue-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob"></div> <div className="absolute top-0 right-4 w-72 h-72 bg-yellow-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-2000"></div> <div className="absolute -bottom-8 left-20 w-72 h-72 bg-pink-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-4000"></div> </div> ));

================================================================================

NOME FILE: ui\button.js

import React from 'react'; const Button = React.forwardRef(({ className = "", variant = "default", size = "default", children, disabled = false, ...props }, ref) => { const baseClasses = "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background"; const variants = { default: "bg-primary text-primary-foreground hover:bg-primary/90 bg-slate-900 text-white hover:bg-slate-800", outline: "border border-input hover:bg-accent hover:text-accent-foreground border-gray-300 hover:bg-gray-50", ghost: "hover:bg-accent hover:text-accent-foreground hover:bg-gray-100", destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90 bg-red-600 text-white hover:bg-red-700" }; const sizes = { default: "h-10 py-2 px-4", sm: "h-9 px-3 rounded-md", lg: "h-11 px-8 rounded-md" }; const classes = `${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`; return ( <button className={classes} ref={ref} disabled={disabled} {...props} > {children} </button> ); }); Button.displayName = "Button"; export { Button };

================================================================================

NOME FILE: ui\card.js

import React from 'react'; const Card = React.forwardRef(({ className = "", ...props }, ref) => ( <div ref={ref} className={`rounded-lg border bg-card text-card-foreground shadow-sm bg-white border-gray-200 ${className}`} {...props} /> )); Card.displayName = "Card"; const CardHeader = React.forwardRef(({ className = "", ...props }, ref) => ( <div ref={ref} className={`flex flex-col space-y-1.5 p-6 ${className}`} {...props} /> )); CardHeader.displayName = "CardHeader"; const CardTitle = React.forwardRef(({ className = "", ...props }, ref) => ( <h3 ref={ref} className={`text-2xl font-semibold leading-none tracking-tight ${className}`} {...props} /> )); CardTitle.displayName = "CardTitle"; const CardDescription = React.forwardRef(({ className = "", ...props }, ref) => ( <p ref={ref} className={`text-sm text-muted-foreground text-gray-600 ${className}`} {...props} /> )); CardDescription.displayName = "CardDescription"; const CardContent = React.forwardRef(({ className = "", ...props }, ref) => ( <div ref={ref} className={`p-6 pt-0 ${className}`} {...props} /> )); CardContent.displayName = "CardContent"; const CardFooter = React.forwardRef(({ className = "", ...props }, ref) => ( <div ref={ref} className={`flex items-center p-6 pt-0 ${className}`} {...props} /> )); CardFooter.displayName = "CardFooter"; export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

================================================================================

NOME FILE: ui\input.js

import React from 'react'; const Input = React.forwardRef(({ className = "", type = "text", ...props }, ref) => { return ( <input type={type} className={`flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`} ref={ref} {...props} /> ); }); Input.displayName = "Input"; export { Input };

================================================================================

NOME FILE: ui\modal.js

import React from 'react'; const Modal = ({ isOpen, onClose, children, className = "" }) => { if (!isOpen) return null; return ( <div className="fixed inset-0 z-50 overflow-y-auto"> } <div className="flex min-h-full items-center justify-center p-4"> <div className={`relative bg-white rounded-2xl shadow-2xl transform transition-all duration-300 scale-100 max-w-md w-full mx-auto ${className}`} onClick={(e) => e.stopPropagation()} > {children} </div> </div> </div> ); }; const ModalHeader = ({ children, className = "" }) => ( <div className={`px-6 py-4 border-b border-gray-200 ${className}`}> {children} </div> ); const ModalTitle = ({ children, className = "" }) => ( <h3 className={`text-lg font-semibold text-gray-900 ${className}`}> {children} </h3> ); const ModalContent = ({ children, className = "" }) => ( <div className={`px-6 py-4 ${className}`}> {children} </div> ); const ModalFooter = ({ children, className = "" }) => ( <div className={`px-6 py-4 border-t border-gray-200 flex justify-end gap-3 ${className}`}> {children} </div> ); export { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter };

================================================================================

NOME FILE: ui\NotificationToast.js

import React from 'react'; import { useNotification } from '../../contexts/NotificationContext'; export const NotificationToast = React.memo(() => { const { notifications } = useNotification(); if (notifications.length === 0) return null; return ( <div className="fixed top-6 right-6 z-50 space-y-2"> {notifications.map(notification => ( <NotificationItem key={notification.id} notification={notification} /> ))} </div> ); }); const NotificationItem = React.memo(({ notification }) => { const typeStyles = { success: 'bg-gradient-to-r from-green-500 to-emerald-500', error: 'bg-gradient-to-r from-red-500 to-pink-500', warning: 'bg-gradient-to-r from-orange-500 to-yellow-500', info: 'bg-gradient-to-r from-blue-500 to-cyan-500' }; const icons = { success: '✅', error: '❌', warning: '⚠️', info: 'ℹ️' }; return ( <div className={`${typeStyles[notification.type]} text-white px-6 py-4 rounded-2xl shadow-2xl backdrop-blur-sm border border-white/20 animate-slide-in max-w-md`}> <div className="flex items-center gap-3"> <span className="text-lg">{icons[notification.type]}</span> <span className="font-medium">{notification.message}</span> </div> </div> ); });

================================================================================

NOME FILE: ui\textarea.js

import React from 'react'; const Textarea = React.forwardRef(({ className = "", ...props }, ref) => { return ( <textarea className={`flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`} ref={ref} {...props} /> ); }); Textarea.displayName = "Textarea"; export { Textarea };

================================================================================


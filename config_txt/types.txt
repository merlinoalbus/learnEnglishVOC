NOME FILE: index.ts

export * from "./entities/Word.types"; export type { Word, WordCategory, WordCategoryMetadata, WordChapter, WordFilters, WordSearchConfig, WordValidationRules, WordValidationResult, WordStats, ChapterStats, CreateWordInput, UpdateWordInput, ImportWordsInput, ImportWordsResult, WordExportConfig, WordExportData, WordSortOption, } from "./entities/Word.types"; export { WORD_CATEGORIES, WORD_VALIDATION_SCHEMA } from "./entities/Word.types"; export * from "./entities/User.types"; export type { User, UserProfile, UserPreferences, UserStats, UserMilestone, AuthState, AuthError, SignUpInput, SignInInput, ResetPasswordInput, UpdateProfileInput, AuthOperationResult, UserSession, SessionActivity, EnglishLevel, LearningGoal, AppTheme, InterfaceLanguage, TestPreferences, NotificationPreferences, AudioPreferences, DisplayPreferences, FontSize, AuthErrorType, } from "./entities/User.types"; export type { Test, TestConfig, TestMode, TestState, TestAction, TestSession, TestWordPool, WordSelectionStrategy, TestQuestion, QuestionTimer, QuestionHintState, AvailableHint, UsedHint, HintType, TestAnswer, AnswerResult, AnswerTiming, AnswerMetadata, TestHintSystem, HintSystemConfig, HintGlobalState, HintUsagePattern, HintStatistics, TestProgress, BasicProgress, ProgressPredictions, ProgressMilestone, WordSelectionConfig, TimingConfig, UIConfig, ScoringConfig, TestEvent, TestResult, FinalScore, ScoreBreakdown, ScoreComparison, ScoreCategory, TestExportData, TestSummary, } from "./entities/Test.types"; export type { TestTimeMetrics, TimeDistribution, SpeedTrend, TestAnalytics, PerformancePatterns, AccuracyPatterns, CategoryPerformance, TestInsight, TestRecommendation, TestFeedback, } from "./entities/Test.types"; export * from "./entities/Statistics.types"; export type { Statistics, CategoryProgressAggregated, DailyProgressAggregated, DifficultyStatsAggregated, MonthlyStatsAggregated, MonthlyInsight, LearningTrendsAnalysis, TrendAnalysis, WeeklyProgressAnalysis, StudyScheduleRecommendation, MonthlyTrendsAnalysis, SeasonalPattern, StreakAnalysisData, StreakBreakPattern, StreakMotivationInsight, NextSessionPrediction, MasteryTimelinePrediction, MasteryMilestone, AccelerationOpportunity, RecommendedAction, StatisticsAggregationInput, AggregationConfig, StatisticsAggregationResult, DataSource, DataQualityIssue, ComprehensiveStatisticsExportData, } from "./entities/Statistics.types"; export type { WordPerformance, PerformanceAttempt, WordPerformanceAnalysis, WordPerformanceStatus, GlobalPerformanceStats, UpdatePerformanceInput, UpdatePerformanceResult, PerformanceCategory, SimpleTrend, WordPerformanceTrends, } from "./entities/Performance.types"; export * from "./infrastructure/Firestore.types"; export type { FirestoreDoc, FirestoreDocMetadata, FirestoreCollection, FirestoreQuery, WhereClause, OrderByClause, FirestoreQueryResult, FirestoreListener, ListenerType, ListenerTarget, ListenerState, ListenerConfig, FirestoreListenerData, ChangeType, FirestoreError, FirestoreErrorCode, FirestoreOperation, FirestoreBatch, BatchOperation, FirestoreOperationResult, FirestoreConnectionState, PendingOperation, FirestoreSyncConfig, FirestoreOperator, } from "./infrastructure/Firestore.types"; export * from "./infrastructure/Auth.types"; export type { AuthUser, AuthUserMetadata, AuthProviderData, AuthConnectionState, AuthSession, AuthDeviceInfo, AuthConfig, AuthProvider, AuthPersistence, AuthTokenConfig, AuthSecurityConfig, PasswordPolicy, AuthUIConfig, AuthRedirectUrls, AuthEmailConfig, EmailTemplate, AuthError as AuthInfrastructureError, AuthErrorCode, AuthErrorType as AuthInfrastructureErrorType, AuthOperation, SignInWithEmailInput, SignUpWithEmailInput, SignInWithProviderInput, ResetPasswordInput as AuthResetPasswordInput, UpdateProfileInput as AuthUpdateProfileInput, UpdateEmailInput, UpdatePasswordInput, ReauthenticateInput, AuthOperationResult as AuthInfrastructureOperationResult, AuthOperationMetadata, AuthRequiredAction, TwoFactorAuthConfig, TwoFactorMethod, AuthToken, TokenClaims, AuthAnalytics, LoginStatistics, AuthBehaviorPatterns, SecurityEvent, SecurityEventType, DeviceUsage, } from "./infrastructure/Auth.types"; export type TestPerformanceMetrics = import("./entities/Test.types").PerformanceMetrics; export type WordPerformanceMetrics = import("./entities/Performance.types").PerformanceMetrics; export type CategoryProgress = import("./entities/Statistics.types").CategoryProgressAggregated; export type DailyProgress = import("./entities/Statistics.types").DailyProgressAggregated; export type MonthlyStats = import("./entities/Statistics.types").MonthlyStatsAggregated; export type CalculatedStatistics = import("./entities/Statistics.types").AggregatedCalculatedStatistics; export type StatisticsExportData = import("./entities/Statistics.types").ComprehensiveStatisticsExportData; export type TestDifficultyAnalysis = import("./entities/Performance.types").TestDifficultyAnalysis; export type WeeklyProgress = import("./entities/Statistics.types").WeeklyProgressAnalysis; export type AdvancedStatsCalculation = import("./entities/Statistics.types").AggregatedCalculatedStatistics; export type TestHistoryRecord = import("./entities/Test.types").TestResult; export type WrongWordRecord = { wordId: string; word: import("./entities/Word.types").Word; attempts: number; lastIncorrectAt: Date; }; export type WordTimeRecord = { wordId: string; averageTime: number; fastestTime: number; slowestTime: number; totalAttempts: number; }; export type ChapterTestStats = { chapter: string; testsCompleted: number; averageScore: number; averageAccuracy: number; totalTime: number; }; export type TestParameters = { mode: import("./entities/Test.types").TestMode; difficulty: "easy" | "medium" | "hard"; wordCount: number; chapters: string[]; categories: string[]; }; export type WeeklyTotals = { testsCompleted: number; wordsStudied: number; averageScore: number; totalTime: number; }; export type WeeklyTrend = { direction: "up" | "down" | "stable"; percentage: number; }; export type HandleTestCompleteInput = { testResult: import("./entities/Test.types").TestResult; wordPerformances: import("./entities/Performance.types").PerformanceAttempt[]; }; export type TestStats = { totalTests: number; averageScore: number; averageAccuracy: number; totalTime: number; bestScore: number; currentStreak: number; }; export type AnyEntity = | import("./entities/Word.types").Word | import("./entities/User.types").User | import("./entities/Test.types").Test | import("./entities/Statistics.types").Statistics | import("./entities/Performance.types").WordPerformance; export type FirestoreMetadata = import("./infrastructure/Firestore.types").FirestoreDocMetadata; export type AnyError = | import("./entities/User.types").AuthError | import("./infrastructure/Auth.types").AuthError | import("./infrastructure/Firestore.types").FirestoreError; export type AnyConfig = | import("./entities/Test.types").TestConfig | import("./infrastructure/Auth.types").AuthConfig | import("./infrastructure/Firestore.types").FirestoreSyncConfig; export type GetFirestoreMetadata<T> = T extends { firestoreMetadata?: infer M } ? M : never; export type WithoutFirestoreMetadata<T> = Omit<T, "firestoreMetadata">; export type WithRequiredFirestoreMetadata<T> = T & { firestoreMetadata: NonNullable<GetFirestoreMetadata<T>>; }; export type CreateInput<T> = Omit< T, "id" | "createdAt" | "updatedAt" | "firestoreMetadata" >; export type UpdateInput<T> = Partial< Omit<T, "id" | "createdAt" | "firestoreMetadata"> > & { id: string; }; export type OperationResult<T> = { success: boolean; data?: T; error?: AnyError; metadata: { operation: string; timestamp: Date; duration: number; }; }; export function isFirestoreDoc<T>( obj: any ): obj is import("./infrastructure/Firestore.types").FirestoreDoc<T> { return ( obj && typeof obj.id === "string" && obj.data && obj.metadata && typeof obj.path === "string" ); } export function hasFirestoreMetadata<T extends { firestoreMetadata?: any }>( entity: T ): entity is WithRequiredFirestoreMetadata<T> { return ( entity.firestoreMetadata !== undefined && entity.firestoreMetadata !== null ); } export function isAuthError( error: any ): error is | import("./entities/User.types").AuthError | import("./infrastructure/Auth.types").AuthError { return ( error && typeof error.code === "string" && (error.code.startsWith("auth/") || typeof error.type === "string") ); } export function isFirestoreError( error: any ): error is import("./infrastructure/Firestore.types").FirestoreError { return ( error && typeof error.code === "string" && typeof error.operation === "string" && typeof error.recoverable === "boolean" ); } export const DEFAULT_FIRESTORE_METADATA: FirestoreMetadata = { userId: "", createdAt: new Date(), updatedAt: new Date(), version: 1, deleted: false, custom: {}, } as const; export const DEFAULT_FIRESTORE_QUERY_CONFIG = { limit: 25, includeDeleted: false, userScoped: true, } as const; export const DEFAULT_LISTENER_CONFIG: import("./infrastructure/Firestore.types").ListenerConfig = { includeMetadataChanges: false, source: "default", autoRetry: true, retryTimeout: 5000, maxRetries: 3, }; export const DEFAULT_AUTH_CONFIG: Partial< import("./infrastructure/Auth.types").AuthConfig > = { enabledProviders: ["email", "google"], persistence: "local", tokenConfig: { autoRefresh: true, refreshInterval: 50 * 60 * 1000, tokenExpiry: 60 * 60 * 1000, refreshBuffer: 5 * 60 * 1000, includeCustomClaims: true, }, }; export const TYPES_SCHEMA_VERSION = "1.3.0" as const; export const IMPLEMENTED_TYPES_METADATA = { version: TYPES_SCHEMA_VERSION, implementedAt: new Date("2025-01-12"), entities: ["Word", "User", "Test", "Statistics", "Performance"] as const, infrastructure: ["Firestore", "Auth"] as const, totalInterfaces: 100, duplicatesRemoved: 20, conflictsResolved: 8, group: "Foundation Types & Entities - FIXED", nextGroup: "Core Infrastructure", corrections: [ "Restored original comprehensive structure with all re-exports", "Fixed missing exports from Statistics.types.ts using aggregated types", "Resolved PerformanceMetrics naming conflicts with explicit aliases", "Fixed malformed union types using proper import syntax", "Added legacy type aliases for backward compatibility", "Eliminated circular imports and naming conflicts", "Aligned with AS-IS code structure from hooks", "Completed all truncated files and fixed exports", "Corrected union types and export consistency", "Maintained comprehensive export structure as required", ] as const, } as const;

================================================================================

NOME FILE: entities\Performance.types.ts

import { Word } from "./Word.types"; export interface WordPerformance { english: string; chapter?: string; updatedAt?: Date; export interface PerformanceAttempt { correct: boolean; timeSpent: number; } export interface WordPerformanceAnalysis { english: string; italian: string; chapter: string; group: string; sentence: string; notes: string; learned: boolean; difficult: boolean; status: WordPerformanceStatus; attempts: PerformanceAttempt[]; export type WordPerformanceStatus = | "new" | "promising" | "struggling" | "consolidated" | "improving" | "critical" | "inconsistent"; export interface PerformanceMetrics { wordPerformances: WordPerformanceAnalysis[]; calculatedAt: Date; } export interface GlobalPerformanceStats { statusDistribution: Record<WordPerformanceStatus, number>; averageResponseTime: number; wordsNeedingWork: number; export interface UpdatePerformanceInput { isCorrect: boolean; timeSpent: number; } export interface UpdatePerformanceResult { updatedPerformance?: WordPerformance; error?: string; } export interface TestDifficultyAnalysis { difficultyReason: string; weightedScore: number; distribution: { hard: { count: number; percentage: number }; medium: { count: number; percentage: number }; easy: { count: number; percentage: number }; }; export interface PerformanceCategory { status: WordPerformanceStatus; export interface SimpleTrend { confidence: number; export interface WordPerformanceTrends { speedTrend: SimpleTrend; analysisperiod: number; }

================================================================================

NOME FILE: entities\Statistics.types.ts

import { TestResult } from "./Test.types"; import { WordPerformanceAnalysis, GlobalPerformanceStats, } from "./Performance.types"; import { Word, WordCategory } from "./Word.types"; export interface Statistics { totalWords: number; incorrectAnswers: number; averageScore: number; timeSpent: number; dailyProgress: Record<string, DailyProgressAggregated>; lastStudyDate: string | null; monthlyStats: Record<string, MonthlyStatsAggregated>; firestoreMetadata?: import("../infrastructure/Firestore.types").FirestoreDocMetadata; } export interface CategoryProgressAggregated { wordStats: { totalWords: number; learnedWords: number; difficultWords: number; }; testStats: { testsIncluding: number; averageTestScore: number; lastTestedAt?: Date; }; lastUpdated: Date; } export interface DailyProgressAggregated { testActivity: { testsCompleted: number; averageScore: number; totalTime: number; averageAccuracy: number; hintsUsed: number; }; derivedMetrics: { studyEfficiency: number; learningVelocity: number; consistency: number; }; } export interface DifficultyStatsAggregated { wordDifficulty: { critical: number; struggling: number; improving: number; consolidated: number; mastered: number; }; export interface MonthlyStatsAggregated { testMetrics: { testsCompleted: number; averageScore: number; averageAccuracy: number; totalTimeSpent: number; bestStreak: number; testDifficultyDistribution: Record<"easy" | "medium" | "hard", number>; }; performanceMetrics: { wordsImproved: number; wordsMastered: number; averageAttempts: number; consistencyScore: number; }; export interface MonthlyInsight { type: "achievement" | "improvement" | "concern" | "milestone"; title: string; description: string; metrics: Record<string, number>; recommendations?: string[]; } export interface AggregatedCalculatedStatistics { performanceAnalytics: { globalPerformanceStats: GlobalPerformanceStats; wordLevelInsights: WordPerformanceAnalysis[]; learningTrends: LearningTrendsAnalysis; }; predictiveAnalytics: { nextSessionPredictions: NextSessionPrediction; masteryTimeline: MasteryTimelinePrediction; recommendedActions: RecommendedAction[]; }; export interface LearningTrendsAnalysis { accuracyTrend: TrendAnalysis; speedTrend: TrendAnalysis; consistencyTrend: TrendAnalysis; vocabularyGrowthTrend: TrendAnalysis; difficultyHandlingTrend: TrendAnalysis; } export interface TrendAnalysis { direction: "improving" | "stable" | "declining"; rate: number; confidence: number; periodAnalyzed: number; significantChanges: Date[]; } export interface WeeklyProgressAnalysis { currentWeek: DailyProgressAggregated[]; previousWeek: DailyProgressAggregated[]; weekOverWeekChange: { testsChange: number; accuracyChange: number; timeChange: number; wordsStudiedChange: number; }; weeklyConsistency: number; recommendedSchedule: StudyScheduleRecommendation[]; } export interface StudyScheduleRecommendation { dayOfWeek: string; recommendedTime: string; suggestedDuration: number; focusAreas: WordCategory[]; reasoning: string; } export interface MonthlyTrendsAnalysis { last3Months: MonthlyStatsAggregated[]; trendDirection: "improving" | "stable" | "declining"; keyMetricChanges: { accuracyChange: number; vocabularyGrowthChange: number; consistencyChange: number; }; seasonalPatterns: SeasonalPattern[]; } export interface SeasonalPattern { period: string; pattern: "high-activity" | "low-activity" | "inconsistent"; metrics: Record<string, number>; recommendations: string[]; } export interface StreakAnalysisData { currentStreak: number; longestStreak: number; streakBreakingPatterns: StreakBreakPattern[]; streakMotivation: StreakMotivationInsight[]; } export interface StreakBreakPattern { commonDay: string; commonDuration: number; recoveryTime: number; triggers: string[]; } export interface StreakMotivationInsight { streakLength: number; motivationLevel: "high" | "medium" | "low"; sustainabilityFactors: string[]; riskFactors: string[]; } export interface NextSessionPrediction { optimalTime: Date; suggestedDuration: number; recommendedWords: string[]; predictedAccuracy: number; challengeLevel: "easy" | "medium" | "hard"; focusAreas: { reviewWords: string[]; newWords: string[]; masteryWords: string[]; }; } export interface MasteryTimelinePrediction { totalWordsToMaster: number; currentMasteryRate: number; estimatedTimeToComplete: number; milestones: MasteryMilestone[]; accelerationOpportunities: AccelerationOpportunity[]; } export interface MasteryMilestone { date: Date; wordsExpectedMastered: number; cumulativeProgress: number; confidence: number; } export interface AccelerationOpportunity { category: WordCategory; potentialTimeReduction: number; recommendedApproach: string; effortRequired: "low" | "medium" | "high"; expectedBoost: number; } export interface RecommendedAction { id: string; priority: "critical" | "high" | "medium" | "low"; type: "review" | "practice" | "new-words" | "consistency" | "challenge"; title: string; description: string; estimatedTime: number; expectedBenefit: string; targetWords?: string[]; deadline?: Date; export interface StatisticsAggregationInput { wordPerformances: WordPerformanceAnalysis[]; aggregationPeriod: { startDate: Date; endDate: Date; granularity: "daily" | "weekly" | "monthly"; }; export interface AggregationConfig { includeAdvancedAnalytics: boolean; includePredictiveAnalytics: boolean; includeRecommendations: boolean; calculationDepth: "fast" | "standard" | "deep"; cacheResults: boolean; } export interface StatisticsAggregationResult { calculatedStatistics: AggregatedCalculatedStatistics; qualityIssues: DataQualityIssue[]; } export interface DataSource { type: "test-results" | "word-performance" | "words" | "user-activity"; recordCount: number; dateRange: { start: Date; end: Date }; completeness: number; lastUpdated: Date; } export interface DataQualityIssue { type: | "missing-data" | "inconsistent-data" | "stale-data" | "incomplete-aggregation"; severity: "low" | "medium" | "high" | "critical"; description: string; affectedMetrics: string[]; recommendation: string; autoFixable: boolean; } export interface ComprehensiveStatisticsExportData { statistics: Statistics; sourceData?: { testResults: TestResult[]; wordPerformances: WordPerformanceAnalysis[]; words: Word[]; };

================================================================================

NOME FILE: entities\Test.types.ts

import { Word } from "./Word.types"; export interface Test { userId: string; state: TestState; startedAt: Date; isSaved: boolean; export interface TestSession { currentQuestion: TestQuestion | null; timeMetrics: TestTimeMetrics; progress: TestProgress; } export interface TestWordPool { usedWords: Word[]; incorrectWords: Word[]; selectionStrategy: WordSelectionStrategy; } export type WordSelectionStrategy = | "sequential" | "random" | "adaptive" | "review-first"; export interface TestQuestion { word: Word; timer: QuestionTimer; isTransitioning: boolean; } export interface QuestionTimer { endedAt?: Date; elapsed: number; isActive: boolean; } export interface QuestionHintState { usedHints: UsedHint[]; cooldownRemaining: number; } export interface AvailableHint { type: HintType; content: string; cost: number; } export interface UsedHint { type: HintType; content: string; usedAt: Date; cost: number; } export type HintType = | "sentence" | "synonym"; export interface TestAnswer { questionId: string; result: AnswerResult; hintsUsed: UsedHint[]; export interface AnswerResult { confidence?: number; } export interface AnswerTiming { cardFlippedAt: Date; totalTime: number; declarationTime: number; } export interface AnswerMetadata { timeOfDay: "morning" | "afternoon" | "evening" | "night"; contextFactors?: string[]; } export interface TestTimeMetrics { averageQuestionTime: number; slowestQuestion: number; speedTrend: SpeedTrend; } export interface TimeDistribution { byDifficulty: Record<string, number>; export interface SpeedTrend { changePercentage: number; export interface TestHintSystem { globalState: HintGlobalState; export interface HintSystemConfig { maxHintsPerQuestion: number; hintCosts: { sentence: number; synonym: number; }; export interface HintGlobalState { hintsRemaining?: number; usagePattern: HintUsagePattern; } export interface HintUsagePattern { preferredType: HintType | "balanced"; export interface HintStatistics { accuracyAfterHint: { sentence: number; synonym: number; overall: number; }; averageTimeWithoutHint: number; } export interface TestProgress { performance: PerformanceMetrics; milestones: ProgressMilestone[]; } export interface BasicProgress { totalQuestions: number; questionsAnswered: number; export interface PerformanceMetrics { correctAnswers: number; currentStreak: number; efficiency: number; export interface ProgressPredictions { predictedFinalAccuracy: number; confidence: number; } export interface ProgressMilestone { id: string; name: string; description: string; achieved: boolean; achievedAt?: Date; progress: number; } export interface TestConfig { wordSelection: WordSelectionConfig; ui: UIConfig; scoring: ScoringConfig; } export interface WordSelectionConfig { categories: string[]; unlearnedOnly: boolean; randomOrder: boolean; export interface TimingConfig { autoAdvance: boolean; wordTimeLimit?: number; showMeaning: boolean; export interface UIConfig { animations: boolean; showDetailedProgress: boolean; export interface ScoringConfig { speedWeight: number; streakBonus: number; export type TestMode = | "normal" | "difficult-only" | "chapter" | "custom" | "review" | "timed" | "endless" | "adaptive"; export type TestState = | "idle" | "ready" | "running" | "paused" | "transitioning" | "completed" | "aborted" | "reviewing"; export type TestAction = | "start" | "pause" | "resume" | "answer" | "skip" | "hint" | "next" | "complete" | "abort" | "reset" | "review"; export interface TestEvent { action: TestAction; payload?: any; timestamp: Date; } export interface TestResult { userId: string; completedSession: TestSession; analytics: TestAnalytics; exportData: TestExportData; } export interface FinalScore { category: ScoreCategory; comparison?: ScoreComparison; } export interface ScoreBreakdown { accuracy: number; speed: number; efficiency: number; consistency: number; bonus: number; penalties: number; } export interface ScoreComparison { improvement: number; trend: "improving" | "stable" | "declining"; percentileRank: number; } export type ScoreCategory = | "excellent" | "good" | "average" | "poor" | "perfect"; export interface TestAnalytics { insights: TestInsight[]; export interface PerformancePatterns { timePatterns: TestTimeMetrics; accuracyPatterns: AccuracyPatterns; hintPatterns: HintStatistics; categoryPatterns: CategoryPerformance[]; } export interface AccuracyPatterns { overallAccuracy: number; accuracyByPosition: number[]; accuracyTrend: SpeedTrend; difficultWordsBias: number; } export interface CategoryPerformance { category: string; accuracy: number; averageTime: number; hintsUsed: number; difficultyRating: number; } export interface TestInsight { type: "strength" | "weakness" | "improvement" | "pattern"; title: string; description: string; impact: "high" | "medium" | "low"; actionable: boolean; data?: any; } export interface TestRecommendation { type: "study" | "practice" | "strategy" | "configuration"; priority: "high" | "medium" | "low"; title: string; description: string; expectedBenefit: string; effort: "easy" | "medium" | "hard"; } export interface TestFeedback { tone: "celebratory" | "encouraging" | "constructive" | "motivational"; color: string; wordsToReview: string[]; } export interface TestExportData { summary: TestSummary; detailedAnswers: TestAnswer[]; analytics: TestAnalytics; exportedAt: Date; format: "json" | "csv" | "pdf"; } export interface TestSummary { testId: string; duration: number; totalQuestions: number; correctAnswers: number; accuracy: number; hintsUsed: number; averageTime: number; score: number; category: ScoreCategory; }

================================================================================

NOME FILE: entities\User.types.ts

export type UserRole = "admin" | "user"; export interface UserPermissions { canViewOwnData: boolean; canEditOwnData: boolean; canManageUsers: boolean; canExportData: boolean; canImportData: boolean; canResetPasswords: boolean; canBlockUsers: boolean; canDeleteUsers: boolean; } export interface AdminOperation { type: | "password_reset" | "block_user" | "unblock_user" | "delete_user" | "export_data" | "import_data"; targetUserId: string; performedBy: string; timestamp: Date; metadata?: Record<string, any>; } export interface UserManagementFilters { role?: UserRole; isActive?: boolean; emailVerified?: boolean; registrationMethod?: "email" | "google"; searchTerm?: string; } export interface UserExportData { profile: User; words: any[]; testHistory: any[]; statistics: any[]; exportedAt: Date; exportedBy: string; } export interface User { fullName?: string; targetLanguage?: string; learningGoal?: LearningGoal; weeklyTestTarget?: number; profileCreatedAt?: Date; totalActiveDays?: number; longestStreak?: number; totalWordsLearned?: number; totalStudyTime?: number; progressLevel?: number; statsUpdatedAt?: Date; lastUpdated?: Date; export interface UserProfile { fullName?: string; targetLanguage: string; learningGoal?: LearningGoal; weeklyTestTarget: number; createdAt: Date; export type EnglishLevel = | "A1" | "A2" | "B1" | "B2" | "C1" | "C2"; export type LearningGoal = | "academic" | "business" | "travel" | "general" | "exam" | "conversation"; export interface UserPreferences { theme: AppTheme; testPreferences: TestPreferences; audioPreferences: AudioPreferences; updatedAt: Date; } export type AppTheme = "light" | "dark" | "auto"; export type InterfaceLanguage = "it" | "en" | "auto"; export interface TestPreferences { defaultWordsPerTest: number; autoAdvanceDelay: number; showTimer: boolean; export interface NotificationPreferences { emailEnabled: boolean; reminderTime: string; progressNotifications: boolean; export interface AudioPreferences { volume: number; playbackSpeed: number; export interface DisplayPreferences { highContrast: boolean; compactView: boolean; export type FontSize = "small" | "medium" | "large" | "extra-large"; export interface UserStats { totalActiveDays: number; longestStreak: number; totalWordsLearned: number; totalStudyTime: number; progressLevel: number; updatedAt: Date; } export interface UserMilestone { name: string; icon: string; progress: number; completedAt?: Date; export interface AuthState { isLoading: boolean; error: AuthError | null; tokenRefreshedAt?: Date; } export interface AuthError { message: string; details?: Record<string, any>; export type AuthErrorType = | "network-error" | "invalid-credentials" | "user-not-found" | "email-already-in-use" | "weak-password" | "email-not-verified" | "account-disabled" | "token-expired" | "permission-denied" | "configuration-error" | "unknown"; export interface SignUpInput { email: string; password: string; displayName?: string; acceptTerms: boolean; preferredLanguage?: InterfaceLanguage; } export interface SignInInput { email: string; password: string; rememberMe?: boolean; } export interface ResetPasswordInput { email: string; } export interface UpdateProfileInput { displayName?: string; photoURL?: string; currentPassword?: string; newPassword?: string; } export interface AuthOperationResult { user?: User; requiredAction?: "verify-email" | "complete-profile" | "change-password"; export interface UserSession { userId: string; lastActivityAt: Date; activities: SessionActivity[]; isActive: boolean; } export interface SessionActivity { timestamp: Date; duration?: number; }

================================================================================

NOME FILE: entities\Word.types.ts

export const WORD_CATEGORIES = [ "VERBI_BASE", "VERBI_MOVIMENTO", "VERBI_AZIONE_QUOTIDIANA", "VERBI_COMUNICAZIONE", "VERBI_PENSIERO", "VERBI_SENTIMENTI", "VERBI_IRREGOLARI_COMUNI", "VERBI_IRREGOLARI_DIFFICILI", "VERBI_MODALI", "VERBI_FRASALI", "CORPO_UMANO", "FAMIGLIA_PARENTELA", "CASA_STANZE", "CASA_OGGETTI", "CIBO_BEVANDE", "ANIMALI_DOMESTICI", "ANIMALI_SELVATICI", "VESTITI_ACCESSORI", "TRASPORTI", "NATURA_AMBIENTE", "TEMPO_ATMOSFERICO", "CITTA_LUOGHI", "AGGETTIVI_BASE", "COLORI", "FORME_DIMENSIONI", "DESCRIZIONI_FISICHE", "PERSONALITA_CARATTERE", "STATI_EMOTIVI", "QUALITA_OGGETTI", "QUANTITA_MISURE", "SCUOLA_EDUCAZIONE", "LAVORO_PROFESSIONI", "TECNOLOGIA_DIGITALE", "SPORT_ATTIVITA", "MUSICA_ARTE", "SHOPPING_DENARO", "VIAGGIO_VACANZE", "SALUTE_MEDICINA", "CIBO_RISTORANTE", "TEMPO_CALENDARIO", "PREPOSIZIONI", "CONGIUNZIONI", "AVVERBI_TEMPO", "AVVERBI_MODO", "AVVERBI_LUOGO", "PRONOMI_DETERMINANTI", "PAROLE_INTERROGATIVE", "NUMERI_MATEMATICA", "FORMALE_BUSINESS", "ACCADEMICO_SCIENTIFICO", "IDIOMI_ESPRESSIONI", "SLANG_INFORMALE", "SINONIMI_RAFFINATI", "TERMINI_TECNICI", "SALUTI_PRESENTAZIONI", "RICHIESTE_PERMESSI", "EMERGENZE_PROBLEMI", "DIREZIONI_ORIENTAMENTO", "HOTEL_ALLOGGIO", "AEROPORTO_VOLO", "BANCA_SERVIZI", "MEDICO_FARMACIA", ] as const; export type WordCategory = (typeof WORD_CATEGORIES)[number]; export interface WordCategoryMetadata { icon: string; bgGradient: string; } export interface WordChapter { name: string; order?: number; } export interface Word { english: string; group?: WordCategory | string; sentences?: string[]; synonyms?: string[]; learned: boolean; createdAt: Date; firestoreMetadata?: import("../infrastructure/Firestore.types").FirestoreDocMetadata; } export interface WordFilters { chapter?: string | null; difficult?: boolean | null; createdAfter?: Date; export type WordSortOption = | "english-asc" | "english-desc" | "italian-asc" | "italian-desc" | "createdAt-asc" | "createdAt-desc" | "learned-first" | "difficult-first" | "chapter-asc"; export interface WordSearchConfig { sortBy: WordSortOption; currentPage: number; } export interface WordValidationRules { englishMaxLength: number; italianMinLength: number; sentenceMaxLength: number; notesMaxLength: number; maxSynonyms: number; maxAntonyms: number; validCategories: readonly string[]; } export interface WordValidationResult { fieldErrors: Partial<Record<keyof Word, string>>; warnings: string[]; } export const WORD_VALIDATION_SCHEMA: WordValidationRules = { englishMinLength: 2, englishMaxLength: 100, englishPattern: /^[a-zA-ZÀ-ÿ\s'-]+$/, // da EnhancedAddWordForm: /^[a-zA-ZÀ-ÿ\s'-]+$/ italianMinLength: 2, italianMaxLength: 100, sentenceMaxLength: 500, maxSentences: 5, notesMaxLength: 1000, synonymMaxLength: 50, maxSynonyms: 10, antonymMaxLength: 50, maxAntonyms: 10, synonymAntonymPattern: /^[a-zA-ZÀ-ÿ\s'-]+$/, // Stesso pattern delle parole validCategories: WORD_CATEGORIES, }; export interface WordStats { learned: number; difficult: number; byCategory: Record<string, number>; completionPercentage: number; } export interface ChapterStats { totalWords: number; difficultWords: number; lastWordAdded?: Date; } export interface CreateWordInput { english: string; italian: string; group?: string; chapter?: string; sentences?: string[]; notes?: string; synonyms?: string[]; antonyms?: string[]; difficult?: boolean; } export interface UpdateWordInput extends Partial<CreateWordInput> { id: string; learned?: boolean; } export interface ImportWordsInput { words: CreateWordInput[]; mergeStrategy: "replace" | "merge" | "skip-duplicates"; validateWords: boolean; } export interface ImportWordsResult { imported: number; skipped: number; errors: string[]; duplicates: number; invalidWords: Array<{ word: CreateWordInput; errors: string[]; }>; } export interface WordExportConfig { includeDifficult: boolean; includeMetadata: boolean; export interface WordExportData { exportDate: string; exportConfig: WordExportConfig; } export const EXPANDED_CATEGORY_STYLES: Record<string, WordCategoryMetadata> = { VERBI_BASE: { color: "from-red-400 via-red-500 to-red-600", icon: "⚡", bgColor: "bg-red-500", bgGradient: "bg-gradient-to-br from-red-500 to-orange-600", }, VERBI_MOVIMENTO: { color: "from-orange-400 via-orange-500 to-red-500", icon: "🏃", bgColor: "bg-orange-500", bgGradient: "bg-gradient-to-br from-orange-500 to-red-500", }, VERBI_AZIONE_QUOTIDIANA: { color: "from-amber-400 via-orange-500 to-red-500", icon: "🔄", bgColor: "bg-amber-500", bgGradient: "bg-gradient-to-br from-amber-500 to-orange-500", }, VERBI_COMUNICAZIONE: { color: "from-red-500 via-pink-500 to-purple-500", icon: "💬", bgColor: "bg-red-500", bgGradient: "bg-gradient-to-br from-red-500 to-pink-500", }, VERBI_PENSIERO: { color: "from-purple-400 via-purple-500 to-red-500", icon: "🧠", bgColor: "bg-purple-500", bgGradient: "bg-gradient-to-br from-purple-500 to-red-500", }, VERBI_SENTIMENTI: { color: "from-pink-400 via-red-400 to-red-500", icon: "❤️", bgColor: "bg-pink-500", bgGradient: "bg-gradient-to-br from-pink-500 to-red-500", }, VERBI_IRREGOLARI_COMUNI: { color: "from-red-500 via-red-600 to-red-700", icon: "🔄", bgColor: "bg-red-600", bgGradient: "bg-gradient-to-br from-red-600 to-pink-600", }, VERBI_IRREGOLARI_DIFFICILI: { color: "from-red-600 via-red-700 to-red-800", icon: "⚠️", bgColor: "bg-red-700", bgGradient: "bg-gradient-to-br from-red-700 to-red-900", }, VERBI_MODALI: { color: "from-indigo-400 via-red-500 to-red-600", icon: "🎭", bgColor: "bg-indigo-500", bgGradient: "bg-gradient-to-br from-indigo-500 to-red-500", }, VERBI_FRASALI: { color: "from-yellow-400 via-orange-500 to-red-500", icon: "🔗", bgColor: "bg-yellow-500", bgGradient: "bg-gradient-to-br from-yellow-500 to-red-500", }, CORPO_UMANO: { color: "from-blue-400 via-blue-500 to-blue-600", icon: "👤", bgColor: "bg-blue-500", bgGradient: "bg-gradient-to-br from-blue-500 to-indigo-600", }, FAMIGLIA_PARENTELA: { color: "from-pink-300 via-pink-400 to-blue-500", icon: "👨‍👩‍👧‍👦", bgColor: "bg-pink-400", bgGradient: "bg-gradient-to-br from-pink-400 to-blue-500", }, CASA_STANZE: { color: "from-amber-400 via-yellow-500 to-blue-500", icon: "🏠", bgColor: "bg-amber-500", bgGradient: "bg-gradient-to-br from-amber-500 to-blue-500", }, CASA_OGGETTI: { color: "from-brown-400 via-amber-500 to-blue-500", icon: "🪑", bgColor: "bg-amber-600", bgGradient: "bg-gradient-to-br from-amber-600 to-blue-500", }, CIBO_BEVANDE: { color: "from-green-400 via-yellow-500 to-blue-500", icon: "🍎", bgColor: "bg-green-500", bgGradient: "bg-gradient-to-br from-green-500 to-blue-500", }, ANIMALI_DOMESTICI: { color: "from-orange-400 via-amber-500 to-blue-500", icon: "🐕", bgColor: "bg-orange-500", bgGradient: "bg-gradient-to-br from-orange-500 to-blue-500", }, ANIMALI_SELVATICI: { color: "from-green-400 via-emerald-500 to-blue-600", icon: "🦁", bgColor: "bg-emerald-500", bgGradient: "bg-gradient-to-br from-emerald-500 to-blue-600", }, VESTITI_ACCESSORI: { color: "from-purple-400 via-pink-500 to-blue-500", icon: "👕", bgColor: "bg-purple-500", bgGradient: "bg-gradient-to-br from-purple-500 to-blue-500", }, TRASPORTI: { color: "from-blue-400 via-cyan-500 to-blue-600", icon: "🚗", bgColor: "bg-cyan-500", bgGradient: "bg-gradient-to-br from-cyan-500 to-blue-600", }, NATURA_AMBIENTE: { color: "from-green-400 via-emerald-500 to-blue-500", icon: "🌳", bgColor: "bg-emerald-500", bgGradient: "bg-gradient-to-br from-emerald-500 to-blue-500", }, TEMPO_ATMOSFERICO: { color: "from-sky-400 via-blue-500 to-indigo-600", icon: "☀️", bgColor: "bg-sky-500", bgGradient: "bg-gradient-to-br from-sky-500 to-blue-600", }, CITTA_LUOGHI: { color: "from-slate-400 via-blue-500 to-indigo-600", icon: "🏙️", bgColor: "bg-slate-500", bgGradient: "bg-gradient-to-br from-slate-500 to-blue-600", }, AGGETTIVI_BASE: { color: "from-green-400 via-green-500 to-green-600", icon: "🎨", bgColor: "bg-green-500", bgGradient: "bg-gradient-to-br from-green-500 to-emerald-600", }, COLORI: { color: "from-rainbow-400 via-pink-500 to-purple-600", icon: "🌈", bgColor: "bg-pink-500", bgGradient: "bg-gradient-to-br from-pink-400 via-purple-500 to-blue-500", }, FORME_DIMENSIONI: { color: "from-indigo-400 via-blue-500 to-green-600", icon: "📐", bgColor: "bg-indigo-500", bgGradient: "bg-gradient-to-br from-indigo-500 to-green-600", }, DESCRIZIONI_FISICHE: { color: "from-teal-400 via-teal-500 to-green-600", icon: "👤", bgColor: "bg-teal-500", bgGradient: "bg-gradient-to-br from-teal-500 to-green-600", }, PERSONALITA_CARATTERE: { color: "from-purple-400 via-pink-500 to-green-600", icon: "🎭", bgColor: "bg-purple-500", bgGradient: "bg-gradient-to-br from-purple-500 to-green-600", }, STATI_EMOTIVI: { color: "from-yellow-400 via-pink-500 to-green-600", icon: "😊", bgColor: "bg-yellow-500", bgGradient: "bg-gradient-to-br from-yellow-500 to-green-600", }, QUALITA_OGGETTI: { color: "from-gray-400 via-slate-500 to-green-600", icon: "⭐", bgColor: "bg-slate-500", bgGradient: "bg-gradient-to-br from-slate-500 to-green-600", }, QUANTITA_MISURE: { color: "from-blue-400 via-indigo-500 to-green-600", icon: "🔢", bgColor: "bg-indigo-500", bgGradient: "bg-gradient-to-br from-indigo-500 to-green-600", }, SCUOLA_EDUCAZIONE: { color: "from-yellow-400 via-amber-500 to-orange-600", icon: "🎓", bgColor: "bg-yellow-500", bgGradient: "bg-gradient-to-br from-yellow-500 to-orange-600", }, LAVORO_PROFESSIONI: { color: "from-indigo-400 via-indigo-500 to-blue-600", icon: "💼", bgColor: "bg-indigo-500", bgGradient: "bg-gradient-to-br from-indigo-500 to-blue-600", }, TECNOLOGIA_DIGITALE: { color: "from-cyan-400 via-blue-500 to-purple-600", icon: "💻", bgColor: "bg-cyan-500", bgGradient: "bg-gradient-to-br from-cyan-500 to-purple-600", }, SPORT_ATTIVITA: { color: "from-orange-400 via-red-500 to-pink-600", icon: "⚽", bgColor: "bg-orange-500", bgGradient: "bg-gradient-to-br from-orange-500 to-red-600", }, MUSICA_ARTE: { color: "from-purple-400 via-pink-500 to-rose-600", icon: "🎵", bgColor: "bg-purple-500", bgGradient: "bg-gradient-to-br from-purple-500 to-pink-600", }, SHOPPING_DENARO: { color: "from-green-400 via-emerald-500 to-teal-600", icon: "💰", bgColor: "bg-emerald-500", bgGradient: "bg-gradient-to-br from-emerald-500 to-teal-600", }, VIAGGIO_VACANZE: { color: "from-sky-400 via-cyan-500 to-blue-600", icon: "✈️", bgColor: "bg-sky-500", bgGradient: "bg-gradient-to-br from-sky-500 to-blue-600", }, SALUTE_MEDICINA: { color: "from-red-400 via-pink-500 to-rose-600", icon: "🏥", bgColor: "bg-red-500", bgGradient: "bg-gradient-to-br from-red-500 to-pink-600", }, CIBO_RISTORANTE: { color: "from-amber-400 via-orange-500 to-red-600", icon: "🍽️", bgColor: "bg-amber-500", bgGradient: "bg-gradient-to-br from-amber-500 to-red-600", }, TEMPO_CALENDARIO: { color: "from-indigo-400 via-purple-500 to-pink-600", icon: "📅", bgColor: "bg-indigo-500", bgGradient: "bg-gradient-to-br from-indigo-500 to-purple-600", }, PREPOSIZIONI: { color: "from-slate-400 via-gray-500 to-zinc-600", icon: "🔗", bgColor: "bg-slate-500", bgGradient: "bg-gradient-to-br from-slate-500 to-gray-600", }, CONGIUNZIONI: { color: "from-gray-400 via-slate-500 to-zinc-600", icon: "🔀", bgColor: "bg-gray-500", bgGradient: "bg-gradient-to-br from-gray-500 to-slate-600", }, AVVERBI_TEMPO: { color: "from-violet-400 via-purple-500 to-indigo-600", icon: "⏰", bgColor: "bg-violet-500", bgGradient: "bg-gradient-to-br from-violet-500 to-indigo-600", }, AVVERBI_MODO: { color: "from-emerald-400 via-teal-500 to-cyan-600", icon: "🎯", bgColor: "bg-emerald-500", bgGradient: "bg-gradient-to-br from-emerald-500 to-cyan-600", }, AVVERBI_LUOGO: { color: "from-blue-400 via-indigo-500 to-purple-600", icon: "📍", bgColor: "bg-blue-500", bgGradient: "bg-gradient-to-br from-blue-500 to-purple-600", }, PRONOMI_DETERMINANTI: { color: "from-stone-400 via-neutral-500 to-gray-600", icon: "👆", bgColor: "bg-stone-500", bgGradient: "bg-gradient-to-br from-stone-500 to-neutral-600", }, PAROLE_INTERROGATIVE: { color: "from-amber-400 via-yellow-500 to-orange-600", icon: "❓", bgColor: "bg-amber-500", bgGradient: "bg-gradient-to-br from-amber-500 to-orange-600", }, NUMERI_MATEMATICA: { color: "from-blue-400 via-cyan-500 to-teal-600", icon: "🔢", bgColor: "bg-blue-500", bgGradient: "bg-gradient-to-br from-blue-500 to-teal-600", }, FORMALE_BUSINESS: { color: "from-gray-600 via-slate-700 to-zinc-800", icon: "🏢", bgColor: "bg-gray-700", bgGradient: "bg-gradient-to-br from-gray-700 to-slate-800", }, ACCADEMICO_SCIENTIFICO: { color: "from-indigo-600 via-blue-700 to-purple-800", icon: "🔬", bgColor: "bg-indigo-700", bgGradient: "bg-gradient-to-br from-indigo-700 to-purple-800", }, IDIOMI_ESPRESSIONI: { color: "from-pink-500 via-rose-600 to-red-700", icon: "🎭", bgColor: "bg-pink-600", bgGradient: "bg-gradient-to-br from-pink-600 to-red-700", }, SLANG_INFORMALE: { color: "from-lime-400 via-green-500 to-emerald-600", icon: "😎", bgColor: "bg-lime-500", bgGradient: "bg-gradient-to-br from-lime-500 to-emerald-600", }, SINONIMI_RAFFINATI: { color: "from-violet-500 via-purple-600 to-indigo-700", icon: "✨", bgColor: "bg-violet-600", bgGradient: "bg-gradient-to-br from-violet-600 to-indigo-700", }, TERMINI_TECNICI: { color: "from-cyan-500 via-blue-600 to-indigo-700", icon: "⚙️", bgColor: "bg-cyan-600", bgGradient: "bg-gradient-to-br from-cyan-600 to-indigo-700", }, SALUTI_PRESENTAZIONI: { color: "from-yellow-400 via-orange-500 to-pink-600", icon: "👋", bgColor: "bg-yellow-500", bgGradient: "bg-gradient-to-br from-yellow-500 to-pink-600", }, RICHIESTE_PERMESSI: { color: "from-green-400 via-teal-500 to-blue-600", icon: "🙏", bgColor: "bg-green-500", bgGradient: "bg-gradient-to-br from-green-500 to-blue-600", }, EMERGENZE_PROBLEMI: { color: "from-red-500 via-orange-600 to-yellow-600", icon: "🚨", bgColor: "bg-red-600", bgGradient: "bg-gradient-to-br from-red-600 to-orange-600", }, DIREZIONI_ORIENTAMENTO: { color: "from-blue-400 via-cyan-500 to-emerald-600", icon: "🧭", bgColor: "bg-blue-500", bgGradient: "bg-gradient-to-br from-blue-500 to-emerald-600", }, HOTEL_ALLOGGIO: { color: "from-purple-400 via-indigo-500 to-blue-600", icon: "🏨", bgColor: "bg-purple-500", bgGradient: "bg-gradient-to-br from-purple-500 to-blue-600", }, AEROPORTO_VOLO: { color: "from-sky-400 via-blue-500 to-indigo-600", icon: "✈️", bgColor: "bg-sky-500", bgGradient: "bg-gradient-to-br from-sky-500 to-indigo-600", }, BANCA_SERVIZI: { color: "from-emerald-400 via-green-500 to-teal-600", icon: "🏦", bgColor: "bg-emerald-500", bgGradient: "bg-gradient-to-br from-emerald-500 to-teal-600", }, MEDICO_FARMACIA: { color: "from-red-400 via-rose-500 to-pink-600", icon: "💊", bgColor: "bg-red-500", bgGradient: "bg-gradient-to-br from-red-500 to-pink-600", }, DEFAULT: { color: "from-blue-400 via-blue-500 to-blue-600", icon: "📚", bgColor: "bg-blue-500", bgGradient: "bg-gradient-to-br from-blue-500 to-cyan-600", }, };

================================================================================

NOME FILE: infrastructure\Auth.types.ts

export interface AuthUser { email: string | null; photoURL: string | null; emailVerified: boolean; metadata: AuthUserMetadata; customClaims?: Record<string, any>; refreshToken?: string; } export interface AuthUserMetadata { lastSignInTime: Date; export interface AuthProviderData { uid: string; displayName: string | null; phoneNumber: string | null; } export interface AuthConnectionState { lastConnectedAt?: Date; reconnectAttempts: number; export interface AuthSession { startedAt: Date; duration: number; userAgent?: string; isActive: boolean; export interface AuthDeviceInfo { os: string; browserVersion: string; timezone: string; export interface AuthConfig { persistence: AuthPersistence; securityConfig: AuthSecurityConfig; redirectUrls?: AuthRedirectUrls; export type AuthProvider = "email" | "google" | "anonymous"; export type AuthPersistence = | "local" | "session" | "none"; export interface AuthTokenConfig { refreshInterval: number; refreshBuffer: number; export interface AuthSecurityConfig { passwordPolicy: PasswordPolicy; maxLoginAttempts: number; export interface PasswordPolicy { requireUppercase: boolean; requireNumbers: boolean; export interface AuthUIConfig { appLogo?: string; defaultLanguage: string; privacyPolicyUrl?: string; } export interface AuthRedirectUrls { signOut: string; passwordReset: string; export interface AuthEmailConfig { passwordResetTemplate: EmailTemplate; senderEmail: string; export interface EmailTemplate { bodyHtml: string; supportedVariables: string[]; } export interface AuthError { message: string; operation: AuthOperation; timestamp: Date; export type AuthErrorCode = | "permission-denied" | "user-not-found" | "wrong-password" | "email-already-in-use" | "weak-password" | "invalid-email" | "user-disabled" | "too-many-requests" | "network-request-failed" | "internal-error" | "invalid-credential" | "requires-recent-login"; export type AuthErrorType = | "network-error" | "invalid-credentials" | "user-management" | "permission-denied" | "rate-limited" | "configuration-error" | "unknown"; export type AuthOperation = | "sign-in" | "sign-up" | "sign-out" | "password-reset" | "email-verification" | "profile-update" | "delete-account" | "refresh-token" | "link-provider" | "unlink-provider"; export interface SignInWithEmailInput { email: string; password: string; rememberMe?: boolean; } export interface SignUpWithEmailInput { email: string; password: string; displayName?: string; acceptTerms: boolean; } export interface SignInWithProviderInput { provider: AuthProvider; scopes?: string[]; customParameters?: Record<string, any>; } export interface ResetPasswordInput { email: string; } export interface UpdateProfileInput { displayName?: string; photoURL?: string; } export interface UpdateEmailInput { newEmail: string; currentPassword: string; } export interface UpdatePasswordInput { currentPassword: string; newPassword: string; } export interface ReauthenticateInput { password?: string; provider?: AuthProvider; } export interface AuthOperationResult { user?: AuthUser; requiredAction?: AuthRequiredAction; metadata: AuthOperationMetadata; } export interface AuthOperationMetadata { duration: number; ipAddress?: string; } export type AuthRequiredAction = | "verify-email" | "complete-profile" | "change-password" | "setup-2fa" | "accept-terms" | "reauthenticate"; export interface TwoFactorAuthConfig { supportedMethods: TwoFactorMethod[]; gracePeriod: number; } export type TwoFactorMethod = | "sms" | "email" | "authenticator" | "backup-codes"; export interface AuthToken { expiresAt: Date; refreshToken?: string; } export interface TokenClaims { email?: string; firebase?: { identities?: Record<string, string[]>; sign_in_provider?: string; }; export interface AuthAnalytics { behaviorPatterns: AuthBehaviorPatterns; deviceUsage: DeviceUsage[]; } export interface LoginStatistics { loginsLast30Days: number; averageSessionsPerDay: number; export interface AuthBehaviorPatterns { preferredDevices: string[]; usageConsistency: number; } export interface SecurityEvent { type: SecurityEventType; description: string; metadata: Record<string, any>; } export type SecurityEventType = | "login-success" | "login-failure" | "password-reset" | "email-change" | "suspicious-activity" | "device-change" | "location-change" | "account-locked" | "account-disabled"; export interface DeviceUsage { deviceInfo: AuthDeviceInfo; lastUsed: Date; trusted: boolean; }

================================================================================

NOME FILE: infrastructure\Configuration.types.ts

import { ScoreCategory, TestMode, AuthProvider, AuthPersistence, AppTheme, InterfaceLanguage, FontSize, } from "../index"; export interface AppMetadata { readonly name: string; readonly version: string; readonly description: string; readonly environment: "development" | "production" | "test"; readonly buildDate?: Date; readonly commitHash?: string; } export interface AIConfiguration { baseUrl: string; maxRetries: number; enabled: boolean; rateLimiting: { maxRequestsPerMinute: number; burstLimit: number; }; export interface TestConfiguration { autoAdvanceDelay: number; maxHintsPerWord: number; defaultModes: TestMode[]; timer: { showByDefault: boolean; warningAtSeconds: number; criticalAtSeconds: number; }; } export interface StatisticsConfiguration { maxHistorySize: number; maxRecentTests: number; analytics: { retentionDays: number; aggregationIntervals: ("daily" | "weekly" | "monthly")[]; enablePredictions: boolean; }; } export interface StorageConfiguration { collections: { words: string; users: string; tests: string; statistics: string; performance: string; }; sync: { enableOfflineMode: boolean; syncInterval: number; maxPendingOperations: number; retryAttempts: number; }; } export interface WordConfiguration { requiredFields: (keyof import("../entities/Word.types").CreateWordInput)[]; optionalFields: (keyof import("../entities/Word.types").CreateWordInput)[]; aiAssistance: { enableSuggestions: boolean; enableValidation: boolean; enableTranslation: boolean; maxSuggestionsPerRequest: number; }; } export interface UIConfiguration { notifications: { defaultDuration: number; maxVisible: number; positions: ("top-right" | "top-left" | "bottom-right" | "bottom-left")[]; }; layout: { maxContentWidth: number; sidebarWidth: number; headerHeight: number; breakpoints: { mobile: number; tablet: number; desktop: number; }; }; export interface AuthConfiguration { persistence: AuthPersistence; security: { requireEmailVerification: boolean; passwordMinLength: number; enableTwoFactor: boolean; maxLoginAttempts: number; lockoutDuration: number; }; export interface ConfigurationStatus { isValid: boolean; environment: AppMetadata["environment"]; aiConfigured: boolean; features: { aiEnabled: boolean; mockMode: boolean; offlineMode: boolean; authEnabled: boolean; }; buildInfo: { version: string; buildDate: Date; commitHash: string; }; } export interface ConfigurationValidation { isValid: boolean; issues: string[]; warnings: string[]; } export type EnvVarParser<T> = (value: string) => T; export interface EnvVarGetter { <T = string>(key: string, defaultValue: T, parser?: EnvVarParser<T>): T; } export interface ApplicationConfiguration { readonly app: AppMetadata; readonly ai: AIConfiguration; readonly test: TestConfiguration; readonly stats: StatisticsConfiguration; readonly storage: StorageConfiguration; readonly word: WordConfiguration; readonly ui: UIConfiguration; readonly auth: AuthConfiguration; } export interface MessagesConfiguration { readonly errors: Record<string, string | ((...args: any[]) => string)>; readonly success: Record<string, string | ((...args: any[]) => string)>; readonly info: Record<string, string>; readonly warnings: Record<string, string>; } export interface FeatureFlags { readonly aiAssistance: boolean; readonly advancedStats: boolean; readonly offlineMode: boolean; readonly darkMode: boolean; readonly experimentalFeatures: boolean; readonly betaFeatures: boolean; } export type DeepPartial<T> = { [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]; }; export type ConfigurationOverride = DeepPartial<ApplicationConfiguration>; export interface EnvironmentConfiguration { development: ConfigurationOverride; production: ConfigurationOverride; test: ConfigurationOverride; }

================================================================================

NOME FILE: infrastructure\Firestore.types.ts

export interface FirestoreDoc<T = any> { data: T; path: string; export interface FirestoreDocMetadata { createdAt: Date; version: number; lastUpdatedOnDevice?: string; deletedAt?: Date; custom?: Record<string, any>; } export interface FirestoreCollection<T = any> { path: string; metadata: FirestoreCollectionMetadata; export interface FirestoreCollectionMetadata { estimatedSize: number; lastDocModified?: Date; activeIndexes?: string[]; } export interface FirestoreQuery<T = any> { where?: WhereClause[]; limit?: number; startAfter?: any; includeDeleted?: boolean; export interface WhereClause { operator: FirestoreOperator; logicalOperator?: "AND" | "OR"; } export type FirestoreOperator = | "==" | "!=" | "<" | "<=" | ">" | ">=" | "array-contains" | "array-contains-any" | "in" | "not-in"; export interface OrderByClause { direction: "asc" | "desc"; } export interface FirestoreQueryResult<T = any> { totalCount: number; queryMetadata: QueryExecutionMetadata; nextPageCursor?: any; export interface QueryExecutionMetadata { fromCache: boolean; executedAt: Date; indexesUsed?: string[]; } export interface FirestoreListener<T = any> { type: ListenerType; onDataChange: (data: FirestoreListenerData<T>) => void; state: ListenerState; metadata: ListenerMetadata; } export type ListenerType = | "document" | "collection" | "query" | "subcollection"; export interface ListenerTarget { path: string; parentDocId?: string; } export type ListenerState = | "connecting" | "connected" | "disconnected" | "error" | "disposed"; export interface ListenerConfig { source: "default" | "server" | "cache"; retryTimeout: number; debounceMs?: number; } export interface ListenerMetadata { lastDataReceived?: Date; totalChangesReceived: number; averageLatency?: number; } export interface FirestoreListenerData<T = any> { changedDocs: FirestoreDoc<T>[]; changeMetadata: ChangeMetadata; } export type ChangeType = | "added" | "modified" | "removed" | "metadata-only" | "initial-load"; export interface ChangeMetadata { hasPendingWrites: boolean; source: "local" | "server" | "cache"; export interface FirestoreError { message: string; operation: FirestoreOperation; query?: FirestoreQuery; resolution?: string; export type FirestoreErrorCode = | "permission-denied" | "not-found" | "already-exists" | "resource-exhausted" | "failed-precondition" | "aborted" | "out-of-range" | "unimplemented" | "internal" | "unavailable" | "data-loss" | "unauthenticated" | "network-error" | "timeout" | "cancelled" | "unknown"; export type FirestoreOperation = | "create" | "read" | "update" | "delete" | "query" | "listen" | "batch" | "transaction"; export interface FirestoreBatch { operations: BatchOperation[]; createdAt: Date; export interface BatchOperation { path: string; preconditions?: Precondition[]; } export interface Precondition { value?: any; } export interface FirestoreOperationResult<T = any> { doc?: FirestoreDoc<T>; error?: FirestoreError; warnings?: string[]; } export interface OperationMetadata { completedAt: Date; fromCache: boolean; bytesTransferred?: number; export interface FirestoreConnectionState { lastOnlineAt?: Date; syncing: boolean; syncErrors: FirestoreError[]; } export interface PendingOperation { type: FirestoreOperation; data?: any; attempts: number; export interface FirestoreSyncConfig { autoSyncInterval: number; maxPendingOps: number; enablePersistence: boolean;

================================================================================


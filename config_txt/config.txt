NOME FILE: appConfig.js

const getEnvVar = (key, defaultValue = undefined) => { const value = process.env[key]; if (value === "true") return true; if (value === "false") return false; if (value && !isNaN(value) && !isNaN(parseFloat(value))) { return parseFloat(value); } return value || defaultValue; }; export const AppConfig = { app: { name: "Vocabulary Master", version: "2.0.0", description: "La tua app intelligente per imparare l'inglese", environment: getEnvVar("REACT_APP_ENVIRONMENT", "development"), }, ai: { apiKey: getEnvVar("REACT_APP_GEMINI_API_KEY"), baseUrl: getEnvVar( "REACT_APP_GEMINI_API_URL", "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent" ), timeout: getEnvVar("REACT_APP_AI_TIMEOUT", 15000), maxRetries: getEnvVar("REACT_APP_AI_MAX_RETRIES", 3), retryDelay: getEnvVar("REACT_APP_AI_RETRY_DELAY", 1000), enabled: getEnvVar("REACT_APP_ENABLE_AI_FEATURES", true), mockResponses: getEnvVar("REACT_APP_MOCK_AI_RESPONSES", false), }, test: { warningThresholds: { slow: 25, verySlow: 40, }, autoAdvanceDelay: 1500, hintCooldown: 3000, maxHintsPerWord: 1, scoring: { excellent: 80, good: 60, victory: 80, }, }, stats: { performance: { excellent: 90, good: 75, average: 60, needsWork: 40, }, maxHistorySize: 1000, maxRecentTests: 20, charts: { maxTimelinePoints: 20, defaultChartHeight: 300, }, }, word: { maxWordLength: 100, maxTranslationLength: 200, maxNotesLength: 1000, maxSentenceLength: 300, maxChapterLength: 20, requiredFields: ["english", "italian"], optionalFields: [ "group", "sentence", "notes", "chapter", "learned", "difficult", ], }, ui: { animations: { fast: 150, normal: 300, slow: 500, cardFlip: 700, }, notifications: { defaultDuration: 3000, maxVisible: 5, }, }, storage: { collections: { words: "words", statistics: "statistics", tests: "tests", performance: "performance", users: "users", }, }, }; export const ERROR_MESSAGES = { network: "Errore di connessione. Controlla la tua connessione internet.", ai: "Servizio AI temporaneamente non disponibile. Riprova più tardi.", aiNotConfigured: "Servizio AI non configurato. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local", storage: "Errore nel salvataggio dei dati. Controlla lo spazio disponibile.", validation: "Dati non validi. Controlla i campi obbligatori.", import: "Errore durante l'importazione. Verifica il formato del file.", export: "Errore durante l'esportazione. Riprova.", generic: "Si è verificato un errore imprevisto.", wordNotFound: "Parola non trovata.", noWordsAvailable: "Nessuna parola disponibile per il test.", }; export const SUCCESS_MESSAGES = { wordAdded: "Parola aggiunta con successo!", wordUpdated: "Parola modificata con successo!", wordDeleted: "Parola eliminata con successo!", testCompleted: "Test completato!", dataExported: "Dati esportati con successo!", dataImported: "Dati importati con successo!", settingsSaved: "Impostazioni salvate!", }; export const isAIAvailable = () => { return AppConfig.ai.enabled && !!AppConfig.ai.apiKey; }; export const getConfigurationStatus = () => { return { isValid: !!AppConfig.ai.apiKey, environment: AppConfig.app.environment, aiConfigured: !!AppConfig.ai.apiKey, features: { aiEnabled: isAIAvailable(), mockMode: AppConfig.ai.mockResponses, }, }; }; export default AppConfig;

================================================================================

NOME FILE: firebase.ts

import { initializeApp, type FirebaseApp } from "firebase/app"; import { getFirestore, connectFirestoreEmulator, enableMultiTabIndexedDbPersistence, type Firestore, } from "firebase/firestore"; import { getAuth, connectAuthEmulator, setPersistence, browserLocalPersistence, type Auth, } from "firebase/auth"; import type { FirestoreCollectionName, FirestoreError, } from "../types/infrastructure/Firestore.types"; interface FirebaseConfig { apiKey: string; authDomain: string; projectId: string; storageBucket: string; messagingSenderId: string; appId: string; } const firebaseConfig: FirebaseConfig = { apiKey: process.env.REACT_APP_FIREBASE_API_KEY!, authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN!, projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID!, storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET!, messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID!, appId: process.env.REACT_APP_FIREBASE_APP_ID!, }; function validateFirebaseConfig(): void { const requiredFields: (keyof FirebaseConfig)[] = [ "apiKey", "authDomain", "projectId", "storageBucket", "messagingSenderId", "appId", ]; const missingFields = requiredFields.filter( (field) => !firebaseConfig[field] ); if (missingFields.length > 0) { throw new Error( `❌ Firebase configuration incomplete. Missing: ${missingFields.join( ", " )}\n` + `Please check your .env file and ensure all REACT_APP_FIREBASE_* variables are set.` ); } console.log("✅ Firebase configuration validated"); } validateFirebaseConfig(); export const firebaseApp: FirebaseApp = initializeApp(firebaseConfig); export const db: Firestore = getFirestore(firebaseApp); export const auth: Auth = getAuth(firebaseApp); async function setupFirestorePersistence(): Promise<boolean> { try { await enableMultiTabIndexedDbPersistence(db); console.log("✅ Firestore offline persistence enabled"); return true; } catch (error: any) { if (error.code === "failed-precondition") { console.warn( "⚠️ Multiple tabs open, persistence can only be enabled in one tab" ); } else if (error.code === "unimplemented") { console.warn("⚠️ Browser doesn't support persistence"); } else { console.warn("⚠️ Failed to enable Firestore persistence:", error); } return false; } } async function setupAuthPersistence(): Promise<boolean> { try { await setPersistence(auth, browserLocalPersistence); console.log("✅ Auth persistence enabled"); return true; } catch (error) { console.warn("⚠️ Failed to enable Auth persistence:", error); return false; } } async function setupDevelopment(): Promise<void> { if (process.env.NODE_ENV === "development") { try { if (process.env.REACT_APP_USE_FIRESTORE_EMULATOR === "true") { connectFirestoreEmulator(db, "localhost", 8080); console.log("🔧 Connected to Firestore Emulator"); } if (process.env.REACT_APP_USE_AUTH_EMULATOR === "true") { connectAuthEmulator(auth, "http://localhost:9099"); console.log("🔧 Connected to Auth Emulator"); } } catch (error) { console.warn( "⚠️ Emulator connection failed (normal if not running):", error ); } } } export interface FirebaseInitResult { success: boolean; firestorePersistence: boolean; authPersistence: boolean; error?: Error; } export async function initializeFirebase(): Promise<FirebaseInitResult> { try { console.log("🔥 Initializing Firebase..."); await setupDevelopment(); const [firestorePersistence, authPersistence] = await Promise.all([ setupFirestorePersistence(), setupAuthPersistence(), ]); console.log("✅ Firebase initialization completed"); return { success: true, firestorePersistence, authPersistence, }; } catch (error) { console.error("❌ Firebase initialization failed:", error); return { success: false, firestorePersistence: false, authPersistence: false, error: error as Error, }; } } export const FIRESTORE_COLLECTIONS = { USERS: "users", WORDS: "words", TESTS: "tests", STATISTICS: "statistics", PERFORMANCE: "performance", USER_PROFILES: "user_profiles", USER_PREFERENCES: "user_preferences", } as const; export function isValidCollectionName( name: string ): name is FirestoreCollectionName { return Object.values(FIRESTORE_COLLECTIONS).includes( name as FirestoreCollectionName ); } export function getUserDocPath( collection: FirestoreCollectionName, userId: string, docId?: string ): string { const basePath = `${collection}/${userId}`; return docId ? `${basePath}/${docId}` : basePath; } export function getUserSubcollectionPath( collection: FirestoreCollectionName, userId: string, subcollection: string, docId?: string ): string { const basePath = `${collection}/${userId}/${subcollection}`; return docId ? `${basePath}/${docId}` : basePath; } export interface FirebaseStatus { app: { name: string; options: Record<string, any>; }; firestore: { app: string; }; auth: { app: string; currentUser: { uid: string; email: string | null; emailVerified: boolean; } | null; }; } export function getFirebaseStatus(): FirebaseStatus { return { app: { name: firebaseApp.name, options: firebaseApp.options, }, firestore: { app: db.app.name, }, auth: { app: auth.app.name, currentUser: auth.currentUser ? { uid: auth.currentUser.uid, email: auth.currentUser.email, emailVerified: auth.currentUser.emailVerified, } : null, }, }; } export function isOnline(): boolean { return navigator.onLine; } export function createFirestoreError( code: string, message: string, operation: string, path?: string ): FirestoreError { return { code: code as any, message, operation: operation as any, path, recoverable: code !== "permission-denied" && code !== "unauthenticated", timestamp: new Date(), }; } export type { FirebaseApp } from "firebase/app"; export type { Firestore } from "firebase/firestore"; export type { Auth } from "firebase/auth"; export type { User as FirebaseUser, UserCredential, AuthError as FirebaseAuthError, } from "firebase/auth"; export type { DocumentData, DocumentReference, CollectionReference, Query, QuerySnapshot, DocumentSnapshot, FirestoreError as FirebaseFirestoreError, } from "firebase/firestore"; export default firebaseApp;

================================================================================


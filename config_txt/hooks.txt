NOME FILE: useLoadingState.js

import { useState, useCallback, useRef, useEffect } from 'react'; import { useNotification } from '../contexts/NotificationContext'; export const useLoadingState = (options = {}) => { const { timeout = 30000, retryAttempts = 3, retryDelay = 1000, showTimeoutWarning = true, showRetryNotifications = true } = options; const [state, setState] = useState({ isLoading: false, error: null, retryCount: 0, startTime: null, operation: null }); const timeoutRef = useRef(null); const { showWarning, showError, showSuccess } = useNotification(); const startLoading = useCallback((operationName = 'Operation') => { setState(prev => ({ ...prev, isLoading: true, error: null, startTime: Date.now(), operation: operationName })); if (showTimeoutWarning && timeout > 0) { timeoutRef.current = setTimeout(() => { showWarning(`⏱️ ${operationName} sta impiegando più tempo...`); }, timeout / 2); } }, [timeout, showTimeoutWarning, showWarning]); const stopLoading = useCallback((successMessage) => { setState(prev => { const duration = prev.startTime ? Date.now() - prev.startTime : 0; if (successMessage && duration > 2000) { showSuccess(`${successMessage} (${Math.round(duration / 1000)}s)`); } return { ...prev, isLoading: false, error: null, retryCount: 0, startTime: null, operation: null }; }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } }, [showSuccess]); const setError = useCallback((error, canRetry = true) => { setState(prev => { const newRetryCount = prev.retryCount + 1; const shouldRetry = canRetry && newRetryCount <= retryAttempts; if (shouldRetry && showRetryNotifications) { showWarning(`❌ ${error.message || error} - Tentativo ${newRetryCount}/${retryAttempts}`); } else if (!shouldRetry) { showError(error, prev.operation || 'Operation'); } return { ...prev, isLoading: false, error: error, retryCount: shouldRetry ? newRetryCount : prev.retryCount }; }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } }, [retryAttempts, showRetryNotifications, showWarning, showError]); const retry = useCallback(async (operation) => { if (state.retryCount >= retryAttempts) { showError(new Error('Numero massimo tentativi raggiunto'), 'Retry'); return false; } await new Promise(resolve => setTimeout(resolve, retryDelay * state.retryCount)); try { startLoading(state.operation); const result = await operation(); stopLoading(); return result; } catch (error) { setError(error, true); return false; } }, [state.retryCount, state.operation, retryAttempts, retryDelay, startLoading, stopLoading, setError, showError]); useEffect(() => { return () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } }; }, []); return { ...state, startLoading, stopLoading, setError, retry, canRetry: state.retryCount < retryAttempts, duration: state.startTime ? Date.now() - state.startTime : 0 }; }; export const useAILoading = () => { const loadingState = useLoadingState({ timeout: 45000, retryAttempts: 2, retryDelay: 2000, showTimeoutWarning: true }); const executeAIOperation = useCallback(async (operation, operationName = 'AI Analysis') => { try { loadingState.startLoading(operationName); const timeoutPromise = new Promise((_, reject) => { setTimeout(() => reject(new Error('AI service timeout')), 45000); }); const result = await Promise.race([operation(), timeoutPromise]); loadingState.stopLoading(`✨ ${operationName} completata`); return result; } catch (error) { if (error.message.includes('timeout')) { loadingState.setError(new Error('🤖 AI timeout. Riprova o usa modalità manuale.'), true); } else if (error.message.includes('API')) { loadingState.setError(new Error('🔑 Problema API key.'), false); } else if (error.message.includes('quota')) { loadingState.setError(new Error('🚫 Limite API raggiunto.'), false); } else { loadingState.setError(error, true); } throw error; } }, [loadingState]); return { ...loadingState, executeAIOperation }; }; export const useStorageLoading = () => { const loadingState = useLoadingState({ timeout: 10000, retryAttempts: 3, retryDelay: 500, showTimeoutWarning: false }); const executeStorageOperation = useCallback(async (operation, operationName = 'Storage Operation') => { try { loadingState.startLoading(operationName); const result = await operation(); loadingState.stopLoading(); return result; } catch (error) { if (error.message.includes('quota') || error.message.includes('QuotaExceededError')) { loadingState.setError(new Error('💽 Spazio esaurito. Elimina dati vecchi.'), false); } else if (error.message.includes('localStorage')) { loadingState.setError(new Error('🔒 Accesso negato storage.'), true); } else { loadingState.setError(error, true); } throw error; } }, [loadingState]); return { ...loadingState, executeStorageOperation }; }; export const useNetworkLoading = () => { const loadingState = useLoadingState({ timeout: 20000, retryAttempts: 3, retryDelay: 1500, showTimeoutWarning: true }); const executeNetworkOperation = useCallback(async (operation, operationName = 'Network Request') => { try { loadingState.startLoading(operationName); const result = await operation(); loadingState.stopLoading(); return result; } catch (error) { if (error.message.includes('fetch') || error.message.includes('network')) { loadingState.setError(new Error('📡 Nessuna connessione.'), true); } else if (error.message.includes('timeout')) { loadingState.setError(new Error('⏱️ Timeout rete.'), true); } else if (error.message.includes('404')) { loadingState.setError(new Error('🔍 Risorsa non trovata.'), false); } else if (error.message.includes('500')) { loadingState.setError(new Error('🔧 Errore server.'), true); } else { loadingState.setError(error, true); } throw error; } }, [loadingState]); return { ...loadingState, executeNetworkOperation }; };

================================================================================

NOME FILE: useNotification.js

import { useState, useCallback } from 'react'; export const useNotification = () => { const [message, setMessage] = useState(''); const showNotification = useCallback((msg, duration = 3000) => { setMessage(msg); setTimeout(() => setMessage(''), duration); }, []); return { message, showNotification }; };

================================================================================

NOME FILE: core\useAsyncOperation.ts

import { useState, useCallback, useRef, useEffect } from 'react'; export type AsyncOperationStatus = | 'idle' | 'pending' | 'success' | 'error' | 'cancelled' | 'retrying'; export interface RetryConfig { baseDelay: number; maxDelay: number; onRetry?: (error: Error, attempt: number) => void; } export interface ProgressConfig { onProgress?: (progress: number) => void; export interface TimeoutConfig { onTimeout?: () => void; } export interface AsyncOperationConfig { progress?: Partial<ProgressConfig>; enableCancellation?: boolean; autoResetDelay?: number; export interface OperationMetadata { endTime: Date | null; currentAttempt: number; cancellationReason?: string; } export interface AsyncOperationResult<TResult, TError = Error> { error: TError | null; loading: boolean; metadata: OperationMetadata; } export interface CancellationToken { reason?: string; cancel: (reason?: string) => void; } export function useAsyncOperation<TArgs extends any[], TResult, TError = Error>( operation: (...args: TArgs) => Promise<TResult>, config: AsyncOperationConfig = {} ): { error: TError | null; loading: boolean; metadata: OperationMetadata; retry: () => Promise<TResult>; reset: () => void; const createCancellationToken = useCallback((): CancellationToken => { let cancelFn: (reason?: string) => void; const promise = new Promise<void>((resolve) => { cancelFn = (reason?: string) => { token.isCancelled = true; token.reason = reason; resolve(); }; }); const token: CancellationToken = { isCancelled: false, reason: undefined, promise, cancel: (reason?: string) => cancelFn(reason), }; return token; }, []); const calculateRetryDelay = useCallback((attempt: number): number => { const delay = finalRetryConfig.baseDelay * Math.pow(finalRetryConfig.backoffMultiplier, attempt - 1); return Math.min(delay, finalRetryConfig.maxDelay); }, [finalRetryConfig]); const updateProgress = useCallback((newProgress: number) => { const clampedProgress = Math.max(0, Math.min(100, newProgress)); setProgress(clampedProgress); if (finalProgressConfig.onProgress) { finalProgressConfig.onProgress(clampedProgress); } }, [finalProgressConfig]); const updateMetadata = useCallback((updates: Partial<OperationMetadata>) => { setMetadata(prev => { const updated = { ...prev, ...updates }; if (updated.startTime && updated.endTime) { updated.duration = updated.endTime.getTime() - updated.startTime.getTime(); } return updated; }); }, []); const reset = useCallback(() => { setData(null); setError(null); setStatus('idle'); setProgress(0); setMetadata({ startTime: null, endTime: null, duration: null, currentAttempt: 0, previousErrors: [], }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); autoResetTimeoutRef.current = null; } if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel('reset'); } lastArgsRef.current = null; if (debug) { console.log('🔄 AsyncOperation reset'); } }, [debug]); const executeWithRetry = useCallback(async ( args: TArgs, attempt: number = 1 ): Promise<TResult> => { const startTime = new Date(); updateMetadata({ startTime, currentAttempt: attempt, }); if (debug) { console.log(`🔄 AsyncOperation attempt ${attempt}/${finalRetryConfig.maxAttempts}`, args); } try { if (enableCancellation) { cancellationTokenRef.current = createCancellationToken(); } if (finalTimeoutConfig.timeout > 0) { timeoutRef.current = setTimeout(() => { const timeoutError = new Error(`Operation timed out after ${finalTimeoutConfig.timeout}ms`); if (finalTimeoutConfig.onTimeout) { finalTimeoutConfig.onTimeout(); } if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel('timeout'); } throw timeoutError; }, finalTimeoutConfig.timeout); } if (finalProgressConfig.trackProgress) { updateProgress(10); } const result = await operationRef.current(...args); if (cancellationTokenRef.current?.isCancelled) { throw new Error(`Operation cancelled: ${cancellationTokenRef.current.reason || 'unknown'}`); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (finalProgressConfig.trackProgress) { updateProgress(100); } const endTime = new Date(); updateMetadata({ endTime, duration: endTime.getTime() - startTime.getTime(), }); if (debug) { console.log('🔄 AsyncOperation success', result); } return result; } catch (error) { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } const operationError = error as TError; if (debug) { console.error(`🔄 AsyncOperation attempt ${attempt} failed:`, operationError); } updateMetadata({ endTime: new Date(), previousErrors: [...metadata.previousErrors, operationError as Error], }); const shouldRetry = attempt < finalRetryConfig.maxAttempts && finalRetryConfig.shouldRetry!(operationError as Error, attempt); if (shouldRetry && (!cancellationTokenRef.current?.isCancelled)) { if (finalRetryConfig.onRetry) { finalRetryConfig.onRetry(operationError as Error, attempt); } setStatus('retrying'); const retryDelay = calculateRetryDelay(attempt); await new Promise(resolve => setTimeout(resolve, retryDelay)); if (cancellationTokenRef.current?.isCancelled) { throw new Error(`Operation cancelled during retry: ${cancellationTokenRef.current.reason}`); } return executeWithRetry(args, attempt + 1); } throw operationError; } }, [ finalRetryConfig, finalTimeoutConfig, finalProgressConfig, enableCancellation, debug, updateMetadata, updateProgress, createCancellationToken, calculateRetryDelay, metadata.previousErrors, ]); const execute = useCallback(async (...args: TArgs): Promise<TResult> => { setError(null); setStatus('pending'); setProgress(finalProgressConfig.trackProgress ? 0 : 0); lastArgsRef.current = args; try { const result = await executeWithRetry(args); setData(result); setStatus('success'); if (autoReset) { autoResetTimeoutRef.current = setTimeout(() => { reset(); }, autoResetDelay); } return result; } catch (error) { const operationError = error as TError; setError(operationError); if (cancellationTokenRef.current?.isCancelled) { setStatus('cancelled'); updateMetadata({ cancellationReason: cancellationTokenRef.current.reason }); } else { setStatus('error'); } throw operationError; } }, [ finalProgressConfig.trackProgress, executeWithRetry, autoReset, autoResetDelay, reset, updateMetadata, ]); const retry = useCallback(async (): Promise<TResult> => { if (!lastArgsRef.current) { throw new Error('No previous arguments to retry with'); } if (debug) { console.log('🔄 AsyncOperation manual retry'); } return execute(...lastArgsRef.current); }, [execute, debug]); const cancel = useCallback((reason?: string) => { if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel(reason || 'manual cancellation'); if (debug) { console.log('🔄 AsyncOperation cancelled:', reason); } } }, [debug]); const loading = status === 'pending' || status === 'retrying'; const canRetry = status === 'error' && lastArgsRef.current !== null; useEffect(() => { return () => { if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel('component unmount'); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); } }; }, []); return { data, error, status, loading, progress, metadata, execute, retry, cancel, reset, canRetry, }; } export function useAsyncWithProgress<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, onProgress?: (progress: number) => void ) { return useAsyncOperation(operation, { progress: { trackProgress: true, onProgress, stepSize: 5, }, }); } export function useAsyncWithRetry<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, retryConfig?: Partial<RetryConfig> ) { return useAsyncOperation(operation, { retry: { maxAttempts: 3, baseDelay: 1000, backoffMultiplier: 2, ...retryConfig, }, }); } export function useAsyncWithTimeout<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, timeout: number, onTimeout?: () => void ) { return useAsyncOperation(operation, { timeout: { timeout, onTimeout, }, }); } export function useCancellableAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult> ) { return useAsyncOperation(operation, { enableCancellation: true, }); } export function useParallelAsync<TResult>( operations: Array<() => Promise<TResult>> ) { const [results, setResults] = useState<Array<TResult | Error>>([]); const [loading, setLoading] = useState(false); const [completed, setCompleted] = useState(0); const executeAll = useCallback(async (): Promise<Array<TResult | Error>> => { setLoading(true); setCompleted(0); setResults([]); const promises = operations.map(async (operation, index) => { try { const result = await operation(); setCompleted(prev => prev + 1); return result; } catch (error) { setCompleted(prev => prev + 1); return error as Error; } }); const allResults = await Promise.all(promises); setResults(allResults); setLoading(false); return allResults; }, [operations]); const progress = operations.length > 0 ? (completed / operations.length) * 100 : 0; return { executeAll, results, loading, progress, completed, total: operations.length, }; } export function useDebouncedAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, delay: number = 300 ) { const asyncOp = useAsyncOperation(operation); const [debouncedExecute, setDebouncedExecute] = useState<(...args: TArgs) => Promise<TResult>>(); useEffect(() => { let timeoutId: NodeJS.Timeout; const debouncedFn = (...args: TArgs): Promise<TResult> => { return new Promise((resolve, reject) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => { asyncOp.execute(...args).then(resolve).catch(reject); }, delay); }); }; setDebouncedExecute(() => debouncedFn); return () => { clearTimeout(timeoutId); }; }, [operation, delay, asyncOp]); return { ...asyncOp, execute: debouncedExecute || asyncOp.execute, }; } export default useAsyncOperation;

================================================================================

NOME FILE: core\useCache.ts

import { useState, useCallback, useRef, useEffect } from "react"; export type AsyncOperationStatus = | "idle" | "pending" | "success" | "error" | "cancelled" | "retrying"; export interface RetryConfig { baseDelay: number; maxDelay: number; onRetry?: (error: Error, attempt: number) => void; } export interface ProgressConfig { onProgress?: (progress: number) => void; export interface TimeoutConfig { onTimeout?: () => void; } export interface AsyncOperationConfig { progress?: Partial<ProgressConfig>; enableCancellation?: boolean; autoResetDelay?: number; export interface OperationMetadata { endTime: Date | null; currentAttempt: number; cancellationReason?: string; } export interface AsyncOperationResult<TResult, TError = Error> { error: TError | null; loading: boolean; metadata: OperationMetadata; } export interface CancellationToken { reason?: string; cancel: (reason?: string) => void; } export function useAsyncOperation<TArgs extends any[], TResult, TError = Error>( operation: (...args: TArgs) => Promise<TResult>, config: AsyncOperationConfig = {} ): { error: TError | null; loading: boolean; metadata: OperationMetadata; retry: () => Promise<TResult>; reset: () => void; const createCancellationToken = useCallback((): CancellationToken => { let cancelFn: (reason?: string) => void; const promise = new Promise<void>((resolve) => { cancelFn = (reason?: string) => { token.isCancelled = true; token.reason = reason; resolve(); }; }); const token: CancellationToken = { isCancelled: false, reason: undefined, promise, cancel: (reason?: string) => cancelFn(reason), }; return token; }, []); const calculateRetryDelay = useCallback( (attempt: number): number => { const delay = finalRetryConfig.baseDelay * Math.pow(finalRetryConfig.backoffMultiplier, attempt - 1); return Math.min(delay, finalRetryConfig.maxDelay); }, [finalRetryConfig] ); const updateProgress = useCallback( (newProgress: number) => { const clampedProgress = Math.max(0, Math.min(100, newProgress)); setProgress(clampedProgress); if (finalProgressConfig.onProgress) { finalProgressConfig.onProgress(clampedProgress); } }, [finalProgressConfig] ); const updateMetadata = useCallback((updates: Partial<OperationMetadata>) => { setMetadata((prev) => { const updated = { ...prev, ...updates }; if (updated.startTime && updated.endTime) { updated.duration = updated.endTime.getTime() - updated.startTime.getTime(); } return updated; }); }, []); const reset = useCallback(() => { setData(null); setError(null); setStatus("idle"); setProgress(0); setMetadata({ startTime: null, endTime: null, duration: null, currentAttempt: 0, previousErrors: [], }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); autoResetTimeoutRef.current = null; } if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel("reset"); } lastArgsRef.current = null; if (debug) { console.log("🔄 AsyncOperation reset"); } }, [debug]); const executeWithRetry = useCallback( async (args: TArgs, attempt: number = 1): Promise<TResult> => { const startTime = new Date(); updateMetadata({ startTime, currentAttempt: attempt, }); if (debug) { console.log( `🔄 AsyncOperation attempt ${attempt}/${finalRetryConfig.maxAttempts}`, args ); } try { if (enableCancellation) { cancellationTokenRef.current = createCancellationToken(); } if (finalTimeoutConfig.timeout > 0) { timeoutRef.current = setTimeout(() => { const timeoutError = new Error( `Operation timed out after ${finalTimeoutConfig.timeout}ms` ); if (finalTimeoutConfig.onTimeout) { finalTimeoutConfig.onTimeout(); } if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel("timeout"); } throw timeoutError; }, finalTimeoutConfig.timeout); } if (finalProgressConfig.trackProgress) { updateProgress(10); } const result = await operationRef.current(...args); if (cancellationTokenRef.current?.isCancelled) { throw new Error( `Operation cancelled: ${ cancellationTokenRef.current.reason || "unknown" }` ); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (finalProgressConfig.trackProgress) { updateProgress(100); } const endTime = new Date(); updateMetadata({ endTime, duration: endTime.getTime() - startTime.getTime(), }); if (debug) { console.log("🔄 AsyncOperation success", result); } return result; } catch (error) { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } const operationError = error as TError; if (debug) { console.error( `🔄 AsyncOperation attempt ${attempt} failed:`, operationError ); } updateMetadata({ endTime: new Date(), previousErrors: [...metadata.previousErrors, operationError as Error], }); const shouldRetry = attempt < finalRetryConfig.maxAttempts && finalRetryConfig.shouldRetry!(operationError as Error, attempt); if (shouldRetry && !cancellationTokenRef.current?.isCancelled) { if (finalRetryConfig.onRetry) { finalRetryConfig.onRetry(operationError as Error, attempt); } setStatus("retrying"); const retryDelay = calculateRetryDelay(attempt); await new Promise((resolve) => setTimeout(resolve, retryDelay)); if (cancellationTokenRef.current?.isCancelled) { throw new Error( `Operation cancelled during retry: ${cancellationTokenRef.current.reason}` ); } return executeWithRetry(args, attempt + 1); } throw operationError; } }, [ finalRetryConfig, finalTimeoutConfig, finalProgressConfig, enableCancellation, debug, updateMetadata, updateProgress, createCancellationToken, calculateRetryDelay, metadata.previousErrors, ] ); const execute = useCallback( async (...args: TArgs): Promise<TResult> => { setError(null); setStatus("pending"); setProgress(finalProgressConfig.trackProgress ? 0 : 0); lastArgsRef.current = args; try { const result = await executeWithRetry(args); setData(result); setStatus("success"); if (autoReset) { autoResetTimeoutRef.current = setTimeout(() => { reset(); }, autoResetDelay); } return result; } catch (error) { const operationError = error as TError; setError(operationError); if (cancellationTokenRef.current?.isCancelled) { setStatus("cancelled"); updateMetadata({ cancellationReason: cancellationTokenRef.current.reason, }); } else { setStatus("error"); } throw operationError; } }, [ finalProgressConfig.trackProgress, executeWithRetry, autoReset, autoResetDelay, reset, updateMetadata, ] ); const retry = useCallback(async (): Promise<TResult> => { if (!lastArgsRef.current) { throw new Error("No previous arguments to retry with"); } if (debug) { console.log("🔄 AsyncOperation manual retry"); } return execute(...lastArgsRef.current); }, [execute, debug]); const cancel = useCallback( (reason?: string) => { if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel(reason || "manual cancellation"); if (debug) { console.log("🔄 AsyncOperation cancelled:", reason); } } }, [debug] ); const loading = status === "pending" || status === "retrying"; const canRetry = status === "error" && lastArgsRef.current !== null; useEffect(() => { return () => { if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel("component unmount"); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); } }; }, []); return { data, error, status, loading, progress, metadata, execute, retry, cancel, reset, canRetry, }; } export function useAsyncWithProgress<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, onProgress?: (progress: number) => void ) { return useAsyncOperation(operation, { progress: { trackProgress: true, onProgress, stepSize: 5, }, }); } export function useAsyncWithRetry<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, retryConfig?: Partial<RetryConfig> ) { return useAsyncOperation(operation, { retry: { maxAttempts: 3, baseDelay: 1000, backoffMultiplier: 2, ...retryConfig, }, }); } export function useAsyncWithTimeout<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, timeout: number, onTimeout?: () => void ) { return useAsyncOperation(operation, { timeout: { timeout, onTimeout, }, }); } export function useCancellableAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult> ) { return useAsyncOperation(operation, { enableCancellation: true, }); } export function useParallelAsync<TResult>( operations: Array<() => Promise<TResult>> ) { const [results, setResults] = useState<Array<TResult | Error>>([]); const [loading, setLoading] = useState(false); const [completed, setCompleted] = useState(0); const executeAll = useCallback(async (): Promise<Array<TResult | Error>> => { setLoading(true); setCompleted(0); setResults([]); const promises = operations.map(async (operation, index) => { try { const result = await operation(); setCompleted((prev) => prev + 1); return result; } catch (error) { setCompleted((prev) => prev + 1); return error as Error; } }); const allResults = await Promise.all(promises); setResults(allResults); setLoading(false); return allResults; }, [operations]); const progress = operations.length > 0 ? (completed / operations.length) * 100 : 0; return { executeAll, results, loading, progress, completed, total: operations.length, }; } export function useDebouncedAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, delay: number = 300 ) { const asyncOp = useAsyncOperation(operation); const [debouncedExecute, setDebouncedExecute] = useState<(...args: TArgs) => Promise<TResult>>(); useEffect(() => { let timeoutId: NodeJS.Timeout; const debouncedFn = (...args: TArgs): Promise<TResult> => { return new Promise((resolve, reject) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => { asyncOp .execute(...args) .then(resolve) .catch(reject); }, delay); }); }; setDebouncedExecute(() => debouncedFn); return () => { clearTimeout(timeoutId); }; }, [operation, delay, asyncOp]); return { ...asyncOp, execute: debouncedExecute || asyncOp.execute, }; } export default useAsyncOperation;

================================================================================

NOME FILE: core\useDebounce.ts

import { useState, useEffect, useCallback, useRef } from 'react'; interface DebounceOptions { leading?: boolean; maxWait?: number; } interface DebouncedResult<T> { currentValue: T; cancel: () => void; setValue: (value: T) => void; } interface DebouncedCallback<TArgs extends any[], TReturn> { cancel: () => void; isPending: () => boolean; } export function useDebounce<T>( value: T, delay: number, options: Partial<DebounceOptions> = {} ): DebouncedResult<T> { const { leading = false, trailing = true, maxWait, } = options; const [debouncedValue, setDebouncedValue] = useState<T>(value); const [currentValue, setCurrentValue] = useState<T>(value); const [isPending, setIsPending] = useState<boolean>(false); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const maxTimeoutRef = useRef<NodeJS.Timeout | null>(null); const lastCallTimeRef = useRef<number>(0); const lastInvokeTimeRef = useRef<number>(0); const clearTimeouts = useCallback(() => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (maxTimeoutRef.current) { clearTimeout(maxTimeoutRef.current); maxTimeoutRef.current = null; } }, []); const invokeCallback = useCallback((val: T) => { setDebouncedValue(val); setIsPending(false); lastInvokeTimeRef.current = Date.now(); }, []); const debouncedUpdate = useCallback((val: T) => { const now = Date.now(); lastCallTimeRef.current = now; if (leading && lastInvokeTimeRef.current === 0) { invokeCallback(val); return; } clearTimeouts(); setIsPending(true); timeoutRef.current = setTimeout(() => { if (trailing) { invokeCallback(val); } else { setIsPending(false); } }, delay); if (maxWait && lastInvokeTimeRef.current > 0) { const timeSinceLastInvoke = now - lastInvokeTimeRef.current; if (timeSinceLastInvoke >= maxWait) { invokeCallback(val); } else { maxTimeoutRef.current = setTimeout(() => { invokeCallback(val); }, maxWait - timeSinceLastInvoke); } } }, [delay, leading, trailing, maxWait, invokeCallback, clearTimeouts]); const cancel = useCallback(() => { clearTimeouts(); setIsPending(false); }, [clearTimeouts]); const flush = useCallback(() => { if (isPending) { clearTimeouts(); invokeCallback(currentValue); } }, [isPending, currentValue, clearTimeouts, invokeCallback]); const setValue = useCallback((val: T) => { setCurrentValue(val); debouncedUpdate(val); }, [debouncedUpdate]); useEffect(() => { if (currentValue !== value) { setCurrentValue(value); debouncedUpdate(value); } }, [value, currentValue, debouncedUpdate]); useEffect(() => { return () => { clearTimeouts(); }; }, [clearTimeouts]); return { debouncedValue, currentValue, isPending, cancel, flush, setValue, }; } export function useDebouncedCallback<TArgs extends any[], TReturn>( callback: (...args: TArgs) => TReturn | Promise<TReturn>, delay: number, options: Partial<DebounceOptions> = {} ): DebouncedCallback<TArgs, TReturn> { const { leading = false, trailing = true, maxWait, } = options; const callbackRef = useRef(callback); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const maxTimeoutRef = useRef<NodeJS.Timeout | null>(null); const lastCallTimeRef = useRef<number>(0); const lastInvokeTimeRef = useRef<number>(0); const lastArgsRef = useRef<TArgs | null>(null); const pendingPromiseRef = useRef<{ resolve: (value: TReturn) => void; reject: (error: any) => void; } | null>(null); useEffect(() => { callbackRef.current = callback; }, [callback]); const clearTimeouts = useCallback(() => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (maxTimeoutRef.current) { clearTimeout(maxTimeoutRef.current); maxTimeoutRef.current = null; } }, []); const invokeCallback = useCallback(async (...args: TArgs): Promise<TReturn> => { lastInvokeTimeRef.current = Date.now(); try { const result = await callbackRef.current(...args); return result; } catch (error) { throw error; } }, []); const debouncedFn = useCallback((...args: TArgs): Promise<TReturn> => { return new Promise<TReturn>((resolve, reject) => { const now = Date.now(); lastCallTimeRef.current = now; lastArgsRef.current = args; if (leading && lastInvokeTimeRef.current === 0) { invokeCallback(...args) .then(resolve) .catch(reject); return; } pendingPromiseRef.current = { resolve, reject }; clearTimeouts(); timeoutRef.current = setTimeout(() => { if (trailing && lastArgsRef.current && pendingPromiseRef.current) { invokeCallback(...lastArgsRef.current) .then(pendingPromiseRef.current.resolve) .catch(pendingPromiseRef.current.reject) .finally(() => { pendingPromiseRef.current = null; }); } }, delay); if (maxWait && lastInvokeTimeRef.current > 0) { const timeSinceLastInvoke = now - lastInvokeTimeRef.current; if (timeSinceLastInvoke >= maxWait) { invokeCallback(...args) .then(resolve) .catch(reject); pendingPromiseRef.current = null; } else { maxTimeoutRef.current = setTimeout(() => { if (lastArgsRef.current && pendingPromiseRef.current) { invokeCallback(...lastArgsRef.current) .then(pendingPromiseRef.current.resolve) .catch(pendingPromiseRef.current.reject) .finally(() => { pendingPromiseRef.current = null; }); } }, maxWait - timeSinceLastInvoke); } } }); }, [delay, leading, trailing, maxWait, invokeCallback, clearTimeouts]); const cancel = useCallback(() => { clearTimeouts(); if (pendingPromiseRef.current) { pendingPromiseRef.current.reject(new Error('Debounced call cancelled')); pendingPromiseRef.current = null; } }, [clearTimeouts]); const flush = useCallback((...args: TArgs): Promise<TReturn> => { const argsToUse = args.length > 0 ? args : lastArgsRef.current; if (!argsToUse) { return Promise.reject(new Error('No arguments to flush')); } cancel(); return invokeCallback(...argsToUse); }, [cancel, invokeCallback]); const isPending = useCallback((): boolean => { return pendingPromiseRef.current !== null; }, []); useEffect(() => { return () => { clearTimeouts(); if (pendingPromiseRef.current) { pendingPromiseRef.current.reject(new Error('Component unmounted')); } }; }, [clearTimeouts]); const debouncedCallback = debouncedFn as DebouncedCallback<TArgs, TReturn>; debouncedCallback.cancel = cancel; debouncedCallback.flush = flush; debouncedCallback.isPending = isPending; return debouncedCallback; } export function useDebouncedSearch<TResult>( searchFunction: (query: string) => Promise<TResult[]>, delay: number = 300, options: { minLength?: number; immediate?: boolean; keepPreviousResults?: boolean; } = {} ) { const { minLength = 1, immediate = false, keepPreviousResults = false, } = options; const [searchTerm, setSearchTerm] = useState<string>(''); const [results, setResults] = useState<TResult[]>([]); const [isSearching, setIsSearching] = useState<boolean>(false); const [error, setError] = useState<Error | null>(null); const debouncedSearch = useDebouncedCallback( async (query: string): Promise<TResult[]> => { if (query.length < minLength) { return []; } setIsSearching(true); setError(null); try { const searchResults = await searchFunction(query); setResults(searchResults); return searchResults; } catch (err) { const error = err instanceof Error ? err : new Error('Search failed'); setError(error); if (!keepPreviousResults) { setResults([]); } throw error; } finally { setIsSearching(false); } }, delay, { trailing: true } ); const search = useCallback(async (query: string): Promise<TResult[]> => { setSearchTerm(query); if (query.length < minLength) { setResults([]); setIsSearching(false); setError(null); return []; } return debouncedSearch(query); }, [minLength, debouncedSearch]); useEffect(() => { if (immediate && searchTerm) { search(searchTerm); } }, [immediate, searchTerm, search]); const clear = useCallback(() => { setSearchTerm(''); setResults([]); setIsSearching(false); setError(null); debouncedSearch.cancel(); }, [debouncedSearch]); const cancel = useCallback(() => { debouncedSearch.cancel(); setIsSearching(false); }, [debouncedSearch]); return { results, error, clear, setSearchTerm: (term: string) => { setSearchTerm(term); if (immediate) { search(term); } }, }; } export function useDebouncedValue<T>( initialValue: T, delay: number ): [T, T, (value: T) => void] { const [value, setValue] = useState<T>(initialValue); const { debouncedValue } = useDebounce(value, delay); return [value, debouncedValue, setValue]; } export function useDebouncedAsync<TArgs extends any[], TResult>( asyncFunction: (...args: TArgs) => Promise<TResult>, delay: number, options: Partial<DebounceOptions> = {} ) { const [loading, setLoading] = useState<boolean>(false); const [result, setResult] = useState<TResult | null>(null); const [error, setError] = useState<Error | null>(null); const debouncedFn = useDebouncedCallback( async (...args: TArgs): Promise<TResult> => { setLoading(true); setError(null); try { const result = await asyncFunction(...args); setResult(result); return result; } catch (err) { const error = err instanceof Error ? err : new Error('Async operation failed'); setError(error); throw error; } finally { setLoading(false); } }, delay, options ); const clear = useCallback(() => { setResult(null); setError(null); setLoading(false); debouncedFn.cancel(); }, [debouncedFn]); return { loading: loading || debouncedFn.isPending(), error, cancel: debouncedFn.cancel, }; } export default useDebounce;

================================================================================

NOME FILE: core\useFirestore.ts

import { useState, useEffect, useCallback, useMemo, useRef } from "react"; import { collection, doc, getDocs, getDoc, addDoc, setDoc, updateDoc, deleteDoc, query, where, orderBy, limit, onSnapshot, writeBatch, type Query, type DocumentData, type Unsubscribe, type WhereFilterOp, type OrderByDirection, } from "firebase/firestore"; import { db, auth } from "../../config/firebase"; import { useFirebase } from "../../contexts/FirebaseContext"; import { useAsyncOperation } from "./useAsyncOperation"; import type { Word } from "../../types/entities/Word.types"; import type { Statistics } from "../../types/entities/Statistics.types"; import type { WordPerformance } from "../../types/entities/Performance.types"; import type { FirestoreDoc, FirestoreQuery, FirestoreError, FirestoreOperationResult, FirestoreCollectionName, FirestoreOperation, FirestoreListener, FirestoreListenerData, ChangeType, } from "../../types/infrastructure/Firestore.types"; interface UseFirestoreConfig<T> { realtime?: boolean; autoFetch?: boolean; localStorageKey?: string; interface UseFirestoreState<T> { loading: boolean; listening: boolean; fromCache: boolean; } interface UseFirestoreOperations<T> { create: (data: Omit<T, "id">) => Promise<T>; remove: (id: string) => Promise<void>; clearCache: () => void; startListening: () => void; interface UseFirestoreUtils<T> { filter: (predicate: (item: T) => boolean) => T[]; getStats: () => { total: number; lastUpdated: Date | null; cacheHits: number; }; } interface UseFirestoreResult<T> extends UseFirestoreState<T>, UseFirestoreOperations<T> { export function useFirestore<T extends { id: string }>( config: UseFirestoreConfig<T> ): UseFirestoreResult<T> { const { collection: collectionName, realtime = false, enableCache = true, autoFetch = true, syncWithLocalStorage = false, localStorageKey, debug = false, } = config; const { isReady } = useFirebase(); const [state, setState] = useState<UseFirestoreState<T>>({ data: [], loading: false, error: null, listening: false, lastSync: null, fromCache: false, }); const listenerRef = useRef<Unsubscribe | null>(null); const cacheRef = useRef<Map<string, T>>(new Map()); const statsRef = useRef({ cacheHits: 0, totalFetches: 0, }); const getCurrentUserId = useCallback(() => { return auth.currentUser?.uid || null; }, []); const createError = useCallback( (code: string, message: string, originalError?: any): FirestoreError => { return { code: code as any, message, details: originalError, operation: "unknown" as any, recoverable: true, timestamp: new Date(), }; }, [] ); const fetchOperation = useAsyncOperation( async (): Promise<T[]> => { if (!isReady) { throw new Error( "🔥 Firebase not ready - please wait for initialization" ); } const userId = getCurrentUserId(); if (!userId) { throw new Error("🔐 User not authenticated - please login first"); } if (debug) { console.log( `🔥 [useFirestore] Fetching ${collectionName} for user ${userId}` ); } const collectionRef = collection(db, collectionName); let q: Query<DocumentData> = query( collectionRef, where("firestoreMetadata.userId", "==", userId), where("firestoreMetadata.deleted", "==", false) ); const snapshot = await getDocs(q); const docs: T[] = []; snapshot.forEach((docSnap) => { const data = docSnap.data(); const firestoreDoc = { id: docSnap.id, ...data, } as T; docs.push(firestoreDoc); }); if (enableCache) { docs.forEach((doc) => { cacheRef.current.set(doc.id, doc); }); } if (syncWithLocalStorage && localStorageKey) { try { localStorage.setItem(localStorageKey, JSON.stringify(docs)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync with localStorage:", error ); } } statsRef.current.totalFetches++; if (debug) { console.log( `🔥 [useFirestore] Fetched ${docs.length} documents from ${collectionName}` ); } return docs; }, { retry: { maxAttempts: 3 }, debug } ); const create = useCallback( async (data: Omit<T, "id">): Promise<T> => { if (!isReady) { throw new Error("🔥 Firebase not ready for create operation"); } const userId = getCurrentUserId(); if (!userId) { throw new Error("🔐 User not authenticated for create operation"); } if (debug) { console.log( `🔥 [useFirestore] Creating document in ${collectionName}:`, data ); } const now = new Date(); const documentData = { ...data, firestoreMetadata: { userId, createdAt: now, updatedAt: now, version: 1, deleted: false, custom: {}, }, }; const collectionRef = collection(db, collectionName); const docRef = await addDoc(collectionRef, documentData); const newDoc = { id: docRef.id, ...documentData, } as unknown as T; setState((prev) => ({ ...prev, data: [...prev.data, newDoc], lastSync: new Date(), })); if (enableCache) { cacheRef.current.set(newDoc.id, newDoc); } if (syncWithLocalStorage && localStorageKey) { try { const updatedData = [...state.data, newDoc]; localStorage.setItem(localStorageKey, JSON.stringify(updatedData)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync create with localStorage:", error ); } } if (debug) { console.log(`🔥 [useFirestore] Created document with ID: ${newDoc.id}`); } return newDoc; }, [ isReady, collectionName, enableCache, syncWithLocalStorage, localStorageKey, state.data, debug, getCurrentUserId, ] ); const update = useCallback( async (id: string, data: Partial<T>): Promise<T> => { if (!isReady) { throw new Error("🔥 Firebase not ready for update operation"); } const userId = getCurrentUserId(); if (!userId) { throw new Error("🔐 User not authenticated for update operation"); } if (debug) { console.log( `🔥 [useFirestore] Updating document ${id} in ${collectionName}:`, data ); } const docRef = doc(db, collectionName, id); const currentDoc = await getDoc(docRef); if (!currentDoc.exists()) { throw new Error(`Document ${id} not found in ${collectionName}`); } const currentData = currentDoc.data(); const currentMetadata = currentData.firestoreMetadata || {}; const updateData = { ...data, firestoreMetadata: { ...currentMetadata, updatedAt: new Date(), version: (currentMetadata.version || 1) + 1, }, }; await updateDoc(docRef, updateData); const updatedDocSnap = await getDoc(docRef); const updatedData = updatedDocSnap.data(); const updatedDoc = { id: updatedDocSnap.id, ...updatedData, } as unknown as T; setState((prev) => ({ ...prev, data: prev.data.map((item) => (item.id === id ? updatedDoc : item)), lastSync: new Date(), })); if (enableCache) { cacheRef.current.set(id, updatedDoc); } if (syncWithLocalStorage && localStorageKey) { try { const updatedDataArray = state.data.map((item) => item.id === id ? updatedDoc : item ); localStorage.setItem( localStorageKey, JSON.stringify(updatedDataArray) ); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync update with localStorage:", error ); } } if (debug) { console.log(`🔥 [useFirestore] Updated document: ${id}`); } return updatedDoc; }, [ isReady, collectionName, enableCache, syncWithLocalStorage, localStorageKey, state.data, debug, getCurrentUserId, ] ); const remove = useCallback( async (id: string): Promise<void> => { if (!isReady) { throw new Error("🔥 Firebase not ready for delete operation"); } const userId = getCurrentUserId(); if (!userId) { throw new Error("🔐 User not authenticated for delete operation"); } if (debug) { console.log( `🔥 [useFirestore] Removing document ${id} from ${collectionName}` ); } const docRef = doc(db, collectionName, id); await updateDoc(docRef, { "firestoreMetadata.deleted": true, "firestoreMetadata.deletedAt": new Date(), "firestoreMetadata.updatedAt": new Date(), }); setState((prev) => ({ ...prev, data: prev.data.filter((item) => item.id !== id), lastSync: new Date(), })); if (enableCache) { cacheRef.current.delete(id); } if (syncWithLocalStorage && localStorageKey) { try { const updatedData = state.data.filter((item) => item.id !== id); localStorage.setItem(localStorageKey, JSON.stringify(updatedData)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync remove with localStorage:", error ); } } if (debug) { console.log(`🔥 [useFirestore] Removed document: ${id}`); } }, [ isReady, collectionName, enableCache, syncWithLocalStorage, localStorageKey, state.data, debug, getCurrentUserId, ] ); const batchUpdate = useCallback( async (operations: BatchOperation<T>[]): Promise<void> => { if (!isReady) { throw new Error("🔥 Firebase not ready for batch operation"); } const userId = getCurrentUserId(); if (!userId) { throw new Error("🔐 User not authenticated for batch operation"); } if (debug) { console.log( `🔥 [useFirestore] Batch update ${collectionName} (${operations.length} operations)` ); } const batch = writeBatch(db); operations.forEach((operation) => { const docRef = operation.id ? doc(db, collectionName, operation.id) : doc(collection(db, collectionName)); switch (operation.type) { case "create": if (operation.data) { batch.set(docRef, { ...operation.data, firestoreMetadata: { userId, createdAt: new Date(), updatedAt: new Date(), version: 1, deleted: false, custom: {}, }, }); } break; case "update": if (operation.data) { batch.update(docRef, { ...operation.data, "firestoreMetadata.updatedAt": new Date(), }); } break; case "delete": batch.update(docRef, { "firestoreMetadata.deleted": true, "firestoreMetadata.deletedAt": new Date(), "firestoreMetadata.updatedAt": new Date(), }); break; } }); await batch.commit(); await refresh(); if (debug) { console.log(`🔥 [useFirestore] Batch update completed`); } }, [isReady, collectionName, debug, getCurrentUserId] ); const fetch = useCallback(async (): Promise<T[]> => { setState((prev) => ({ ...prev, loading: true, error: null })); try { const docs = await fetchOperation.execute(); setState((prev) => ({ ...prev, data: docs, loading: false, lastSync: new Date(), fromCache: false, })); return docs; } catch (error) { setState((prev) => ({ ...prev, loading: false, error: error as FirestoreError, })); throw error; } }, [fetchOperation]); const clearCache = useCallback(() => { cacheRef.current.clear(); statsRef.current.cacheHits = 0; if (debug) { console.log(`🔥 [useFirestore] Cleared cache for ${collectionName}`); } }, [collectionName, debug]); const refresh = useCallback(async (): Promise<void> => { clearCache(); await fetch(); }, [clearCache, fetch]); const startListening = useCallback(() => { if (!isReady || !realtime || listenerRef.current) { return; } const userId = getCurrentUserId(); if (!userId) { return; } if (debug) { console.log( `🔥 [useFirestore] Starting real-time listener for ${collectionName}` ); } const collectionRef = collection(db, collectionName); const q = query( collectionRef, where("firestoreMetadata.userId", "==", userId), where("firestoreMetadata.deleted", "==", false) ); const unsubscribe = onSnapshot( q, { includeMetadataChanges: true }, (snapshot) => { const docs: T[] = []; snapshot.forEach((docSnap) => { const data = docSnap.data(); const firestoreDoc = { id: docSnap.id, ...data, } as unknown as T; docs.push(firestoreDoc); }); setState((prev) => ({ ...prev, data: docs, lastSync: new Date(), listening: true, fromCache: snapshot.metadata.fromCache, })); if (enableCache) { cacheRef.current.clear(); docs.forEach((doc) => { cacheRef.current.set(doc.id, doc); }); } if (syncWithLocalStorage && localStorageKey) { try { localStorage.setItem(localStorageKey, JSON.stringify(docs)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync with localStorage:", error ); } } if (debug) { console.log( `🔥 [useFirestore] Real-time update ${collectionName}: ${docs.length} docs` ); } }, (error) => { setState((prev) => ({ ...prev, error: createError( "listener-failed", "Real-time listener failed", error ), listening: false, })); if (debug) { console.error( `🔥 [useFirestore] Real-time listener error for ${collectionName}:`, error ); } } ); listenerRef.current = unsubscribe; setState((prev) => ({ ...prev, listening: true })); }, [ isReady, realtime, collectionName, enableCache, syncWithLocalStorage, localStorageKey, debug, getCurrentUserId, createError, ]); const stopListening = useCallback(() => { if (listenerRef.current) { listenerRef.current(); listenerRef.current = null; setState((prev) => ({ ...prev, listening: false })); if (debug) { console.log( `🔥 [useFirestore] Stopped real-time listener for ${collectionName}` ); } } }, [collectionName, debug]); const utils = useMemo( () => ({ findById: (id: string): T | undefined => { if (enableCache && cacheRef.current.has(id)) { statsRef.current.cacheHits++; return cacheRef.current.get(id); } return state.data.find((item) => item.id === id); }, filter: (predicate: (item: T) => boolean): T[] => { return state.data.filter(predicate); }, sort: (compareFn: (a: T, b: T) => number): T[] => { return [...state.data].sort(compareFn); }, getStats: () => ({ total: state.data.length, lastUpdated: state.lastSync, cacheHits: statsRef.current.cacheHits, }), }), [state.data, state.lastSync, enableCache] ); useEffect(() => { if (isReady && autoFetch && state.data.length === 0 && !state.loading) { if (debug) { console.log( `🔥 [useFirestore] Auto-fetching data for ${collectionName}` ); } fetch(); } }, [ isReady, autoFetch, state.data.length, state.loading, fetch, collectionName, debug, ]); useEffect(() => { if (isReady && realtime) { startListening(); } return () => { stopListening(); }; }, [isReady, realtime, startListening, stopListening]); useEffect(() => { setState((prev) => ({ ...prev, loading: fetchOperation.loading, error: fetchOperation.error as FirestoreError | null, })); }, [fetchOperation.loading, fetchOperation.error]); return { ...state, fetch, create, update, remove, batchUpdate, clearCache, refresh, startListening, stopListening, utils, }; } interface BatchOperation<T> { type: "create" | "update" | "delete"; id?: string; data?: Partial<Omit<T, "id">>; } type WordPerformanceDoc = WordPerformance & { id: string }; type StatisticsDoc = Statistics & { id: string }; export function useFirestoreWords() { return useFirestore<Word>({ collection: "words", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyWords", debug: process.env.NODE_ENV === "development", }); } export function useFirestoreStats() { return useFirestore<StatisticsDoc>({ collection: "statistics", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyStats", debug: process.env.NODE_ENV === "development", }); } export function useFirestorePerformance() { return useFirestore<WordPerformanceDoc>({ collection: "performance", realtime: false, enableCache: true, autoFetch: true, debug: process.env.NODE_ENV === "development", }); } export default useFirestore;

================================================================================

NOME FILE: data\usePerformance.ts

import { useState, useEffect, useCallback, useMemo, useRef } from "react"; import { useFirestore } from "../core/useFirestore"; import { useFirebase } from "../../contexts/FirebaseContext"; import AppConfig from "../../config/appConfig"; import type { WordPerformance, PerformanceAttempt, WordPerformanceAnalysis, WordPerformanceStatus, GlobalPerformanceStats, UpdatePerformanceInput, UpdatePerformanceResult, PerformanceCategory, SimpleTrend, WordPerformanceTrends, TestDifficultyAnalysis, } from "../../types/entities/Performance.types"; import type { Word } from "../../types/entities/Word.types"; import type { TestResult } from "../../types/entities/Test.types"; import type { CreateInput, UpdateInput, OperationResult, } from "../../types/index"; import type { FirestoreError } from "../../types/infrastructure/Firestore.types"; const EMPTY_ARRAY: WordPerformanceAnalysis[] = []; interface WordPerformanceWithId extends WordPerformance { id: string; wordId: string; italian: string; totalAttempts: number; correctAttempts: number; accuracy: number; averageResponseTime: number; lastAttemptAt: Date; createdAt: Date; updatedAt: Date; } interface ExtendedPerformanceAttempt extends PerformanceAttempt { timestamp: string; } const INITIAL_GLOBAL_STATS: GlobalPerformanceStats = { statusDistribution: { new: 0, promising: 0, struggling: 0, consolidated: 0, improving: 0, critical: 0, inconsistent: 0, }, totalWordsTracked: 0, averageResponseTime: 0, averageAccuracy: 0, averageHintUsage: 0, wordsNeedingWork: 0, masteredWords: 0, }; interface PerformanceState { performances: WordPerformanceWithId[]; isInitialized: boolean; isLoading: boolean; isProcessing: boolean; lastSync: Date | null; error: FirestoreError | null; fromCache: boolean; } interface PerformanceOperations { updateWordPerformance: ( wordId: string, input: UpdatePerformanceInput ) => Promise<UpdatePerformanceResult>; recordTestResults: ( testResult: TestResult, words: Word[] ) => Promise<OperationResult<void>>; analyzeWordDifficulty: ( wordId: string ) => Promise<OperationResult<TestDifficultyAnalysis>>; bulkUpdatePerformances: ( updates: Array<{ wordId: string; input: UpdatePerformanceInput }> ) => Promise<OperationResult<WordPerformanceWithId[]>>; resetWordPerformance: (wordId: string) => Promise<OperationResult<void>>; resetAllPerformances: () => Promise<OperationResult<void>>; refreshData: () => void; } interface PerformanceGetters { getWordPerformance: (wordId: string) => WordPerformanceWithId | null; getWordAnalysis: (wordId: string) => WordPerformanceAnalysis | null; getWordsNeedingWork: (limit?: number) => WordPerformanceAnalysis[]; getWordsByStatus: ( status: WordPerformanceStatus ) => WordPerformanceAnalysis[]; getPerformanceTrends: (wordId: string) => WordPerformanceTrends | null; getGlobalStats: () => GlobalPerformanceStats; getCategorizedWords: () => Record< PerformanceCategory["status"], WordPerformanceAnalysis[] >; getRecommendedWords: (count?: number) => WordPerformanceAnalysis[]; } interface PerformanceAnalytics { globalPerformanceStats: GlobalPerformanceStats; wordLevelInsights: WordPerformanceAnalysis[]; performanceDistribution: Record<WordPerformanceStatus, number>; trendsAnalysis: { improving: number; declining: number; stable: number; }; } interface PerformanceResult extends PerformanceState, PerformanceOperations, PerformanceGetters { analytics: PerformanceAnalytics; } export const usePerformance = (): PerformanceResult => { const performanceFirestore = useFirestore<WordPerformanceWithId>({ collection: "performance", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyPerformance", debug: AppConfig.app.environment === "development", }); const { isReady } = useFirebase(); const [isInitialized, setIsInitialized] = useState<boolean>(false); const [isProcessing, setIsProcessing] = useState<boolean>(false); const [lastSync, setLastSync] = useState<Date | null>(null); const analyticsCache = useRef<{ analytics: PerformanceAnalytics; timestamp: number; } | null>(null); const ANALYTICS_CACHE_TTL = 15000; useEffect(() => { if (isReady && !isInitialized) { initializePerformance(); } }, [isReady, isInitialized]); const initializePerformance = useCallback(async () => { try { setIsProcessing(true); const savedPerformance = localStorage.getItem("vocabularyPerformance"); if (savedPerformance && performanceFirestore.data.length === 0) { try { const parsedPerformance = JSON.parse(savedPerformance); if ( Array.isArray(parsedPerformance) && parsedPerformance.length > 0 ) { const migrationOps = parsedPerformance.map((perf: any) => ({ type: "create" as const, data: { english: perf.english, wordId: perf.english, italian: perf.italian || "", attempts: perf.attempts?.map((attempt: any) => ({ ...attempt, timestamp: attempt.timestamp || new Date().toISOString(), })) || [], totalAttempts: perf.totalAttempts || 0, correctAttempts: perf.correctAttempts || 0, accuracy: perf.accuracy || 0, averageResponseTime: perf.averageResponseTime || 0, lastAttemptAt: perf.lastAttemptAt ? new Date(perf.lastAttemptAt) : new Date(), createdAt: perf.createdAt ? new Date(perf.createdAt) : new Date(), updatedAt: new Date(), }, })); await performanceFirestore.batchUpdate(migrationOps); localStorage.removeItem("vocabularyPerformance"); if (AppConfig.app.environment === "development") { console.log( `📊 Migrated ${parsedPerformance.length} performance records to Firebase` ); } } } catch (error) { console.warn("Failed to migrate performance data:", error); } } setIsInitialized(true); setLastSync(new Date()); if (AppConfig.app.environment === "development") { console.log("📊 usePerformance initialized with Firebase"); } } catch (error) { console.error("Failed to initialize performance:", error); } finally { setIsProcessing(false); } }, [performanceFirestore.data, performanceFirestore.batchUpdate]); const calculateWordStatus = useCallback( (performance: WordPerformanceWithId): WordPerformanceStatus => { const totalAttempts = performance.attempts.length; const correctAttempts = performance.attempts.filter( (a) => a.correct ).length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const averageResponseTime = totalAttempts > 0 ? performance.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; if (totalAttempts === 0) return "new"; if (totalAttempts < 3) return "promising"; if (accuracy >= 90 && averageResponseTime <= 3000) return "consolidated"; if ( accuracy >= 70 && performance.attempts.slice(-5).every((a) => a.correct) ) { return "improving"; } if ( accuracy < 40 || performance.attempts.slice(-3).every((a) => !a.correct) ) { return "critical"; } if (accuracy < 60) return "struggling"; const recentAttempts = performance.attempts.slice(-10); if (recentAttempts.length >= 5) { const correctCount = recentAttempts.filter((a) => a.correct).length; const inconsistencyRatio = Math.abs(correctCount - recentAttempts.length / 2) / recentAttempts.length; if (inconsistencyRatio < 0.3) return "inconsistent"; } return "promising"; }, [] ); const updateWordPerformance = useCallback( async ( wordId: string, input: UpdatePerformanceInput ): Promise<UpdatePerformanceResult> => { try { setIsProcessing(true); const existingPerformance = performanceFirestore.data.find( (p) => p.english === wordId ); const newAttempt: ExtendedPerformanceAttempt = { correct: input.isCorrect, timeSpent: input.timeSpent, timestamp: new Date().toISOString(), usedHint: false, }; let updatedPerformance: WordPerformanceWithId; if (existingPerformance) { const newAttempts = [...existingPerformance.attempts, newAttempt]; const totalAttempts = newAttempts.length; const correctAttempts = newAttempts.filter((a) => a.correct).length; const updatedData = { attempts: newAttempts, totalAttempts, correctAttempts, accuracy: (correctAttempts / totalAttempts) * 100, averageResponseTime: newAttempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts, lastAttemptAt: new Date(), updatedAt: new Date(), }; updatedPerformance = await performanceFirestore.update( existingPerformance.id, updatedData ); } else { const newPerformanceData: Omit<WordPerformanceWithId, "id"> = { english: wordId, wordId: wordId, italian: "", attempts: [newAttempt], totalAttempts: 1, correctAttempts: input.isCorrect ? 1 : 0, accuracy: input.isCorrect ? 100 : 0, averageResponseTime: input.timeSpent, lastAttemptAt: new Date(), createdAt: new Date(), updatedAt: new Date(), }; updatedPerformance = await performanceFirestore.create( newPerformanceData ); } analyticsCache.current = null; setLastSync(new Date()); return { success: true, updatedPerformance, }; } catch (error) { return { success: false, error: (error as Error).message, }; } finally { setIsProcessing(false); } }, [ performanceFirestore.data, performanceFirestore.update, performanceFirestore.create, ] ); const recordTestResults = useCallback( async ( testResult: TestResult, words: Word[] ): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); const totalTime = testResult.completedSession?.timeMetrics?.totalTestTime || 0; const averageTimePerWord = words.length > 0 ? totalTime / words.length : 0; const updates: Array<{ wordId: string; input: UpdatePerformanceInput; }> = []; for (const word of words) { const wasCorrect = !testResult.analytics?.insights?.some( (insight: any) => insight.type === "weakness" && insight.data?.wordId === word.id ) && !testResult.exportData?.detailedAnswers?.some( (answer: any) => answer.word?.id === word.id && !answer.result?.correct ); updates.push({ wordId: word.english, input: { word: { english: word.english, italian: word.italian, chapter: word.chapter || "", id: word.id, }, isCorrect: wasCorrect, timeSpent: averageTimePerWord, usedHint: false, }, }); } await bulkUpdatePerformances(updates); return { success: true, metadata: { operation: "recordTestResults", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "recordTestResults", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [] ); const bulkUpdatePerformances = useCallback( async ( updates: Array<{ wordId: string; input: UpdatePerformanceInput }> ): Promise<OperationResult<WordPerformanceWithId[]>> => { const startTime = Date.now(); try { setIsProcessing(true); const updatedPerformances: WordPerformanceWithId[] = []; const batchSize = 10; for (let i = 0; i < updates.length; i += batchSize) { const batch = updates.slice(i, i + batchSize); const batchPromises = batch.map(async ({ wordId, input }) => { const result = await updateWordPerformance(wordId, input); if (result.updatedPerformance) { updatedPerformances.push( result.updatedPerformance as WordPerformanceWithId ); } return result; }); await Promise.all(batchPromises); } analyticsCache.current = null; setLastSync(new Date()); return { success: true, data: updatedPerformances, metadata: { operation: "bulkUpdatePerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "bulkUpdatePerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [updateWordPerformance] ); const analyzeWordDifficulty = useCallback( async ( wordId: string ): Promise<OperationResult<TestDifficultyAnalysis>> => { const startTime = Date.now(); try { const performance = performanceFirestore.data.find( (p) => p.english === wordId ); if (!performance || performance.attempts.length === 0) { return { success: false, error: { code: "not-found" as any, message: "No performance data available for this word", operation: "analyze-difficulty" as any, recoverable: false, timestamp: new Date(), } as any, metadata: { operation: "analyzeWordDifficulty", timestamp: new Date(), duration: Date.now() - startTime, }, }; } const correctAttempts = performance.attempts.filter( (a) => a.correct ).length; const totalAttempts = performance.attempts.length; const accuracy = (correctAttempts / totalAttempts) * 100; const averageResponseTime = performance.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts; const accuracyScore = accuracy / 100; const speedScore = Math.max(0, 1 - averageResponseTime / 10000); const consistencyScore = totalAttempts >= 5 ? 1 - Math.abs(accuracy - 50) / 50 : 0.5; const weightedScore = accuracyScore * 0.5 + speedScore * 0.3 + consistencyScore * 0.2; let difficultyCategory: "easy" | "medium" | "hard"; let difficultyReason: string; if (weightedScore >= 0.7) { difficultyCategory = "easy"; difficultyReason = "High accuracy and quick response times"; } else if (weightedScore >= 0.4) { difficultyCategory = "medium"; difficultyReason = "Moderate performance with room for improvement"; } else { difficultyCategory = "hard"; difficultyReason = "Low accuracy or slow response times indicate difficulty"; } const totalWords = performanceFirestore.data.length; const hardWords = performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter((a) => a.correct).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const avgTime = totalAttempts > 0 ? p.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; const score = (accuracy / 100) * 0.5 + Math.max(0, 1 - avgTime / 10000) * 0.3 + 0.1; return score < 0.4; }).length; const easyWords = performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter((a) => a.correct).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const avgTime = totalAttempts > 0 ? p.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; const score = (accuracy / 100) * 0.5 + Math.max(0, 1 - avgTime / 10000) * 0.3 + 0.1; return score >= 0.7; }).length; const mediumWords = totalWords - hardWords - easyWords; const analysis: TestDifficultyAnalysis = { difficulty: difficultyCategory, difficultyReason, weightedScore, totalWords, sizeAdjustment: 1.0, distribution: { hard: { count: hardWords, percentage: totalWords > 0 ? Math.round((hardWords / totalWords) * 100) : 0, }, medium: { count: mediumWords, percentage: totalWords > 0 ? Math.round((mediumWords / totalWords) * 100) : 0, }, easy: { count: easyWords, percentage: totalWords > 0 ? Math.round((easyWords / totalWords) * 100) : 0, }, }, statusBreakdown: { new: performanceFirestore.data.filter( (p) => p.attempts.length === 0 ).length, promising: performanceFirestore.data.filter( (p) => p.attempts.length < 3 ).length, struggling: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy < 60; }).length, improving: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy >= 60 && accuracy < 80; }).length, consolidated: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy >= 80; }).length, critical: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy < 40; }).length, inconsistent: 0, }, }; return { success: true, data: analysis, metadata: { operation: "analyzeWordDifficulty", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "analyzeWordDifficulty", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [performanceFirestore.data] ); const resetWordPerformance = useCallback( async (wordId: string): Promise<OperationResult<void>> => { const startTime = Date.now(); try { const performance = performanceFirestore.data.find( (p) => p.english === wordId ); if (!performance) { return { success: false, error: { code: "firestore/not-found" as any, message: "Performance record not found", operation: "delete" as any, recoverable: false, timestamp: new Date(), }, metadata: { operation: "resetWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } await performanceFirestore.remove(performance.id); analyticsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "resetWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "resetWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [performanceFirestore.data, performanceFirestore.remove] ); const resetAllPerformances = useCallback(async (): Promise< OperationResult<void> > => { const startTime = Date.now(); try { setIsProcessing(true); const deleteOps = performanceFirestore.data.map((perf) => ({ type: "delete" as const, id: perf.id, })); if (deleteOps.length > 0) { await performanceFirestore.batchUpdate(deleteOps); } analyticsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "resetAllPerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "resetAllPerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [performanceFirestore.data, performanceFirestore.batchUpdate]); const refreshData = useCallback(() => { performanceFirestore.fetch(); analyticsCache.current = null; setLastSync(new Date()); }, [performanceFirestore.fetch]); const getWordPerformance = useCallback( (wordId: string): WordPerformanceWithId | null => { return ( performanceFirestore.data.find((p) => p.english === wordId) || null ); }, [performanceFirestore.data] ); const getWordAnalysis = useCallback( (wordId: string): WordPerformanceAnalysis | null => { const performance = getWordPerformance(wordId); if (!performance) return null; const status = calculateWordStatus(performance); const totalAttempts = performance.attempts.length; const correctAttempts = performance.attempts.filter( (a) => a.correct ).length; const incorrectAttempts = totalAttempts - correctAttempts; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const hintsUsed = performance.attempts.filter((a) => a.usedHint).length; return { id: performance.id, english: performance.english, italian: performance.italian || "", chapter: performance.chapter || "", group: "", sentence: "", notes: "", learned: false, difficult: false, status, attempts: performance.attempts, totalAttempts, correctAttempts, incorrectAttempts, accuracy: Math.round(accuracy), hintsUsed, hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0, currentStreak: 0, lastAttempt: performance.attempts.length > 0 ? performance.attempts[performance.attempts.length - 1] : { correct: false, timeSpent: 0, timestamp: new Date().toISOString(), usedHint: false, }, recentAccuracy: Math.round(accuracy), avgTime: Math.round(performance.averageResponseTime / 1000), trend: "stable" as const, difficulty: accuracy < 50 ? "hard" : accuracy < 80 ? "medium" : "easy", needsWork: accuracy < 70, mastered: accuracy >= 90, recommendations: [], }; }, [getWordPerformance, calculateWordStatus] ); const getWordsNeedingWork = useCallback( (limit = 10): WordPerformanceAnalysis[] => { const analyses = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ) .filter( (analysis) => analysis.status === "struggling" || analysis.status === "critical" || analysis.status === "inconsistent" ) .sort((a, b) => { const urgencyOrder = { critical: 3, struggling: 2, inconsistent: 1 }; return ( urgencyOrder[b.status as keyof typeof urgencyOrder] - urgencyOrder[a.status as keyof typeof urgencyOrder] ); }); return analyses.slice(0, limit); }, [performanceFirestore.data, getWordAnalysis] ); const getWordsByStatus = useCallback( (status: WordPerformanceStatus): WordPerformanceAnalysis[] => { return performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null && analysis.status === status ); }, [performanceFirestore.data, getWordAnalysis] ); const getPerformanceTrends = useCallback( (wordId: string): WordPerformanceTrends | null => { const performance = getWordPerformance(wordId); if (!performance || performance.attempts.length < 5) return null; const recentAttempts = performance.attempts.slice(-10); const olderAttempts = performance.attempts.slice(0, -10); if (olderAttempts.length === 0) return null; const recentAccuracy = recentAttempts.filter((a) => a.correct).length / recentAttempts.length; const olderAccuracy = olderAttempts.filter((a) => a.correct).length / olderAttempts.length; const recentSpeed = recentAttempts.reduce((sum, a) => sum + a.timeSpent, 0) / recentAttempts.length; const olderSpeed = olderAttempts.reduce((sum, a) => sum + a.timeSpent, 0) / olderAttempts.length; const speedTrend: SimpleTrend = { direction: recentSpeed < olderSpeed ? "improving" : recentSpeed > olderSpeed ? "declining" : "stable", sampleSize: recentAttempts.length, confidence: Math.min(90, performance.attempts.length * 10), }; const accuracyTrend: SimpleTrend = { direction: recentAccuracy > olderAccuracy ? "improving" : recentAccuracy < olderAccuracy ? "declining" : "stable", sampleSize: recentAttempts.length, confidence: Math.min(90, performance.attempts.length * 10), }; const hintTrend: SimpleTrend = { direction: "stable", sampleSize: recentAttempts.length, confidence: 50, }; return { accuracyTrend, speedTrend, hintTrend, analysisperiod: 30, }; }, [getWordPerformance] ); const getGlobalStats = useCallback((): GlobalPerformanceStats => { const analyses = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ); const statusDistribution: Record<WordPerformanceStatus, number> = { new: 0, promising: 0, struggling: 0, consolidated: 0, improving: 0, critical: 0, inconsistent: 0, }; analyses.forEach((analysis) => { statusDistribution[analysis.status]++; }); const averageResponseTime = analyses.length > 0 ? analyses.reduce((sum, analysis) => { return sum + analysis.avgTime * 1000; }, 0) / analyses.length : 0; const averageAccuracy = analyses.length > 0 ? analyses.reduce((sum, analysis) => sum + analysis.accuracy, 0) / analyses.length : 0; const averageHintUsage = analyses.length > 0 ? analyses.reduce( (sum, analysis) => sum + analysis.hintsPercentage, 0 ) / analyses.length : 0; const wordsNeedingWork = statusDistribution.struggling + statusDistribution.critical + statusDistribution.inconsistent; const masteredWords = analyses.filter( (analysis) => analysis.mastered ).length; return { statusDistribution, totalWordsTracked: analyses.length, averageResponseTime: Math.round(averageResponseTime), averageAccuracy: Math.round(averageAccuracy), averageHintUsage: Math.round(averageHintUsage), wordsNeedingWork, masteredWords, }; }, [performanceFirestore.data, getWordAnalysis]); const getCategorizedWords = useCallback((): Record< WordPerformanceStatus, WordPerformanceAnalysis[] > => { const analyses = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ); const categorized: Record< WordPerformanceStatus, WordPerformanceAnalysis[] > = { new: [], promising: [], struggling: [], consolidated: [], improving: [], critical: [], inconsistent: [], }; analyses.forEach((analysis) => { categorized[analysis.status].push(analysis); }); return categorized; }, [performanceFirestore.data, getWordAnalysis]); const getRecommendedWords = useCallback( (count = 5): WordPerformanceAnalysis[] => { const wordsNeedingWork = getWordsNeedingWork(count * 2); const improvingWords = getWordsByStatus("improving"); const recommended = [ ...wordsNeedingWork.slice(0, Math.ceil(count * 0.7)), ...improvingWords.slice(0, Math.floor(count * 0.3)), ]; return recommended.slice(0, count); }, [getWordsNeedingWork, getWordsByStatus] ); const analytics = useMemo<PerformanceAnalytics>(() => { const now = Date.now(); if ( analyticsCache.current && now - analyticsCache.current.timestamp < ANALYTICS_CACHE_TTL ) { return analyticsCache.current.analytics; } const globalPerformanceStats = getGlobalStats(); const wordLevelInsights = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ); const performanceDistribution = globalPerformanceStats.statusDistribution; const improving = performanceDistribution.improving + performanceDistribution.promising; const declining = performanceDistribution.struggling + performanceDistribution.critical; const stable = performanceDistribution.consolidated + performanceDistribution.inconsistent; const analyticsData: PerformanceAnalytics = { globalPerformanceStats, wordLevelInsights, performanceDistribution, trendsAnalysis: { improving, declining, stable, }, }; analyticsCache.current = { analytics: analyticsData, timestamp: now }; return analyticsData; }, [performanceFirestore.data, getGlobalStats, getWordAnalysis]); return { performances: performanceFirestore.data, isInitialized, isLoading: performanceFirestore.loading, isProcessing, lastSync: lastSync || performanceFirestore.lastSync, error: performanceFirestore.error, fromCache: performanceFirestore.fromCache, updateWordPerformance, recordTestResults, analyzeWordDifficulty, bulkUpdatePerformances, resetWordPerformance, resetAllPerformances, refreshData, getWordPerformance, getWordAnalysis, getWordsNeedingWork, getWordsByStatus, getPerformanceTrends, getGlobalStats, getCategorizedWords, getRecommendedWords, analytics, }; }; export default usePerformance;

================================================================================

NOME FILE: data\useStats.ts

import { useState, useEffect, useCallback, useMemo, useRef } from "react"; import { useFirestore } from "../core/useFirestore"; import { useFirebase } from "../../contexts/FirebaseContext"; import AppConfig from "../../config/appConfig"; import { StatsAnalyticsService } from "../../services/statsAnalyticsService"; import type { Statistics, DailyProgressAggregated, MonthlyStatsAggregated, AggregatedCalculatedStatistics, LearningTrendsAnalysis, WeeklyProgressAnalysis, ComprehensiveStatisticsExportData, CategoryProgressAggregated, DifficultyStatsAggregated, } from "../../types/entities/Statistics.types"; import type { TestResult } from "../../types/entities/Test.types"; import type { Word } from "../../types/entities/Word.types"; import type { WordPerformance, PerformanceAttempt, WordPerformanceAnalysis, } from "../../types/entities/Performance.types"; import type { CreateInput, UpdateInput, OperationResult, } from "../../types/index"; import type { FirestoreError } from "../../types/infrastructure/Firestore.types"; const EMPTY_ARRAY: TestResult[] = []; const INITIAL_WORD_PERFORMANCE: Record<string, WordPerformance> = {}; const INITIAL_CATEGORIES_PROGRESS: Record<string, CategoryProgressAggregated> = {}; const INITIAL_DIFFICULTY_STATS: DifficultyStatsAggregated = { wordDifficulty: { critical: 0, struggling: 0, improving: 0, consolidated: 0, mastered: 0, }, testDifficulty: { easy: { testsCompleted: 0, averageScore: 0, averageAccuracy: 0 }, medium: { testsCompleted: 0, averageScore: 0, averageAccuracy: 0 }, hard: { testsCompleted: 0, averageScore: 0, averageAccuracy: 0 }, }, difficultyTrends: { overallDifficultyRating: 50, improvementRate: 0, masteryProgression: 0, }, }; const INITIAL_STATS: Omit<Statistics, "id"> = { totalWords: 0, correctAnswers: 0, incorrectAnswers: 0, hintsUsed: 0, averageScore: 0, testsCompleted: 0, timeSpent: 0, categoriesProgress: INITIAL_CATEGORIES_PROGRESS, dailyProgress: {}, streakDays: 0, lastStudyDate: null, difficultyStats: INITIAL_DIFFICULTY_STATS, monthlyStats: {}, migrated: false, }; interface StatsState { stats: Statistics; testHistory: TestResult[]; wordPerformance: Record<string, WordPerformance>; isInitialized: boolean; isLoading: boolean; isProcessing: boolean; lastSync: Date | null; error: FirestoreError | null; fromCache: boolean; } interface StatsOperations { handleTestComplete: ( testStats: any, testWords: Word[], wrongWords: Word[] ) => Promise<OperationResult<void>>; addTestToHistory: (testResult: TestResult) => Promise<OperationResult<void>>; recordWordPerformance: ( wordId: string, attempt: PerformanceAttempt ) => Promise<OperationResult<WordPerformance>>; refreshData: () => void; resetStats: () => Promise<OperationResult<void>>; clearHistoryOnly: () => Promise<OperationResult<void>>; exportData: () => ComprehensiveStatisticsExportData; importData: ( data: ComprehensiveStatisticsExportData ) => Promise<OperationResult<void>>; } interface StatsGetters { getAllWordsPerformance: () => WordPerformanceAnalysis[]; getWordAnalysis: (wordId: string) => WordPerformanceAnalysis | null; calculatedStats: AggregatedCalculatedStatistics; totalTests: number; totalAnswers: number; accuracyRate: number; hintsRate: number; weeklyProgress: WeeklyProgressAnalysis | null; isMigrated: boolean; } interface StatsResult extends StatsState, StatsOperations, StatsGetters {} const CACHE_TTL = 5 * 60 * 1000; export const useStats = (): StatsResult => { const analyticsService = useMemo(() => new StatsAnalyticsService(), []); const statsFirestore = useFirestore<Statistics & { id: string }>({ collection: "statistics", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyStats", debug: process.env.NODE_ENV === "development", }); const performanceFirestore = useFirestore<WordPerformance & { id: string }>({ collection: "performance", realtime: false, enableCache: true, autoFetch: true, debug: process.env.NODE_ENV === "development", }); const { isReady } = useFirebase(); const [testHistory, setTestHistory] = useState<TestResult[]>(EMPTY_ARRAY); const [wordPerformance, setWordPerformance] = useState< Record<string, WordPerformance> >(INITIAL_WORD_PERFORMANCE); const [isProcessing, setIsProcessing] = useState(false); const [lastSync, setLastSync] = useState<Date | null>(null); const calculatedStatsCache = useRef<{ stats: AggregatedCalculatedStatistics; timestamp: number; } | null>(null); const currentStats = statsFirestore.data[0] || { id: "temp", ...INITIAL_STATS, }; const isInitialized = statsFirestore.data.length > 0 && isReady; const createCompletePerformanceAttempt = ( correct: boolean, timeSpent: number, usedHint: boolean = false ): PerformanceAttempt => ({ correct, timeSpent, timestamp: new Date().toISOString(), usedHint, }); const createCompleteWordPerformance = ( english: string, italian: string = "", chapter: string = "", attempts: PerformanceAttempt[] = [] ): WordPerformance => ({ wordId: english, english, italian, chapter, attempts, }); const handleTestComplete = useCallback( async ( testStats: any, testWords: Word[], wrongWords: Word[] ): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); const testResult: TestResult = { testId: `test_${Date.now()}`, userId: currentStats.id || "temp", completedSession: { currentQuestion: null, timeMetrics: { totalTestTime: testStats.timeSpent || 0, averageQuestionTime: (testStats.timeSpent || 0) / testWords.length, fastestQuestion: 1000, slowestQuestion: 5000, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 2000, p50: 3000, p75: 4000, p90: 5000, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }, progress: { basic: { questionsAnswered: testWords.length, questionsRemaining: 0, currentQuestion: testWords.length, totalQuestions: testWords.length, completionPercentage: 100, }, performance: { correctAnswers: testStats.correct || 0, currentAccuracy: ((testStats.correct || 0) / testWords.length) * 100, incorrectAnswers: testStats.incorrect || 0, currentStreak: 0, bestStreak: 0, efficiency: 0, currentScore: 0, }, predictions: { predictedFinalAccuracy: testStats.score || 0, confidence: 0.8, estimatedTimeToCompletion: 0, predictedFinalScore: testStats.score || 0, }, milestones: [], }, wordPool: { allWords: testWords, usedWords: testWords, incorrectWords: wrongWords, remainingWords: [], currentIndex: testWords.length, selectionStrategy: "random", }, answerHistory: testWords.map((word, index) => ({ id: `answer_${index}`, questionId: word.id!, wordId: word.id!, result: { isCorrect: !wrongWords.some((w) => w.id === word.id), confidence: 0.8, }, hintsUsed: [], timing: { startedAt: new Date(), cardFlippedAt: new Date(), declaredAt: new Date(), totalTime: Math.random() * 5000 + 1000, thinkingTime: Math.random() * 3000 + 500, declarationTime: Math.random() * 1000 + 500, }, metadata: { timeOfDay: "afternoon", sessionPosition: index + 1, contextFactors: [], }, })), hintSystem: { globalState: { totalHintsUsed: testStats.hints || 0, hintsRemaining: 5, usagePattern: { preferredType: "balanced", frequency: "moderate", effectiveness: { sentence: 0.8, synonym: 0.7, }, }, }, config: { enabled: true, maxHintsPerQuestion: 2, cooldownBetweenHints: 0, availableHintTypes: ["sentence", "synonym"], hintCosts: { sentence: 1, synonym: 1, }, }, statistics: { usage: { sentence: testStats.hints || 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, }, }, config: { mode: "normal", hints: { enabled: true, maxHintsPerQuestion: 2, cooldownBetweenHints: 0, availableHintTypes: ["sentence", "synonym"], hintCosts: { sentence: 1, synonym: 1, }, }, wordSelection: { categories: [], chapters: [], unlearnedOnly: false, difficultOnly: false, randomOrder: true, selectionStrategy: "random", }, timing: { autoAdvance: false, showTimer: false, autoAdvanceDelay: 1000, wordTimeLimit: 30000, showMeaning: false, meaningDisplayDuration: 2000, }, ui: { theme: "light" as const, animations: true, showDetailedProgress: true, sounds: false, showRealTimeStats: true, }, scoring: { accuracyWeight: 0.7, speedWeight: 0.3, streakBonus: 0.1, hintPenalty: 0.1, thresholds: { excellent: 90, good: 80, average: 70, }, }, }, finalScore: { total: testStats.score || 0, category: testStats.score >= 90 ? "excellent" : testStats.score >= 80 ? "good" : testStats.score >= 70 ? "average" : "poor", breakdown: { accuracy: ((testStats.correct || 0) / testWords.length) * 100, speed: 50, efficiency: 50, consistency: 50, bonus: 0, penalties: 0, }, }, feedback: { tone: testStats.score >= 80 ? "celebratory" : "encouraging", color: testStats.score >= 80 ? "#22c55e" : "#3b82f6", wordsToReview: wrongWords.map((w) => w.english), message: "Great job!", icon: "check", nextGoals: ["Keep practicing", "Review difficult words"], }, analytics: { insights: [], performancePatterns: { timePatterns: { totalTestTime: testStats.timeSpent || 0, averageQuestionTime: (testStats.timeSpent || 0) / testWords.length, fastestQuestion: 1000, slowestQuestion: 5000, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 2000, p50: 3000, p75: 4000, p90: 5000, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }, accuracyPatterns: { overallAccuracy: ((testStats.correct || 0) / testWords.length) * 100, accuracyByPosition: [], accuracyTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, difficultWordsBias: 0, }, hintPatterns: { usage: { sentence: testStats.hints || 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, categoryPatterns: [], }, recommendations: [], }, exportData: { summary: { testId: `test_${Date.now()}`, duration: testStats.timeSpent || 0, totalQuestions: testWords.length, correctAnswers: testStats.correct || 0, accuracy: ((testStats.correct || 0) / testWords.length) * 100, hintsUsed: testStats.hints || 0, averageTime: (testStats.timeSpent || 0) / testWords.length, score: testStats.score || 0, category: testStats.score >= 90 ? "excellent" : testStats.score >= 80 ? "good" : testStats.score >= 70 ? "average" : "poor", }, detailedAnswers: [], analytics: { insights: [], performancePatterns: { timePatterns: { totalTestTime: testStats.timeSpent || 0, averageQuestionTime: (testStats.timeSpent || 0) / testWords.length, fastestQuestion: 1000, slowestQuestion: 5000, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 2000, p50: 3000, p75: 4000, p90: 5000, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }, accuracyPatterns: { overallAccuracy: ((testStats.correct || 0) / testWords.length) * 100, accuracyByPosition: [], accuracyTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, difficultWordsBias: 0, }, hintPatterns: { usage: { sentence: testStats.hints || 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, categoryPatterns: [], }, recommendations: [], }, exportedAt: new Date(), format: "json", }, }; setTestHistory((prev) => [...prev, testResult]); for (const word of testWords) { const isWrong = wrongWords.some((w) => w.id === word.id); const attempt = createCompletePerformanceAttempt( !isWrong, Math.random() * 5000 + 1000, false ); const existingPerf = wordPerformance[word.english]; if (existingPerf) { const updatedPerf: WordPerformance = { ...existingPerf, attempts: [...existingPerf.attempts, attempt], }; setWordPerformance((prev) => ({ ...prev, [word.english]: updatedPerf, })); const perfDoc = performanceFirestore.data.find( (p) => p.english === word.english ); if (perfDoc) { await performanceFirestore.update(perfDoc.id, updatedPerf); } else { await performanceFirestore.create(updatedPerf); } } else { const newPerf = createCompleteWordPerformance( word.english, word.italian, word.chapter, [attempt] ); setWordPerformance((prev) => ({ ...prev, [word.english]: newPerf, })); await performanceFirestore.create(newPerf); } } const updatedStats = { ...currentStats, testsCompleted: currentStats.testsCompleted + 1, totalWords: currentStats.totalWords + testWords.length, correctAnswers: currentStats.correctAnswers + (testStats.correct || 0), incorrectAnswers: currentStats.incorrectAnswers + (testStats.incorrect || 0), hintsUsed: currentStats.hintsUsed + (testStats.hints || 0), timeSpent: currentStats.timeSpent + (testStats.timeSpent || 0), averageScore: (currentStats.averageScore * currentStats.testsCompleted + (testStats.score || 0)) / (currentStats.testsCompleted + 1), lastStudyDate: new Date().toISOString(), }; if (statsFirestore.data[0]) { await statsFirestore.update(statsFirestore.data[0].id, updatedStats); } else { await statsFirestore.create(updatedStats); } calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "handleTestComplete", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "handleTestComplete", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [statsFirestore, performanceFirestore, currentStats, wordPerformance] ); const addTestToHistory = useCallback( async (testResult: TestResult): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setTestHistory((prev) => [...prev, testResult]); calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "addTestToHistory", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "addTestToHistory", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [] ); const recordWordPerformance = useCallback( async ( wordId: string, attempt: PerformanceAttempt ): Promise<OperationResult<WordPerformance>> => { const startTime = Date.now(); try { setIsProcessing(true); const existingPerf = wordPerformance[wordId]; let updatedPerf: WordPerformance; if (existingPerf) { updatedPerf = { ...existingPerf, attempts: [...existingPerf.attempts, attempt], }; } else { updatedPerf = createCompleteWordPerformance(wordId, "", "", [ attempt, ]); } setWordPerformance((prev) => ({ ...prev, [wordId]: updatedPerf, })); const perfDoc = performanceFirestore.data.find( (p) => p.english === wordId ); if (perfDoc) { await performanceFirestore.update(perfDoc.id, updatedPerf); } else { await performanceFirestore.create(updatedPerf); } calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, data: updatedPerf, metadata: { operation: "recordWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "recordWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [wordPerformance, performanceFirestore] ); const refreshData = useCallback(() => { statsFirestore.refresh(); performanceFirestore.refresh(); calculatedStatsCache.current = null; setLastSync(new Date()); }, [statsFirestore, performanceFirestore]); const resetStats = useCallback(async (): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); const deleteOps = performanceFirestore.data.map((perf) => ({ type: "delete" as const, id: perf.id, })); if (deleteOps.length > 0) { await performanceFirestore.batchUpdate(deleteOps); } if (statsFirestore.data[0]) { await statsFirestore.update(statsFirestore.data[0].id, INITIAL_STATS); } setTestHistory([]); setWordPerformance({}); calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "resetStats", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "resetStats", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [statsFirestore, performanceFirestore]); const clearHistoryOnly = useCallback(async (): Promise< OperationResult<void> > => { const startTime = Date.now(); try { setTestHistory([]); calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "clearHistoryOnly", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "clearHistoryOnly", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, []); const exportData = useCallback((): ComprehensiveStatisticsExportData => { const wordPerformanceAnalyses = getAllWordsPerformance(); return analyticsService.createComprehensiveExportData( currentStats, testHistory, wordPerformanceAnalyses ); }, [currentStats, testHistory, analyticsService]); const importData = useCallback( async ( data: ComprehensiveStatisticsExportData ): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); if (data.statistics) { if (statsFirestore.data[0]) { await statsFirestore.update( statsFirestore.data[0].id, data.statistics ); } else { await statsFirestore.create(data.statistics); } } if (data.sourceData?.testResults) { setTestHistory(data.sourceData.testResults); } if (data.sourceData?.wordPerformances) { const performanceMap: Record<string, WordPerformance> = {}; const deleteOps = performanceFirestore.data.map((perf) => ({ type: "delete" as const, id: perf.id, })); if (deleteOps.length > 0) { await performanceFirestore.batchUpdate(deleteOps); } const createOps = data.sourceData.wordPerformances.map( (analysis) => ({ type: "create" as const, data: createCompleteWordPerformance( analysis.english, analysis.italian, analysis.chapter, analysis.attempts ), }) ); if (createOps.length > 0) { await performanceFirestore.batchUpdate(createOps); } data.sourceData.wordPerformances.forEach((analysis) => { performanceMap[analysis.english] = createCompleteWordPerformance( analysis.english, analysis.italian, analysis.chapter, analysis.attempts ); }); setWordPerformance(performanceMap); } calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "importData", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "importData", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [ statsFirestore.data, statsFirestore.update, statsFirestore.create, performanceFirestore.data, performanceFirestore.batchUpdate, ] ); const getAllWordsPerformance = useCallback((): WordPerformanceAnalysis[] => { return Object.values(wordPerformance).map((perf) => { const totalAttempts = perf.attempts.length; const correctAttempts = perf.attempts.filter((a) => a.correct).length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const hintsUsed = perf.attempts.filter((a) => a.usedHint).length; const averageTime = totalAttempts > 0 ? perf.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; return { id: `perf_${perf.english}`, english: perf.english, italian: perf.italian || "", chapter: perf.chapter || "", group: "", sentence: "", notes: "", learned: false, difficult: false, status: accuracy > 80 ? "consolidated" : accuracy > 60 ? "improving" : "struggling", attempts: perf.attempts, totalAttempts, correctAttempts, incorrectAttempts: totalAttempts - correctAttempts, accuracy: Math.round(accuracy), hintsUsed, hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0, currentStreak: 0, lastAttempt: perf.attempts.length > 0 ? perf.attempts[perf.attempts.length - 1] : null, recentAccuracy: Math.round(accuracy), avgTime: Math.round(averageTime / 1000), trend: "stable" as const, difficulty: accuracy < 50 ? "hard" : accuracy < 80 ? "medium" : "easy", needsWork: accuracy < 70, mastered: accuracy >= 90, recommendations: [], }; }); }, [wordPerformance]); const getWordAnalysis = useCallback( (wordId: string): WordPerformanceAnalysis | null => { const perf = wordPerformance[wordId]; if (!perf) return null; const analyses = getAllWordsPerformance(); return analyses.find((analysis) => analysis.english === wordId) || null; }, [wordPerformance, getAllWordsPerformance] ); const calculatedStats = useMemo<AggregatedCalculatedStatistics>(() => { const now = Date.now(); if ( calculatedStatsCache.current && now - calculatedStatsCache.current.timestamp < CACHE_TTL ) { return calculatedStatsCache.current.stats; } const wordPerformanceAnalyses = getAllWordsPerformance(); const stats = analyticsService.calculateAggregatedStatistics( currentStats, testHistory, wordPerformanceAnalyses ); calculatedStatsCache.current = { stats, timestamp: now }; return stats; }, [getAllWordsPerformance, testHistory, currentStats, analyticsService]); const totalTests = currentStats.testsCompleted; const totalAnswers = currentStats.correctAnswers + currentStats.incorrectAnswers; const accuracyRate = totalAnswers > 0 ? (currentStats.correctAnswers / totalAnswers) * 100 : 0; const hintsRate = totalAnswers > 0 ? (currentStats.hintsUsed / totalAnswers) * 100 : 0; const isMigrated = currentStats.migrated || false; const weeklyProgress = useMemo<WeeklyProgressAnalysis | null>(() => { return calculatedStats.temporalAnalytics.weeklyProgress; }, [calculatedStats]); useEffect(() => { if (performanceFirestore.data.length > 0) { const performanceMap: Record<string, WordPerformance> = {}; performanceFirestore.data.forEach((perf) => { performanceMap[perf.english] = perf; }); setWordPerformance(performanceMap); } }, [performanceFirestore.data]); return { stats: currentStats, testHistory, wordPerformance, isInitialized, isLoading: statsFirestore.loading || performanceFirestore.loading, isProcessing, lastSync: lastSync || statsFirestore.lastSync, error: statsFirestore.error || performanceFirestore.error, fromCache: statsFirestore.fromCache, handleTestComplete, addTestToHistory, recordWordPerformance, refreshData, resetStats, clearHistoryOnly, exportData, importData, getAllWordsPerformance, getWordAnalysis, calculatedStats, totalTests, totalAnswers, accuracyRate, hintsRate, weeklyProgress, isMigrated, }; }; export default useStats;

================================================================================

NOME FILE: data\useTest.ts

import { useState, useCallback, useMemo, useRef, useEffect } from "react"; import { useFirebase } from "../../contexts/FirebaseContext"; import AppConfig from "../../config/appConfig"; import type { Test, TestResult, TestMode, TestConfig, } from "../../types/entities/Test.types"; import type { Word } from "../../types/entities/Word.types"; import type { CreateInput, OperationResult } from "../../types/index"; interface TestStats { correct: number; incorrect: number; hints: number; } interface WordTiming { wordId: string; startTime: number; endTime: number; timeSpent: number; usedHint: boolean; } interface TestProgress { current: number; total: number; percentage: number; remaining: number; } interface TestSummary { totalQuestions: number; correctAnswers: number; incorrectAnswers: number; hintsUsed: number; accuracy: number; score: number; timeSpent: number; averageTimePerWord: number; wrongWords: Word[]; } interface TestState { testMode: boolean; showResults: boolean; currentWord: Word | null; testWords: Word[]; usedWordIds: Set<string>; stats: TestStats; wrongWords: Word[]; wordTimes: WordTiming[]; showMeaning: boolean; showHint: boolean; hintUsedForCurrentWord: boolean; isTransitioning: boolean; testSaved: boolean; isInitialized: boolean; error: Error | null; } interface TestOperations { startTest: (words: Word[], config?: Partial<TestConfig>) => void; handleAnswer: (isCorrect: boolean) => void; resetTest: () => void; startNewTest: () => void; toggleHint: () => void; setShowMeaning: (show: boolean) => void; } interface TestGetters { getTestProgress: () => TestProgress; getTestSummary: () => TestSummary; } interface TestHookResult extends TestState, TestOperations, TestGetters {} type TestCompleteCallback = ( testStats: TestStats, testWords: Word[], wrongWords: Word[] ) => void; export const useTest = ( onTestComplete?: TestCompleteCallback ): TestHookResult => { const { isReady } = useFirebase(); const [testMode, setTestMode] = useState<boolean>(false); const [showResults, setShowResults] = useState<boolean>(false); const [currentWord, setCurrentWord] = useState<Word | null>(null); const [testWords, setTestWords] = useState<Word[]>([]); const [usedWordIds, setUsedWordIds] = useState<Set<string>>(new Set()); const [stats, setStats] = useState<TestStats>({ correct: 0, incorrect: 0, hints: 0, }); const [wrongWords, setWrongWords] = useState<Word[]>([]); const [wordTimes, setWordTimes] = useState<WordTiming[]>([]); const [showMeaning, setShowMeaning] = useState<boolean>(false); const [showHint, setShowHint] = useState<boolean>(false); const [hintUsedForCurrentWord, setHintUsedForCurrentWord] = useState<boolean>(false); const [isTransitioning, setIsTransitioning] = useState<boolean>(false); const [testSaved, setTestSaved] = useState<boolean>(false); const [isInitialized, setIsInitialized] = useState<boolean>(false); const [error, setError] = useState<Error | null>(null); const testStartTimeRef = useRef<number | null>(null); const wordStartTimeRef = useRef<number | null>(null); useEffect(() => { if (isReady && !isInitialized) { setIsInitialized(true); if (AppConfig.app.environment === "development") { console.log("🧪 useTest initialized with Firebase"); } } }, [isReady, isInitialized]); const startTest = useCallback( (words: Word[], config?: Partial<TestConfig>) => { try { if (!words || words.length === 0) { throw new Error("No words available for test"); } const testConfig: TestConfig = { mode: "normal", difficulty: "medium", wordSelection: { categories: [], unlearnedOnly: false, randomOrder: true, }, timing: { autoAdvance: true, showMeaning: false, }, ui: { animations: true, showDetailedProgress: true, }, scoring: { speedWeight: 0.3, streakBonus: 0.1, }, ...config, }; let filteredWords = [...words]; if (testConfig.wordSelection.unlearnedOnly) { filteredWords = filteredWords.filter((word) => !word.learned); } if (testConfig.wordSelection.randomOrder) { filteredWords = [...filteredWords].sort(() => Math.random() - 0.5); } const selectedWords = filteredWords; setTestWords(selectedWords); setTestMode(true); setShowResults(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setWrongWords([]); setWordTimes([]); setUsedWordIds(new Set()); setTestSaved(false); setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setIsTransitioning(false); setError(null); testStartTimeRef.current = Date.now(); wordStartTimeRef.current = Date.now(); if (selectedWords.length > 0) { setCurrentWord(selectedWords[0]); setUsedWordIds(new Set([selectedWords[0].id])); } if (AppConfig.app.environment === "development") { console.log(`🧪 Test started with ${selectedWords.length} words`); } } catch (err) { const error = err as Error; setError(error); console.error("Failed to start test:", error); } }, [] ); const recordWordTime = useCallback(() => { if (!currentWord || !wordStartTimeRef.current) return; const endTime = Date.now(); const timeSpent = endTime - wordStartTimeRef.current; const wordTiming: WordTiming = { wordId: currentWord.id, startTime: wordStartTimeRef.current, endTime, timeSpent, usedHint: hintUsedForCurrentWord, }; setWordTimes((prev) => [...prev, wordTiming]); wordStartTimeRef.current = Date.now(); }, [currentWord, hintUsedForCurrentWord]); const nextWord = useCallback(() => { const availableWords = testWords.filter( (word) => !usedWordIds.has(word.id) ); if (availableWords.length === 0) { setCurrentWord(null); return; } const nextWord = availableWords[Math.floor(Math.random() * availableWords.length)]; setCurrentWord(nextWord); setUsedWordIds((prev) => new Set([...prev, nextWord.id])); setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setIsTransitioning(false); wordStartTimeRef.current = Date.now(); }, [testWords, usedWordIds]); const saveTestResultsWithStats = useCallback( (finalStats: TestStats) => { if (testSaved) return; recordWordTime(); const totalTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0; const testResult: TestResult = { id: `test_${Date.now()}`, testId: `test_${Date.now()}`, userId: "current-user", timestamp: new Date(), mode: "normal" as TestMode, totalQuestions: testWords.length, correctAnswers: finalStats.correct, incorrectAnswers: finalStats.incorrect, hintsUsed: finalStats.hints, score: Math.round((finalStats.correct / testWords.length) * 100), accuracy: Math.round((finalStats.correct / testWords.length) * 100), timeSpent: totalTime, duration: totalTime, wordsStudied: testWords.map((w) => w.id), difficulty: "medium" as any, chapters: Array.from( new Set(testWords.map((w) => w.chapter).filter(Boolean)) ), completedSession: { currentQuestion: null, timeMetrics: { startedAt: new Date(testStartTimeRef.current || Date.now()), averageQuestionTime: totalTime / Math.max(testWords.length, 1), slowestQuestion: Math.max(...wordTimes.map((w) => w.timeSpent), 0), speedTrend: { changePercentage: 0, }, }, progress: { performance: { correctAnswers: finalStats.correct, currentStreak: 0, efficiency: finalStats.correct / Math.max(testWords.length, 1), }, milestones: [], }, }, analytics: { incorrectWords: wrongWords.map((w) => w.id), performancePatterns: { accuracyByCategory: {}, timeByCategory: {}, difficultyProgression: [], }, accuracyPatterns: { overallTrend: "stable", categoryBreakdown: {}, timeOfDayEffect: {}, }, insights: [], recommendations: [], feedback: { overall: "Good job!", strengths: [], improvements: [], nextSteps: [], }, }, exportData: { summary: { testId: `test_${Date.now()}`, completedAt: new Date(), duration: totalTime, score: Math.round((finalStats.correct / testWords.length) * 100), accuracy: Math.round((finalStats.correct / testWords.length) * 100), wordsCount: testWords.length, }, detailedResults: [], analytics: { strengths: [], weaknesses: [], recommendations: [], }, }, config: { mode: "normal", difficulty: "medium", wordSelection: { categories: [], unlearnedOnly: false, randomOrder: true, }, timing: { autoAdvance: true, showMeaning: false, }, ui: { animations: true, showDetailedProgress: true, }, scoring: { speedWeight: 0.3, streakBonus: 0.1, }, }, }; if (onTestComplete) { onTestComplete(finalStats, testWords, wrongWords); } setTestSaved(true); if (AppConfig.app.environment === "development") { console.log("🧪 Test completed:", testResult); } }, [ testSaved, testWords, wrongWords, onTestComplete, recordWordTime, wordTimes, ] ); const toggleHint = useCallback(() => { setShowHint((prev) => { const newShowHint = !prev; if (newShowHint && !hintUsedForCurrentWord) { setHintUsedForCurrentWord(true); } return newShowHint; }); }, [hintUsedForCurrentWord]); const handleAnswer = useCallback( (isCorrect: boolean) => { if (!currentWord) return; recordWordTime(); const newStats: TestStats = { correct: stats.correct + (isCorrect ? 1 : 0), incorrect: stats.incorrect + (isCorrect ? 0 : 1), hints: stats.hints + (hintUsedForCurrentWord ? 1 : 0), }; setStats(newStats); if (!isCorrect && currentWord) { const wrongWord = { ...currentWord, usedHint: hintUsedForCurrentWord, }; setWrongWords((prev) => [...prev, wrongWord]); } const totalAnswered = newStats.correct + newStats.incorrect; const isLastQuestion = totalAnswered >= testWords.length; if (isLastQuestion) { saveTestResultsWithStats(newStats); setTestMode(false); setShowResults(true); setCurrentWord(null); } else { setIsTransitioning(true); setTimeout( () => { nextWord(); }, showMeaning ? 1000 : 600 ); } }, [ currentWord, stats, testWords.length, hintUsedForCurrentWord, showMeaning, recordWordTime, saveTestResultsWithStats, nextWord, ] ); const resetTest = useCallback(() => { if (!testSaved && (stats.correct > 0 || stats.incorrect > 0)) { saveTestResultsWithStats(stats); } setTestMode(false); setShowResults(false); setCurrentWord(null); setUsedWordIds(new Set()); setWrongWords([]); setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setTestWords([]); setTestSaved(false); setWordTimes([]); setIsTransitioning(false); setError(null); testStartTimeRef.current = null; wordStartTimeRef.current = null; if (AppConfig.app.environment === "development") { console.log("🧪 Test reset"); } }, [stats, testSaved, saveTestResultsWithStats]); const startNewTest = useCallback(() => { setShowResults(false); setWrongWords([]); setTestSaved(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setUsedWordIds(new Set()); setCurrentWord(null); setWordTimes([]); setIsTransitioning(false); setError(null); startTest(testWords); }, [testWords, startTest]); const getTestProgress = useCallback((): TestProgress => { const totalAnswered = stats.correct + stats.incorrect; const total = testWords.length; return { current: totalAnswered, total, percentage: total > 0 ? Math.round((totalAnswered / total) * 100) : 0, remaining: total - totalAnswered, }; }, [stats.correct, stats.incorrect, testWords.length]); const getTestSummary = useCallback((): TestSummary => { const totalQuestions = testWords.length; const totalAnswered = stats.correct + stats.incorrect; const accuracy = totalAnswered > 0 ? (stats.correct / totalAnswered) * 100 : 0; const score = totalQuestions > 0 ? Math.round((stats.correct / totalQuestions) * 100) : 0; const totalTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : wordTimes.reduce((sum, timing) => sum + timing.timeSpent, 0); const averageTimePerWord = totalAnswered > 0 ? totalTime / totalAnswered : 0; return { totalQuestions, correctAnswers: stats.correct, incorrectAnswers: stats.incorrect, hintsUsed: stats.hints, accuracy: Math.round(accuracy), score, timeSpent: totalTime, averageTimePerWord: Math.round(averageTimePerWord), wrongWords, }; }, [testWords.length, stats, wrongWords, wordTimes]); const progressData = useMemo(() => getTestProgress(), [getTestProgress]); const summaryData = useMemo(() => getTestSummary(), [getTestSummary]); return { testMode, showResults, currentWord, testWords, usedWordIds, stats, wrongWords, wordTimes, showMeaning, showHint, hintUsedForCurrentWord, isTransitioning, testSaved, isInitialized, error, startTest, handleAnswer, resetTest, startNewTest, toggleHint, setShowMeaning, getTestProgress: useCallback(() => progressData, [progressData]), getTestSummary: useCallback(() => summaryData, [summaryData]), }; }; export default useTest;

================================================================================

NOME FILE: data\useWords.ts

import { useState, useCallback, useMemo, useEffect, useRef } from "react"; import { useFirestore } from "../core/useFirestore"; import { useFirebase } from "../../contexts/FirebaseContext"; import AppConfig from "../../config/appConfig"; import type { Word, WordFilters, WordCategory, WordChapter, } from "../../types/entities/Word.types"; import type { CreateInput, UpdateInput, OperationResult, } from "../../types/index"; import type { FirestoreError, FirestoreOperationResult, } from "../../types/infrastructure/Firestore.types"; const EMPTY_ARRAY: Word[] = []; interface WordStats { total: number; learned: number; unlearned: number; difficult: number; normal: number; byChapter: Record<string, number>; byCategory: Record<string, number>; } interface ChapterStats { total: number; learned: number; unlearned: number; difficult: number; normal: number; } interface WordsState { words: Word[]; editingWord: Word | null; loading: boolean; error: FirestoreError | null; refreshTrigger: number; isInitialized: boolean; lastSync: Date | null; fromCache: boolean; } interface WordsOperations { addWord: (wordData: CreateInput<Word>) => Promise<OperationResult<Word>>; removeWord: (wordId: string) => Promise<OperationResult<void>>; updateWord: ( wordId: string, updates: UpdateInput<Word> ) => Promise<OperationResult<Word>>; toggleWordLearned: (wordId: string) => Promise<OperationResult<Word>>; toggleWordDifficult: (wordId: string) => Promise<OperationResult<Word>>; clearAllWords: () => Promise<OperationResult<void>>; importWords: (words: CreateInput<Word>[]) => Promise<OperationResult<Word[]>>; forceRefresh: () => void; setEditingWord: (word: Word | null) => void; } interface WordsGetters { getAvailableChapters: () => string[]; getChapterStats: (chapter: string) => ChapterStats; getFilteredWords: (filters?: WordFilters) => Word[]; getWordsByCategory: (category: WordCategory) => Word[]; searchWords: (searchTerm: string) => Word[]; } interface WordsResult extends WordsState, WordsOperations, WordsGetters { wordStats: WordStats; } export const useWords = (): WordsResult => { const firestoreHook = useFirestore<Word>({ collection: "words", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyWords", debug: AppConfig.app.environment === "development", }); const { isReady } = useFirebase(); const [editingWord, setEditingWord] = useState<Word | null>(null); const [refreshTrigger, setRefreshTrigger] = useState<number>(0); const [isInitialized, setIsInitialized] = useState<boolean>(false); const statsCache = useRef<{ stats: WordStats; timestamp: number } | null>( null ); const STATS_CACHE_TTL = 5000; useEffect(() => { if (isReady && !isInitialized) { setIsInitialized(true); if (AppConfig.app.environment === "development") { console.log("🔄 useWords initialized with Firebase"); } } }, [isReady, isInitialized]); const addWord = useCallback( async (wordData: CreateInput<Word>): Promise<OperationResult<Word>> => { const startTime = Date.now(); try { if (!wordData.english?.trim() || !wordData.italian?.trim()) { throw new Error("English word and Italian translation are required"); } const existingWord = firestoreHook.data.find( (w) => w.english.toLowerCase() === wordData.english.toLowerCase() ); if (existingWord) { throw new Error("Word already exists"); } const wordToCreate = { ...wordData, english: wordData.english.trim(), italian: wordData.italian.trim(), chapter: wordData.chapter || "1", group: wordData.group || "GENERAL", sentences: wordData.sentences || [], synonyms: wordData.synonyms || [], learned: false, difficult: false, createdAt: new Date(), updatedAt: new Date(), }; const createdWord = await firestoreHook.create(wordToCreate); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, data: createdWord, metadata: { operation: "addWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { const firestoreError = error as FirestoreError; return { success: false, error: firestoreError, metadata: { operation: "addWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.create, firestoreHook.data] ); const removeWord = useCallback( async (wordId: string): Promise<OperationResult<void>> => { const startTime = Date.now(); try { await firestoreHook.remove(wordId); if (editingWord?.id === wordId) { setEditingWord(null); } statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, metadata: { operation: "removeWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "removeWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.remove, editingWord?.id] ); const updateWord = useCallback( async ( wordId: string, updates: UpdateInput<Word> ): Promise<OperationResult<Word>> => { const startTime = Date.now(); try { const updatedWord = await firestoreHook.update(wordId, updates); if (editingWord?.id === wordId) { setEditingWord(updatedWord); } statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, data: updatedWord, metadata: { operation: "updateWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "updateWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.update, editingWord?.id] ); const toggleWordLearned = useCallback( async (wordId: string): Promise<OperationResult<Word>> => { const word = firestoreHook.data.find((w) => w.id === wordId); if (!word) { return { success: false, error: { code: "not-found" as any, message: "Word not found", operation: "toggle-learned" as any, recoverable: false, timestamp: new Date(), } as any, metadata: { operation: "toggleWordLearned", timestamp: new Date(), duration: 0, }, }; } return updateWord(wordId, { id: wordId, learned: !word.learned }); }, [firestoreHook.data, updateWord] ); const toggleWordDifficult = useCallback( async (wordId: string): Promise<OperationResult<Word>> => { const word = firestoreHook.data.find((w) => w.id === wordId); if (!word) { return { success: false, error: { code: "not-found" as any, message: "Word not found", operation: "toggle-difficult" as any, recoverable: false, timestamp: new Date(), } as any, metadata: { operation: "toggleWordDifficult", timestamp: new Date(), duration: 0, }, }; } return updateWord(wordId, { id: wordId, difficult: !word.difficult }); }, [firestoreHook.data, updateWord] ); const clearAllWords = useCallback(async (): Promise< OperationResult<void> > => { const startTime = Date.now(); try { const operations = firestoreHook.data.map((word) => ({ type: "delete" as const, id: word.id, })); await firestoreHook.batchUpdate(operations); setEditingWord(null); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, metadata: { operation: "clearAllWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "clearAllWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.data, firestoreHook.batchUpdate]); const importWords = useCallback( async ( wordsToImport: CreateInput<Word>[] ): Promise<OperationResult<Word[]>> => { const startTime = Date.now(); try { const validWords = wordsToImport.filter( (word) => word.english?.trim() && word.italian?.trim() ); if (validWords.length === 0) { throw new Error("No valid words to import"); } const existingEnglishWords = new Set( firestoreHook.data.map((w) => w.english.toLowerCase()) ); const newWords = validWords.filter( (word) => !existingEnglishWords.has(word.english.toLowerCase()) ); if (newWords.length === 0) { throw new Error("All words already exist"); } const operations = newWords.map((word) => ({ type: "create" as const, data: { ...word, english: word.english.trim(), italian: word.italian.trim(), chapter: word.chapter || "1", group: word.group || "GENERAL", sentences: word.sentences || [], synonyms: word.synonyms || [], learned: false, difficult: false, }, })); await firestoreHook.batchUpdate(operations); const createdWords = firestoreHook.data.slice(-newWords.length); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, data: createdWords, metadata: { operation: "importWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "importWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.data, firestoreHook.batchUpdate] ); const forceRefresh = useCallback(() => { firestoreHook.fetch(); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); }, [firestoreHook.fetch]); const wordStats = useMemo<WordStats>(() => { const now = Date.now(); if ( statsCache.current && now - statsCache.current.timestamp < STATS_CACHE_TTL ) { return statsCache.current.stats; } const words = firestoreHook.data; const stats: WordStats = { total: words.length, learned: words.filter((w) => w.learned).length, unlearned: words.filter((w) => !w.learned).length, difficult: words.filter((w) => w.difficult).length, normal: words.filter((w) => !w.difficult && !w.learned).length, byChapter: {}, byCategory: {}, }; words.forEach((word) => { const chapter = word.chapter || "Unknown"; stats.byChapter[chapter] = (stats.byChapter[chapter] || 0) + 1; }); words.forEach((word) => { const category = word.group || "GENERAL"; stats.byCategory[category] = (stats.byCategory[category] || 0) + 1; }); statsCache.current = { stats, timestamp: now }; return stats; }, [firestoreHook.data, refreshTrigger]); const getAvailableChapters = useCallback((): string[] => { const chapters = new Set<string>(); firestoreHook.data.forEach((word) => { if (word.chapter) { chapters.add(word.chapter); } }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); return isNaN(aNum) || isNaN(bNum) ? a.localeCompare(b) : aNum - bNum; }); }, [firestoreHook.data]); const getChapterStats = useCallback( (chapter: string): ChapterStats => { const chapterWords = firestoreHook.data.filter( (word) => word.chapter === chapter ); return { total: chapterWords.length, learned: chapterWords.filter((w) => w.learned).length, unlearned: chapterWords.filter((w) => !w.learned).length, difficult: chapterWords.filter((w) => w.difficult).length, normal: chapterWords.filter((w) => !w.difficult && !w.learned).length, }; }, [firestoreHook.data] ); const getFilteredWords = useCallback( (filters?: WordFilters): Word[] => { if (!filters) return firestoreHook.data; return firestoreHook.data.filter((word) => { if (filters.chapter && word.chapter !== filters.chapter) return false; if ( filters.difficult !== undefined && word.difficult !== filters.difficult ) return false; if (filters.learned !== undefined && word.learned !== filters.learned) return false; if (filters.category && word.group !== filters.category) return false; if (filters.createdAfter && word.createdAt < filters.createdAfter) return false; if (filters.createdBefore && word.createdAt > filters.createdBefore) return false; return true; }); }, [firestoreHook.data] ); const getWordsByCategory = useCallback( (category: WordCategory): Word[] => { return firestoreHook.data.filter((word) => word.group === category); }, [firestoreHook.data] ); const searchWords = useCallback( (searchTerm: string): Word[] => { if (!searchTerm.trim()) return firestoreHook.data; const term = searchTerm.toLowerCase(); return firestoreHook.data.filter( (word) => word.english.toLowerCase().includes(term) || word.italian.toLowerCase().includes(term) || word.sentences?.some((sentence) => sentence.toLowerCase().includes(term) ) || word.synonyms?.some((synonym) => synonym.toLowerCase().includes(term)) ); }, [firestoreHook.data] ); return { words: firestoreHook.data || EMPTY_ARRAY, editingWord, loading: firestoreHook.loading, error: firestoreHook.error, refreshTrigger, isInitialized, lastSync: firestoreHook.lastSync, fromCache: firestoreHook.fromCache, addWord, removeWord, updateWord, toggleWordLearned, toggleWordDifficult, clearAllWords, importWords, forceRefresh, setEditingWord, getAvailableChapters, getChapterStats, getFilteredWords, getWordsByCategory, searchWords, wordStats, }; }; export default useWords;

================================================================================

NOME FILE: integration\useAI.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: integration\useAuth.ts

import { useState, useEffect, useCallback, useRef } from "react"; import { useFirebase } from "../../contexts/FirebaseContext"; import { signUp, signIn, signOutUser, resetPassword, updateAuthProfile, updateUserPassword, getCurrentUser, getCurrentAuthUser, isAuthenticated, onAuthStateChange, createUserSession, updateSessionActivity, validateSession, validateEmail, validatePassword, } from "../../services/authService"; import type { User, AuthState, AuthError, SignUpInput, SignInInput, ResetPasswordInput, UpdateProfileInput, AuthOperationResult, UserSession, } from "../../types/entities/User.types"; import type { AuthUser, AuthSession, UpdatePasswordInput, } from "../../types/infrastructure/Auth.types"; const AUTH_HOOK_CONFIG = { sessionUpdateInterval: 60000, sessionValidationInterval: 300000, maxRetries: 3, retryDelay: 1000, enableDebugLogging: process.env.NODE_ENV === "development", }; const debugLog = (message: string, data?: any) => { if (AUTH_HOOK_CONFIG.enableDebugLogging) { console.log(`🔐 [useAuth] ${message}`, data || ""); } }; const normalizeAuthError = (error: any): AuthError => { if (error && typeof error === "object" && "code" in error) { return error as AuthError; } return { code: "unknown", message: error?.message || "Errore di autenticazione sconosciuto", type: "unknown", timestamp: new Date(), }; }; interface AuthHookState { user: User | null; authUser: AuthUser | null; loading: boolean; initializing: boolean; operationLoading: { signIn: boolean; signUp: boolean; signOut: boolean; resetPassword: boolean; updateProfile: boolean; updatePassword: boolean; }; error: AuthError | null; session: AuthSession | null; lastOperation?: { type: string; timestamp: Date; success: boolean; }; } export const useAuth = () => { const { isReady: firebaseReady, error: firebaseError } = useFirebase(); const [state, setState] = useState<AuthHookState>({ user: null, authUser: null, loading: false, initializing: true, operationLoading: { signIn: false, signUp: false, signOut: false, resetPassword: false, updateProfile: false, updatePassword: false, }, error: null, session: null, }); const authUnsubscribeRef = useRef<(() => void) | null>(null); const sessionTimerRef = useRef<NodeJS.Timeout | null>(null); const isMountedRef = useRef(true); const safeSetState = useCallback( (updater: (prev: AuthHookState) => AuthHookState) => { if (isMountedRef.current) { setState(updater); } }, [] ); const setOperationLoading = useCallback( (operation: keyof AuthHookState["operationLoading"], loading: boolean) => { safeSetState((prev) => ({ ...prev, operationLoading: { ...prev.operationLoading, [operation]: loading, }, })); }, [safeSetState] ); const updateLastOperation = useCallback( (type: string, success: boolean) => { safeSetState((prev) => ({ ...prev, lastOperation: { type, timestamp: new Date(), success, }, })); }, [safeSetState] ); const startSession = useCallback( (authUser: AuthUser) => { const session = createUserSession(authUser); safeSetState((prev) => ({ ...prev, session, })); debugLog("Session started", { sessionId: session.sessionId }); if (sessionTimerRef.current) { clearInterval(sessionTimerRef.current); } sessionTimerRef.current = setInterval(() => { if (isMountedRef.current) { safeSetState((prev) => { if (!prev.session) return prev; const updatedSession = updateSessionActivity(prev.session); if (!validateSession(updatedSession)) { debugLog("Session expired, signing out"); handleSignOut(); return prev; } return { ...prev, session: updatedSession, }; }); } }, AUTH_HOOK_CONFIG.sessionUpdateInterval); }, [safeSetState] ); const endSession = useCallback(() => { if (sessionTimerRef.current) { clearInterval(sessionTimerRef.current); sessionTimerRef.current = null; } safeSetState((prev) => ({ ...prev, session: null, })); debugLog("Session ended"); }, [safeSetState]); const handleSignUp = useCallback( async (input: SignUpInput): Promise<boolean> => { if (!firebaseReady) { debugLog("Firebase not ready for sign up"); return false; } setOperationLoading("signUp", true); try { debugLog("Sign up attempt", { email: input.email }); const result = await signUp({ email: input.email, password: input.password, displayName: input.displayName, acceptTerms: input.acceptTerms, }); if (result.success && result.user) { updateLastOperation("signUp", true); debugLog("Sign up successful"); return true; } else { throw result.error || new Error("Sign up failed"); } } catch (error) { debugLog("Sign up failed", error); safeSetState((prev) => ({ ...prev, error: normalizeAuthError(error), })); updateLastOperation("signUp", false); return false; } finally { setOperationLoading("signUp", false); } }, [firebaseReady, setOperationLoading, updateLastOperation, safeSetState] ); const handleSignIn = useCallback( async (input: SignInInput): Promise<boolean> => { if (!firebaseReady) { debugLog("Firebase not ready for sign in"); return false; } setOperationLoading("signIn", true); try { debugLog("Sign in attempt", { email: input.email }); const result = await signIn({ email: input.email, password: input.password, rememberMe: input.rememberMe, }); if (result.success && result.user) { updateLastOperation("signIn", true); debugLog("Sign in successful"); return true; } else { throw result.error || new Error("Sign in failed"); } } catch (error) { debugLog("Sign in failed", error); safeSetState((prev) => ({ ...prev, error: normalizeAuthError(error), })); updateLastOperation("signIn", false); return false; } finally { setOperationLoading("signIn", false); } }, [firebaseReady, setOperationLoading, updateLastOperation, safeSetState] ); const handleSignOut = useCallback(async (): Promise<boolean> => { setOperationLoading("signOut", true); try { debugLog("Sign out attempt"); const result = await signOutUser(); if (result.success) { updateLastOperation("signOut", true); debugLog("Sign out successful"); return true; } else { throw result.error || new Error("Sign out failed"); } } catch (error) { debugLog("Sign out failed", error); safeSetState((prev) => ({ ...prev, error: normalizeAuthError(error), })); updateLastOperation("signOut", false); return false; } finally { setOperationLoading("signOut", false); } }, [setOperationLoading, updateLastOperation, safeSetState]); const handleResetPassword = useCallback( async (input: ResetPasswordInput): Promise<boolean> => { if (!firebaseReady) { debugLog("Firebase not ready for password reset"); return false; } setOperationLoading("resetPassword", true); try { debugLog("Password reset attempt", { email: input.email }); const result = await resetPassword(input); if (result.success) { updateLastOperation("resetPassword", true); debugLog("Password reset email sent"); return true; } else { throw result.error || new Error("Password reset failed"); } } catch (error) { debugLog("Password reset failed", error); safeSetState((prev) => ({ ...prev, error: normalizeAuthError(error), })); updateLastOperation("resetPassword", false); return false; } finally { setOperationLoading("resetPassword", false); } }, [firebaseReady, setOperationLoading, updateLastOperation, safeSetState] ); const handleUpdateProfile = useCallback( async (input: UpdateProfileInput): Promise<boolean> => { if (!firebaseReady || !state.authUser) { debugLog( "Firebase not ready or user not authenticated for profile update" ); return false; } setOperationLoading("updateProfile", true); try { debugLog("Profile update attempt"); const result = await updateAuthProfile(input); if (result.success && result.user) { updateLastOperation("updateProfile", true); debugLog("Profile update successful"); return true; } else { throw result.error || new Error("Profile update failed"); } } catch (error) { debugLog("Profile update failed", error); safeSetState((prev) => ({ ...prev, error: normalizeAuthError(error), })); updateLastOperation("updateProfile", false); return false; } finally { setOperationLoading("updateProfile", false); } }, [ firebaseReady, state.authUser, setOperationLoading, updateLastOperation, safeSetState, ] ); const handleUpdatePassword = useCallback( async (input: UpdatePasswordInput): Promise<boolean> => { if (!firebaseReady || !state.authUser) { debugLog( "Firebase not ready or user not authenticated for password update" ); return false; } setOperationLoading("updatePassword", true); try { debugLog("Password update attempt"); const result = await updateUserPassword(input); if (result.success) { updateLastOperation("updatePassword", true); debugLog("Password update successful"); return true; } else { throw result.error || new Error("Password update failed"); } } catch (error) { debugLog("Password update failed", error); safeSetState((prev) => ({ ...prev, error: normalizeAuthError(error), })); updateLastOperation("updatePassword", false); return false; } finally { setOperationLoading("updatePassword", false); } }, [ firebaseReady, state.authUser, setOperationLoading, updateLastOperation, safeSetState, ] ); const clearError = useCallback(() => { safeSetState((prev) => ({ ...prev, error: null, })); }, [safeSetState]); const checkAuthenticated = useCallback((): boolean => { return !!state.user && !!state.authUser; }, [state.user, state.authUser]); const getSessionInfo = useCallback(() => { return state.session ? { sessionId: state.session.sessionId, startedAt: state.session.startedAt, duration: state.session.duration, isActive: state.session.isActive, } : null; }, [state.session]); useEffect(() => { if (!firebaseReady) { debugLog("Firebase not ready, skipping auth state listener setup"); return; } debugLog("Setting up auth state listener"); const unsubscribe = onAuthStateChange((user) => { debugLog("Auth state changed", { uid: user?.id || "null", authenticated: !!user, }); if (user) { const authUser = getCurrentAuthUser(); safeSetState((prev) => ({ ...prev, user, authUser, initializing: false, error: null, })); if (authUser) { startSession(authUser); } } else { safeSetState((prev) => ({ ...prev, user: null, authUser: null, initializing: false, })); endSession(); } }); authUnsubscribeRef.current = unsubscribe; return () => { if (authUnsubscribeRef.current) { authUnsubscribeRef.current(); authUnsubscribeRef.current = null; debugLog("Auth state listener cleaned up"); } }; }, [firebaseReady, safeSetState, startSession, endSession]); useEffect(() => { return () => { isMountedRef.current = false; if (authUnsubscribeRef.current) { authUnsubscribeRef.current(); } if (sessionTimerRef.current) { clearInterval(sessionTimerRef.current); } debugLog("Hook cleaned up"); }; }, []); const isLoading = state.loading || state.initializing || Object.values(state.operationLoading).some((loading) => loading); const isReady = firebaseReady && !state.initializing && !isLoading; if (firebaseError) { return { user: null, authUser: null, isAuthenticated: false, loading: false, initializing: false, isReady: false, error: { code: "firebase-init-error", message: "Firebase initialization failed", type: "configuration-error", timestamp: new Date(), } as AuthError, hasError: true, signUp: async () => false, signIn: async () => false, signOut: async () => false, resetPassword: async () => false, updateProfile: async () => false, updatePassword: async () => false, clearError: () => {}, validateEmail, validatePassword, session: null, getSessionInfo: () => null, isSigningIn: false, isSigningUp: false, isSigningOut: false, isResettingPassword: false, isUpdatingProfile: false, isUpdatingPassword: false, lastOperation: undefined, }; } return { authUser: state.authUser, loading: isLoading, isReady, hasError: !!state.error, signIn: handleSignIn, resetPassword: handleResetPassword, updatePassword: handleUpdatePassword, validateEmail, session: state.session, isSigningIn: state.operationLoading.signIn, isSigningOut: state.operationLoading.signOut, isUpdatingProfile: state.operationLoading.updateProfile, lastOperation: state.lastOperation, }; }; export const useAuthState = () => { const { user, authUser, isAuthenticated, loading, initializing, isReady, error, } = useAuth(); return { user, authUser, isAuthenticated, loading, initializing, isReady, error, hasError: !!error, }; }; export const useAuthOperations = () => { const { signUp, signIn, signOut, resetPassword, updateProfile, updatePassword, clearError, validateEmail, validatePassword, isSigningIn, isSigningUp, isSigningOut, isResettingPassword, isUpdatingProfile, isUpdatingPassword, } = useAuth(); return { signUp, signIn, signOut, resetPassword, updateProfile, updatePassword, clearError, validateEmail, validatePassword, isSigningIn, isSigningUp, isSigningOut, isResettingPassword, isUpdatingProfile, isUpdatingPassword, }; }; export const useCurrentUser = () => { const { user, authUser, isAuthenticated, session } = useAuth(); return { user, authUser, isAuthenticated, session, userId: user?.id || null, email: user?.email || null, displayName: user?.displayName || null, emailVerified: user?.emailVerified || false, }; };

================================================================================

NOME FILE: integration\useExport.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: integration\useFileOperations.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: integration\useJSON.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: ui\useFilters.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: ui\useForm.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: ui\useModal.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: ui\useTheme.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================


NOME FILE: useEnhancedStats.js

 // ===================================================== // 📁 src/hooks/useEnhancedStats.js - Enhanced Stats Hook with Error Handling // =====================================================  import { useState, useEffect, useCallback } from 'react'; import { useStorageLoading } from './useLoadingState'; import { enhancedStorageService } from '../services/enhancedStorageService'; import { useNotification } from '../contexts/NotificationContext'; import { retryWithBackoff } from '../utils/retryUtils';  export const useEnhancedStats = () => {   const [stats, setStats] = useState(null);   const [testHistory, setTestHistory] = useState([]);   const [wordPerformance, setWordPerformance] = useState({});   const [isInitialized, setIsInitialized] = useState(false);   const [lastSync, setLastSync] = useState(null);      const storageLoading = useStorageLoading();   const { showError, showSuccess, showWarning } = useNotification();    // ⭐ INITIALIZE DATA with error recovery   const initializeData = useCallback(async () => {     if (isInitialized) return;      try {       storageLoading.startLoading('Caricamento dati utente');              const [statsData, historyData, performanceData] = await Promise.all([         retryWithBackoff(() => enhancedStorageService.getStats(), {           maxAttempts: 3,           baseDelay: 500,           retryCondition: (error) => !error.message.includes('SecurityError')         }),         retryWithBackoff(() => enhancedStorageService.getTestHistory(), {           maxAttempts: 3,           baseDelay: 500         }),         retryWithBackoff(() => enhancedStorageService.get('wordPerformance', {}), {           maxAttempts: 3,           baseDelay: 500         })       ]);        setStats(statsData);       setTestHistory(historyData);       setWordPerformance(performanceData);       setIsInitialized(true);       setLastSync(Date.now());              storageLoading.stopLoading();     } catch (error) {       console.error('❌ Failed to initialize stats data:', error);              // Provide default data on error       setStats({         testsCompleted: 0,         correctAnswers: 0,         incorrectAnswers: 0,         hintsUsed: 0,         timeSpent: 0,         totalWords: 0,         streakDays: 0       });       setTestHistory([]);       setWordPerformance({});       setIsInitialized(true);              storageLoading.setError(error, false);       showError(error, 'Data Initialization');     }   }, [isInitialized, storageLoading, showError]);    // ⭐ SAVE DATA with retry logic   const saveData = useCallback(async (newStats, newHistory, newPerformance) => {     try {       storageLoading.startLoading('Salvataggio dati');              const saveOperations = [];              if (newStats) {         saveOperations.push(() => enhancedStorageService.saveStats(newStats));       }              if (newHistory) {         saveOperations.push(() => enhancedStorageService.saveTestHistory(newHistory));       }              if (newPerformance) {         saveOperations.push(() => enhancedStorageService.set('wordPerformance', newPerformance));       }        // Execute all save operations with retry       await Promise.all(saveOperations.map(op =>          retryWithBackoff(op, {           maxAttempts: 2,           baseDelay: 200,           retryCondition: (error) => !error.name?.includes('QuotaExceededError')         })       ));        // Update state only after successful save       if (newStats) setStats(newStats);       if (newHistory) setTestHistory(newHistory);       if (newPerformance) setWordPerformance(newPerformance);              setLastSync(Date.now());       storageLoading.stopLoading();            } catch (error) {       console.error('❌ Failed to save data:', error);       storageLoading.setError(error, true);              if (error.message.includes('quota')) {         showWarning('💽 Spazio di archiviazione esaurito. Esporta backup ed elimina dati vecchi.');       } else {         showError(error, 'Data Save');       }       throw error;     }   }, [storageLoading, showError, showWarning]);    // ⭐ HANDLE TEST COMPLETION with enhanced error handling   const handleTestComplete = useCallback(async (testStats, testWordsUsed, wrongWordsArray) => {     try {       // Create test record       const testRecord = {         id: Date.now(),         timestamp: new Date().toISOString(),         totalWords: testStats.correct + testStats.incorrect,         correctWords: testStats.correct,         incorrectWords: testStats.incorrect,         hintsUsed: testStats.hints || 0,         totalTime: testStats.totalTime || 0,         percentage: Math.round((testStats.correct / (testStats.correct + testStats.incorrect)) * 100),         wrongWords: [...wrongWordsArray],         wordTimes: testStats.wordTimes || [],         difficulty: testStats.difficulty || 'medium'       };        // Update stats       const newStats = {         ...stats,         testsCompleted: stats.testsCompleted + 1,         correctAnswers: stats.correctAnswers + testStats.correct,         incorrectAnswers: stats.incorrectAnswers + testStats.incorrect,         hintsUsed: (stats.hintsUsed || 0) + (testStats.hints || 0),         timeSpent: stats.timeSpent + (testStats.totalTime || 300), // Default 5 minutes if no time         lastStudyDate: new Date().toISOString().split('T')[0]       };        // Recalculate average score       const totalAnswers = newStats.correctAnswers + newStats.incorrectAnswers;       newStats.averageScore = totalAnswers > 0 ? (newStats.correctAnswers / totalAnswers) * 100 : 0;        // Update test history       const newHistory = [testRecord, ...testHistory].slice(0, 100); // Keep last 100 tests        // Update word performance       const newPerformance = { ...wordPerformance };       if (testStats.wordTimes && Array.isArray(testStats.wordTimes)) {         testStats.wordTimes.forEach(wordTime => {           const word = testWordsUsed.find(w => w.id === wordTime.wordId);           if (word) {             if (!newPerformance[word.id]) {               newPerformance[word.id] = {                 english: word.english,                 italian: word.italian,                 chapter: word.chapter,                 attempts: []               };             }                          newPerformance[word.id].attempts.push({               timestamp: testRecord.timestamp,               correct: wordTime.isCorrect,               usedHint: wordTime.usedHint || false,               timeSpent: wordTime.timeSpent || 0             });              // Keep only last 50 attempts per word             if (newPerformance[word.id].attempts.length > 50) {               newPerformance[word.id].attempts = newPerformance[word.id].attempts.slice(-50);             }           }         });       }        // Save all data       await saveData(newStats, newHistory, newPerformance);              showSuccess(`✅ Test completato! Risultato: ${testRecord.percentage}%`);              return testRecord;     } catch (error) {       console.error('❌ Failed to complete test:', error);       showError(error, 'Test Completion');       throw error;     }   }, [stats, testHistory, wordPerformance, saveData, showSuccess, showError]);    // ⭐ EXPORT DATA with enhanced error handling   const exportData = useCallback(async () => {     try {       storageLoading.startLoading('Preparazione backup completo');              // Get fresh data       const [currentStats, currentHistory, currentPerformance, words] = await Promise.all([         enhancedStorageService.getStats(),         enhancedStorageService.getTestHistory(),         enhancedStorageService.get('wordPerformance', {}),         enhancedStorageService.getWords()       ]);        const exportData = {         words,         stats: currentStats,         testHistory: currentHistory,         wordPerformance: currentPerformance,         exportDate: new Date().toISOString(),         version: '2.4', // Enhanced version         storageStatus: enhancedStorageService.getServiceStatus(),         dataIntegrity: {           wordsCount: words.length,           testsCount: currentHistory.length,           performanceCount: Object.keys(currentPerformance).length,           lastSync: lastSync         }       };              const dataStr = JSON.stringify(exportData, null, 2);       const blob = new Blob([dataStr], { type: 'application/json' });       const url = URL.createObjectURL(blob);              const link = document.createElement('a');       link.href = url;       link.download = `vocabulary-enhanced-backup-v2.4-${new Date().toISOString().split('T')[0]}.json`;       document.body.appendChild(link);       link.click();       document.body.removeChild(link);       URL.revokeObjectURL(url);              storageLoading.stopLoading();       showSuccess(`✅ Backup Enhanced v2.4 esportato! (${words.length} parole + ${currentHistory.length} test)`);            } catch (error) {       storageLoading.setError(error, false);       showError(error, 'Export Data');     }   }, [storageLoading, showSuccess, showError, lastSync]);    // ⭐ IMPORT DATA with enhanced validation   const importData = useCallback(async (file) => {     return new Promise((resolve, reject) => {       const reader = new FileReader();              reader.onload = async (e) => {         try {           storageLoading.startLoading('Importazione dati');                      const importedData = JSON.parse(e.target.result);                      // Enhanced validation           const validation = {             hasWords: importedData.words && Array.isArray(importedData.words),             hasStats: importedData.stats && typeof importedData.stats === 'object',             hasHistory: importedData.testHistory && Array.isArray(importedData.testHistory),             hasPerformance: importedData.wordPerformance && typeof importedData.wordPerformance === 'object',             version: importedData.version || 'unknown',             isEnhanced: importedData.version && parseFloat(importedData.version) >= 2.4           };                      if (!validation.hasWords && !validation.hasStats && !validation.hasHistory) {             throw new Error('File non contiene dati validi');           }                      const shouldOverwrite = window.confirm(             `Importare ${validation.isEnhanced ? 'Enhanced ' : ''}backup v${validation.version}?\n` +             `${validation.hasWords ? `${importedData.words.length} parole` : 'Nessuna parola'}\n` +             `${validation.hasHistory ? `${importedData.testHistory.length} test` : 'Nessun test'}\n` +             `${validation.hasPerformance ? `${Object.keys(importedData.wordPerformance).length} performance` : 'Nessuna performance'}\n\n` +             `OK = Sostituisci tutto | Annulla = Combina`           );                      let newStats = stats;           let newHistory = testHistory;           let newPerformance = wordPerformance;                      if (shouldOverwrite) {             // Replace all data             if (validation.hasStats) newStats = importedData.stats;             if (validation.hasHistory) newHistory = importedData.testHistory;             if (validation.hasPerformance) newPerformance = importedData.wordPerformance;                          if (validation.hasWords) {               await enhancedStorageService.saveWords(importedData.words);             }           } else {             // Merge data intelligently             if (validation.hasHistory) {               const existingIds = new Set(testHistory.map(test => test.id));               const newTests = importedData.testHistory.filter(test => !existingIds.has(test.id));               newHistory = [...testHistory, ...newTests].sort((a, b) =>                  new Date(b.timestamp) - new Date(a.timestamp)               ).slice(0, 200); // Keep last 200 tests             }                          if (validation.hasPerformance) {               newPerformance = { ...wordPerformance };               Object.entries(importedData.wordPerformance).forEach(([wordId, data]) => {                 if (newPerformance[wordId]) {                   // Merge attempts                   const existingAttempts = newPerformance[wordId].attempts || [];                   const importedAttempts = data.attempts || [];                   const allAttempts = [...existingAttempts, ...importedAttempts]                     .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))                     .slice(-50); // Keep last 50                                      newPerformance[wordId] = { ...data, attempts: allAttempts };                 } else {                   newPerformance[wordId] = data;                 }               });             }                          if (validation.hasWords) {               const currentWords = await enhancedStorageService.getWords();               const existingEnglish = new Set(currentWords.map(w => w.english.toLowerCase()));               const newWords = importedData.words.filter(word =>                  !existingEnglish.has(word.english.toLowerCase())               );                              if (newWords.length > 0) {                 await enhancedStorageService.saveWords([...currentWords, ...newWords]);               }             }           }                      // Save updated data           await saveData(newStats, newHistory, newPerformance);                      storageLoading.stopLoading();           showSuccess(`✅ Dati importati con successo! (v${validation.version})`);           resolve({ newStats, newHistory, newPerformance });                    } catch (error) {           storageLoading.setError(error, false);           showError(error, 'Import Data');           reject(error);         }       };              reader.onerror = () => {         const error = new Error('Errore lettura file');         showError(error, 'File Reading');         reject(error);       };              reader.readAsText(file);     });   }, [stats, testHistory, wordPerformance, storageLoading, saveData, showSuccess, showError]);    // ⭐ REFRESH DATA from storage   const refreshData = useCallback(async () => {     try {       storageLoading.startLoading('Aggiornamento dati');              const [newStats, newHistory, newPerformance] = await Promise.all([         enhancedStorageService.getStats(),         enhancedStorageService.getTestHistory(),         enhancedStorageService.get('wordPerformance', {})       ]);              setStats(newStats);       setTestHistory(newHistory);       setWordPerformance(newPerformance);       setLastSync(Date.now());              storageLoading.stopLoading();       showSuccess('✅ Dati aggiornati');     } catch (error) {       storageLoading.setError(error, true);       showError(error, 'Refresh Data');     }   }, [storageLoading, showSuccess, showError]);    // ⭐ GET SERVICE STATUS   const getServiceStatus = useCallback(() => {     const storageStatus = enhancedStorageService.getServiceStatus();          return {       storage: storageStatus,       data: {         initialized: isInitialized,         lastSync,         statsLoaded: !!stats,         historyCount: testHistory.length,         performanceCount: Object.keys(wordPerformance).length       },       health: storageStatus.health,       recommendations: [         ...storageStatus.recommendations,         ...(Date.now() - lastSync > 300000 ? ['🔄 Considera aggiornamento dati (5+ minuti fa)'] : [])       ]     };   }, [isInitialized, lastSync, stats, testHistory, wordPerformance]);    // Initialize on mount   useEffect(() => {     initializeData();   }, [initializeData]);    // Auto-refresh every 5 minutes if app is visible   useEffect(() => {     const interval = setInterval(() => {       if (document.visibilityState === 'visible' && isInitialized) {         refreshData();       }     }, 300000); // 5 minutes      return () => clearInterval(interval);   }, [isInitialized, refreshData]);    return {     // Data     stats,     testHistory,     wordPerformance,          // State     isInitialized,     lastSync,     ...storageLoading,          // Actions     handleTestComplete,     refreshData,     exportData,     importData,          // Status     getServiceStatus,          // Computed values     totalTests: testHistory.length,     totalAnswers: stats ? stats.correctAnswers + stats.incorrectAnswers : 0,     accuracyRate: stats && stats.correctAnswers + stats.incorrectAnswers > 0        ? Math.round((stats.correctAnswers / (stats.correctAnswers + stats.incorrectAnswers)) * 100)       : 0,     hintsRate: stats && stats.correctAnswers + stats.incorrectAnswers > 0        ? Math.round(((stats.hintsUsed || 0) / (stats.correctAnswers + stats.incorrectAnswers)) * 100)       : 0   }; }; 

================================================================================

NOME FILE: useLoadingState.js

// ===================================================== // 📁 src/hooks/useLoadingState.js - Advanced Loading State Hook // =====================================================  import { useState, useCallback, useRef, useEffect } from 'react'; import { useNotification } from '../contexts/NotificationContext';  // ===================================================== // 🎯 MAIN LOADING STATE HOOK // ===================================================== export const useLoadingState = (options = {}) => {   const {     timeout = 30000,     retryAttempts = 3,     retryDelay = 1000,     showTimeoutWarning = true,     showRetryNotifications = true   } = options;    const [state, setState] = useState({     isLoading: false,     error: null,     retryCount: 0,     startTime: null,     operation: null   });    const timeoutRef = useRef(null);   const { showWarning, showError, showSuccess } = useNotification();    // ⭐ START LOADING   const startLoading = useCallback((operationName = 'Operation') => {     setState(prev => ({       ...prev,       isLoading: true,       error: null,       startTime: Date.now(),       operation: operationName     }));      if (showTimeoutWarning && timeout > 0) {       timeoutRef.current = setTimeout(() => {         showWarning(`⏱️ ${operationName} sta impiegando più tempo...`);       }, timeout / 2);     }   }, [timeout, showTimeoutWarning, showWarning]);    // ⭐ STOP LOADING   const stopLoading = useCallback((successMessage) => {     setState(prev => {       const duration = prev.startTime ? Date.now() - prev.startTime : 0;              if (successMessage && duration > 2000) {         showSuccess(`${successMessage} (${Math.round(duration / 1000)}s)`);       }              return {         ...prev,         isLoading: false,         error: null,         retryCount: 0,         startTime: null,         operation: null       };     });      if (timeoutRef.current) {       clearTimeout(timeoutRef.current);       timeoutRef.current = null;     }   }, [showSuccess]);    // ⭐ SET ERROR   const setError = useCallback((error, canRetry = true) => {     setState(prev => {       const newRetryCount = prev.retryCount + 1;       const shouldRetry = canRetry && newRetryCount <= retryAttempts;        if (shouldRetry && showRetryNotifications) {         showWarning(`❌ ${error.message || error} - Tentativo ${newRetryCount}/${retryAttempts}`);       } else if (!shouldRetry) {         showError(error, prev.operation || 'Operation');       }        return {         ...prev,         isLoading: false,         error: error,         retryCount: shouldRetry ? newRetryCount : prev.retryCount       };     });      if (timeoutRef.current) {       clearTimeout(timeoutRef.current);       timeoutRef.current = null;     }   }, [retryAttempts, showRetryNotifications, showWarning, showError]);    // ⭐ RETRY OPERATION   const retry = useCallback(async (operation) => {     if (state.retryCount >= retryAttempts) {       showError(new Error('Numero massimo tentativi raggiunto'), 'Retry');       return false;     }      await new Promise(resolve => setTimeout(resolve, retryDelay * state.retryCount));          try {       startLoading(state.operation);       const result = await operation();       stopLoading();       return result;     } catch (error) {       setError(error, true);       return false;     }   }, [state.retryCount, state.operation, retryAttempts, retryDelay, startLoading, stopLoading, setError, showError]);    // ⭐ CLEANUP   useEffect(() => {     return () => {       if (timeoutRef.current) {         clearTimeout(timeoutRef.current);       }     };   }, []);    return {     ...state,     startLoading,     stopLoading,     setError,     retry,     canRetry: state.retryCount < retryAttempts,     duration: state.startTime ? Date.now() - state.startTime : 0   }; };  // ===================================================== // 🤖 AI LOADING HOOK // ===================================================== export const useAILoading = () => {   const loadingState = useLoadingState({     timeout: 45000,     retryAttempts: 2,     retryDelay: 2000,     showTimeoutWarning: true   });    const executeAIOperation = useCallback(async (operation, operationName = 'AI Analysis') => {     try {       loadingState.startLoading(operationName);              const timeoutPromise = new Promise((_, reject) => {         setTimeout(() => reject(new Error('AI service timeout')), 45000);       });              const result = await Promise.race([operation(), timeoutPromise]);              loadingState.stopLoading(`✨ ${operationName} completata`);       return result;     } catch (error) {       if (error.message.includes('timeout')) {         loadingState.setError(new Error('🤖 AI timeout. Riprova o usa modalità manuale.'), true);       } else if (error.message.includes('API')) {         loadingState.setError(new Error('🔑 Problema API key.'), false);       } else if (error.message.includes('quota')) {         loadingState.setError(new Error('🚫 Limite API raggiunto.'), false);       } else {         loadingState.setError(error, true);       }       throw error;     }   }, [loadingState]);    return {     ...loadingState,     executeAIOperation   }; };  // ===================================================== // 💾 STORAGE LOADING HOOK // ===================================================== export const useStorageLoading = () => {   const loadingState = useLoadingState({     timeout: 10000,     retryAttempts: 3,     retryDelay: 500,     showTimeoutWarning: false   });    const executeStorageOperation = useCallback(async (operation, operationName = 'Storage Operation') => {     try {       loadingState.startLoading(operationName);       const result = await operation();       loadingState.stopLoading();       return result;     } catch (error) {       if (error.message.includes('quota') || error.message.includes('QuotaExceededError')) {         loadingState.setError(new Error('💽 Spazio esaurito. Elimina dati vecchi.'), false);       } else if (error.message.includes('localStorage')) {         loadingState.setError(new Error('🔒 Accesso negato storage.'), true);       } else {         loadingState.setError(error, true);       }       throw error;     }   }, [loadingState]);    return {     ...loadingState,     executeStorageOperation   }; };  // ===================================================== // 🌐 NETWORK LOADING HOOK // ===================================================== export const useNetworkLoading = () => {   const loadingState = useLoadingState({     timeout: 20000,     retryAttempts: 3,     retryDelay: 1500,     showTimeoutWarning: true   });    const executeNetworkOperation = useCallback(async (operation, operationName = 'Network Request') => {     try {       loadingState.startLoading(operationName);       const result = await operation();       loadingState.stopLoading();       return result;     } catch (error) {       if (error.message.includes('fetch') || error.message.includes('network')) {         loadingState.setError(new Error('📡 Nessuna connessione.'), true);       } else if (error.message.includes('timeout')) {         loadingState.setError(new Error('⏱️ Timeout rete.'), true);       } else if (error.message.includes('404')) {         loadingState.setError(new Error('🔍 Risorsa non trovata.'), false);       } else if (error.message.includes('500')) {         loadingState.setError(new Error('🔧 Errore server.'), true);       } else {         loadingState.setError(error, true);       }       throw error;     }   }, [loadingState]);    return {     ...loadingState,     executeNetworkOperation   }; };

================================================================================

NOME FILE: useLocalStorage.js

// /src/hooks/useLocalStorage.js // This file contains a custom React hook for managing local storage. // It allows you to store and retrieve values from local storage with automatic JSON serialization and deserialization // while providing a default initial value. // The hook also handles errors gracefully, ensuring that the application can continue to function even if local storage is not available or if there are issues with the stored data. // The `useLocalStorage` hook can be used in any React component to persist state across page reloads or sessions, making it useful for settings, user preferences, or any data that needs to be retained between visits. // It returns the stored value and a function to update it, which will also update the local storage accordingly. // It is a convenient way to manage state that needs to be persistent in a React application.  import { useState } from 'react';  export const useLocalStorage = (key, initialValue) => {   const [storedValue, setStoredValue] = useState(() => {     try {       const item = localStorage.getItem(key);       return item ? JSON.parse(item) : initialValue;     } catch (error) {       console.error(`Error loading ${key} from localStorage:`, error);       return initialValue;     }   });    const setValue = (value) => {     try {       const valueToStore = value instanceof Function ? value(storedValue) : value;       setStoredValue(valueToStore);       localStorage.setItem(key, JSON.stringify(valueToStore));     } catch (error) {       console.error(`Error saving ${key} to localStorage:`, error);     }   };    return [storedValue, setValue]; };

================================================================================

NOME FILE: useNotification.js

// /src/hooks/useNotification.js // This file contains a custom React hook for managing notifications. // It provides functionality to show a notification message for a specified duration.  import { useState, useCallback } from 'react';  export const useNotification = () => {   const [message, setMessage] = useState('');    const showNotification = useCallback((msg, duration = 3000) => {     setMessage(msg);     setTimeout(() => setMessage(''), duration);   }, []);    return { message, showNotification }; };

================================================================================

NOME FILE: useOptimizedStats.js

import { useState, useEffect, useCallback, useMemo } from 'react';  import { useLocalStorage } from './useLocalStorage';  import { useNotification } from '../contexts/NotificationContext';  const INITIAL_STATS = {   totalWords: 0,   correctAnswers: 0,   incorrectAnswers: 0,   hintsUsed: 0, // ⭐ NEW: Track hints globally   averageScore: 0,   testsCompleted: 0,   timeSpent: 0,   categoriesProgress: {},   dailyProgress: {},   streakDays: 0,   lastStudyDate: null,   difficultyStats: {     easy: { correct: 0, total: 0 },     medium: { correct: 0, total: 0 },     hard: { correct: 0, total: 0 }   },   monthlyStats: {},   migrated: false };  // ⭐ NEW: Word-specific performance tracking const INITIAL_WORD_PERFORMANCE = {};  const EMPTY_ARRAY = [];  export const useOptimizedStats = () => {   const [testHistory, setTestHistory] = useLocalStorage('testHistory', EMPTY_ARRAY);   const [stats, setStats] = useLocalStorage('vocabularyStats', INITIAL_STATS);   const [wordPerformance, setWordPerformance] = useLocalStorage('wordPerformance', INITIAL_WORD_PERFORMANCE); // ⭐ NEW   const { showSuccess, showError } = useNotification();       const [optimizationState, setOptimizationState] = useState({     isProcessing: false,     lastUpdate: Date.now(),     forceUpdate: 0   });    // ⭐ MEMOIZED SELECTORS with hints   const selectors = useMemo(() => ({     totalTests: testHistory.length,     totalAnswers: stats.correctAnswers + stats.incorrectAnswers,     totalHints: stats.hintsUsed, // ⭐ NEW     accuracyRate: stats.correctAnswers + stats.incorrectAnswers > 0        ? Math.round((stats.correctAnswers / (stats.correctAnswers + stats.incorrectAnswers)) * 100)       : 0,     hintsRate: stats.correctAnswers + stats.incorrectAnswers > 0        ? Math.round((stats.hintsUsed / (stats.correctAnswers + stats.incorrectAnswers)) * 100)       : 0, // ⭐ NEW: Percentage of answers with hints     isActiveToday: (() => {       const today = new Date().toISOString().split('T')[0];       return Boolean(stats.dailyProgress[today]?.tests > 0);     })(),     avgTimePerTest: stats.testsCompleted > 0        ? Math.round(stats.timeSpent / stats.testsCompleted)        : 0   }), [     testHistory.length,      stats.correctAnswers,      stats.incorrectAnswers,      stats.hintsUsed, // ⭐ NEW     stats.testsCompleted,      stats.timeSpent,      stats.dailyProgress   ]);    // ⭐ NEW: Word-specific analysis   const getWordAnalysis = useCallback((wordId) => {     const wordData = wordPerformance[wordId];     if (!wordData) return null;      const attempts = wordData.attempts || [];     const totalAttempts = attempts.length;     const correctAttempts = attempts.filter(a => a.correct).length;     const hintsUsed = attempts.filter(a => a.usedHint).length;     const lastAttempt = attempts[attempts.length - 1];           // Calculate streak     let currentStreak = 0;     for (let i = attempts.length - 1; i >= 0; i--) {       if (attempts[i].correct) {         currentStreak++;       } else {         break;       }     }      // Calculate improvement trend     const recentAttempts = attempts.slice(-5);     const recentCorrect = recentAttempts.filter(a => a.correct).length;     const recentAccuracy = recentAttempts.length > 0 ? (recentCorrect / recentAttempts.length) * 100 : 0;      // Word status classification     let status = 'new';     if (totalAttempts >= 3) {       if (currentStreak >= 3) status = 'consolidated';       else if (correctAttempts / totalAttempts >= 0.7) status = 'improving';       else if (correctAttempts / totalAttempts <= 0.3) status = 'critical';       else status = 'inconsistent';     } else if (totalAttempts > 0) {       status = currentStreak > 0 ? 'promising' : 'struggling';     }      return {       totalAttempts,       correctAttempts,       accuracy: totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0,       hintsUsed,       hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0,       currentStreak,       lastAttempt,       recentAccuracy: Math.round(recentAccuracy),       status,       avgTime: attempts.length > 0 ? Math.round(attempts.reduce((sum, a) => sum + (a.timeSpent || 0), 0) / attempts.length / 1000) : 0,       attempts: attempts.slice(-10) // Last 10 attempts for trend     };   }, [wordPerformance]);    // ⭐ NEW: ENHANCED Word detailed analysis for WordDetailSection   const getWordDetailedAnalysis = useCallback((wordId) => {     // Get basic analysis first     const wordAnalysis = getWordAnalysis(wordId);     if (!wordAnalysis) return null;      // Get word info from wordPerformance     const wordData = wordPerformance[wordId];     const wordInfo = {       english: wordData?.english || 'N/A',       italian: wordData?.italian || 'N/A',       chapter: wordData?.chapter || null     };      // ⭐ MOVED: Timeline reconstruction logic from WordDetailSection     const buildTimelineFromHistory = () => {       const attempts = [];              // Sort tests chronologically (oldest to newest)       const sortedTests = [...testHistory].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));              sortedTests.forEach((test, testIndex) => {         let wasInTest = false;         let wasCorrect = false;         let usedHint = false;         let timeSpent = 0;                  // PRIORITY 1: Check wrongWords first (most reliable)         if (test.wrongWords && Array.isArray(test.wrongWords)) {           const wrongWord = test.wrongWords.find(w => w.id === wordId);           if (wrongWord) {             wasInTest = true;             wasCorrect = false; // Was wrong             usedHint = (test.hintsUsed > 0) && Math.random() > 0.7; // 30% chance if hints were used in test             timeSpent = test.totalTime ? Math.floor((test.totalTime * 1000) / test.totalWords) : 0;           }         }                  // PRIORITY 2: Check wordTimes for specific data (preferred but often empty)         if (!wasInTest && test.wordTimes && Array.isArray(test.wordTimes)) {           const wordTime = test.wordTimes.find(wt => wt.wordId === wordId);           if (wordTime) {             wasInTest = true;             wasCorrect = wordTime.isCorrect;             usedHint = wordTime.usedHint || false;             timeSpent = wordTime.timeSpent || 0;           }         }                  // PRIORITY 3: Infer from chapter inclusion (if word wasn't in wrongWords, it was correct)         if (!wasInTest && test.testParameters?.selectedChapters && wordInfo.chapter) {           if (test.testParameters.selectedChapters.includes(wordInfo.chapter)) {             wasInTest = true;             wasCorrect = true; // Wasn't wrong, so must have been correct                          // Estimate data for correct answers from test totals             const totalWordsInTest = test.totalWords || 1;             const avgTimePerWord = test.totalTime ? (test.totalTime * 1000) / totalWordsInTest : 0;             timeSpent = avgTimePerWord + (Math.random() * 2000 - 1000); // Add some variation ±1s                          // Distribute hints proportionally among correct words             if (test.hintsUsed > 0) {               const correctWordsInTest = test.correctWords || 1;               const hintProbability = Math.min(test.hintsUsed / correctWordsInTest, 1);               usedHint = Math.random() < hintProbability;             }           }         }                  // Add attempt if word was in test         if (wasInTest) {           attempts.push({             timestamp: test.timestamp,             correct: wasCorrect,             usedHint: usedHint,             timeSpent: Math.max(timeSpent, 0), // Ensure non-negative             testId: test.id           });         }       });              return attempts;     };      // Build actual attempts from test history     const actualAttempts = buildTimelineFromHistory();          if (actualAttempts.length === 0) {       return {         wordInfo,         hasData: false,         totalAttempts: 0,         message: `La parola "${wordInfo.english}" non è ancora stata testata.`       };     }      // ⭐ MOVED: Timeline data calculation logic from WordDetailSection     const timelineData = actualAttempts.map((attempt, index) => {       // Calculate cumulative precision up to this attempt       const attemptsUpToHere = actualAttempts.slice(0, index + 1);       const correctUpToHere = attemptsUpToHere.filter(a => a.correct).length;       const cumulativePrecision = Math.round((correctUpToHere / attemptsUpToHere.length) * 100);              // Use real date for X-axis instead of attempt numbers       const attemptDate = new Date(attempt.timestamp);       const shortDate = attemptDate.toLocaleDateString('it-IT', {         day: '2-digit',         month: '2-digit'       });              return {         // Use actual date instead of attempt number         attempt: shortDate,         attemptNumber: index + 1,         // Individual attempt result (0 or 100 for visualization)         success: attempt.correct ? 100 : 0,         // This is the cumulative precision (Precisione Globale)         globalPrecision: cumulativePrecision,         // Hint usage         hint: attempt.usedHint ? 50 : 0,         // Time in seconds         time: Math.round((attempt.timeSpent || 0) / 1000),         // Full date for tooltip         fullDate: attemptDate.toLocaleDateString('it-IT', {           day: '2-digit',           month: '2-digit',            year: 'numeric',           hour: '2-digit',           minute: '2-digit'         }),         // Raw data for analysis         isCorrect: attempt.correct,         usedHint: attempt.usedHint,         timestamp: attempt.timestamp       };     });      // Take only last 10 attempts for the chart (most recent) - CORRECTLY ORDERED     const chartData = timelineData.slice(-10).map((data, index, array) => ({       ...data,       // Recalculate cumulative precision for just the visible attempts       globalPrecision: (() => {         const visibleAttempts = array.slice(0, index + 1);         const correctInVisible = visibleAttempts.filter(a => a.isCorrect).length;         return Math.round((correctInVisible / visibleAttempts.length) * 100);       })()     }));      // ⭐ MOVED: Statistics calculation from WordDetailSection     const recalculatedStats = {       totalAttempts: actualAttempts.length,       correctAttempts: actualAttempts.filter(a => a.correct).length,       accuracy: actualAttempts.length > 0 ? Math.round((actualAttempts.filter(a => a.correct).length / actualAttempts.length) * 100) : 0,       hintsUsed: actualAttempts.filter(a => a.usedHint).length,       hintsPercentage: actualAttempts.length > 0 ? Math.round((actualAttempts.filter(a => a.usedHint).length / actualAttempts.length) * 100) : 0,       avgTime: actualAttempts.length > 0 ? Math.round(actualAttempts.reduce((sum, a) => sum + (a.timeSpent || 0), 0) / actualAttempts.length / 1000) : 0,       currentStreak: (() => {         let streak = 0;         for (let i = actualAttempts.length - 1; i >= 0; i--) {           if (actualAttempts[i].correct) {             streak++;           } else {             break;           }         }         return streak;       })()     };      // Additional statistics     const recentStats = {       totalAttempts: recalculatedStats.totalAttempts,       recentAttempts: chartData.length,       currentAccuracy: recalculatedStats.accuracy,       trend: chartData.length >= 2          ? chartData[chartData.length - 1].globalPrecision - chartData[0].globalPrecision         : 0,       recentHints: chartData.filter(d => d.usedHint).length,       avgRecentTime: chartData.length > 0          ? Math.round(chartData.reduce((sum, d) => sum + d.time, 0) / chartData.length)         : 0     };      return {       wordInfo,       hasData: true,       chartData,       timelineData,       actualAttempts,       recalculatedStats,       recentStats,       // Additional info for debugging       debugInfo: {         testHistoryLength: testHistory.length,         originalAnalysis: wordAnalysis       }     };   }, [getWordAnalysis, wordPerformance, testHistory]);    // ⭐ NEW: Get all words with their performance   const getAllWordsPerformance = useCallback(() => {     return Object.keys(wordPerformance).map(wordId => {       const analysis = getWordAnalysis(wordId);       return {         wordId,         english: wordPerformance[wordId].english,         italian: wordPerformance[wordId].italian,         chapter: wordPerformance[wordId].chapter,         ...analysis       };     }).sort((a, b) => {       // Sort by status priority: critical -> inconsistent -> improving -> consolidated       const statusPriority = {         critical: 1,         inconsistent: 2,         struggling: 3,         promising: 4,         improving: 5,         consolidated: 6,         new: 7       };       return statusPriority[a.status] - statusPriority[b.status];     });   }, [wordPerformance, getWordAnalysis]);    // ⭐ ENHANCED: Record word performance   const recordWordPerformance = useCallback((word, isCorrect, usedHint, timeSpent) => {     const wordId = word.id;     const attempt = {       timestamp: new Date().toISOString(),       correct: isCorrect,       usedHint: usedHint || false,       timeSpent: timeSpent || 0     };      setWordPerformance(prev => ({       ...prev,       [wordId]: {         english: word.english,         italian: word.italian,         chapter: word.chapter,         attempts: [...(prev[wordId]?.attempts || []), attempt]       }     }));   }, [setWordPerformance]);    // ⭐ MEMOIZED WEEKLY PROGRESS   const weeklyProgress = useMemo(() => {     const last7Days = Array.from({ length: 7 }, (_, i) => {       const date = new Date();       date.setDate(date.getDate() - i);       return date.toISOString().split('T')[0];     });           return last7Days.map(date => ({       date,       tests: stats.dailyProgress[date]?.tests || 0,       correct: stats.dailyProgress[date]?.correct || 0,       incorrect: stats.dailyProgress[date]?.incorrect || 0,       hints: stats.dailyProgress[date]?.hints || 0 // ⭐ NEW     }));   }, [stats.dailyProgress]);    // ⭐ OPTIMIZED STREAK CALCULATION   const calculateStreak = useCallback((dailyProgress) => {     const today = new Date();     let streak = 0;           for (let i = 0; i < 365; i++) {       const date = new Date(today);       date.setDate(date.getDate() - i);       const dateStr = date.toISOString().split('T')[0];               if (dailyProgress[dateStr]?.tests > 0) {         streak++;       } else if (i === 0) {         continue;       } else {         break;       }               if (i > 30 && streak === 0) break;     }           return streak;   }, []);    // ⭐ BATCH OPERATIONS   const performBatchUpdate = useCallback((updates) => {     setOptimizationState(prev => ({ ...prev, isProcessing: true }));           try {       if (updates.stats) {         setStats(updates.stats);       }       if (updates.testHistory) {         setTestHistory(updates.testHistory);       }       if (updates.wordPerformance) {         setWordPerformance(updates.wordPerformance);       }               setOptimizationState(prev => ({         ...prev,         lastUpdate: Date.now(),         forceUpdate: prev.forceUpdate + 1,         isProcessing: false       }));             } catch (error) {       console.error('❌ Batch update error:', error);       showError(error, 'Batch Update');       setOptimizationState(prev => ({ ...prev, isProcessing: false }));     }   }, [setStats, setTestHistory, setWordPerformance, showError]);    // ⭐ OPTIMIZED MIGRATION   const optimizedMigration = useCallback(() => {     if (testHistory.length === 0) return;      const migrationData = testHistory.reduce((acc, test) => {       acc.correctAnswers += test.correctWords || 0;       acc.incorrectAnswers += test.incorrectWords || 0;       acc.hintsUsed += test.hintsUsed || 0; // ⭐ NEW       acc.totalWords = Math.max(acc.totalWords, test.totalWords || 0);       acc.timeSpent += test.timeSpent || Math.floor(Math.random() * 6) + 5;        if (test.timestamp) {         const testDate = new Date(test.timestamp).toISOString().split('T')[0];         if (!acc.dailyProgress[testDate]) {           acc.dailyProgress[testDate] = { tests: 0, correct: 0, incorrect: 0, hints: 0 };         }         acc.dailyProgress[testDate].tests += 1;         acc.dailyProgress[testDate].correct += test.correctWords || 0;         acc.dailyProgress[testDate].incorrect += test.incorrectWords || 0;         acc.dailyProgress[testDate].hints += test.hintsUsed || 0; // ⭐ NEW                   if (!acc.lastStudyDate || testDate > acc.lastStudyDate) {           acc.lastStudyDate = testDate;         }       }        if (test.chapterStats) {         Object.entries(test.chapterStats).forEach(([chapter, chapterData]) => {           if (!acc.categoriesProgress[chapter]) {             acc.categoriesProgress[chapter] = { correct: 0, total: 0, hints: 0 };           }           acc.categoriesProgress[chapter].correct += chapterData.correctWords || 0;           acc.categoriesProgress[chapter].total += chapterData.totalWords || 0;           acc.categoriesProgress[chapter].hints += chapterData.hintsUsed || 0; // ⭐ NEW         });       }        return acc;     }, {       correctAnswers: 0,       incorrectAnswers: 0,       hintsUsed: 0, // ⭐ NEW       totalWords: 0,       timeSpent: 0,       dailyProgress: {},       categoriesProgress: {},       lastStudyDate: null     });      const migratedStats = {       ...INITIAL_STATS,       ...migrationData,       testsCompleted: testHistory.length,       averageScore: migrationData.correctAnswers + migrationData.incorrectAnswers > 0          ? (migrationData.correctAnswers / (migrationData.correctAnswers + migrationData.incorrectAnswers)) * 100          : 0,       streakDays: calculateStreak(migrationData.dailyProgress),       migrated: true     };      performBatchUpdate({ stats: migratedStats });     showSuccess(`✅ Migrati ${testHistory.length} test!`);   }, [testHistory, calculateStreak, performBatchUpdate, showSuccess]);    // ⭐ NEW: Smart Test Difficulty Calculator - PROPORTIONAL & WEIGHTED   const calculateSmartTestDifficulty = useCallback((testWords, getWordAnalysisFunc) => {     // ⭐ Categorize words by difficulty level     const categories = {       hard: [], // critical, inconsistent, struggling       medium: [], // promising, new (uncertain)       easy: [] // improving, consolidated     };      testWords.forEach(word => {       const analysis = getWordAnalysisFunc(word.id);       const status = analysis ? analysis.status : 'new';               if (['critical', 'inconsistent', 'struggling'].includes(status)) {         categories.hard.push({ word, status, analysis });       } else if (['promising', 'new'].includes(status)) {         categories.medium.push({ word, status, analysis });       } else if (['improving', 'consolidated'].includes(status)) {         categories.easy.push({ word, status, analysis });       }     });      const totalWords = testWords.length;     const hardCount = categories.hard.length;     const mediumCount = categories.medium.length;     const easyCount = categories.easy.length;      // ⭐ Calculate proportions     const hardPercentage = (hardCount / totalWords) * 100;     const easyPercentage = (easyCount / totalWords) * 100;     const mediumPercentage = (mediumCount / totalWords) * 100;      // ⭐ Weighted scoring system     const hardWeight = 3; // Critical words have high impact     const mediumWeight = 1; // Neutral impact     const easyWeight = -1; // Easy words reduce difficulty      const weightedScore = (hardCount * hardWeight + mediumCount * mediumWeight + easyCount * easyWeight) / totalWords;      // ⭐ Size adjustment factor - larger tests are generally easier to manage     const sizeAdjustment = totalWords > 50 ? -0.3 : totalWords < 15 ? +0.2 : 0;     const adjustedScore = weightedScore + sizeAdjustment;      // ⭐ Determine difficulty level with nuanced thresholds     let difficulty;     let difficultyReason;      if (hardPercentage >= 50 || adjustedScore >= 1.5) {       difficulty = 'hard';       difficultyReason = `Test difficile: ${hardPercentage.toFixed(1)}% parole problematiche (${hardCount}/${totalWords})`;     } else if (easyPercentage >= 70 || adjustedScore <= -0.5) {       difficulty = 'easy';       difficultyReason = `Test facile: ${easyPercentage.toFixed(1)}% parole consolidate/miglioranti (${easyCount}/${totalWords})`;     } else {       difficulty = 'medium';       difficultyReason = `Test bilanciato: ${hardPercentage.toFixed(1)}% difficili, ${easyPercentage.toFixed(1)}% facili (${totalWords} parole)`;     }      // ⭐ Detailed analysis for debugging and statistics     const difficultyAnalysis = {       difficulty,       difficultyReason,       totalWords,       weightedScore: parseFloat(adjustedScore.toFixed(2)),       sizeAdjustment,       distribution: {         hard: { count: hardCount, percentage: parseFloat(hardPercentage.toFixed(1)) },         medium: { count: mediumCount, percentage: parseFloat(mediumPercentage.toFixed(1)) },         easy: { count: easyCount, percentage: parseFloat(easyPercentage.toFixed(1)) }       },       statusBreakdown: {         critical: categories.hard.filter(item => item.status === 'critical').length,         inconsistent: categories.hard.filter(item => item.status === 'inconsistent').length,         struggling: categories.hard.filter(item => item.status === 'struggling').length,         promising: categories.medium.filter(item => item.status === 'promising').length,         new: categories.medium.filter(item => item.status === 'new').length,         improving: categories.easy.filter(item => item.status === 'improving').length,         consolidated: categories.easy.filter(item => item.status === 'consolidated').length       }     };            return { difficulty, difficultyAnalysis };   }, []);    // ⭐ ENHANCED: Test completion with smart difficulty calculation   const handleTestComplete = useCallback((testStats, testWordsUsed, wrongWordsArray) => {           const usedChapters = [...new Set(testWordsUsed.map(word => word.chapter || 'Senza Capitolo'))];           const chapterStats = {};     usedChapters.forEach(chapter => {       const chapterWords = testWordsUsed.filter(word =>          (word.chapter || 'Senza Capitolo') === chapter       );       const chapterWrongWords = wrongWordsArray.filter(word =>          (word.chapter || 'Senza Capitolo') === chapter       );               // ⭐ NEW: Calculate hints for this chapter       const chapterHints = testStats.wordTimes ?          testStats.wordTimes           .filter(wt => chapterWords.some(cw => cw.id === wt.wordId))           .filter(wt => wt.usedHint).length : 0;               chapterStats[chapter] = {         totalWords: chapterWords.length,         correctWords: chapterWords.length - chapterWrongWords.length,         incorrectWords: chapterWrongWords.length,         hintsUsed: chapterHints, // ⭐ NEW         percentage: chapterWords.length > 0 ?            Math.round(((chapterWords.length - chapterWrongWords.length) / chapterWords.length) * 100) : 0       };     });      // ⭐ NEW: Record individual word performances     if (testStats.wordTimes && Array.isArray(testStats.wordTimes)) {       testStats.wordTimes.forEach(wordTime => {         const word = testWordsUsed.find(w => w.id === wordTime.wordId);         if (word) {           recordWordPerformance(word, wordTime.isCorrect, wordTime.usedHint, wordTime.timeSpent);         }       });     }      // ⭐ CRITICAL: Calculate smart difficulty     const { difficulty, difficultyAnalysis } = calculateSmartTestDifficulty(testWordsUsed, getWordAnalysis);      const updates = {       stats: { ...stats },       testHistory: [         {           id: Date.now(),           timestamp: new Date(),           totalWords: testStats.correct + testStats.incorrect,           correctWords: testStats.correct,           incorrectWords: testStats.incorrect,           hintsUsed: testStats.hints || 0, // ⭐ NEW           totalTime: testStats.totalTime || 0, // ⭐ NEW           avgTimePerWord: testStats.avgTimePerWord || 0, // ⭐ NEW           percentage: Math.round((testStats.correct / (testStats.correct + testStats.incorrect)) * 100),           wrongWords: [...wrongWordsArray],           wordTimes: testStats.wordTimes || [], // ⭐ NEW: Store individual word times           chapterStats,           testParameters: {             selectedChapters: usedChapters,             includeLearnedWords: testWordsUsed.some(w => w.learned),             totalAvailableWords: testWordsUsed.length           },           testType: usedChapters.length === 1 ? 'selective' : 'complete',                       // ⭐ NEW: Smart proportional difficulty system           difficulty, // Smart calculated difficulty           difficultyAnalysis, // Detailed analysis for stats/debugging                       // ⭐ LEGACY: Keep old system for comparison           legacyDifficulty: testWordsUsed.length < 10 ? 'easy' : testWordsUsed.length < 25 ? 'medium' : 'hard'         },         ...testHistory       ]     };      // ⭐ ENHANCED: Update stats with hints     updates.stats.testsCompleted += 1;     updates.stats.correctAnswers += testStats.correct;     updates.stats.incorrectAnswers += testStats.incorrect;     updates.stats.hintsUsed += testStats.hints || 0; // ⭐ NEW     updates.stats.timeSpent += testStats.totalTime || (Math.round(Math.random() * 10) + 5);           const totalAnswers = updates.stats.correctAnswers + updates.stats.incorrectAnswers;     updates.stats.averageScore = (updates.stats.correctAnswers / totalAnswers) * 100;      const today = new Date().toISOString().split('T')[0];     if (!updates.stats.dailyProgress[today]) {       updates.stats.dailyProgress[today] = { tests: 0, correct: 0, incorrect: 0, hints: 0 };     }     updates.stats.dailyProgress[today].tests += 1;     updates.stats.dailyProgress[today].correct += testStats.correct;     updates.stats.dailyProgress[today].incorrect += testStats.incorrect;     updates.stats.dailyProgress[today].hints += testStats.hints || 0; // ⭐ NEW           updates.stats.lastStudyDate = today;     updates.stats.streakDays = calculateStreak(updates.stats.dailyProgress);      performBatchUpdate(updates);     showSuccess(`✅ Test completato! Risultato: ${updates.testHistory[0].percentage}% (Difficoltà: ${difficulty})`);   }, [stats, testHistory, calculateStreak, performBatchUpdate, showSuccess, recordWordPerformance, calculateSmartTestDifficulty, getWordAnalysis]);    // ⭐ CENTRALIZED: Export Data Creation Function   const createExportData = useCallback(() => {     // ⭐ CRITICAL: Get words from localStorage - they're managed by useOptimizedWords     const words = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');           return {       words, // ⭐ CRITICAL: Include actual words!       stats,       testHistory,       wordPerformance, // ⭐ NEW: Include word performance       exportDate: new Date().toISOString(),       version: '2.3', // ⭐ Updated version for smart difficulty       dataTypes: ['words', 'stats', 'testHistory', 'wordPerformance'], // ⭐ Updated       totalTests: testHistory.length,       totalWords: words.length, // ⭐ FIXED: Count actual words, not performance       totalWordPerformance: Object.keys(wordPerformance).length,       description: 'Backup completo v2.3: parole + statistiche + cronologia test + performance parole + difficoltà intelligente'     };   }, [stats, testHistory, wordPerformance]);    // ⭐ UPDATED: Export using centralized function   const exportStats = useCallback(() => {     try {       const exportData = createExportData();               const dataStr = JSON.stringify(exportData, null, 2);       const blob = new Blob([dataStr], { type: 'application/json' });       const url = URL.createObjectURL(blob);               const link = document.createElement('a');       link.href = url;       link.download = `vocabulary-complete-backup-v2.3-${new Date().toISOString().split('T')[0]}.json`;       document.body.appendChild(link);       link.click();       document.body.removeChild(link);       URL.revokeObjectURL(url);               showSuccess(`✅ Backup v2.3 esportato! (${exportData.totalWords} parole + ${exportData.totalTests} test + ${exportData.totalWordPerformance} performance)`);     } catch (error) {       showError(error, 'Export');     }   }, [createExportData, showSuccess, showError]);    // ⭐ FIXED: Import with WORDS support   const importStats = useCallback((file) => {     return new Promise((resolve, reject) => {       if (optimizationState.isProcessing) {         reject(new Error('Operazione già in corso'));         return;       }        const reader = new FileReader();               reader.onload = (e) => {         try {           setOptimizationState(prev => ({ ...prev, isProcessing: true }));           const importedData = JSON.parse(e.target.result);                       // ⭐ IMPROVED: Better validation           const hasWords = importedData.words && Array.isArray(importedData.words);           const hasStats = importedData.stats && typeof importedData.stats === 'object';           const hasHistory = importedData.testHistory && Array.isArray(importedData.testHistory);           const hasWordPerformance = importedData.wordPerformance && typeof importedData.wordPerformance === 'object';                       if (!hasWords && !hasStats && !hasHistory) {             throw new Error('File non contiene dati validi (parole, statistiche o cronologia)');           }                       const isNewFormat = importedData.version === '2.3' && hasWords;           const isEnhancedBackup = importedData.version === '2.2' && hasWordPerformance;                       let confirmMessage = '';           if (isNewFormat) {             confirmMessage = `Backup Completo v2.3 rilevato (${importedData.words?.length || 0} parole + ${importedData.testHistory?.length || 0} test + ${Object.keys(importedData.wordPerformance || {}).length} performance).\nOK = Sostituisci tutto | Annulla = Combina`;           } else if (isEnhancedBackup) {             confirmMessage = `Backup Enhanced v2.2 rilevato (${importedData.testHistory?.length || 0} test + ${Object.keys(importedData.wordPerformance || {}).length} performance).\nOK = Sostituisci tutto | Annulla = Combina\n⚠️ ATTENZIONE: Non contiene parole!`;           } else {             confirmMessage = `Backup standard rilevato.\nOK = Sostituisci | Annulla = Combina`;           }                       const shouldOverwrite = window.confirm(confirmMessage);                       // ⭐ IMPROVED: Better data handling           let newStats = stats;           let newHistory = testHistory;           let newWordPerformance = wordPerformance;           let importedWords = [];                       if (shouldOverwrite) {             // Replace all data             if (hasStats) {               newStats = { ...importedData.stats, migrated: true };             }             if (hasHistory) {               newHistory = [...importedData.testHistory];             }             if (hasWordPerformance) {               newWordPerformance = { ...importedData.wordPerformance };             }             if (hasWords) {               importedWords = [...importedData.words];               // ⭐ CRITICAL: Save words to their storage               localStorage.setItem('vocabularyWords', JSON.stringify(importedWords));             }                           const components = [];             if (hasWords) components.push(`${importedWords.length} parole`);             if (hasHistory) components.push(`${newHistory.length} test`);             if (hasWordPerformance) components.push(`${Object.keys(newWordPerformance).length} performance`);                           showSuccess(`✅ Backup ${isNewFormat ? 'v2.3' : isEnhancedBackup ? 'v2.2' : 'standard'} importato! ${components.join(' + ')}`);           } else {             // Merge data             if (hasHistory) {               const existingIds = new Set(testHistory.map(test => test.id));               const newTests = importedData.testHistory.filter(test => !existingIds.has(test.id));               newHistory = [...testHistory, ...newTests].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));             }                           if (hasWordPerformance) {               newWordPerformance = { ...wordPerformance };               Object.entries(importedData.wordPerformance).forEach(([wordId, data]) => {                 if (newWordPerformance[wordId]) {                   // Merge attempts                   const existingAttempts = newWordPerformance[wordId].attempts || [];                   const newAttempts = data.attempts || [];                   const allAttempts = [...existingAttempts, ...newAttempts]                     .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));                   newWordPerformance[wordId] = { ...data, attempts: allAttempts };                 } else {                   newWordPerformance[wordId] = data;                 }               });             }                           if (hasWords) {               // ⭐ IMPROVED: Merge words intelligently               const currentWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');               const existingEnglish = new Set(currentWords.map(w => w.english.toLowerCase()));               const newWords = importedData.words.filter(word =>                  !existingEnglish.has(word.english.toLowerCase())               );                               if (newWords.length > 0) {                 importedWords = [...currentWords, ...newWords];                 localStorage.setItem('vocabularyWords', JSON.stringify(importedWords));               } else {                 importedWords = currentWords;               }             }                           const components = [];             if (hasWords) components.push(`+${importedWords.length - JSON.parse(localStorage.getItem('vocabularyWords') || '[]').length} nuove parole`);             if (hasHistory) components.push(`+${newHistory.length - testHistory.length} test`);             if (hasWordPerformance) components.push(`${Object.keys(importedData.wordPerformance).length} performance`);                           showSuccess(`✅ Dati combinati! ${components.join(', ')}`);           }                       // ⭐ IMPROVED: Update all data           performBatchUpdate({              stats: newStats,              testHistory: newHistory,             wordPerformance: newWordPerformance           });                       // ⭐ IMPORTANT: Trigger words refresh if words were imported           if (hasWords) {             // Signal that words have changed by updating localStorage timestamp             localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());           }                       resolve({              newStats,              newHistory,              newWordPerformance,             importedWords: hasWords ? importedWords : null            });                     } catch (error) {           console.error('Import error:', error);           showError(error, 'Import');           reject(error);         } finally {           setOptimizationState(prev => ({ ...prev, isProcessing: false }));         }       };               reader.onerror = () => {         setOptimizationState(prev => ({ ...prev, isProcessing: false }));         const error = new Error('Errore lettura file');         showError(error, 'File Reading');         reject(error);       };               reader.readAsText(file);     });   }, [stats, testHistory, wordPerformance, performBatchUpdate, showSuccess, showError, optimizationState.isProcessing]);    // ⭐ COMPUTED VALUES   const computedStats = useMemo(() => ({     ...selectors,     weeklyProgress,     isMigrated: stats.migrated,     isProcessing: optimizationState.isProcessing,     forceUpdate: optimizationState.forceUpdate   }), [selectors, weeklyProgress, stats.migrated, optimizationState]);    // ⭐ AUTO-MIGRATION   useEffect(() => {     const shouldMigrate = !stats.migrated && testHistory.length > 0 && !optimizationState.isProcessing;           if (shouldMigrate) {       const timeoutId = setTimeout(optimizedMigration, 500);       return () => clearTimeout(timeoutId);     }   }, [stats.migrated, testHistory.length, optimizationState.isProcessing, optimizedMigration]);    return {     stats,     testHistory,     wordPerformance, // ⭐ NEW     calculatedStats: computedStats,           handleTestComplete,     addTestToHistory: useCallback((testResult) => {       const updatedHistory = [testResult, ...testHistory];       performBatchUpdate({ testHistory: updatedHistory });     }, [testHistory, performBatchUpdate]),           // ⭐ NEW: Word performance functions     getWordAnalysis,     getWordDetailedAnalysis, // ⭐ NEW: Enhanced analysis for WordDetailSection     getAllWordsPerformance,     recordWordPerformance,           refreshData: useCallback(() => {       if (optimizationState.isProcessing) return;               try {         const freshHistory = JSON.parse(localStorage.getItem('testHistory') || '[]');         const freshStats = JSON.parse(localStorage.getItem('vocabularyStats') || JSON.stringify(INITIAL_STATS));         const freshWordPerformance = JSON.parse(localStorage.getItem('wordPerformance') || '{}');                   performBatchUpdate({           stats: freshStats,           testHistory: freshHistory,           wordPerformance: freshWordPerformance         });       } catch (error) {         showError(error, 'Refresh');       }     }, [optimizationState.isProcessing, performBatchUpdate, showError]),           resetStats: useCallback(() => {       if (window.confirm('⚠️ Cancellare tutto (parole, test, statistiche)?')) {         // ⭐ ENHANCED: Also clear words         localStorage.removeItem('vocabularyWords');         localStorage.removeItem('vocabularyWords_lastUpdate');                   performBatchUpdate({           stats: { ...INITIAL_STATS, migrated: true },           testHistory: EMPTY_ARRAY,           wordPerformance: INITIAL_WORD_PERFORMANCE         });         showSuccess('✅ Tutti i dati cancellati (parole, test, statistiche)!');       }     }, [performBatchUpdate, showSuccess]),           clearHistoryOnly: useCallback(() => {       if (window.confirm(`Cancellare ${testHistory.length} test?`)) {         performBatchUpdate({ testHistory: EMPTY_ARRAY });         showSuccess('✅ Cronologia cancellata!');       }     }, [testHistory.length, performBatchUpdate, showSuccess]),      // ⭐ CENTRALIZED: Export functions     createExportData, // ⭐ NEW: For reuse in emergency export     exportStats,     importStats,           ...computedStats   }; };  export { useOptimizedStats as useStats };

================================================================================

NOME FILE: useOptimizedTest.js

// ===================================================== // 📁 hooks/useOptimizedTest.js - CLEANED VERSION // =====================================================  import { useState, useCallback, useMemo, useRef, useEffect } from 'react';  export const useOptimizedTest = (onTestComplete) => {   const [currentWord, setCurrentWord] = useState(null);   const [usedWordIds, setUsedWordIds] = useState(new Set());   const [showMeaning, setShowMeaning] = useState(false);   const [testMode, setTestMode] = useState(false);   const [showResults, setShowResults] = useState(false);   const [stats, setStats] = useState({ correct: 0, incorrect: 0, hints: 0 });   const [wrongWords, setWrongWords] = useState([]);   const [testWords, setTestWords] = useState([]);   const [testSaved, setTestSaved] = useState(false);      // Enhanced: Timer e transizioni   const [wordTimes, setWordTimes] = useState([]);   const [isTransitioning, setIsTransitioning] = useState(false);   const testStartTimeRef = useRef(null);   const wordStartTimeRef = useRef(null);      // Enhanced: Hint functionality   const [showHint, setShowHint] = useState(false);   const [hintUsedForCurrentWord, setHintUsedForCurrentWord] = useState(false);    // Start timing when word appears (SOLO quando non in transizione)   useEffect(() => {     if (currentWord && testMode && !isTransitioning) {       wordStartTimeRef.current = Date.now();       setHintUsedForCurrentWord(false);       setShowHint(false);       setShowMeaning(false);     }   }, [currentWord, testMode, isTransitioning]);    // Enhanced: Record word completion time   const recordWordTime = useCallback((isCorrect, usedHint = false) => {     if (wordStartTimeRef.current && currentWord) {       const timeSpent = Date.now() - wordStartTimeRef.current;              const wordRecord = {         wordId: currentWord.id,         english: currentWord.english,         italian: currentWord.italian,         chapter: currentWord.chapter,         timeSpent,         isCorrect,         usedHint,         timestamp: new Date().toISOString()       };              setWordTimes(prev => [...prev, wordRecord]);       wordStartTimeRef.current = null;     }   }, [currentWord]);    // Progress: Enhanced with hints   const progressData = useMemo(() => {     if (testWords.length === 0) return { current: 0, total: 0, percentage: 0, hints: 0 };          const answered = stats.correct + stats.incorrect;          return {       current: answered + 1,       total: testWords.length,       percentage: Math.round((answered / testWords.length) * 100),       hints: stats.hints     };   }, [stats.correct, stats.incorrect, stats.hints, testWords.length]);    // Enhanced: Summary con TUTTI i dati timing e hints per ResultsView   const summaryData = useMemo(() => {     const totalAnswered = stats.correct + stats.incorrect;     const accuracy = totalAnswered > 0 ? Math.round((stats.correct / totalAnswered) * 100) : 0;     const totalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0;          // Enhanced: Calcoli timing più precisi da wordTimes     const timingStats = wordTimes.length > 0 ? {       avgTimePerWord: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000),       maxTimePerWord: Math.round(Math.max(...wordTimes.map(r => r.timeSpent)) / 1000),       minTimePerWord: Math.round(Math.min(...wordTimes.map(r => r.timeSpent)) / 1000),       totalRecordedTime: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / 1000)     } : {       avgTimePerWord: 0,       maxTimePerWord: 0,       minTimePerWord: 0,       totalRecordedTime: 0     };          // Return COMPLETE summary with ALL enhanced data     const completeSummary = {       current: totalAnswered + 1,       total: testWords.length,       percentage: Math.round((totalAnswered / testWords.length) * 100),       answered: totalAnswered,       remaining: testWords.length - totalAnswered,       accuracy,       correct: stats.correct,       incorrect: stats.incorrect,       hints: stats.hints,       totalTime: Math.round(totalTestTime / 1000),       ...timingStats,       // Additional enhanced data for results       wordTimes: [...wordTimes],       testStartTime: testStartTimeRef.current,       hintsPercentage: totalAnswered > 0 ? Math.round((stats.hints / totalAnswered) * 100) : 0,       efficiency: totalAnswered > 0 ? Math.max(0, accuracy - Math.round((stats.hints / totalAnswered) * 100)) : 0     };          return completeSummary;   }, [stats.correct, stats.incorrect, stats.hints, testWords.length, wordTimes, testStartTimeRef.current]);    // Optimized random word selection   const getRandomUnusedWord = useCallback((wordList, usedIds) => {     const unusedWords = wordList.filter(word => !usedIds.has(word.id));     if (unusedWords.length === 0) return null;          const randomIndex = Math.floor(Math.random() * unusedWords.length);     return unusedWords[randomIndex];   }, []);    // Enhanced: Save test results with complete stats   const saveTestResultsWithStats = useCallback((finalStats) => {     if (!testSaved && (finalStats.correct > 0 || finalStats.incorrect > 0) && onTestComplete) {       const finalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0;              // Enhanced: Calcoli timing completi       const timingStats = wordTimes.length > 0 ? {         avgTimePerWord: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000),         maxTimePerWord: Math.round(Math.max(...wordTimes.map(r => r.timeSpent)) / 1000),         minTimePerWord: Math.round(Math.min(...wordTimes.map(r => r.timeSpent)) / 1000),         totalRecordedTime: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / 1000)       } : {         avgTimePerWord: 0,         maxTimePerWord: 0,         minTimePerWord: 0,         totalRecordedTime: 0       };              const enhancedStats = {         ...finalStats,         totalTime: Math.round(finalTestTime / 1000),         ...timingStats,         wordTimes: [...wordTimes]       };              onTestComplete(enhancedStats, testWords, wrongWords);       setTestSaved(true);     }   }, [testWords, wrongWords, testSaved, onTestComplete, wordTimes]);    const startTest = useCallback((filteredWords = []) => {     if (filteredWords.length === 0) return;          setTestWords(filteredWords);     setWrongWords([]);     setTestSaved(false);     setStats({ correct: 0, incorrect: 0, hints: 0 });     setUsedWordIds(new Set());     setWordTimes([]);     setIsTransitioning(false);     testStartTimeRef.current = Date.now();     wordStartTimeRef.current = null;          const firstWord = getRandomUnusedWord(filteredWords, new Set());     setCurrentWord(firstWord);          if (firstWord) {       setUsedWordIds(new Set([firstWord.id]));     }          setShowMeaning(false);     setShowHint(false);     setHintUsedForCurrentWord(false);     setTestMode(true);   }, [getRandomUnusedWord]);    // Enhanced: Next word con transizione corretta   const nextWord = useCallback(() => {     const nextRandomWord = getRandomUnusedWord(testWords, usedWordIds);          if (nextRandomWord) {       setIsTransitioning(true);       setShowMeaning(false);              setTimeout(() => {         setCurrentWord(nextRandomWord);         setUsedWordIds(prev => new Set([...prev, nextRandomWord.id]));         setShowHint(false);         setHintUsedForCurrentWord(false);                  setTimeout(() => {           setIsTransitioning(false);         }, 100);       }, 400);     }   }, [testWords, usedWordIds, getRandomUnusedWord]);    // Enhanced: Hint functionality   const toggleHint = useCallback(() => {     if (!showHint && currentWord?.sentence) {       setShowHint(true);       setHintUsedForCurrentWord(true);     } else {       setShowHint(false);     }   }, [showHint, currentWord]);    // Answer handling con timing corretto   const handleAnswer = useCallback((isCorrect) => {     // Record timing IMMEDIATAMENTE     recordWordTime(isCorrect, hintUsedForCurrentWord);          // Update stats with hints properly tracked     const newStats = {       correct: stats.correct + (isCorrect ? 1 : 0),       incorrect: stats.incorrect + (isCorrect ? 0 : 1),       hints: stats.hints + (hintUsedForCurrentWord ? 1 : 0)     };          setStats(newStats);          // Track wrong words with hint info     if (!isCorrect && currentWord) {       const wrongWord = { ...currentWord, usedHint: hintUsedForCurrentWord };       setWrongWords(prev => [...prev, wrongWord]);     }          const totalAnswered = newStats.correct + newStats.incorrect;     const isLastQuestion = totalAnswered >= testWords.length;          // Enhanced: Gestione sequenza risposta → fine test o prossima parola     if (isLastQuestion) {       saveTestResultsWithStats(newStats);       setTestMode(false);       setShowResults(true);       setCurrentWord(null);     } else {       setTimeout(() => {         nextWord();       }, showMeaning ? 1000 : 600);     }   }, [currentWord, showMeaning, stats, testWords.length, hintUsedForCurrentWord, recordWordTime, saveTestResultsWithStats, nextWord]);    const resetTest = useCallback(() => {     if (!testSaved && (stats.correct > 0 || stats.incorrect > 0)) {       saveTestResultsWithStats(stats);     }          setTestMode(false);     setShowResults(false);     setCurrentWord(null);     setUsedWordIds(new Set());     setWrongWords([]);     setShowMeaning(false);     setShowHint(false);     setHintUsedForCurrentWord(false);     setStats({ correct: 0, incorrect: 0, hints: 0 });     setTestWords([]);     setTestSaved(false);     setWordTimes([]);     setIsTransitioning(false);     testStartTimeRef.current = null;     wordStartTimeRef.current = null;   }, [stats, testSaved, saveTestResultsWithStats]);    const startNewTest = useCallback(() => {     setShowResults(false);     setWrongWords([]);     setTestSaved(false);     setStats({ correct: 0, incorrect: 0, hints: 0 });     setUsedWordIds(new Set());     setCurrentWord(null);     setWordTimes([]);     setIsTransitioning(false);     startTest(testWords);   }, [startTest, testWords]);    return {     currentWord,     usedWordIds,     showMeaning,     setShowMeaning,     testMode,     showResults,     stats,     wrongWords,     testWords,     isTransitioning,          // Enhanced: Hint functionality     showHint,     toggleHint,     hintUsed: hintUsedForCurrentWord,          // Enhanced: Timer functionality     wordTimes,          startTest,     handleAnswer,     resetTest,     startNewTest,     getTestProgress: useCallback(() => progressData, [progressData]),     // Return complete summary with ALL enhanced data     getTestSummary: useCallback(() => summaryData, [summaryData])   }; };

================================================================================

NOME FILE: useOptimizedWords.js

// ===================================================== // 📁 hooks/useOptimizedWords.js - FIXED MAJOR ISSUES // =====================================================  import { useState, useCallback, useMemo, useEffect } from 'react'; import { useLocalStorage } from './useLocalStorage';  const EMPTY_ARRAY = [];  export const useOptimizedWords = () => {   const [words, setWords] = useLocalStorage('vocabularyWords', EMPTY_ARRAY);   const [editingWord, setEditingWord] = useState(null);   const [refreshTrigger, setRefreshTrigger] = useState(0);    // ⭐ FIXED: Better import change detection   useEffect(() => {     const handleStorageChange = (e) => {       if (e.key === 'vocabularyWords' || e.key === 'vocabularyWords_lastUpdate') {         forceRefresh();       }     };      window.addEventListener('storage', handleStorageChange);          const handleCustomRefresh = () => {       forceRefresh();     };          window.addEventListener('wordsImported', handleCustomRefresh);      let lastCheck = localStorage.getItem('vocabularyWords_lastUpdate');     const checkInterval = setInterval(() => {       const currentCheck = localStorage.getItem('vocabularyWords_lastUpdate');       if (currentCheck && currentCheck !== lastCheck) {         lastCheck = currentCheck;         handleCustomRefresh();       }     }, 1000);      return () => {       window.removeEventListener('storage', handleStorageChange);       window.removeEventListener('wordsImported', handleCustomRefresh);       clearInterval(checkInterval);     };   }, []);    // ⭐ NEW: Force refresh function   const forceRefresh = useCallback(() => {     try {       const updatedWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');       setWords(updatedWords);       setRefreshTrigger(prev => prev + 1);     } catch (error) {       // Silently handle errors     }   }, [setWords]);    // ⭐ ENHANCED: Word stats with difficult words   const wordStats = useMemo(() => ({     total: words.length,     learned: words.filter(w => w.learned).length,     unlearned: words.filter(w => !w.learned).length,     difficult: words.filter(w => w.difficult).length,     normal: words.filter(w => !w.difficult && !w.learned).length,     chapters: [...new Set(words.map(w => w.chapter).filter(Boolean))].sort(),     groups: [...new Set(words.map(w => w.group).filter(Boolean))].sort()   }), [words, refreshTrigger]);    // ⭐ FIXED: Better word map generation with proper ID handling   const wordMap = useMemo(() => {     const map = {};     words.forEach(word => {       // Map by ID (primary key)       if (word.id) {         map[word.id] = word;       }       // Separate map for english words (for duplicate checking)       if (word.english) {         map[`english_${word.english.toLowerCase()}`] = word;       }     });     return map;   }, [words, refreshTrigger]);    // ⭐ FIXED: Batch word operations with immediate localStorage sync   const batchUpdateWords = useCallback((updateFn) => {     setWords(prevWords => {       const newWords = updateFn(prevWords);       const sortedWords = newWords.sort((a, b) => a.english.localeCompare(b.english));              // ⭐ CRITICAL: Immediate localStorage sync       try {         localStorage.setItem('vocabularyWords', JSON.stringify(sortedWords));         localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());       } catch (error) {         // Silently handle errors       }              return sortedWords;     });          // ⭐ FIXED: Force trigger refresh to ensure UI updates     setRefreshTrigger(prev => prev + 1);   }, [setWords]);    // ⭐ FIXED: Enhanced add word with better duplicate checking and editing logic   const addWord = useCallback((wordData) => {     if (!wordData.english?.trim() || !wordData.italian?.trim()) {       throw new Error('English word and Italian translation are required');     }      const englishWord = wordData.english.trim().toLowerCase();     const englishKey = `english_${englishWord}`;          // ⭐ FIXED: Better duplicate checking logic     const existingWord = wordMap[englishKey];     if (existingWord && (!editingWord || existingWord.id !== editingWord.id)) {       throw new Error(`Word "${wordData.english}" already exists`);     }          batchUpdateWords(prevWords => {       if (editingWord) {         // ⭐ FIXED: Editing mode - ensure we find and update the correct word                  const updatedWords = prevWords.map(word => {           if (word.id === editingWord.id) {             const updatedWord = {                ...word,                ...wordData,                id: editingWord.id, // ⭐ CRITICAL: Preserve original ID               english: wordData.english.trim(),               italian: wordData.italian.trim()             };             return updatedWord;           }           return word;         });                  // ⭐ VERIFICATION: Check if update actually happened         const foundUpdated = updatedWords.find(w => w.id === editingWord.id);         if (!foundUpdated) {           throw new Error('Failed to update word - word not found');         }                  return updatedWords;       } else {         // ⭐ FIXED: Adding new word with guaranteed unique ID         const newWord = {           id: `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,           english: wordData.english.trim(),           italian: wordData.italian.trim(),           group: wordData.group?.trim() || null,           sentence: wordData.sentence?.trim() || null,           notes: wordData.notes?.trim() || null,           chapter: wordData.chapter?.trim() || null,           learned: Boolean(wordData.learned),           difficult: Boolean(wordData.difficult)         };         return [...prevWords, newWord];       }     });          // ⭐ FIXED: Clear editing state after successful operation     setEditingWord(null);   }, [editingWord, wordMap, batchUpdateWords]);    // ⭐ FIXED: Enhanced toggle functions with proper ID validation   const toggleWordLearned = useCallback((id) => {     // ⭐ VERIFICATION: Check if word exists before toggle     const existingWord = wordMap[id];     if (!existingWord) {       throw new Error('Word not found');     }          batchUpdateWords(prevWords =>       prevWords.map(word => {         if (word.id === id) {           return { ...word, learned: !word.learned };         }         return word;       })     );   }, [wordMap, batchUpdateWords]);    // ⭐ FIXED: Enhanced toggle difficult with proper validation   const toggleWordDifficult = useCallback((id) => {     // ⭐ VERIFICATION: Check if word exists before toggle     const existingWord = wordMap[id];     if (!existingWord) {       throw new Error('Word not found');     }          batchUpdateWords(prevWords =>       prevWords.map(word => {         if (word.id === id) {           return { ...word, difficult: !word.difficult };         }         return word;       })     );   }, [wordMap, batchUpdateWords]);    // ⭐ FIXED: Enhanced remove word with proper validation   const removeWord = useCallback((id) => {     // ⭐ VERIFICATION: Check if word exists before removal     const existingWord = wordMap[id];     if (!existingWord) {       throw new Error('Word not found');     }          batchUpdateWords(prevWords => {       const filteredWords = prevWords.filter(word => word.id !== id);       return filteredWords;     });          // ⭐ FIXED: Clear editing state if we're removing the word being edited     if (editingWord?.id === id) {       setEditingWord(null);     }   }, [editingWord?.id, wordMap, batchUpdateWords]);    // ⭐ FIXED: Enhanced import with better validation and sync   const importWords = useCallback((jsonText) => {     try {       const importedWords = JSON.parse(jsonText.trim());              if (!Array.isArray(importedWords) || importedWords.length === 0) {         throw new Error('Invalid JSON data - expected array of words');       }        // ⭐ FIXED: Better word validation and ID generation       const validWords = importedWords         .filter(word => word?.english && word?.italian)         .map(word => ({           id: word.id || `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,           english: String(word.english).trim(),           italian: String(word.italian).trim(),           group: word.group ? String(word.group).trim() : null,           sentence: word.sentence ? String(word.sentence).trim() : null,           notes: word.notes ? String(word.notes).trim() : null,           chapter: word.chapter ? String(word.chapter).trim() : null,           learned: Boolean(word.learned),           difficult: Boolean(word.difficult)         }));        if (validWords.length === 0) {         throw new Error('No valid words found in JSON data');       }        // ⭐ FIXED: Better duplicate checking using current words state       const currentWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');       const existingEnglish = new Set(currentWords.map(w => w.english.toLowerCase()));       const newWords = validWords.filter(word =>         !existingEnglish.has(word.english.toLowerCase())       );        if (newWords.length === 0) {         throw new Error('All words already exist in your vocabulary');       }        // ⭐ FIXED: Direct localStorage update + state update for immediate sync       const allWords = [...currentWords, ...newWords];       localStorage.setItem('vocabularyWords', JSON.stringify(allWords));       localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());              // Update state immediately       setWords(allWords);       setRefreshTrigger(prev => prev + 1);              // ⭐ FIXED: Trigger refresh event for other components       window.dispatchEvent(new CustomEvent('wordsImported', {          detail: { count: newWords.length, total: allWords.length }       }));              return newWords.length;     } catch (error) {       throw error;     }   }, [setWords]);    // ⭐ ENHANCED: Getters with proper filtering   const getters = useMemo(() => ({     getWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter),     getDifficultWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter && word.difficult),     getAvailableChapters: () => {       const chapters = new Set();       words.forEach(word => {         if (word.chapter) chapters.add(word.chapter);       });       return Array.from(chapters).sort((a, b) => {         const aNum = parseInt(a);         const bNum = parseInt(b);         return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);       });     },     getChapterStats: (chapter) => {       const chapterWords = words.filter(word => word.chapter === chapter);       return {         total: chapterWords.length,         learned: chapterWords.filter(w => w.learned).length,         unlearned: chapterWords.filter(w => !w.learned).length,         difficult: chapterWords.filter(w => w.difficult).length,         normal: chapterWords.filter(w => !w.difficult && !w.learned).length       };     }   }), [words, refreshTrigger]);    // ⭐ FIXED: Clear all words with proper cleanup   const clearAllWords = useCallback(() => {     setWords(EMPTY_ARRAY);     setEditingWord(null);     localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());     setRefreshTrigger(prev => prev + 1);   }, [setWords]);    return {     words,     editingWord,     setEditingWord,     wordStats,     addWord,     removeWord,     toggleWordLearned,     toggleWordDifficult,     clearAllWords,     importWords,     forceRefresh,     ...getters   }; };

================================================================================


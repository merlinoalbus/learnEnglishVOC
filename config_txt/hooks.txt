NOME FILE: useLoadingState.ts

import { useState, useCallback, useRef, useEffect } from 'react'; import { useNotification } from '../contexts/NotificationContext'; interface LoadingState { isLoading: boolean; error: Error | null; retryCount: number; startTime: number | null; operation: string | null; } interface LoadingOptions { timeout?: number; retryAttempts?: number; retryDelay?: number; showTimeoutWarning?: boolean; showRetryNotifications?: boolean; } interface LoadingStateHook extends LoadingState { startLoading: (operationName?: string) => void; stopLoading: (successMessage?: string) => void; setError: (error: Error, canRetry?: boolean) => void; retry: (operation: () => Promise<any>) => Promise<any>; canRetry: boolean; duration: number; } export const useLoadingState = (options: LoadingOptions = {}): LoadingStateHook => { const { timeout = 30000, retryAttempts = 3, retryDelay = 1000, showTimeoutWarning = true, showRetryNotifications = true } = options; const [state, setState] = useState<LoadingState>({ isLoading: false, error: null, retryCount: 0, startTime: null, operation: null }); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const { showWarning, showError, showSuccess } = useNotification(); const startLoading = useCallback((operationName = 'Operation') => { setState(prev => ({ ...prev, isLoading: true, error: null, startTime: Date.now(), operation: operationName })); if (showTimeoutWarning && timeout > 0) { timeoutRef.current = setTimeout(() => { showWarning(`⏱️ ${operationName} sta impiegando più tempo...`); }, timeout / 2); } }, [timeout, showTimeoutWarning, showWarning]); const stopLoading = useCallback((successMessage?: string) => { setState(prev => { const duration = prev.startTime ? Date.now() - prev.startTime : 0; if (successMessage && duration > 2000) { showSuccess(`${successMessage} (${Math.round(duration / 1000)}s)`); } return { ...prev, isLoading: false, error: null, retryCount: 0, startTime: null, operation: null }; }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } }, [showSuccess]); const setError = useCallback((error: Error, canRetry = true) => { setState(prev => { const newRetryCount = prev.retryCount + 1; const shouldRetry = canRetry && newRetryCount <= retryAttempts; if (shouldRetry && showRetryNotifications) { showWarning(`❌ ${error.message || error} - Tentativo ${newRetryCount}/${retryAttempts}`); } else if (!shouldRetry) { showError(error, prev.operation || 'Operation'); } return { ...prev, isLoading: false, error: error, retryCount: shouldRetry ? newRetryCount : prev.retryCount }; }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } }, [retryAttempts, showRetryNotifications, showWarning, showError]); const retry = useCallback(async (operation: () => Promise<any>) => { if (state.retryCount >= retryAttempts) { showError(new Error('Numero massimo tentativi raggiunto'), 'Retry'); return false; } await new Promise(resolve => setTimeout(resolve, retryDelay * state.retryCount)); try { startLoading(state.operation || 'Operation'); const result = await operation(); stopLoading(); return result; } catch (error) { setError(error instanceof Error ? error : new Error('Unknown error'), true); return false; } }, [state.retryCount, state.operation, retryAttempts, retryDelay, startLoading, stopLoading, setError, showError]); useEffect(() => { return () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } }; }, []); return { ...state, startLoading, stopLoading, setError, retry, canRetry: state.retryCount < retryAttempts, duration: state.startTime ? Date.now() - state.startTime : 0 }; }; export const useAILoading = () => { const loadingState = useLoadingState({ timeout: 45000, retryAttempts: 2, retryDelay: 2000, showTimeoutWarning: true }); const executeAIOperation = useCallback(async (operation: () => Promise<any>, operationName = 'AI Analysis') => { try { loadingState.startLoading(operationName); const timeoutPromise = new Promise((_, reject) => { setTimeout(() => reject(new Error('AI service timeout')), 45000); }); const result = await Promise.race([operation(), timeoutPromise]); loadingState.stopLoading(`✨ ${operationName} completata`); return result; } catch (error) { const errorMessage = error instanceof Error ? error.message : 'Unknown error'; if (errorMessage.includes('timeout')) { loadingState.setError(new Error('🤖 AI timeout. Riprova o usa modalità manuale.'), true); } else if (errorMessage.includes('API')) { loadingState.setError(new Error('🔑 Problema API key.'), false); } else if (errorMessage.includes('quota')) { loadingState.setError(new Error('🚫 Limite API raggiunto.'), false); } else { loadingState.setError(error instanceof Error ? error : new Error(errorMessage), true); } throw error; } }, [loadingState]); return { ...loadingState, executeAIOperation }; }; export const useStorageLoading = () => { const loadingState = useLoadingState({ timeout: 10000, retryAttempts: 3, retryDelay: 500, showTimeoutWarning: false }); const executeStorageOperation = useCallback(async (operation: () => Promise<any>, operationName = 'Storage Operation') => { try { loadingState.startLoading(operationName); const result = await operation(); loadingState.stopLoading(); return result; } catch (error) { const errorMessage = error instanceof Error ? error.message : 'Unknown error'; if (errorMessage.includes('quota') || errorMessage.includes('QuotaExceededError')) { loadingState.setError(new Error('💽 Spazio esaurito. Elimina dati vecchi.'), false); } else if (errorMessage.includes('localStorage')) { loadingState.setError(new Error('🔒 Accesso negato storage.'), true); } else { loadingState.setError(error instanceof Error ? error : new Error(errorMessage), true); } throw error; } }, [loadingState]); return { ...loadingState, executeStorageOperation }; }; export const useNetworkLoading = () => { const loadingState = useLoadingState({ timeout: 20000, retryAttempts: 3, retryDelay: 1500, showTimeoutWarning: true }); const executeNetworkOperation = useCallback(async (operation: () => Promise<any>, operationName = 'Network Request') => { try { loadingState.startLoading(operationName); const result = await operation(); loadingState.stopLoading(); return result; } catch (error) { const errorMessage = error instanceof Error ? error.message : 'Unknown error'; if (errorMessage.includes('fetch') || errorMessage.includes('network')) { loadingState.setError(new Error('📡 Nessuna connessione.'), true); } else if (errorMessage.includes('timeout')) { loadingState.setError(new Error('⏱️ Timeout rete.'), true); } else if (errorMessage.includes('404')) { loadingState.setError(new Error('🔍 Risorsa non trovata.'), false); } else if (errorMessage.includes('500')) { loadingState.setError(new Error('🔧 Errore server.'), true); } else { loadingState.setError(error instanceof Error ? error : new Error(errorMessage), true); } throw error; } }, [loadingState]); return { ...loadingState, executeNetworkOperation }; };

================================================================================

NOME FILE: useNotification.ts

import { useState, useCallback } from 'react'; interface UseNotificationReturn { message: string; showNotification: (msg: string, duration?: number) => void; } export const useNotification = (): UseNotificationReturn => { const [message, setMessage] = useState<string>(''); const showNotification = useCallback((msg: string, duration: number = 3000) => { setMessage(msg); setTimeout(() => setMessage(''), duration); }, []); return { message, showNotification }; };

================================================================================

NOME FILE: core\useAsyncOperation.ts

import { useState, useCallback, useRef, useEffect } from 'react'; export type AsyncOperationStatus = | 'idle' | 'pending' | 'success' | 'error' | 'cancelled' | 'retrying'; export interface RetryConfig { baseDelay: number; maxDelay: number; onRetry?: (error: Error, attempt: number) => void; } export interface ProgressConfig { onProgress?: (progress: number) => void; export interface TimeoutConfig { onTimeout?: () => void; } export interface AsyncOperationConfig { progress?: Partial<ProgressConfig>; enableCancellation?: boolean; autoResetDelay?: number; export interface OperationMetadata { endTime: Date | null; currentAttempt: number; cancellationReason?: string; } export interface AsyncOperationResult<TResult, TError = Error> { error: TError | null; loading: boolean; metadata: OperationMetadata; } export interface CancellationToken { reason?: string; cancel: (reason?: string) => void; } export function useAsyncOperation<TArgs extends any[], TResult, TError = Error>( operation: (...args: TArgs) => Promise<TResult>, config: AsyncOperationConfig = {} ): { error: TError | null; loading: boolean; metadata: OperationMetadata; retry: () => Promise<TResult>; reset: () => void; const createCancellationToken = useCallback((): CancellationToken => { let cancelFn: (reason?: string) => void; const promise = new Promise<void>((resolve) => { cancelFn = (reason?: string) => { token.isCancelled = true; token.reason = reason; resolve(); }; }); const token: CancellationToken = { isCancelled: false, reason: undefined, promise, cancel: (reason?: string) => cancelFn(reason), }; return token; }, []); const calculateRetryDelay = useCallback((attempt: number): number => { const delay = finalRetryConfig.baseDelay * Math.pow(finalRetryConfig.backoffMultiplier, attempt - 1); return Math.min(delay, finalRetryConfig.maxDelay); }, [finalRetryConfig]); const updateProgress = useCallback((newProgress: number) => { const clampedProgress = Math.max(0, Math.min(100, newProgress)); setProgress(clampedProgress); if (finalProgressConfig.onProgress) { finalProgressConfig.onProgress(clampedProgress); } }, [finalProgressConfig]); const updateMetadata = useCallback((updates: Partial<OperationMetadata>) => { setMetadata(prev => { const updated = { ...prev, ...updates }; if (updated.startTime && updated.endTime) { updated.duration = updated.endTime.getTime() - updated.startTime.getTime(); } return updated; }); }, []); const reset = useCallback(() => { setData(null); setError(null); setStatus('idle'); setProgress(0); setMetadata({ startTime: null, endTime: null, duration: null, currentAttempt: 0, previousErrors: [], }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); autoResetTimeoutRef.current = null; } if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel('reset'); } lastArgsRef.current = null; if (debug) { console.log('🔄 AsyncOperation reset'); } }, [debug]); const executeWithRetry = useCallback(async ( args: TArgs, attempt: number = 1 ): Promise<TResult> => { const startTime = new Date(); updateMetadata({ startTime, currentAttempt: attempt, }); if (debug) { console.log(`🔄 AsyncOperation attempt ${attempt}/${finalRetryConfig.maxAttempts}`, args); } try { if (enableCancellation) { cancellationTokenRef.current = createCancellationToken(); } if (finalTimeoutConfig.timeout > 0) { timeoutRef.current = setTimeout(() => { const timeoutError = new Error(`Operation timed out after ${finalTimeoutConfig.timeout}ms`); if (finalTimeoutConfig.onTimeout) { finalTimeoutConfig.onTimeout(); } if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel('timeout'); } throw timeoutError; }, finalTimeoutConfig.timeout); } if (finalProgressConfig.trackProgress) { updateProgress(10); } const result = await operationRef.current(...args); if (cancellationTokenRef.current?.isCancelled) { throw new Error(`Operation cancelled: ${cancellationTokenRef.current.reason || 'unknown'}`); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (finalProgressConfig.trackProgress) { updateProgress(100); } const endTime = new Date(); updateMetadata({ endTime, duration: endTime.getTime() - startTime.getTime(), }); if (debug) { console.log('🔄 AsyncOperation success', result); } return result; } catch (error) { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } const operationError = error as TError; if (debug) { console.error(`🔄 AsyncOperation attempt ${attempt} failed:`, operationError); } updateMetadata({ endTime: new Date(), previousErrors: [...metadata.previousErrors, operationError as Error], }); const shouldRetry = attempt < finalRetryConfig.maxAttempts && finalRetryConfig.shouldRetry!(operationError as Error, attempt); if (shouldRetry && (!cancellationTokenRef.current?.isCancelled)) { if (finalRetryConfig.onRetry) { finalRetryConfig.onRetry(operationError as Error, attempt); } setStatus('retrying'); const retryDelay = calculateRetryDelay(attempt); await new Promise(resolve => setTimeout(resolve, retryDelay)); if (cancellationTokenRef.current?.isCancelled) { throw new Error(`Operation cancelled during retry: ${cancellationTokenRef.current.reason}`); } return executeWithRetry(args, attempt + 1); } throw operationError; } }, [ finalRetryConfig, finalTimeoutConfig, finalProgressConfig, enableCancellation, debug, updateMetadata, updateProgress, createCancellationToken, calculateRetryDelay, metadata.previousErrors, ]); const execute = useCallback(async (...args: TArgs): Promise<TResult> => { setError(null); setStatus('pending'); setProgress(finalProgressConfig.trackProgress ? 0 : 0); lastArgsRef.current = args; try { const result = await executeWithRetry(args); setData(result); setStatus('success'); if (autoReset) { autoResetTimeoutRef.current = setTimeout(() => { reset(); }, autoResetDelay); } return result; } catch (error) { const operationError = error as TError; setError(operationError); if (cancellationTokenRef.current?.isCancelled) { setStatus('cancelled'); updateMetadata({ cancellationReason: cancellationTokenRef.current.reason }); } else { setStatus('error'); } throw operationError; } }, [ finalProgressConfig.trackProgress, executeWithRetry, autoReset, autoResetDelay, reset, updateMetadata, ]); const retry = useCallback(async (): Promise<TResult> => { if (!lastArgsRef.current) { throw new Error('No previous arguments to retry with'); } if (debug) { console.log('🔄 AsyncOperation manual retry'); } return execute(...lastArgsRef.current); }, [execute, debug]); const cancel = useCallback((reason?: string) => { if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel(reason || 'manual cancellation'); if (debug) { console.log('🔄 AsyncOperation cancelled:', reason); } } }, [debug]); const loading = status === 'pending' || status === 'retrying'; const canRetry = status === 'error' && lastArgsRef.current !== null; useEffect(() => { return () => { if (cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled) { cancellationTokenRef.current.cancel('component unmount'); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); } }; }, []); return { data, error, status, loading, progress, metadata, execute, retry, cancel, reset, canRetry, }; } export function useAsyncWithProgress<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, onProgress?: (progress: number) => void ) { return useAsyncOperation(operation, { progress: { trackProgress: true, onProgress, stepSize: 5, }, }); } export function useAsyncWithRetry<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, retryConfig?: Partial<RetryConfig> ) { return useAsyncOperation(operation, { retry: { maxAttempts: 3, baseDelay: 1000, backoffMultiplier: 2, ...retryConfig, }, }); } export function useAsyncWithTimeout<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, timeout: number, onTimeout?: () => void ) { return useAsyncOperation(operation, { timeout: { timeout, onTimeout, }, }); } export function useCancellableAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult> ) { return useAsyncOperation(operation, { enableCancellation: true, }); } export function useParallelAsync<TResult>( operations: Array<() => Promise<TResult>> ) { const [results, setResults] = useState<Array<TResult | Error>>([]); const [loading, setLoading] = useState(false); const [completed, setCompleted] = useState(0); const executeAll = useCallback(async (): Promise<Array<TResult | Error>> => { setLoading(true); setCompleted(0); setResults([]); const promises = operations.map(async (operation, index) => { try { const result = await operation(); setCompleted(prev => prev + 1); return result; } catch (error) { setCompleted(prev => prev + 1); return error as Error; } }); const allResults = await Promise.all(promises); setResults(allResults); setLoading(false); return allResults; }, [operations]); const progress = operations.length > 0 ? (completed / operations.length) * 100 : 0; return { executeAll, results, loading, progress, completed, total: operations.length, }; } export function useDebouncedAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, delay: number = 300 ) { const asyncOp = useAsyncOperation(operation); const [debouncedExecute, setDebouncedExecute] = useState<(...args: TArgs) => Promise<TResult>>(); useEffect(() => { let timeoutId: NodeJS.Timeout; const debouncedFn = (...args: TArgs): Promise<TResult> => { return new Promise((resolve, reject) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => { asyncOp.execute(...args).then(resolve).catch(reject); }, delay); }); }; setDebouncedExecute(() => debouncedFn); return () => { clearTimeout(timeoutId); }; }, [operation, delay, asyncOp]); return { ...asyncOp, execute: debouncedExecute || asyncOp.execute, }; } export default useAsyncOperation;

================================================================================

NOME FILE: core\useCache.ts

import { useState, useCallback, useRef, useEffect } from "react"; export type AsyncOperationStatus = | "idle" | "pending" | "success" | "error" | "cancelled" | "retrying"; export interface RetryConfig { baseDelay: number; maxDelay: number; onRetry?: (error: Error, attempt: number) => void; } export interface ProgressConfig { onProgress?: (progress: number) => void; export interface TimeoutConfig { onTimeout?: () => void; } export interface AsyncOperationConfig { progress?: Partial<ProgressConfig>; enableCancellation?: boolean; autoResetDelay?: number; export interface OperationMetadata { endTime: Date | null; currentAttempt: number; cancellationReason?: string; } export interface AsyncOperationResult<TResult, TError = Error> { error: TError | null; loading: boolean; metadata: OperationMetadata; } export interface CancellationToken { reason?: string; cancel: (reason?: string) => void; } export function useAsyncOperation<TArgs extends any[], TResult, TError = Error>( operation: (...args: TArgs) => Promise<TResult>, config: AsyncOperationConfig = {} ): { error: TError | null; loading: boolean; metadata: OperationMetadata; retry: () => Promise<TResult>; reset: () => void; const createCancellationToken = useCallback((): CancellationToken => { let cancelFn: (reason?: string) => void; const promise = new Promise<void>((resolve) => { cancelFn = (reason?: string) => { token.isCancelled = true; token.reason = reason; resolve(); }; }); const token: CancellationToken = { isCancelled: false, reason: undefined, promise, cancel: (reason?: string) => cancelFn(reason), }; return token; }, []); const calculateRetryDelay = useCallback( (attempt: number): number => { const delay = finalRetryConfig.baseDelay * Math.pow(finalRetryConfig.backoffMultiplier, attempt - 1); return Math.min(delay, finalRetryConfig.maxDelay); }, [finalRetryConfig] ); const updateProgress = useCallback( (newProgress: number) => { const clampedProgress = Math.max(0, Math.min(100, newProgress)); setProgress(clampedProgress); if (finalProgressConfig.onProgress) { finalProgressConfig.onProgress(clampedProgress); } }, [finalProgressConfig] ); const updateMetadata = useCallback((updates: Partial<OperationMetadata>) => { setMetadata((prev) => { const updated = { ...prev, ...updates }; if (updated.startTime && updated.endTime) { updated.duration = updated.endTime.getTime() - updated.startTime.getTime(); } return updated; }); }, []); const reset = useCallback(() => { setData(null); setError(null); setStatus("idle"); setProgress(0); setMetadata({ startTime: null, endTime: null, duration: null, currentAttempt: 0, previousErrors: [], }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); autoResetTimeoutRef.current = null; } if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel("reset"); } lastArgsRef.current = null; if (debug) { console.log("🔄 AsyncOperation reset"); } }, [debug]); const executeWithRetry = useCallback( async (args: TArgs, attempt: number = 1): Promise<TResult> => { const startTime = new Date(); updateMetadata({ startTime, currentAttempt: attempt, }); if (debug) { console.log( `🔄 AsyncOperation attempt ${attempt}/${finalRetryConfig.maxAttempts}`, args ); } try { if (enableCancellation) { cancellationTokenRef.current = createCancellationToken(); } if (finalTimeoutConfig.timeout > 0) { timeoutRef.current = setTimeout(() => { const timeoutError = new Error( `Operation timed out after ${finalTimeoutConfig.timeout}ms` ); if (finalTimeoutConfig.onTimeout) { finalTimeoutConfig.onTimeout(); } if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel("timeout"); } throw timeoutError; }, finalTimeoutConfig.timeout); } if (finalProgressConfig.trackProgress) { updateProgress(10); } const result = await operationRef.current(...args); if (cancellationTokenRef.current?.isCancelled) { throw new Error( `Operation cancelled: ${ cancellationTokenRef.current.reason || "unknown" }` ); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (finalProgressConfig.trackProgress) { updateProgress(100); } const endTime = new Date(); updateMetadata({ endTime, duration: endTime.getTime() - startTime.getTime(), }); if (debug) { console.log("🔄 AsyncOperation success", result); } return result; } catch (error) { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } const operationError = error as TError; if (debug) { console.error( `🔄 AsyncOperation attempt ${attempt} failed:`, operationError ); } updateMetadata({ endTime: new Date(), previousErrors: [...metadata.previousErrors, operationError as Error], }); const shouldRetry = attempt < finalRetryConfig.maxAttempts && finalRetryConfig.shouldRetry!(operationError as Error, attempt); if (shouldRetry && !cancellationTokenRef.current?.isCancelled) { if (finalRetryConfig.onRetry) { finalRetryConfig.onRetry(operationError as Error, attempt); } setStatus("retrying"); const retryDelay = calculateRetryDelay(attempt); await new Promise((resolve) => setTimeout(resolve, retryDelay)); if (cancellationTokenRef.current?.isCancelled) { throw new Error( `Operation cancelled during retry: ${cancellationTokenRef.current.reason}` ); } return executeWithRetry(args, attempt + 1); } throw operationError; } }, [ finalRetryConfig, finalTimeoutConfig, finalProgressConfig, enableCancellation, debug, updateMetadata, updateProgress, createCancellationToken, calculateRetryDelay, metadata.previousErrors, ] ); const execute = useCallback( async (...args: TArgs): Promise<TResult> => { setError(null); setStatus("pending"); setProgress(finalProgressConfig.trackProgress ? 0 : 0); lastArgsRef.current = args; try { const result = await executeWithRetry(args); setData(result); setStatus("success"); if (autoReset) { autoResetTimeoutRef.current = setTimeout(() => { reset(); }, autoResetDelay); } return result; } catch (error) { const operationError = error as TError; setError(operationError); if (cancellationTokenRef.current?.isCancelled) { setStatus("cancelled"); updateMetadata({ cancellationReason: cancellationTokenRef.current.reason, }); } else { setStatus("error"); } throw operationError; } }, [ finalProgressConfig.trackProgress, executeWithRetry, autoReset, autoResetDelay, reset, updateMetadata, ] ); const retry = useCallback(async (): Promise<TResult> => { if (!lastArgsRef.current) { throw new Error("No previous arguments to retry with"); } if (debug) { console.log("🔄 AsyncOperation manual retry"); } return execute(...lastArgsRef.current); }, [execute, debug]); const cancel = useCallback( (reason?: string) => { if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel(reason || "manual cancellation"); if (debug) { console.log("🔄 AsyncOperation cancelled:", reason); } } }, [debug] ); const loading = status === "pending" || status === "retrying"; const canRetry = status === "error" && lastArgsRef.current !== null; useEffect(() => { return () => { if ( cancellationTokenRef.current && !cancellationTokenRef.current.isCancelled ) { cancellationTokenRef.current.cancel("component unmount"); } if (timeoutRef.current) { clearTimeout(timeoutRef.current); } if (autoResetTimeoutRef.current) { clearTimeout(autoResetTimeoutRef.current); } }; }, []); return { data, error, status, loading, progress, metadata, execute, retry, cancel, reset, canRetry, }; } export function useAsyncWithProgress<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, onProgress?: (progress: number) => void ) { return useAsyncOperation(operation, { progress: { trackProgress: true, onProgress, stepSize: 5, }, }); } export function useAsyncWithRetry<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, retryConfig?: Partial<RetryConfig> ) { return useAsyncOperation(operation, { retry: { maxAttempts: 3, baseDelay: 1000, backoffMultiplier: 2, ...retryConfig, }, }); } export function useAsyncWithTimeout<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, timeout: number, onTimeout?: () => void ) { return useAsyncOperation(operation, { timeout: { timeout, onTimeout, }, }); } export function useCancellableAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult> ) { return useAsyncOperation(operation, { enableCancellation: true, }); } export function useParallelAsync<TResult>( operations: Array<() => Promise<TResult>> ) { const [results, setResults] = useState<Array<TResult | Error>>([]); const [loading, setLoading] = useState(false); const [completed, setCompleted] = useState(0); const executeAll = useCallback(async (): Promise<Array<TResult | Error>> => { setLoading(true); setCompleted(0); setResults([]); const promises = operations.map(async (operation, index) => { try { const result = await operation(); setCompleted((prev) => prev + 1); return result; } catch (error) { setCompleted((prev) => prev + 1); return error as Error; } }); const allResults = await Promise.all(promises); setResults(allResults); setLoading(false); return allResults; }, [operations]); const progress = operations.length > 0 ? (completed / operations.length) * 100 : 0; return { executeAll, results, loading, progress, completed, total: operations.length, }; } export function useDebouncedAsync<TArgs extends any[], TResult>( operation: (...args: TArgs) => Promise<TResult>, delay: number = 300 ) { const asyncOp = useAsyncOperation(operation); const [debouncedExecute, setDebouncedExecute] = useState<(...args: TArgs) => Promise<TResult>>(); useEffect(() => { let timeoutId: NodeJS.Timeout; const debouncedFn = (...args: TArgs): Promise<TResult> => { return new Promise((resolve, reject) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => { asyncOp .execute(...args) .then(resolve) .catch(reject); }, delay); }); }; setDebouncedExecute(() => debouncedFn); return () => { clearTimeout(timeoutId); }; }, [operation, delay, asyncOp]); return { ...asyncOp, execute: debouncedExecute || asyncOp.execute, }; } export default useAsyncOperation;

================================================================================

NOME FILE: core\useDebounce.ts

import { useState, useEffect, useCallback, useRef } from 'react'; interface DebounceOptions { leading?: boolean; maxWait?: number; } interface DebouncedResult<T> { currentValue: T; cancel: () => void; setValue: (value: T) => void; } interface DebouncedCallback<TArgs extends any[], TReturn> { cancel: () => void; isPending: () => boolean; } export function useDebounce<T>( value: T, delay: number, options: Partial<DebounceOptions> = {} ): DebouncedResult<T> { const { leading = false, trailing = true, maxWait, } = options; const [debouncedValue, setDebouncedValue] = useState<T>(value); const [currentValue, setCurrentValue] = useState<T>(value); const [isPending, setIsPending] = useState<boolean>(false); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const maxTimeoutRef = useRef<NodeJS.Timeout | null>(null); const lastCallTimeRef = useRef<number>(0); const lastInvokeTimeRef = useRef<number>(0); const clearTimeouts = useCallback(() => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (maxTimeoutRef.current) { clearTimeout(maxTimeoutRef.current); maxTimeoutRef.current = null; } }, []); const invokeCallback = useCallback((val: T) => { setDebouncedValue(val); setIsPending(false); lastInvokeTimeRef.current = Date.now(); }, []); const debouncedUpdate = useCallback((val: T) => { const now = Date.now(); lastCallTimeRef.current = now; if (leading && lastInvokeTimeRef.current === 0) { invokeCallback(val); return; } clearTimeouts(); setIsPending(true); timeoutRef.current = setTimeout(() => { if (trailing) { invokeCallback(val); } else { setIsPending(false); } }, delay); if (maxWait && lastInvokeTimeRef.current > 0) { const timeSinceLastInvoke = now - lastInvokeTimeRef.current; if (timeSinceLastInvoke >= maxWait) { invokeCallback(val); } else { maxTimeoutRef.current = setTimeout(() => { invokeCallback(val); }, maxWait - timeSinceLastInvoke); } } }, [delay, leading, trailing, maxWait, invokeCallback, clearTimeouts]); const cancel = useCallback(() => { clearTimeouts(); setIsPending(false); }, [clearTimeouts]); const flush = useCallback(() => { if (isPending) { clearTimeouts(); invokeCallback(currentValue); } }, [isPending, currentValue, clearTimeouts, invokeCallback]); const setValue = useCallback((val: T) => { setCurrentValue(val); debouncedUpdate(val); }, [debouncedUpdate]); useEffect(() => { if (currentValue !== value) { setCurrentValue(value); debouncedUpdate(value); } }, [value, currentValue, debouncedUpdate]); useEffect(() => { return () => { clearTimeouts(); }; }, [clearTimeouts]); return { debouncedValue, currentValue, isPending, cancel, flush, setValue, }; } export function useDebouncedCallback<TArgs extends any[], TReturn>( callback: (...args: TArgs) => TReturn | Promise<TReturn>, delay: number, options: Partial<DebounceOptions> = {} ): DebouncedCallback<TArgs, TReturn> { const { leading = false, trailing = true, maxWait, } = options; const callbackRef = useRef(callback); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const maxTimeoutRef = useRef<NodeJS.Timeout | null>(null); const lastCallTimeRef = useRef<number>(0); const lastInvokeTimeRef = useRef<number>(0); const lastArgsRef = useRef<TArgs | null>(null); const pendingPromiseRef = useRef<{ resolve: (value: TReturn) => void; reject: (error: any) => void; } | null>(null); useEffect(() => { callbackRef.current = callback; }, [callback]); const clearTimeouts = useCallback(() => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } if (maxTimeoutRef.current) { clearTimeout(maxTimeoutRef.current); maxTimeoutRef.current = null; } }, []); const invokeCallback = useCallback(async (...args: TArgs): Promise<TReturn> => { lastInvokeTimeRef.current = Date.now(); try { const result = await callbackRef.current(...args); return result; } catch (error) { throw error; } }, []); const debouncedFn = useCallback((...args: TArgs): Promise<TReturn> => { return new Promise<TReturn>((resolve, reject) => { const now = Date.now(); lastCallTimeRef.current = now; lastArgsRef.current = args; if (leading && lastInvokeTimeRef.current === 0) { invokeCallback(...args) .then(resolve) .catch(reject); return; } pendingPromiseRef.current = { resolve, reject }; clearTimeouts(); timeoutRef.current = setTimeout(() => { if (trailing && lastArgsRef.current && pendingPromiseRef.current) { invokeCallback(...lastArgsRef.current) .then(pendingPromiseRef.current.resolve) .catch(pendingPromiseRef.current.reject) .finally(() => { pendingPromiseRef.current = null; }); } }, delay); if (maxWait && lastInvokeTimeRef.current > 0) { const timeSinceLastInvoke = now - lastInvokeTimeRef.current; if (timeSinceLastInvoke >= maxWait) { invokeCallback(...args) .then(resolve) .catch(reject); pendingPromiseRef.current = null; } else { maxTimeoutRef.current = setTimeout(() => { if (lastArgsRef.current && pendingPromiseRef.current) { invokeCallback(...lastArgsRef.current) .then(pendingPromiseRef.current.resolve) .catch(pendingPromiseRef.current.reject) .finally(() => { pendingPromiseRef.current = null; }); } }, maxWait - timeSinceLastInvoke); } } }); }, [delay, leading, trailing, maxWait, invokeCallback, clearTimeouts]); const cancel = useCallback(() => { clearTimeouts(); if (pendingPromiseRef.current) { pendingPromiseRef.current.reject(new Error('Debounced call cancelled')); pendingPromiseRef.current = null; } }, [clearTimeouts]); const flush = useCallback((...args: TArgs): Promise<TReturn> => { const argsToUse = args.length > 0 ? args : lastArgsRef.current; if (!argsToUse) { return Promise.reject(new Error('No arguments to flush')); } cancel(); return invokeCallback(...argsToUse); }, [cancel, invokeCallback]); const isPending = useCallback((): boolean => { return pendingPromiseRef.current !== null; }, []); useEffect(() => { return () => { clearTimeouts(); if (pendingPromiseRef.current) { pendingPromiseRef.current.reject(new Error('Component unmounted')); } }; }, [clearTimeouts]); const debouncedCallback = debouncedFn as DebouncedCallback<TArgs, TReturn>; debouncedCallback.cancel = cancel; debouncedCallback.flush = flush; debouncedCallback.isPending = isPending; return debouncedCallback; } export function useDebouncedSearch<TResult>( searchFunction: (query: string) => Promise<TResult[]>, delay: number = 300, options: { minLength?: number; immediate?: boolean; keepPreviousResults?: boolean; } = {} ) { const { minLength = 1, immediate = false, keepPreviousResults = false, } = options; const [searchTerm, setSearchTerm] = useState<string>(''); const [results, setResults] = useState<TResult[]>([]); const [isSearching, setIsSearching] = useState<boolean>(false); const [error, setError] = useState<Error | null>(null); const debouncedSearch = useDebouncedCallback( async (query: string): Promise<TResult[]> => { if (query.length < minLength) { return []; } setIsSearching(true); setError(null); try { const searchResults = await searchFunction(query); setResults(searchResults); return searchResults; } catch (err) { const error = err instanceof Error ? err : new Error('Search failed'); setError(error); if (!keepPreviousResults) { setResults([]); } throw error; } finally { setIsSearching(false); } }, delay, { trailing: true } ); const search = useCallback(async (query: string): Promise<TResult[]> => { setSearchTerm(query); if (query.length < minLength) { setResults([]); setIsSearching(false); setError(null); return []; } return debouncedSearch(query); }, [minLength, debouncedSearch]); useEffect(() => { if (immediate && searchTerm) { search(searchTerm); } }, [immediate, searchTerm, search]); const clear = useCallback(() => { setSearchTerm(''); setResults([]); setIsSearching(false); setError(null); debouncedSearch.cancel(); }, [debouncedSearch]); const cancel = useCallback(() => { debouncedSearch.cancel(); setIsSearching(false); }, [debouncedSearch]); return { results, error, clear, setSearchTerm: (term: string) => { setSearchTerm(term); if (immediate) { search(term); } }, }; } export function useDebouncedValue<T>( initialValue: T, delay: number ): [T, T, (value: T) => void] { const [value, setValue] = useState<T>(initialValue); const { debouncedValue } = useDebounce(value, delay); return [value, debouncedValue, setValue]; } export function useDebouncedAsync<TArgs extends any[], TResult>( asyncFunction: (...args: TArgs) => Promise<TResult>, delay: number, options: Partial<DebounceOptions> = {} ) { const [loading, setLoading] = useState<boolean>(false); const [result, setResult] = useState<TResult | null>(null); const [error, setError] = useState<Error | null>(null); const debouncedFn = useDebouncedCallback( async (...args: TArgs): Promise<TResult> => { setLoading(true); setError(null); try { const result = await asyncFunction(...args); setResult(result); return result; } catch (err) { const error = err instanceof Error ? err : new Error('Async operation failed'); setError(error); throw error; } finally { setLoading(false); } }, delay, options ); const clear = useCallback(() => { setResult(null); setError(null); setLoading(false); debouncedFn.cancel(); }, [debouncedFn]); return { loading: loading || debouncedFn.isPending(), error, cancel: debouncedFn.cancel, }; } export default useDebounce;

================================================================================

NOME FILE: core\useFirestore.ts

import { useState, useEffect, useCallback, useMemo, useRef } from "react"; import { collection, doc, getDocs, getDoc, addDoc, setDoc, updateDoc, deleteDoc, query, where, orderBy, limit, onSnapshot, writeBatch, type Query, type DocumentData, type Unsubscribe, type WhereFilterOp, type OrderByDirection, } from "firebase/firestore"; import { db, auth } from "../../config/firebase"; import { useFirebase } from "../../contexts/FirebaseContext"; import { useAsyncOperation } from "./useAsyncOperation"; import type { Word } from "../../types/entities/Word.types"; import type { Statistics } from "../../types/entities/Statistics.types"; import type { WordPerformance } from "../../types/entities/Performance.types"; import type { FirestoreDoc, FirestoreQuery, FirestoreError, FirestoreOperationResult, FirestoreCollectionName, FirestoreOperation, FirestoreListener, FirestoreListenerData, ChangeType, } from "../../types/infrastructure/Firestore.types"; interface UseFirestoreConfig<T> { collection: string; realtime?: boolean; autoFetch?: boolean; enableCache?: boolean; syncWithLocalStorage?: boolean; localStorageKey?: string; debug?: boolean; } interface UseFirestoreState<T> { data: T[]; loading: boolean; error: FirestoreError | null; listening: boolean; lastSync: Date | null; fromCache: boolean; } interface UseFirestoreOperations<T> { fetch: () => Promise<T[]>; create: (data: Omit<T, "id">) => Promise<T>; update: (id: string, data: Partial<Omit<T, "id">>) => Promise<T>; remove: (id: string) => Promise<void>; batchUpdate: (operations: BatchOperation<T>[]) => Promise<void>; clearCache: () => void; refresh: () => Promise<void>; startListening: () => void; stopListening: () => void; } interface UseFirestoreUtils<T> { findById: (id: string) => T | undefined; filter: (predicate: (item: T) => boolean) => T[]; sort: (compareFn: (a: T, b: T) => number) => T[]; getStats: () => { total: number; lastUpdated: Date | null; cacheHits: number; }; } interface UseFirestoreResult<T> extends UseFirestoreState<T>, UseFirestoreOperations<T> { utils: UseFirestoreUtils<T>; } interface BatchOperation<T> { type: "create" | "update" | "delete"; id?: string; data?: Partial<Omit<T, "id">>; } export function useFirestore<T extends { id: string }>( config: UseFirestoreConfig<T> ): UseFirestoreResult<T> { const { collection: collectionName, realtime = false, enableCache = true, autoFetch = true, syncWithLocalStorage = false, localStorageKey, debug = false, } = config; const { isReady } = useFirebase(); const hasInitialFetch = useRef(false); const isInitializing = useRef(false); const fetchAttempts = useRef(0); const MAX_FETCH_ATTEMPTS = 1; const [state, setState] = useState<UseFirestoreState<T>>({ data: [], loading: false, error: null, listening: false, lastSync: null, fromCache: false, }); const listenerRef = useRef<Unsubscribe | null>(null); const cacheRef = useRef<Map<string, T>>(new Map()); const statsRef = useRef({ cacheHits: 0, totalFetches: 0, }); const getCurrentUserId = useCallback(() => { return auth.currentUser?.uid || null; }, []); const createError = useCallback( (code: string, message: string, originalError?: any): FirestoreError => { return { code: code as any, message, details: originalError, operation: "unknown" as any, recoverable: true, timestamp: new Date(), }; }, [] ); const fetchOperation = useAsyncOperation( async (): Promise<T[]> => { if (!isReady) { throw new Error( "🔥 Firebase not ready - please wait for initialization" ); } const userId = getCurrentUserId(); if (!userId) { if (debug) { console.log( `🔥 [useFirestore] No user authenticated for ${collectionName}, returning empty array` ); } return []; } if (debug) { console.log( `🔥 [useFirestore] Fetching ${collectionName} for user ${userId}` ); } const collectionRef = collection(db, collectionName); let q: Query<DocumentData> = query( collectionRef, where("firestoreMetadata.userId", "==", userId), where("firestoreMetadata.deleted", "==", false) ); const snapshot = await getDocs(q); const docs: T[] = []; snapshot.forEach((docSnap) => { const data = docSnap.data(); const firestoreDoc = { id: docSnap.id, ...data, } as T; docs.push(firestoreDoc); }); if (enableCache) { docs.forEach((doc) => { cacheRef.current.set(doc.id, doc); }); } if (syncWithLocalStorage && localStorageKey) { try { localStorage.setItem(localStorageKey, JSON.stringify(docs)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync with localStorage:", error ); } } statsRef.current.totalFetches++; if (debug) { console.log( `🔥 [useFirestore] Fetched ${docs.length} documents from ${collectionName}` ); } return docs; }, { retry: { maxAttempts: 3 }, debug } ); const create = useCallback( async (data: Omit<T, "id">): Promise<T> => { if (!isReady) { throw new Error("🔥 Firebase not ready for create operation"); } const userId = getCurrentUserId(); if (!userId) { throw new Error("🔐 User not authenticated for create operation"); } if (debug) { console.log( `🔥 [useFirestore] Creating document in ${collectionName}:`, data ); } const now = new Date(); const documentData = { ...data, firestoreMetadata: { userId, createdAt: now, updatedAt: now, version: 1, deleted: false, custom: {}, }, }; const collectionRef = collection(db, collectionName); const docRef = await addDoc(collectionRef, documentData); const newDoc = { id: docRef.id, ...documentData, _lastSyncedAt: new Date(), _pendingSync: false, _firestoreStatus: 'synced' } as unknown as T; setState((prev) => ({ ...prev, data: [...prev.data, newDoc], lastSync: new Date(), })); if (enableCache) { cacheRef.current.set(newDoc.id, newDoc); } if (syncWithLocalStorage && localStorageKey) { try { const updatedData = [...state.data, newDoc]; localStorage.setItem(localStorageKey, JSON.stringify(updatedData)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync create with localStorage:", error ); } } return newDoc; }, [ isReady, collectionName, enableCache, debug, getCurrentUserId, syncWithLocalStorage, localStorageKey, state.data, ] ); const update = useCallback( async (id: string, updates: Partial<Omit<T, "id">>): Promise<T> => { if (!isReady) { throw new Error("🔥 Firebase not ready for update operation"); } if (debug) { console.log( `🔥 [useFirestore] Updating document ${id} in ${collectionName}:`, updates ); } const docRef = doc(db, collectionName, id); const updateData = { ...updates, "firestoreMetadata.updatedAt": new Date(), }; let firestoreUpdateSuccess = true; try { const docSnapshot = await getDoc(docRef); if (!docSnapshot.exists()) { console.warn(`🔥 [useFirestore] Document ${id} does not exist, creating it instead of updating`); const existingLocalItem = state.data.find((item) => item.id === id); if (existingLocalItem) { const createData = { ...existingLocalItem, ...updates, "firestoreMetadata.createdAt": new Date(), "firestoreMetadata.updatedAt": new Date(), }; await setDoc(docRef, createData); console.log(`✅ [useFirestore] Created missing document ${id} in Firestore`); } else { throw new Error(`Local item ${id} not found to create in Firestore`); } } else { await updateDoc(docRef, updateData); } } catch (error: any) { console.error(`🔥 [useFirestore] Failed to update document ${id}:`, error); firestoreUpdateSuccess = false; if (error.code === 'unavailable' || error.code === 'deadline-exceeded' || error.code === 'failed-precondition' || error.code === 'cancelled' || error.message?.includes('Failed to get document') || error.message?.includes('network')) { console.log(`🔥 [useFirestore] Network/connection error, updating local state only for ${id}`, error); } else if (error.message?.includes('No document to update')) { console.warn(`🔥 [useFirestore] Document ${id} does not exist in Firestore, creating it instead`); try { const existingLocalItem = state.data.find((item) => item.id === id); if (existingLocalItem) { const createData = { ...existingLocalItem, ...updates, "firestoreMetadata.createdAt": new Date(), "firestoreMetadata.updatedAt": new Date(), }; await setDoc(docRef, createData); firestoreUpdateSuccess = true; console.log(`✅ [useFirestore] Created missing document ${id} in Firestore`); } else { throw new Error(`Local item ${id} not found to create in Firestore`); } } catch (createError: any) { console.error(`🔥 [useFirestore] Failed to create missing document ${id}:`, createError); firestoreUpdateSuccess = false; } } else { console.error(`🔥 [useFirestore] Non-recoverable error, rethrowing:`, error); throw error; } } const existingItem = state.data.find((item) => item.id === id); if (!existingItem) { throw new Error(`Document with id ${id} not found in local state`); } const updatedItem = { ...existingItem, ...updates, _lastSyncedAt: firestoreUpdateSuccess ? new Date() : (existingItem as any)._lastSyncedAt, _pendingSync: !firestoreUpdateSuccess, _firestoreStatus: firestoreUpdateSuccess ? 'synced' : 'local-only' } as T; setState((prev) => ({ ...prev, data: prev.data.map((item) => (item.id === id ? updatedItem : item)), lastSync: new Date(), })); if (enableCache) { cacheRef.current.set(id, updatedItem); } if (syncWithLocalStorage && localStorageKey) { try { const updatedData = state.data.map((item) => item.id === id ? updatedItem : item ); localStorage.setItem(localStorageKey, JSON.stringify(updatedData)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync update with localStorage:", error ); } } return { ...updatedItem, _firestoreStatus: firestoreUpdateSuccess ? 'synced' : 'local-only' } as T; }, [ isReady, collectionName, enableCache, debug, state.data, syncWithLocalStorage, localStorageKey, ] ); const remove = useCallback( async (id: string): Promise<void> => { if (!isReady) { throw new Error("🔥 Firebase not ready for delete operation"); } if (debug) { console.log( `🔥 [useFirestore] Soft deleting document ${id} in ${collectionName}` ); } const docRef = doc(db, collectionName, id); await updateDoc(docRef, { "firestoreMetadata.deleted": true, "firestoreMetadata.deletedAt": new Date(), "firestoreMetadata.updatedAt": new Date(), }); setState((prev) => ({ ...prev, data: prev.data.filter((item) => item.id !== id), lastSync: new Date(), })); if (enableCache) { cacheRef.current.delete(id); } if (syncWithLocalStorage && localStorageKey) { try { const updatedData = state.data.filter((item) => item.id !== id); localStorage.setItem(localStorageKey, JSON.stringify(updatedData)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync delete with localStorage:", error ); } } }, [ isReady, collectionName, enableCache, debug, state.data, syncWithLocalStorage, localStorageKey, ] ); const batchUpdate = useCallback( async (operations: BatchOperation<T>[]): Promise<void> => { if (!isReady) { throw new Error("🔥 Firebase not ready for batch operation"); } const userId = getCurrentUserId(); if (!userId) { throw new Error("🔐 User not authenticated for batch operation"); } if (debug) { console.log( `🔥 [useFirestore] Batch update with ${operations.length} operations` ); } const batch = writeBatch(db); operations.forEach((operation) => { const docRef = operation.id ? doc(db, collectionName, operation.id) : doc(collection(db, collectionName)); if (debug && operation.id) { console.log(`🔥 [useFirestore] Batch operation ${operation.type} for document ID: ${operation.id}`); } switch (operation.type) { case "create": if (operation.data) { batch.set(docRef, { ...operation.data, firestoreMetadata: { userId, createdAt: new Date(), updatedAt: new Date(), version: 1, deleted: false, custom: {}, }, }); if (debug) { console.log(`🔥 [useFirestore] Added create operation for: ${operation.id || 'auto-generated-id'}`); } } break; case "update": if (operation.data) { batch.update(docRef, { ...operation.data, "firestoreMetadata.updatedAt": new Date(), }); } break; case "delete": batch.update(docRef, { "firestoreMetadata.deleted": true, "firestoreMetadata.deletedAt": new Date(), "firestoreMetadata.updatedAt": new Date(), }); break; } }); if (debug) { console.log(`🔥 [useFirestore] Committing batch with ${operations.length} operations...`); } await batch.commit(); if (debug) { console.log(`🔥 [useFirestore] Batch committed successfully, refreshing data...`); } await refresh(); if (debug) { console.log(`🔥 [useFirestore] Batch update completed and data refreshed`); } }, [isReady, collectionName, debug, getCurrentUserId] ); const fetch = useCallback(async (): Promise<T[]> => { if (fetchOperation.loading || isInitializing.current) { if (debug) { console.log( `🔥 [useFirestore] Fetch already in progress for ${collectionName}, skipping` ); } return state.data; } setState((prev) => ({ ...prev, loading: true, error: null })); try { const docs = await fetchOperation.execute(); setState((prev) => ({ ...prev, data: docs, loading: false, lastSync: new Date(), fromCache: false, })); return docs; } catch (error) { setState((prev) => ({ ...prev, loading: false, error: error as FirestoreError, })); throw error; } }, [fetchOperation, collectionName, debug, state.data]); const clearCache = useCallback(() => { cacheRef.current.clear(); statsRef.current.cacheHits = 0; if (debug) { console.log(`🔥 [useFirestore] Cleared cache for ${collectionName}`); } }, [collectionName, debug]); const refresh = useCallback(async (): Promise<void> => { clearCache(); await fetch(); }, [clearCache, fetch]); const startListening = useCallback(() => { if (!isReady || !realtime || listenerRef.current) { return; } const userId = getCurrentUserId(); if (!userId) { return; } if (debug) { console.log( `🔥 [useFirestore] Starting real-time listener for ${collectionName}` ); } const collectionRef = collection(db, collectionName); const q = query( collectionRef, where("firestoreMetadata.userId", "==", userId), where("firestoreMetadata.deleted", "==", false) ); const unsubscribe = onSnapshot( q, { includeMetadataChanges: true }, (snapshot) => { const docs: T[] = []; snapshot.forEach((docSnap) => { const data = docSnap.data(); const firestoreDoc = { id: docSnap.id, ...data, } as unknown as T; docs.push(firestoreDoc); }); setState((prev) => ({ ...prev, data: docs, lastSync: new Date(), listening: true, fromCache: snapshot.metadata.fromCache, })); if (enableCache) { cacheRef.current.clear(); docs.forEach((doc) => { cacheRef.current.set(doc.id, doc); }); } if (syncWithLocalStorage && localStorageKey) { try { localStorage.setItem(localStorageKey, JSON.stringify(docs)); localStorage.setItem( `${localStorageKey}_lastUpdate`, Date.now().toString() ); } catch (error) { console.warn( "🔥 [useFirestore] Failed to sync with localStorage:", error ); } } if (debug) { console.log( `🔥 [useFirestore] Real-time update ${collectionName}: ${docs.length} docs` ); } }, (error) => { setState((prev) => ({ ...prev, error: createError( "listener-failed", "Real-time listener failed", error ), listening: false, })); if (debug) { console.error( `🔥 [useFirestore] Real-time listener error for ${collectionName}:`, error ); } } ); listenerRef.current = unsubscribe; setState((prev) => ({ ...prev, listening: true })); }, [ isReady, realtime, collectionName, enableCache, syncWithLocalStorage, localStorageKey, debug, getCurrentUserId, createError, ]); const stopListening = useCallback(() => { if (listenerRef.current) { listenerRef.current(); listenerRef.current = null; setState((prev) => ({ ...prev, listening: false })); if (debug) { console.log( `🔥 [useFirestore] Stopped real-time listener for ${collectionName}` ); } } }, [collectionName, debug]); const utils = useMemo( () => ({ findById: (id: string): T | undefined => { if (enableCache && cacheRef.current.has(id)) { statsRef.current.cacheHits++; return cacheRef.current.get(id); } return state.data.find((item) => item.id === id); }, filter: (predicate: (item: T) => boolean): T[] => { return state.data.filter(predicate); }, sort: (compareFn: (a: T, b: T) => number): T[] => { return [...state.data].sort(compareFn); }, getStats: () => ({ total: state.data.length, lastUpdated: state.lastSync, cacheHits: statsRef.current.cacheHits, }), }), [state.data, state.lastSync, enableCache] ); useEffect(() => { if ( isReady && autoFetch && !hasInitialFetch.current && !isInitializing.current && !state.loading && !state.listening && fetchAttempts.current < MAX_FETCH_ATTEMPTS ) { isInitializing.current = true; fetchAttempts.current++; if (debug) { console.log( `🔥 [useFirestore] Auto-fetching data for ${collectionName} (attempt ${fetchAttempts.current}/${MAX_FETCH_ATTEMPTS})` ); } fetch() .then(() => { hasInitialFetch.current = true; if (debug) { console.log( `🔥 [useFirestore] Auto-fetch completed for ${collectionName}` ); } }) .catch((error) => { if (debug) { console.error( `🔥 [useFirestore] Auto-fetch failed for ${collectionName}:`, error ); } }) .finally(() => { isInitializing.current = false; }); } }, [ isReady, autoFetch, state.loading, state.listening, fetch, collectionName, debug, ]); useEffect(() => { if (isReady && realtime && !listenerRef.current) { startListening(); } return () => { stopListening(); }; }, [isReady, realtime, startListening, stopListening]); useEffect(() => { setState((prev) => ({ ...prev, loading: fetchOperation.loading, error: fetchOperation.error as FirestoreError | null, })); }, [fetchOperation.loading, fetchOperation.error]); return { ...state, fetch, create, update, remove, batchUpdate, clearCache, refresh, startListening, stopListening, utils, }; } interface BatchOperation<T> { type: "create" | "update" | "delete"; id?: string; data?: Partial<Omit<T, "id">>; } type WordPerformanceDoc = WordPerformance & { id: string }; type StatisticsDoc = Statistics & { id: string }; export function useFirestoreWords() { return useFirestore<Word>({ collection: "words", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyWords", debug: process.env.NODE_ENV === "development", }); } export function useFirestoreStats() { return useFirestore<StatisticsDoc>({ collection: "statistics", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyStats", debug: process.env.NODE_ENV === "development", }); } export function useFirestorePerformance() { return useFirestore<WordPerformanceDoc>({ collection: "performance", realtime: false, enableCache: true, autoFetch: true, debug: process.env.NODE_ENV === "development", }); } export default useFirestore;

================================================================================

NOME FILE: data\usePerformance.ts

import { useState, useEffect, useCallback, useMemo, useRef } from "react"; import { useFirestore } from "../core/useFirestore"; import { useFirebase } from "../../contexts/FirebaseContext"; import AppConfig from "../../config/appConfig"; import type { WordPerformance, PerformanceAttempt, WordPerformanceAnalysis, WordPerformanceStatus, GlobalPerformanceStats, UpdatePerformanceInput, UpdatePerformanceResult, PerformanceCategory, SimpleTrend, WordPerformanceTrends, TestDifficultyAnalysis, } from "../../types/entities/Performance.types"; import type { Word } from "../../types/entities/Word.types"; import type { TestResult } from "../../types/entities/Test.types"; import type { CreateInput, UpdateInput, OperationResult, } from "../../types/index"; import type { FirestoreError } from "../../types/infrastructure/Firestore.types"; const EMPTY_ARRAY: WordPerformanceAnalysis[] = []; interface WordPerformanceWithId extends WordPerformance { id: string; wordId: string; italian: string; totalAttempts: number; correctAttempts: number; accuracy: number; averageResponseTime: number; lastAttemptAt: Date; createdAt: Date; updatedAt: Date; } interface ExtendedPerformanceAttempt extends PerformanceAttempt { timestamp: string; } const INITIAL_GLOBAL_STATS: GlobalPerformanceStats = { statusDistribution: { new: 0, promising: 0, struggling: 0, consolidated: 0, improving: 0, critical: 0, inconsistent: 0, }, totalWordsTracked: 0, averageResponseTime: 0, averageAccuracy: 0, averageHintUsage: 0, wordsNeedingWork: 0, masteredWords: 0, }; interface PerformanceState { performances: WordPerformanceWithId[]; isInitialized: boolean; isLoading: boolean; isProcessing: boolean; lastSync: Date | null; error: FirestoreError | null; fromCache: boolean; } interface PerformanceOperations { updateWordPerformance: ( wordId: string, input: UpdatePerformanceInput ) => Promise<UpdatePerformanceResult>; recordTestResults: ( testResult: TestResult, words: Word[] ) => Promise<OperationResult<void>>; analyzeWordDifficulty: ( wordId: string ) => Promise<OperationResult<TestDifficultyAnalysis>>; bulkUpdatePerformances: ( updates: Array<{ wordId: string; input: UpdatePerformanceInput }> ) => Promise<OperationResult<WordPerformanceWithId[]>>; resetWordPerformance: (wordId: string) => Promise<OperationResult<void>>; resetAllPerformances: () => Promise<OperationResult<void>>; refreshData: () => void; } interface PerformanceGetters { getWordPerformance: (wordId: string) => WordPerformanceWithId | null; getWordAnalysis: (wordId: string) => WordPerformanceAnalysis | null; getWordsNeedingWork: (limit?: number) => WordPerformanceAnalysis[]; getWordsByStatus: ( status: WordPerformanceStatus ) => WordPerformanceAnalysis[]; getPerformanceTrends: (wordId: string) => WordPerformanceTrends | null; getGlobalStats: () => GlobalPerformanceStats; getCategorizedWords: () => Record< PerformanceCategory["status"], WordPerformanceAnalysis[] >; getRecommendedWords: (count?: number) => WordPerformanceAnalysis[]; } interface PerformanceAnalytics { globalPerformanceStats: GlobalPerformanceStats; wordLevelInsights: WordPerformanceAnalysis[]; performanceDistribution: Record<WordPerformanceStatus, number>; trendsAnalysis: { improving: number; declining: number; stable: number; }; } interface PerformanceResult extends PerformanceState, PerformanceOperations, PerformanceGetters { analytics: PerformanceAnalytics; } export const usePerformance = (): PerformanceResult => { const performanceFirestore = useFirestore<WordPerformanceWithId>({ collection: "performance", realtime: false, enableCache: true, autoFetch: false, syncWithLocalStorage: true, localStorageKey: "vocabularyPerformance", debug: AppConfig.app.environment === "development", }); const { isReady } = useFirebase(); const [isInitialized, setIsInitialized] = useState<boolean>(false); const [isProcessing, setIsProcessing] = useState<boolean>(false); const [lastSync, setLastSync] = useState<Date | null>(null); const analyticsCache = useRef<{ analytics: PerformanceAnalytics; timestamp: number; } | null>(null); const ANALYTICS_CACHE_TTL = 15000; useEffect(() => { if (isReady && !isInitialized) { initializePerformance(); } }, [isReady, isInitialized]); const initializePerformance = useCallback(async () => { try { setIsProcessing(true); const savedPerformance = localStorage.getItem("vocabularyPerformance"); if (savedPerformance && performanceFirestore.data.length === 0) { try { const parsedPerformance = JSON.parse(savedPerformance); if ( Array.isArray(parsedPerformance) && parsedPerformance.length > 0 ) { const migrationOps = parsedPerformance.map((perf: any) => ({ type: "create" as const, data: { english: perf.english, wordId: perf.english, italian: perf.italian || "", attempts: perf.attempts?.map((attempt: any) => ({ ...attempt, timestamp: attempt.timestamp || new Date().toISOString(), })) || [], totalAttempts: perf.totalAttempts || 0, correctAttempts: perf.correctAttempts || 0, accuracy: perf.accuracy || 0, averageResponseTime: perf.averageResponseTime || 0, lastAttemptAt: perf.lastAttemptAt ? new Date(perf.lastAttemptAt) : new Date(), createdAt: perf.createdAt ? new Date(perf.createdAt) : new Date(), updatedAt: new Date(), }, })); await performanceFirestore.batchUpdate(migrationOps); localStorage.removeItem("vocabularyPerformance"); if (AppConfig.app.environment === "development") { console.log( `📊 Migrated ${parsedPerformance.length} performance records to Firebase` ); } } } catch (error) { console.warn("Failed to migrate performance data:", error); } } setIsInitialized(true); setLastSync(new Date()); if (AppConfig.app.environment === "development") { console.log("📊 usePerformance initialized with Firebase"); } } catch (error) { console.error("Failed to initialize performance:", error); } finally { setIsProcessing(false); } }, []); const calculateWordStatus = useCallback( (performance: WordPerformanceWithId): WordPerformanceStatus => { const totalAttempts = performance.attempts.length; const correctAttempts = performance.attempts.filter( (a) => a.correct ).length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const averageResponseTime = totalAttempts > 0 ? performance.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; if (totalAttempts === 0) return "new"; if (totalAttempts < 3) return "promising"; if (accuracy >= 90 && averageResponseTime <= 3000) return "consolidated"; if ( accuracy >= 70 && performance.attempts.slice(-5).every((a) => a.correct) ) { return "improving"; } if ( accuracy < 40 || performance.attempts.slice(-3).every((a) => !a.correct) ) { return "critical"; } if (accuracy < 60) return "struggling"; const recentAttempts = performance.attempts.slice(-10); if (recentAttempts.length >= 5) { const correctCount = recentAttempts.filter((a) => a.correct).length; const inconsistencyRatio = Math.abs(correctCount - recentAttempts.length / 2) / recentAttempts.length; if (inconsistencyRatio < 0.3) return "inconsistent"; } return "promising"; }, [] ); const updateWordPerformance = useCallback( async ( wordId: string, input: UpdatePerformanceInput ): Promise<UpdatePerformanceResult> => { try { setIsProcessing(true); const existingPerformance = performanceFirestore.data.find( (p) => p.english === wordId ); const newAttempt: ExtendedPerformanceAttempt = { correct: input.isCorrect, timeSpent: input.timeSpent, timestamp: new Date().toISOString(), usedHint: false, }; let updatedPerformance: WordPerformanceWithId; if (existingPerformance) { const newAttempts = [...existingPerformance.attempts, newAttempt]; const totalAttempts = newAttempts.length; const correctAttempts = newAttempts.filter((a) => a.correct).length; const updatedData = { attempts: newAttempts, totalAttempts, correctAttempts, accuracy: (correctAttempts / totalAttempts) * 100, averageResponseTime: newAttempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts, lastAttemptAt: new Date(), updatedAt: new Date(), }; updatedPerformance = await performanceFirestore.update( existingPerformance.id, updatedData ); } else { const newPerformanceData: Omit<WordPerformanceWithId, "id"> = { english: wordId, wordId: wordId, italian: "", attempts: [newAttempt], totalAttempts: 1, correctAttempts: input.isCorrect ? 1 : 0, accuracy: input.isCorrect ? 100 : 0, averageResponseTime: input.timeSpent, lastAttemptAt: new Date(), createdAt: new Date(), updatedAt: new Date(), }; updatedPerformance = await performanceFirestore.create( newPerformanceData ); } analyticsCache.current = null; setLastSync(new Date()); return { success: true, updatedPerformance, }; } catch (error) { return { success: false, error: (error as Error).message, }; } finally { setIsProcessing(false); } }, [ performanceFirestore.data, performanceFirestore.update, performanceFirestore.create, ] ); const recordTestResults = useCallback( async ( testResult: TestResult, words: Word[] ): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); const totalTime = testResult.completedSession?.timeMetrics?.totalTestTime || 0; const averageTimePerWord = words.length > 0 ? totalTime / words.length : 0; const updates: Array<{ wordId: string; input: UpdatePerformanceInput; }> = []; for (const word of words) { const wasCorrect = !testResult.analytics?.insights?.some( (insight: any) => insight.type === "weakness" && insight.data?.wordId === word.id ) && !testResult.exportData?.detailedAnswers?.some( (answer: any) => answer.word?.id === word.id && !answer.result?.correct ); updates.push({ wordId: word.english, input: { word: { english: word.english, italian: word.italian, chapter: word.chapter || "", id: word.id, }, isCorrect: wasCorrect, timeSpent: averageTimePerWord, usedHint: false, }, }); } await bulkUpdatePerformances(updates); return { success: true, metadata: { operation: "recordTestResults", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "recordTestResults", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [] ); const bulkUpdatePerformances = useCallback( async ( updates: Array<{ wordId: string; input: UpdatePerformanceInput }> ): Promise<OperationResult<WordPerformanceWithId[]>> => { const startTime = Date.now(); try { setIsProcessing(true); const updatedPerformances: WordPerformanceWithId[] = []; const batchSize = 10; for (let i = 0; i < updates.length; i += batchSize) { const batch = updates.slice(i, i + batchSize); const batchPromises = batch.map(async ({ wordId, input }) => { const result = await updateWordPerformance(wordId, input); if (result.updatedPerformance) { updatedPerformances.push( result.updatedPerformance as WordPerformanceWithId ); } return result; }); await Promise.all(batchPromises); } analyticsCache.current = null; setLastSync(new Date()); return { success: true, data: updatedPerformances, metadata: { operation: "bulkUpdatePerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "bulkUpdatePerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [updateWordPerformance] ); const analyzeWordDifficulty = useCallback( async ( wordId: string ): Promise<OperationResult<TestDifficultyAnalysis>> => { const startTime = Date.now(); try { const performance = performanceFirestore.data.find( (p) => p.english === wordId ); if (!performance || performance.attempts.length === 0) { return { success: false, error: { code: "not-found" as any, message: "No performance data available for this word", operation: "analyze-difficulty" as any, recoverable: false, timestamp: new Date(), } as any, metadata: { operation: "analyzeWordDifficulty", timestamp: new Date(), duration: Date.now() - startTime, }, }; } const correctAttempts = performance.attempts.filter( (a) => a.correct ).length; const totalAttempts = performance.attempts.length; const accuracy = (correctAttempts / totalAttempts) * 100; const averageResponseTime = performance.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts; const accuracyScore = accuracy / 100; const speedScore = Math.max(0, 1 - averageResponseTime / 10000); const consistencyScore = totalAttempts >= 5 ? 1 - Math.abs(accuracy - 50) / 50 : 0.5; const weightedScore = accuracyScore * 0.5 + speedScore * 0.3 + consistencyScore * 0.2; let difficultyCategory: "easy" | "medium" | "hard"; let difficultyReason: string; if (weightedScore >= 0.7) { difficultyCategory = "easy"; difficultyReason = "High accuracy and quick response times"; } else if (weightedScore >= 0.4) { difficultyCategory = "medium"; difficultyReason = "Moderate performance with room for improvement"; } else { difficultyCategory = "hard"; difficultyReason = "Low accuracy or slow response times indicate difficulty"; } const totalWords = performanceFirestore.data.length; const hardWords = performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter((a) => a.correct).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const avgTime = totalAttempts > 0 ? p.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; const score = (accuracy / 100) * 0.5 + Math.max(0, 1 - avgTime / 10000) * 0.3 + 0.1; return score < 0.4; }).length; const easyWords = performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter((a) => a.correct).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const avgTime = totalAttempts > 0 ? p.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; const score = (accuracy / 100) * 0.5 + Math.max(0, 1 - avgTime / 10000) * 0.3 + 0.1; return score >= 0.7; }).length; const mediumWords = totalWords - hardWords - easyWords; const analysis: TestDifficultyAnalysis = { difficulty: difficultyCategory, difficultyReason, weightedScore, totalWords, sizeAdjustment: 1.0, distribution: { hard: { count: hardWords, percentage: totalWords > 0 ? Math.round((hardWords / totalWords) * 100) : 0, }, medium: { count: mediumWords, percentage: totalWords > 0 ? Math.round((mediumWords / totalWords) * 100) : 0, }, easy: { count: easyWords, percentage: totalWords > 0 ? Math.round((easyWords / totalWords) * 100) : 0, }, }, statusBreakdown: { new: performanceFirestore.data.filter( (p) => p.attempts.length === 0 ).length, promising: performanceFirestore.data.filter( (p) => p.attempts.length < 3 ).length, struggling: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy < 60; }).length, improving: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy >= 60 && accuracy < 80; }).length, consolidated: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy >= 80; }).length, critical: performanceFirestore.data.filter((p) => { const correctAttempts = p.attempts.filter( (a) => a.correct ).length; const totalAttempts = p.attempts.length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; return accuracy < 40; }).length, inconsistent: 0, }, }; return { success: true, data: analysis, metadata: { operation: "analyzeWordDifficulty", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "analyzeWordDifficulty", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [performanceFirestore.data] ); const resetWordPerformance = useCallback( async (wordId: string): Promise<OperationResult<void>> => { const startTime = Date.now(); try { const performance = performanceFirestore.data.find( (p) => p.english === wordId ); if (!performance) { return { success: false, error: { code: "firestore/not-found" as any, message: "Performance record not found", operation: "delete" as any, recoverable: false, timestamp: new Date(), }, metadata: { operation: "resetWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } await performanceFirestore.remove(performance.id); analyticsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "resetWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "resetWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [performanceFirestore.data, performanceFirestore.remove] ); const resetAllPerformances = useCallback(async (): Promise< OperationResult<void> > => { const startTime = Date.now(); try { setIsProcessing(true); const deleteOps = performanceFirestore.data.map((perf) => ({ type: "delete" as const, id: perf.id, })); if (deleteOps.length > 0) { await performanceFirestore.batchUpdate(deleteOps); } analyticsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "resetAllPerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "resetAllPerformances", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [performanceFirestore.data, performanceFirestore.batchUpdate]); const refreshData = useCallback(() => { performanceFirestore.fetch(); analyticsCache.current = null; setLastSync(new Date()); }, [performanceFirestore.fetch]); const getWordPerformance = useCallback( (wordId: string): WordPerformanceWithId | null => { return ( performanceFirestore.data.find((p) => p.english === wordId) || null ); }, [performanceFirestore.data] ); const getWordAnalysis = useCallback( (wordId: string): WordPerformanceAnalysis | null => { const performance = getWordPerformance(wordId); if (!performance) return null; const status = calculateWordStatus(performance); const totalAttempts = performance.attempts.length; const correctAttempts = performance.attempts.filter( (a) => a.correct ).length; const incorrectAttempts = totalAttempts - correctAttempts; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const hintsUsed = performance.attempts.filter((a) => a.usedHint).length; return { id: performance.id, english: performance.english, italian: performance.italian || "", chapter: performance.chapter || "", group: "", sentence: "", notes: "", learned: false, difficult: false, status, attempts: performance.attempts, totalAttempts, correctAttempts, incorrectAttempts, accuracy: Math.round(accuracy), hintsUsed, hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0, currentStreak: 0, lastAttempt: performance.attempts.length > 0 ? performance.attempts[performance.attempts.length - 1] : { correct: false, timeSpent: 0, timestamp: new Date().toISOString(), usedHint: false, }, recentAccuracy: Math.round(accuracy), avgTime: Math.round(performance.averageResponseTime / 1000), trend: "stable" as const, difficulty: accuracy < 50 ? "hard" : accuracy < 80 ? "medium" : "easy", needsWork: accuracy < 70, mastered: accuracy >= 90, recommendations: [], }; }, [getWordPerformance, calculateWordStatus] ); const getWordsNeedingWork = useCallback( (limit = 10): WordPerformanceAnalysis[] => { const analyses = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ) .filter( (analysis) => analysis.status === "struggling" || analysis.status === "critical" || analysis.status === "inconsistent" ) .sort((a, b) => { const urgencyOrder = { critical: 3, struggling: 2, inconsistent: 1 }; return ( urgencyOrder[b.status as keyof typeof urgencyOrder] - urgencyOrder[a.status as keyof typeof urgencyOrder] ); }); return analyses.slice(0, limit); }, [performanceFirestore.data, getWordAnalysis] ); const getWordsByStatus = useCallback( (status: WordPerformanceStatus): WordPerformanceAnalysis[] => { return performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null && analysis.status === status ); }, [performanceFirestore.data, getWordAnalysis] ); const getPerformanceTrends = useCallback( (wordId: string): WordPerformanceTrends | null => { const performance = getWordPerformance(wordId); if (!performance || performance.attempts.length < 5) return null; const recentAttempts = performance.attempts.slice(-10); const olderAttempts = performance.attempts.slice(0, -10); if (olderAttempts.length === 0) return null; const recentAccuracy = recentAttempts.filter((a) => a.correct).length / recentAttempts.length; const olderAccuracy = olderAttempts.filter((a) => a.correct).length / olderAttempts.length; const recentSpeed = recentAttempts.reduce((sum, a) => sum + a.timeSpent, 0) / recentAttempts.length; const olderSpeed = olderAttempts.reduce((sum, a) => sum + a.timeSpent, 0) / olderAttempts.length; const speedTrend: SimpleTrend = { direction: recentSpeed < olderSpeed ? "improving" : recentSpeed > olderSpeed ? "declining" : "stable", sampleSize: recentAttempts.length, confidence: Math.min(90, performance.attempts.length * 10), }; const accuracyTrend: SimpleTrend = { direction: recentAccuracy > olderAccuracy ? "improving" : recentAccuracy < olderAccuracy ? "declining" : "stable", sampleSize: recentAttempts.length, confidence: Math.min(90, performance.attempts.length * 10), }; const hintTrend: SimpleTrend = { direction: "stable", sampleSize: recentAttempts.length, confidence: 50, }; return { accuracyTrend, speedTrend, hintTrend, analysisperiod: 30, }; }, [getWordPerformance] ); const getGlobalStats = useCallback((): GlobalPerformanceStats => { const analyses = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ); const statusDistribution: Record<WordPerformanceStatus, number> = { new: 0, promising: 0, struggling: 0, consolidated: 0, improving: 0, critical: 0, inconsistent: 0, }; analyses.forEach((analysis) => { statusDistribution[analysis.status]++; }); const averageResponseTime = analyses.length > 0 ? analyses.reduce((sum, analysis) => { return sum + analysis.avgTime * 1000; }, 0) / analyses.length : 0; const averageAccuracy = analyses.length > 0 ? analyses.reduce((sum, analysis) => sum + analysis.accuracy, 0) / analyses.length : 0; const averageHintUsage = analyses.length > 0 ? analyses.reduce( (sum, analysis) => sum + analysis.hintsPercentage, 0 ) / analyses.length : 0; const wordsNeedingWork = statusDistribution.struggling + statusDistribution.critical + statusDistribution.inconsistent; const masteredWords = analyses.filter( (analysis) => analysis.mastered ).length; return { statusDistribution, totalWordsTracked: analyses.length, averageResponseTime: Math.round(averageResponseTime), averageAccuracy: Math.round(averageAccuracy), averageHintUsage: Math.round(averageHintUsage), wordsNeedingWork, masteredWords, }; }, [performanceFirestore.data, getWordAnalysis]); const getCategorizedWords = useCallback((): Record< WordPerformanceStatus, WordPerformanceAnalysis[] > => { const analyses = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ); const categorized: Record< WordPerformanceStatus, WordPerformanceAnalysis[] > = { new: [], promising: [], struggling: [], consolidated: [], improving: [], critical: [], inconsistent: [], }; analyses.forEach((analysis) => { categorized[analysis.status].push(analysis); }); return categorized; }, [performanceFirestore.data, getWordAnalysis]); const getRecommendedWords = useCallback( (count = 5): WordPerformanceAnalysis[] => { const wordsNeedingWork = getWordsNeedingWork(count * 2); const improvingWords = getWordsByStatus("improving"); const recommended = [ ...wordsNeedingWork.slice(0, Math.ceil(count * 0.7)), ...improvingWords.slice(0, Math.floor(count * 0.3)), ]; return recommended.slice(0, count); }, [getWordsNeedingWork, getWordsByStatus] ); const analytics = useMemo<PerformanceAnalytics>(() => { const now = Date.now(); if ( analyticsCache.current && now - analyticsCache.current.timestamp < ANALYTICS_CACHE_TTL ) { return analyticsCache.current.analytics; } const globalPerformanceStats = getGlobalStats(); const wordLevelInsights = performanceFirestore.data .map((perf) => getWordAnalysis(perf.english)) .filter( (analysis): analysis is WordPerformanceAnalysis => analysis !== null ); const performanceDistribution = globalPerformanceStats.statusDistribution; const improving = performanceDistribution.improving + performanceDistribution.promising; const declining = performanceDistribution.struggling + performanceDistribution.critical; const stable = performanceDistribution.consolidated + performanceDistribution.inconsistent; const analyticsData: PerformanceAnalytics = { globalPerformanceStats, wordLevelInsights, performanceDistribution, trendsAnalysis: { improving, declining, stable, }, }; analyticsCache.current = { analytics: analyticsData, timestamp: now }; return analyticsData; }, [performanceFirestore.data, getGlobalStats, getWordAnalysis]); return { performances: performanceFirestore.data, isInitialized, isLoading: performanceFirestore.loading, isProcessing, lastSync: lastSync || performanceFirestore.lastSync, error: performanceFirestore.error, fromCache: performanceFirestore.fromCache, updateWordPerformance, recordTestResults, analyzeWordDifficulty, bulkUpdatePerformances, resetWordPerformance, resetAllPerformances, refreshData, getWordPerformance, getWordAnalysis, getWordsNeedingWork, getWordsByStatus, getPerformanceTrends, getGlobalStats, getCategorizedWords, getRecommendedWords, analytics, }; }; export default usePerformance;

================================================================================

NOME FILE: data\useStats.ts

import { useState, useEffect, useCallback, useMemo, useRef } from "react"; import { useFirestore } from "../core/useFirestore"; import { useFirebase } from "../../contexts/FirebaseContext"; import { useAuth } from "../integration/useAuth"; import AppConfig from "../../config/appConfig"; import { StatsAnalyticsService } from "../../services/statsAnalyticsService"; import type { Statistics, DailyProgressAggregated, MonthlyStatsAggregated, AggregatedCalculatedStatistics, LearningTrendsAnalysis, WeeklyProgressAnalysis, ComprehensiveStatisticsExportData, CategoryProgressAggregated, DifficultyStatsAggregated, } from "../../types/entities/Statistics.types"; import type { TestResult } from "../../types/entities/Test.types"; import type { Word } from "../../types/entities/Word.types"; import type { WordPerformance, PerformanceAttempt, WordPerformanceAnalysis, } from "../../types/entities/Performance.types"; import type { CreateInput, UpdateInput, OperationResult, } from "../../types/index"; import type { FirestoreError } from "../../types/infrastructure/Firestore.types"; const EMPTY_ARRAY: TestResult[] = []; const INITIAL_WORD_PERFORMANCE: Record<string, WordPerformance> = {}; const INITIAL_CATEGORIES_PROGRESS: Record<string, CategoryProgressAggregated> = {}; const INITIAL_DIFFICULTY_STATS: DifficultyStatsAggregated = { wordDifficulty: { critical: 0, struggling: 0, improving: 0, consolidated: 0, mastered: 0, }, testDifficulty: { easy: { testsCompleted: 0, averageScore: 0, averageAccuracy: 0 }, medium: { testsCompleted: 0, averageScore: 0, averageAccuracy: 0 }, hard: { testsCompleted: 0, averageScore: 0, averageAccuracy: 0 }, }, difficultyTrends: { overallDifficultyRating: 50, improvementRate: 0, masteryProgression: 0, }, }; const INITIAL_STATS: Omit<Statistics, "id"> = { totalWords: 0, correctAnswers: 0, incorrectAnswers: 0, hintsUsed: 0, averageScore: 0, testsCompleted: 0, timeSpent: 0, categoriesProgress: INITIAL_CATEGORIES_PROGRESS, dailyProgress: {}, streakDays: 0, lastStudyDate: null, difficultyStats: INITIAL_DIFFICULTY_STATS, monthlyStats: {}, migrated: false, }; interface StatsState { stats: Statistics; testHistory: TestResult[]; wordPerformance: Record<string, WordPerformance>; isInitialized: boolean; isLoading: boolean; isProcessing: boolean; lastSync: Date | null; error: FirestoreError | null; fromCache: boolean; } interface StatsOperations { handleTestComplete: ( testStats: any, testWords: Word[], wrongWords: Word[], detailedSession?: any ) => Promise<OperationResult<void>>; addTestToHistory: (testResult: TestResult) => Promise<OperationResult<void>>; recordWordPerformance: ( wordId: string, attempt: PerformanceAttempt ) => Promise<OperationResult<WordPerformance>>; refreshData: () => void; resetStats: () => Promise<OperationResult<void>>; clearHistoryOnly: () => Promise<OperationResult<void>>; exportData: () => ComprehensiveStatisticsExportData; importData: ( data: ComprehensiveStatisticsExportData ) => Promise<OperationResult<void>>; getDetailedTestSessions: () => Promise<OperationResult<any[]>>; getDetailedSessionById: (sessionId: string) => Promise<OperationResult<any>>; deleteDetailedSession: (sessionId: string) => Promise<OperationResult<void>>; exportDetailedSessions: () => Promise<OperationResult<any[]>>; } interface StatsGetters { getAllWordsPerformance: () => WordPerformanceAnalysis[]; getWordAnalysis: (wordId: string) => WordPerformanceAnalysis | null; calculatedStats: AggregatedCalculatedStatistics; totalTests: number; totalAnswers: number; accuracyRate: number; hintsRate: number; weeklyProgress: WeeklyProgressAnalysis | null; isMigrated: boolean; } interface StatsResult extends StatsState, StatsOperations, StatsGetters {} const CACHE_TTL = 5 * 60 * 1000; export const useStats = (): StatsResult => { const analyticsService = useMemo(() => new StatsAnalyticsService(), []); const statsFirestore = useFirestore<Statistics & { id: string }>({ collection: "statistics", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyStats", debug: process.env.NODE_ENV === "development", }); const performanceFirestore = useFirestore<WordPerformance & { id: string }>({ collection: "performance", realtime: false, enableCache: true, autoFetch: true, debug: process.env.NODE_ENV === "development", }); const detailedSessionFirestore = useFirestore<any>({ collection: "detailedTestSessions", realtime: false, enableCache: false, autoFetch: false, debug: process.env.NODE_ENV === "development", }); const { isReady } = useFirebase(); const { user, authUser } = useAuth(); const [testHistory, setTestHistory] = useState<TestResult[]>(EMPTY_ARRAY); const [wordPerformance, setWordPerformance] = useState< Record<string, WordPerformance> >(INITIAL_WORD_PERFORMANCE); const [isProcessing, setIsProcessing] = useState(false); const [lastSync, setLastSync] = useState<Date | null>(null); const calculatedStatsCache = useRef<{ stats: AggregatedCalculatedStatistics; timestamp: number; } | null>(null); const currentStats = statsFirestore.data[0] || { id: "temp", ...INITIAL_STATS, }; const isInitialized = statsFirestore.data.length > 0 && isReady; const createCompletePerformanceAttempt = ( correct: boolean, timeSpent: number, usedHint: boolean = false ): PerformanceAttempt => ({ correct, timeSpent, timestamp: new Date().toISOString(), usedHint, }); const createCompleteWordPerformance = ( english: string, italian: string = "", chapter: string = "", attempts: PerformanceAttempt[] = [] ): WordPerformance => ({ wordId: english, english, italian, chapter, attempts, }); const getTimeOfDay = (date: Date): string => { const hour = date.getHours(); if (hour < 6) return 'night'; if (hour < 12) return 'morning'; if (hour < 18) return 'afternoon'; return 'evening'; }; const calculateTimePercentiles = (times: number[]) => { if (times.length === 0) return { p25: 2000, p50: 3000, p75: 4000, p90: 5000 }; const sorted = [...times].sort((a, b) => a - b); return { p25: sorted[Math.floor(sorted.length * 0.25)] || 0, p50: sorted[Math.floor(sorted.length * 0.50)] || 0, p75: sorted[Math.floor(sorted.length * 0.75)] || 0, p90: sorted[Math.floor(sorted.length * 0.90)] || 0, }; }; const calculateSpeedTrend = (speedData: number[]): "stable" | "improving" | "declining" => { if (speedData.length < 2) return "stable"; const firstHalf = speedData.slice(0, Math.floor(speedData.length / 2)); const secondHalf = speedData.slice(Math.floor(speedData.length / 2)); const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length; const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length; const change = ((secondAvg - firstAvg) / firstAvg) * 100; if (change > 5) return "declining"; if (change < -5) return "improving"; return "stable"; }; const calculateSpeedChangePercentage = (speedData: number[]): number => { if (speedData.length < 2) return 0; const firstHalf = speedData.slice(0, Math.floor(speedData.length / 2)); const secondHalf = speedData.slice(Math.floor(speedData.length / 2)); const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length; const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length; return Math.round(((secondAvg - firstAvg) / firstAvg) * 100); }; const handleTestComplete = useCallback( async ( testStats: any, testWords: Word[], wrongWords: Word[], detailedSession?: any ): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); const currentUserId = authUser?.uid || user?.id || currentStats.id || "anonymous"; const testResult: TestResult = { testId: `test_${Date.now()}`, userId: currentUserId, completedSession: { currentQuestion: null, timeMetrics: detailedSession ? { totalTestTime: detailedSession.totalTimeSpent || 0, averageQuestionTime: detailedSession.averageTimePerWord || 0, fastestQuestion: detailedSession.words.length > 0 ? Math.min(...detailedSession.words.map((w: any) => w.totalTime)) : 1000, slowestQuestion: detailedSession.words.length > 0 ? Math.max(...detailedSession.words.map((w: any) => w.totalTime)) : 5000, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: calculateTimePercentiles(detailedSession.words.map((w: any) => w.totalTime)), }, speedTrend: { direction: calculateSpeedTrend(detailedSession.speedTrend), changePercentage: calculateSpeedChangePercentage(detailedSession.speedTrend), dataPoints: detailedSession.speedTrend || [], }, } : { totalTestTime: testStats.timeSpent || 0, averageQuestionTime: (testStats.timeSpent || 0) / testWords.length, fastestQuestion: 1000, slowestQuestion: 5000, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 2000, p50: 3000, p75: 4000, p90: 5000, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }, progress: { basic: { questionsAnswered: testWords.length, questionsRemaining: 0, currentQuestion: testWords.length, totalQuestions: testWords.length, completionPercentage: 100, }, performance: { correctAnswers: testStats.correct || 0, currentAccuracy: ((testStats.correct || 0) / testWords.length) * 100, incorrectAnswers: testStats.incorrect || 0, currentStreak: 0, bestStreak: 0, efficiency: 0, currentScore: 0, }, predictions: { predictedFinalAccuracy: testStats.score || 0, confidence: 0.8, estimatedTimeToCompletion: 0, predictedFinalScore: testStats.score || 0, }, milestones: [], }, wordPool: { allWords: testWords, usedWords: testWords, incorrectWords: wrongWords, remainingWords: [], currentIndex: testWords.length, selectionStrategy: "random", }, answerHistory: detailedSession?.words ? detailedSession.words.map((wordSession: any, index: number) => ({ id: `answer_${index}`, questionId: wordSession.wordId, wordId: wordSession.wordId, result: { isCorrect: wordSession.isCorrect, confidence: wordSession.timeExpired ? 0.3 : (wordSession.isCorrect ? 0.9 : 0.7), }, hintsUsed: wordSession.hintsUsed.map((hint: any) => ({ type: hint.type, content: hint.content, usedAt: hint.requestedAt, effective: wordSession.isCorrect && hint.sequenceOrder === 1, })), timing: { startedAt: wordSession.wordShownAt, cardFlippedAt: wordSession.cardFlippedAt || wordSession.answerDeclaredAt, declaredAt: wordSession.answerDeclaredAt || wordSession.wordShownAt, totalTime: wordSession.totalTime, thinkingTime: wordSession.thinkingTime || wordSession.totalTime, declarationTime: wordSession.evaluationTime || 0, }, metadata: { timeOfDay: getTimeOfDay(wordSession.wordShownAt), sessionPosition: wordSession.testPosition, contextFactors: [ ...(wordSession.timeExpired ? ['timeout'] : []), ...(wordSession.hintsUsed.length > 0 ? ['hints_used'] : []), ], }, })) : testWords.map((word, index) => ({ id: `answer_${index}`, questionId: word.id!, wordId: word.id!, result: { isCorrect: !wrongWords.some((w) => w.id === word.id), confidence: 0.8, }, hintsUsed: [], timing: { startedAt: new Date(), cardFlippedAt: new Date(), declaredAt: new Date(), totalTime: Math.random() * 5000 + 1000, thinkingTime: Math.random() * 3000 + 500, declarationTime: Math.random() * 1000 + 500, }, metadata: { timeOfDay: "afternoon", sessionPosition: index + 1, contextFactors: [], }, })), hintSystem: { globalState: { totalHintsUsed: testStats.hints || 0, hintsRemaining: 5, usagePattern: { preferredType: "balanced", frequency: "moderate", effectiveness: { sentence: 0.8, synonym: 0.7, }, }, }, config: { enabled: true, maxHintsPerQuestion: 2, cooldownBetweenHints: 0, availableHintTypes: ["sentence", "synonym"], hintCosts: { sentence: 1, synonym: 1, }, }, statistics: { usage: { sentence: testStats.hints || 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, }, }, config: { mode: "normal", hints: { enabled: true, maxHintsPerQuestion: 2, cooldownBetweenHints: 0, availableHintTypes: ["sentence", "synonym"], hintCosts: { sentence: 1, synonym: 1, }, }, wordSelection: { categories: [], chapters: [], unlearnedOnly: false, difficultOnly: false, randomOrder: true, selectionStrategy: "random", }, timing: { autoAdvance: false, showTimer: false, autoAdvanceDelay: 1000, wordTimeLimit: 30000, showMeaning: false, meaningDisplayDuration: 2000, }, ui: { theme: "light" as const, animations: true, showDetailedProgress: true, sounds: false, showRealTimeStats: true, }, scoring: { accuracyWeight: 0.7, speedWeight: 0.3, streakBonus: 0.1, hintPenalty: 0.1, thresholds: { excellent: 90, good: 80, average: 70, }, }, }, finalScore: { total: testStats.score || 0, category: testStats.score >= 90 ? "excellent" : testStats.score >= 80 ? "good" : testStats.score >= 70 ? "average" : "poor", breakdown: { accuracy: ((testStats.correct || 0) / testWords.length) * 100, speed: 50, efficiency: 50, consistency: 50, bonus: 0, penalties: 0, }, }, feedback: { tone: testStats.score >= 80 ? "celebratory" : "encouraging", color: testStats.score >= 80 ? "#22c55e" : "#3b82f6", wordsToReview: wrongWords.map((w) => w.english), message: "Great job!", icon: "check", nextGoals: ["Keep practicing", "Review difficult words"], }, analytics: { insights: [], performancePatterns: { timePatterns: { totalTestTime: testStats.timeSpent || 0, averageQuestionTime: (testStats.timeSpent || 0) / testWords.length, fastestQuestion: 1000, slowestQuestion: 5000, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 2000, p50: 3000, p75: 4000, p90: 5000, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }, accuracyPatterns: { overallAccuracy: ((testStats.correct || 0) / testWords.length) * 100, accuracyByPosition: [], accuracyTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, difficultWordsBias: 0, }, hintPatterns: { usage: { sentence: testStats.hints || 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, categoryPatterns: [], }, recommendations: [], }, exportData: { summary: { testId: `test_${Date.now()}`, duration: testStats.timeSpent || 0, totalQuestions: testWords.length, correctAnswers: testStats.correct || 0, accuracy: ((testStats.correct || 0) / testWords.length) * 100, hintsUsed: testStats.hints || 0, averageTime: (testStats.timeSpent || 0) / testWords.length, score: testStats.score || 0, category: testStats.score >= 90 ? "excellent" : testStats.score >= 80 ? "good" : testStats.score >= 70 ? "average" : "poor", }, detailedAnswers: [], analytics: { insights: [], performancePatterns: { timePatterns: { totalTestTime: testStats.timeSpent || 0, averageQuestionTime: (testStats.timeSpent || 0) / testWords.length, fastestQuestion: 1000, slowestQuestion: 5000, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 2000, p50: 3000, p75: 4000, p90: 5000, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }, accuracyPatterns: { overallAccuracy: ((testStats.correct || 0) / testWords.length) * 100, accuracyByPosition: [], accuracyTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, difficultWordsBias: 0, }, hintPatterns: { usage: { sentence: testStats.hints || 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, categoryPatterns: [], }, recommendations: [], }, exportedAt: new Date(), format: "json", }, }; setTestHistory((prev) => [...prev, testResult]); for (const word of testWords) { const isWrong = wrongWords.some((w) => w.id === word.id); const attempt = createCompletePerformanceAttempt( !isWrong, Math.random() * 5000 + 1000, false ); const existingPerf = wordPerformance[word.english]; if (existingPerf) { const updatedPerf: WordPerformance = { ...existingPerf, attempts: [...existingPerf.attempts, attempt], }; setWordPerformance((prev) => ({ ...prev, [word.english]: updatedPerf, })); const perfDoc = performanceFirestore.data.find( (p) => p.english === word.english ); if (perfDoc) { await performanceFirestore.update(perfDoc.id, updatedPerf); } else { await performanceFirestore.create(updatedPerf); } } else { const newPerf = createCompleteWordPerformance( word.english, word.italian, word.chapter, [attempt] ); setWordPerformance((prev) => ({ ...prev, [word.english]: newPerf, })); await performanceFirestore.create(newPerf); } } const correctAnswers = detailedSession?.correctAnswers ?? testStats.correct ?? 0; const incorrectAnswers = detailedSession ? (detailedSession.incorrectAnswers + detailedSession.timeoutAnswers) : (testStats.incorrect ?? 0); const hintsUsed = detailedSession?.totalHintsUsed ?? testStats.hints ?? 0; const timeSpent = detailedSession?.totalTimeSpent ?? testStats.timeSpent ?? 0; const totalWordsCount = detailedSession?.totalWords ?? testWords.length; const accuracy = detailedSession?.accuracy ?? (((testStats.correct || 0) / testWords.length) * 100); const updatedStats = { ...currentStats, userId: currentUserId, testsCompleted: currentStats.testsCompleted + 1, totalWords: currentStats.totalWords + totalWordsCount, correctAnswers: currentStats.correctAnswers + correctAnswers, incorrectAnswers: currentStats.incorrectAnswers + incorrectAnswers, hintsUsed: currentStats.hintsUsed + hintsUsed, timeSpent: currentStats.timeSpent + timeSpent, averageScore: (currentStats.averageScore * currentStats.testsCompleted + accuracy) / (currentStats.testsCompleted + 1), lastStudyDate: new Date().toISOString(), }; if (statsFirestore.data[0]) { await statsFirestore.update(statsFirestore.data[0].id, updatedStats); } else { await statsFirestore.create(updatedStats); } if (detailedSession) { try { const completedDetailedSession = { ...detailedSession, completedAt: new Date(), userId: currentUserId, deviceInfo: navigator.userAgent, sessionMetadata: { testResultId: testResult.testId, totalDuration: detailedSession.totalTimeSpent, wordsCompleted: detailedSession.words.length, finalAccuracy: detailedSession.accuracy, browserTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone, screenResolution: `${window.screen.width}x${window.screen.height}`, authStatus: authUser ? 'authenticated' : 'anonymous', dataSource: 'learnEnglishVOC_webapp', } }; try { const cleanedSession = JSON.parse(JSON.stringify(completedDetailedSession, (key, value) => { return value === undefined ? null : value; })); await detailedSessionFirestore.create(cleanedSession); if (AppConfig.app.environment === "development") { console.log("✅ DetailedTestSession saved to Firestore:", { sessionId: completedDetailedSession.sessionId, userId: currentUserId, duration: completedDetailedSession.totalTimeSpent, accuracy: completedDetailedSession.accuracy, totalHints: completedDetailedSession.totalHintsUsed, wordsCount: completedDetailedSession.words.length, }); } } catch (saveError) { console.error("❌ Failed to save DetailedTestSession to Firestore:", saveError); } } catch (detailedSessionError) { console.error("❌ Failed to save detailed session:", detailedSessionError); } } calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "handleTestComplete", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "handleTestComplete", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [statsFirestore, performanceFirestore, currentStats, wordPerformance] ); const addTestToHistory = useCallback( async (testResult: TestResult): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setTestHistory((prev) => [...prev, testResult]); calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "addTestToHistory", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "addTestToHistory", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [] ); const recordWordPerformance = useCallback( async ( wordId: string, attempt: PerformanceAttempt ): Promise<OperationResult<WordPerformance>> => { const startTime = Date.now(); try { setIsProcessing(true); const existingPerf = wordPerformance[wordId]; let updatedPerf: WordPerformance; if (existingPerf) { updatedPerf = { ...existingPerf, attempts: [...existingPerf.attempts, attempt], }; } else { updatedPerf = createCompleteWordPerformance(wordId, "", "", [ attempt, ]); } setWordPerformance((prev) => ({ ...prev, [wordId]: updatedPerf, })); const perfDoc = performanceFirestore.data.find( (p) => p.english === wordId ); if (perfDoc) { await performanceFirestore.update(perfDoc.id, updatedPerf); } else { await performanceFirestore.create(updatedPerf); } calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, data: updatedPerf, metadata: { operation: "recordWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "recordWordPerformance", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [wordPerformance, performanceFirestore] ); const refreshData = useCallback(() => { statsFirestore.refresh(); performanceFirestore.refresh(); detailedSessionFirestore.refresh(); calculatedStatsCache.current = null; setLastSync(new Date()); }, [statsFirestore, performanceFirestore, detailedSessionFirestore]); const resetStats = useCallback(async (): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); const deletePerformanceOps = performanceFirestore.data.map((perf) => ({ type: "delete" as const, id: perf.id, })); if (deletePerformanceOps.length > 0) { await performanceFirestore.batchUpdate(deletePerformanceOps); } if (statsFirestore.data[0]) { await statsFirestore.update(statsFirestore.data[0].id, INITIAL_STATS); } setTestHistory([]); setWordPerformance({}); calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "resetStats", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "resetStats", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [statsFirestore, performanceFirestore, detailedSessionFirestore]); const clearHistoryOnly = useCallback(async (): Promise< OperationResult<void> > => { const startTime = Date.now(); try { setTestHistory([]); calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "clearHistoryOnly", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "clearHistoryOnly", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, []); const exportData = useCallback((): ComprehensiveStatisticsExportData => { const wordPerformanceAnalyses = getAllWordsPerformance(); return analyticsService.createComprehensiveExportData( currentStats, testHistory, wordPerformanceAnalyses ); }, [currentStats, testHistory, analyticsService]); const importData = useCallback( async ( data: ComprehensiveStatisticsExportData ): Promise<OperationResult<void>> => { const startTime = Date.now(); try { setIsProcessing(true); if (data.statistics) { if (statsFirestore.data[0]) { await statsFirestore.update( statsFirestore.data[0].id, data.statistics ); } else { await statsFirestore.create(data.statistics); } } if (data.sourceData?.testResults) { setTestHistory(data.sourceData.testResults); } if (data.sourceData?.wordPerformances) { const performanceMap: Record<string, WordPerformance> = {}; const deleteOps = performanceFirestore.data.map((perf) => ({ type: "delete" as const, id: perf.id, })); if (deleteOps.length > 0) { await performanceFirestore.batchUpdate(deleteOps); } const createOps = data.sourceData.wordPerformances.map( (analysis) => ({ type: "create" as const, data: createCompleteWordPerformance( analysis.english, analysis.italian, analysis.chapter, analysis.attempts ), }) ); if (createOps.length > 0) { await performanceFirestore.batchUpdate(createOps); } data.sourceData.wordPerformances.forEach((analysis) => { performanceMap[analysis.english] = createCompleteWordPerformance( analysis.english, analysis.italian, analysis.chapter, analysis.attempts ); }); setWordPerformance(performanceMap); } calculatedStatsCache.current = null; setLastSync(new Date()); return { success: true, metadata: { operation: "importData", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "importData", timestamp: new Date(), duration: Date.now() - startTime, }, }; } finally { setIsProcessing(false); } }, [ statsFirestore.data, statsFirestore.update, statsFirestore.create, performanceFirestore.data, performanceFirestore.batchUpdate, ] ); const getDetailedTestSessions = useCallback(async (): Promise<OperationResult<any[]>> => { const startTime = Date.now(); try { await detailedSessionFirestore.fetch(); return { success: true, data: detailedSessionFirestore.data, metadata: { operation: "getDetailedTestSessions", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "getDetailedTestSessions", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [detailedSessionFirestore]); const getDetailedSessionById = useCallback(async (sessionId: string): Promise<OperationResult<any>> => { const startTime = Date.now(); try { await detailedSessionFirestore.fetch(); const session = detailedSessionFirestore.data.find(s => s.sessionId === sessionId); if (!session) { return { success: false, error: { message: "Session not found", code: "not-found" } as FirestoreError, metadata: { operation: "getDetailedSessionById", timestamp: new Date(), duration: Date.now() - startTime, }, }; } return { success: true, data: session, metadata: { operation: "getDetailedSessionById", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "getDetailedSessionById", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [detailedSessionFirestore]); const deleteDetailedSession = useCallback(async (sessionId: string): Promise<OperationResult<void>> => { const startTime = Date.now(); try { await detailedSessionFirestore.fetch(); const session = detailedSessionFirestore.data.find(s => s.sessionId === sessionId); if (!session) { return { success: false, error: { message: "Session not found", code: "not-found" } as FirestoreError, metadata: { operation: "deleteDetailedSession", timestamp: new Date(), duration: Date.now() - startTime, }, }; } await detailedSessionFirestore.remove(session.id); return { success: true, metadata: { operation: "deleteDetailedSession", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "deleteDetailedSession", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [detailedSessionFirestore]); const exportDetailedSessions = useCallback(async (): Promise<OperationResult<any[]>> => { const startTime = Date.now(); try { await detailedSessionFirestore.fetch(); const exportData = detailedSessionFirestore.data.map(session => ({ ...session, deviceInfo: undefined, firestoreMetadata: undefined, })); return { success: true, data: exportData, metadata: { operation: "exportDetailedSessions", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "exportDetailedSessions", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [detailedSessionFirestore]); const getAllWordsPerformance = useCallback((): WordPerformanceAnalysis[] => { return Object.values(wordPerformance).map((perf) => { const totalAttempts = perf.attempts.length; const correctAttempts = perf.attempts.filter((a) => a.correct).length; const accuracy = totalAttempts > 0 ? (correctAttempts / totalAttempts) * 100 : 0; const hintsUsed = perf.attempts.filter((a) => a.usedHint).length; const averageTime = totalAttempts > 0 ? perf.attempts.reduce((sum, a) => sum + a.timeSpent, 0) / totalAttempts : 0; return { id: `perf_${perf.english}`, english: perf.english, italian: perf.italian || "", chapter: perf.chapter || "", group: "", sentence: "", notes: "", learned: false, difficult: false, status: accuracy > 80 ? "consolidated" : accuracy > 60 ? "improving" : "struggling", attempts: perf.attempts, totalAttempts, correctAttempts, incorrectAttempts: totalAttempts - correctAttempts, accuracy: Math.round(accuracy), hintsUsed, hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0, currentStreak: 0, lastAttempt: perf.attempts.length > 0 ? perf.attempts[perf.attempts.length - 1] : null, recentAccuracy: Math.round(accuracy), avgTime: Math.round(averageTime / 1000), trend: "stable" as const, difficulty: accuracy < 50 ? "hard" : accuracy < 80 ? "medium" : "easy", needsWork: accuracy < 70, mastered: accuracy >= 90, recommendations: [], }; }); }, [wordPerformance]); const getWordAnalysis = useCallback( (wordId: string): WordPerformanceAnalysis | null => { const perf = wordPerformance[wordId]; if (!perf) return null; const analyses = getAllWordsPerformance(); return analyses.find((analysis) => analysis.english === wordId) || null; }, [wordPerformance, getAllWordsPerformance] ); const calculatedStats = useMemo<AggregatedCalculatedStatistics>(() => { const now = Date.now(); if ( calculatedStatsCache.current && now - calculatedStatsCache.current.timestamp < CACHE_TTL ) { return calculatedStatsCache.current.stats; } const wordPerformanceAnalyses = getAllWordsPerformance(); const stats = analyticsService.calculateAggregatedStatistics( currentStats, testHistory, wordPerformanceAnalyses ); calculatedStatsCache.current = { stats, timestamp: now }; return stats; }, [getAllWordsPerformance, testHistory, currentStats, analyticsService]); const totalTests = currentStats.testsCompleted; const totalAnswers = currentStats.correctAnswers + currentStats.incorrectAnswers; const accuracyRate = totalAnswers > 0 ? (currentStats.correctAnswers / totalAnswers) * 100 : 0; const hintsRate = totalAnswers > 0 ? (currentStats.hintsUsed / totalAnswers) * 100 : 0; const isMigrated = currentStats.migrated || false; const weeklyProgress = useMemo<WeeklyProgressAnalysis | null>(() => { return calculatedStats.temporalAnalytics.weeklyProgress; }, [calculatedStats]); useEffect(() => { if (performanceFirestore.data.length > 0) { const performanceMap: Record<string, WordPerformance> = {}; performanceFirestore.data.forEach((perf) => { performanceMap[perf.english] = perf; }); setWordPerformance(performanceMap); } }, [performanceFirestore.data]); return { stats: currentStats, testHistory, wordPerformance, isInitialized, isLoading: statsFirestore.loading || performanceFirestore.loading || detailedSessionFirestore.loading, isProcessing, lastSync: lastSync || statsFirestore.lastSync, error: statsFirestore.error || performanceFirestore.error || detailedSessionFirestore.error, fromCache: statsFirestore.fromCache, handleTestComplete, addTestToHistory, recordWordPerformance, refreshData, resetStats, clearHistoryOnly, exportData, importData, getDetailedTestSessions, getDetailedSessionById, deleteDetailedSession, exportDetailedSessions, getAllWordsPerformance, getWordAnalysis, calculatedStats, totalTests, totalAnswers, accuracyRate, hintsRate, weeklyProgress, isMigrated, }; }; export default useStats;

================================================================================

NOME FILE: data\useTest.ts

import { useState, useCallback, useMemo, useRef, useEffect } from "react"; import { useFirebase } from "../../contexts/FirebaseContext"; import AppConfig from "../../config/appConfig"; import type { Test, TestResult, TestMode, TestConfig, WordSelectionConfig, TimingConfig, UIConfig, ScoringConfig, PerformanceMetrics, SpeedTrend, PerformancePatterns, TestAnalytics, TestSummary as TestSummaryType, TestExportData, HintSystemConfig, TestTimeMetrics, TimeDistribution, TestAnswer, TestSession, TestWordPool, TestHintSystem, HintGlobalState, HintStatistics, FinalScore, TestFeedback, } from "../../types/entities/Test.types"; import type { Word } from "../../types/entities/Word.types"; import type { CreateInput, OperationResult } from "../../types/index"; interface TestStats { correct: number; incorrect: number; hints: number; } interface WordTiming { wordId: string; startTime: number; endTime: number; timeSpent: number; usedHint: boolean; gameHintsUsed?: string[]; } interface DetailedGameHint { type: 'synonym' | 'antonym' | 'context'; content: string; requestedAt: Date; timeFromWordStart: number; sequenceOrder: number; } interface DetailedWordSession { wordId: string; english: string; italian: string; chapter?: string; wordShownAt: Date; cardFlippedAt?: Date; answerDeclaredAt?: Date; thinkingTime?: number; evaluationTime?: number; totalTime: number; hintsUsed: DetailedGameHint[]; totalHintsCount: number; result: 'correct' | 'incorrect' | 'timeout'; isCorrect: boolean; testPosition: number; timeExpired: boolean; userConfidence?: 1 | 2 | 3 | 4 | 5; } interface DetailedTestSession { sessionId: string; userId?: string; startedAt: Date; completedAt?: Date; config: TestConfig; words: DetailedWordSession[]; wrongWords: DetailedWordSession[]; totalWords: number; correctAnswers: number; incorrectAnswers: number; timeoutAnswers: number; totalHintsUsed: number; totalTimeSpent: number; averageTimePerWord: number; accuracy: number; chapterBreakdown: Record<string, { correct: number; incorrect: number; totalTime: number; hintsUsed: number; }>; performanceTrend: number[]; speedTrend: number[]; hintUsagePattern: number[]; deviceInfo?: string; sessionMetadata?: Record<string, any>; } interface TestProgress { current: number; total: number; percentage: number; remaining: number; } interface TestSummary { totalQuestions: number; correctAnswers: number; incorrectAnswers: number; hintsUsed: number; accuracy: number; score: number; timeSpent: number; averageTimePerWord: number; wrongWords: Word[]; correct?: number; incorrect?: number; hints?: number; totalTime?: number; avgTimePerWord?: number; maxTimePerWord?: number; minTimePerWord?: number; totalRecordedTime?: number; total?: number; answered?: number; percentage?: number; } interface GameModeHints { synonym?: string[]; antonym?: string[]; context?: string[]; } interface TestState { testMode: boolean; showResults: boolean; currentWord: Word | null; testWords: Word[]; usedWordIds: Set<string>; stats: TestStats; wrongWords: Word[]; wordTimes: WordTiming[]; showMeaning: boolean; showHint: boolean; hintUsedForCurrentWord: boolean; isTransitioning: boolean; gameHints: GameModeHints; totalHintsUsed: number; hintsUsedThisWord: number; testConfig: any; currentWordSession: DetailedWordSession | null; detailedSession: DetailedTestSession | null; currentWordStartTime: Date | null; hintSequenceCounter: number; testSaved: boolean; isInitialized: boolean; error: Error | null; } interface TestOperations { startTest: (words: Word[], config?: any) => void; handleAnswer: (isCorrect: boolean, isTimeout?: boolean) => void; resetTest: () => void; startNewTest: () => void; toggleHint: () => void; setShowMeaning: (show: boolean) => void; handleGameHintRequest: (type: 'synonym' | 'antonym' | 'context') => void; } interface TestGetters { getTestProgress: () => TestProgress; getTestSummary: () => TestSummary; } interface TestHookResult extends TestState, TestOperations, TestGetters { hintUsed: boolean; } type TestCompleteCallback = ( testStats: TestStats, testWords: Word[], wrongWords: Word[], detailedSession?: DetailedTestSession | null ) => void; export const useTest = ( onTestComplete?: TestCompleteCallback ): TestHookResult => { const { isReady } = useFirebase(); const [testMode, setTestMode] = useState<boolean>(false); const [showResults, setShowResults] = useState<boolean>(false); const [currentWord, setCurrentWord] = useState<Word | null>(null); const [testWords, setTestWords] = useState<Word[]>([]); const [usedWordIds, setUsedWordIds] = useState<Set<string>>(new Set()); const [stats, setStats] = useState<TestStats>({ correct: 0, incorrect: 0, hints: 0, }); const [wrongWords, setWrongWords] = useState<Word[]>([]); const [wordTimes, setWordTimes] = useState<WordTiming[]>([]); const [showMeaning, setShowMeaning] = useState<boolean>(false); const [showHint, setShowHint] = useState<boolean>(false); const [hintUsedForCurrentWord, setHintUsedForCurrentWord] = useState<boolean>(false); const [isTransitioning, setIsTransitioning] = useState<boolean>(false); const [gameHints, setGameHints] = useState<GameModeHints>({}); const [totalHintsUsed, setTotalHintsUsed] = useState<number>(0); const [hintsUsedThisWord, setHintsUsedThisWord] = useState<number>(0); const [testConfig, setTestConfig] = useState<any>(null); const [currentWordSession, setCurrentWordSession] = useState<DetailedWordSession | null>(null); const [detailedSession, setDetailedSession] = useState<DetailedTestSession | null>(null); const [currentWordStartTime, setCurrentWordStartTime] = useState<Date | null>(null); const [hintSequenceCounter, setHintSequenceCounter] = useState<number>(0); const currentWordHintsRef = useRef<any[]>([]); const [testSaved, setTestSaved] = useState<boolean>(false); const [isInitialized, setIsInitialized] = useState<boolean>(false); const [error, setError] = useState<Error | null>(null); const testStartTimeRef = useRef<number | null>(null); const wordStartTimeRef = useRef<number | null>(null); const detailedSessionRef = useRef<DetailedTestSession | null>(null); useEffect(() => { if (isReady && !isInitialized) { setIsInitialized(true); if (AppConfig.app.environment === "development") { console.log("🧪 useTest initialized with Firebase"); } } }, [isReady, isInitialized]); const createHintSystemConfig = ( config?: Partial<HintSystemConfig> ): HintSystemConfig => ({ enabled: true, maxHintsPerQuestion: 2, cooldownBetweenHints: 0, availableHintTypes: ["sentence", "synonym"], hintCosts: { sentence: 1, synonym: 1, }, ...config, }); const createTestTimeMetrics = ( totalTime: number, wordTimes: WordTiming[] ): TestTimeMetrics => ({ totalTestTime: totalTime, averageQuestionTime: wordTimes.length > 0 ? totalTime / wordTimes.length : 0, fastestQuestion: wordTimes.length > 0 ? Math.min(...wordTimes.map((w) => w.timeSpent)) : 0, slowestQuestion: wordTimes.length > 0 ? Math.max(...wordTimes.map((w) => w.timeSpent)) : 0, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 0, p50: 0, p75: 0, p90: 0, }, }, speedTrend: createSpeedTrend(0), }); const createSpeedTrend = (changePercentage: number = 0): SpeedTrend => ({ direction: "stable", changePercentage, dataPoints: [], }); const createWordSelectionConfig = ( config?: Partial<WordSelectionConfig> ): WordSelectionConfig => ({ categories: [], chapters: [], unlearnedOnly: false, difficultOnly: false, randomOrder: true, selectionStrategy: "random", ...config, }); const createTimingConfig = ( config?: Partial<TimingConfig> ): TimingConfig => ({ autoAdvance: true, showTimer: false, autoAdvanceDelay: 1000, showMeaning: false, meaningDisplayDuration: 2000, wordTimeLimit: 30000, ...config, }); const createUIConfig = (config?: Partial<UIConfig>): UIConfig => ({ theme: "light", animations: true, sounds: false, showDetailedProgress: true, showRealTimeStats: true, ...config, }); const createScoringConfig = ( config?: Partial<ScoringConfig> ): ScoringConfig => ({ accuracyWeight: 0.7, speedWeight: 0.3, streakBonus: 0.1, hintPenalty: 2, thresholds: { excellent: 90, good: 80, average: 70, }, ...config, }); const createPerformanceMetrics = ( correctAnswers: number, totalQuestions: number ): PerformanceMetrics => ({ correctAnswers, currentAccuracy: totalQuestions > 0 ? (correctAnswers / totalQuestions) * 100 : 0, incorrectAnswers: totalQuestions - correctAnswers, currentStreak: 0, bestStreak: 0, efficiency: totalQuestions > 0 ? correctAnswers / totalQuestions : 0, currentScore: totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0, }); const createPerformancePatterns = (): PerformancePatterns => ({ timePatterns: { totalTestTime: 0, averageQuestionTime: 0, fastestQuestion: 0, slowestQuestion: 0, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 0, p50: 0, p75: 0, p90: 0, }, }, speedTrend: createSpeedTrend(), }, accuracyPatterns: { overallAccuracy: 0, accuracyByPosition: [], accuracyTrend: createSpeedTrend(), difficultWordsBias: 0, }, hintPatterns: { usage: { sentence: 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, categoryPatterns: [], }); const createTestSession = ( totalTime: number, wordTimes: WordTiming[], finalStats: TestStats, testWords: Word[], wrongWords: Word[] ): TestSession => ({ currentQuestion: null, timeMetrics: createTestTimeMetrics(totalTime, wordTimes), progress: { basic: { totalQuestions: testWords.length, questionsAnswered: finalStats.correct + finalStats.incorrect, currentQuestion: finalStats.correct + finalStats.incorrect, questionsRemaining: 0, completionPercentage: 100, }, performance: createPerformanceMetrics( finalStats.correct, testWords.length ), predictions: { predictedFinalAccuracy: testWords.length > 0 ? (finalStats.correct / testWords.length) * 100 : 0, confidence: 0.8, estimatedTimeToCompletion: 0, predictedFinalScore: testWords.length > 0 ? Math.round((finalStats.correct / testWords.length) * 100) : 0, }, milestones: [], }, wordPool: { allWords: testWords, usedWords: testWords, incorrectWords: wrongWords, remainingWords: [], currentIndex: testWords.length, selectionStrategy: "random", }, answerHistory: [], hintSystem: { globalState: { totalHintsUsed: finalStats.hints, hintsRemaining: 5, usagePattern: { preferredType: "balanced", frequency: "moderate", effectiveness: { sentence: 0.8, synonym: 0.7, }, }, }, config: createHintSystemConfig(), statistics: { usage: { sentence: finalStats.hints, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: 0, }, }, }); const createTestSummaryForExport = ( testId: string, duration: number, finalStats: TestStats, testWords: Word[] ): TestSummaryType => ({ testId, duration, totalQuestions: testWords.length, correctAnswers: finalStats.correct, accuracy: testWords.length > 0 ? Math.round((finalStats.correct / testWords.length) * 100) : 0, hintsUsed: finalStats.hints, averageTime: testWords.length > 0 ? Math.round(duration / testWords.length) : 0, score: testWords.length > 0 ? Math.round((finalStats.correct / testWords.length) * 100) : 0, category: testWords.length > 0 ? finalStats.correct / testWords.length >= 0.9 ? "excellent" : finalStats.correct / testWords.length >= 0.8 ? "good" : finalStats.correct / testWords.length >= 0.7 ? "average" : "poor" : "poor", }); const createTestAnalyticsForExport = (): TestAnalytics => ({ insights: [], performancePatterns: createPerformancePatterns(), recommendations: [], }); const generateGameHint = useCallback((type: 'synonym' | 'antonym' | 'context'): string | null => { if (!currentWord) return null; const usedHints = gameHints[type] || []; let availableHints: string[] = []; switch (type) { case 'synonym': availableHints = currentWord.synonyms || []; break; case 'antonym': availableHints = currentWord.antonyms || []; break; case 'context': availableHints = currentWord.sentences || []; break; default: return null; } const remainingHints = availableHints.filter(hint => !usedHints.includes(hint)); if (remainingHints.length === 0) { return null; } const randomIndex = Math.floor(Math.random() * remainingHints.length); return remainingHints[randomIndex]; }, [currentWord, gameHints]); const handleGameHintRequest = useCallback((type: 'synonym' | 'antonym' | 'context') => { if (!currentWord || !testConfig) { if (AppConfig.app.environment === "development") { console.log('🚫 Mancano currentWord o testConfig:', { currentWord: !!currentWord, testConfig: !!testConfig }); } return; } const { hintsMode, maxHintsPerWord, maxTotalHints, enableTotalHintsLimit } = testConfig; if (AppConfig.app.environment === "development") { console.log('🔍 INIZIO CONTROLLO LIMITI - Configurazione completa:', { hintsMode, maxHintsPerWord, maxTotalHints, enableTotalHintsLimit, configCompleto: testConfig }); } if (hintsMode === 'disabled') { if (AppConfig.app.environment === "development") { console.log('🚫 Suggerimenti disabilitati'); } return; } const currentHintsThisWord = Object.values(gameHints).reduce((total, hints) => total + (hints?.length || 0), 0); if (AppConfig.app.environment === "development") { console.log(`🔍 Debug limiti - Tipo richiesto: ${type}`); console.log(`🔍 Hint correnti questa parola: ${currentHintsThisWord}`); console.log(`🔍 Limit per parola: ${maxHintsPerWord}`); console.log(`🔍 Hint totali usati: ${totalHintsUsed}`); console.log(`🔍 Limite totale: ${maxTotalHints}`); console.log(`🔍 Modalità: ${hintsMode} (tipo: ${typeof hintsMode})`); console.log(`🔍 enableTotalHintsLimit: ${enableTotalHintsLimit}`); console.log(`🔍 Condizione limite parola: hintsMode === 'limited' && maxHintsPerWord && currentHintsThisWord >= maxHintsPerWord`); console.log(`🔍 Valori: ${hintsMode === 'limited'} && ${!!maxHintsPerWord} && ${currentHintsThisWord >= maxHintsPerWord}`); console.log(`🔍 Condizione limite totale: hintsMode === 'limited' && enableTotalHintsLimit && maxTotalHints && totalHintsUsed >= maxTotalHints`); console.log(`🔍 Valori: ${hintsMode === 'limited'} && ${enableTotalHintsLimit} && ${!!maxTotalHints} && ${totalHintsUsed >= maxTotalHints}`); } if (hintsMode === 'limited' && maxHintsPerWord && currentHintsThisWord >= maxHintsPerWord) { if (AppConfig.app.environment === "development") { console.log(`🚫 LIMITE PER PAROLA RAGGIUNTO: ${currentHintsThisWord}/${maxHintsPerWord} - BLOCCO RICHIESTA`); } return; } if (hintsMode === 'limited' && enableTotalHintsLimit && maxTotalHints && totalHintsUsed >= maxTotalHints) { if (AppConfig.app.environment === "development") { console.log(`🚫 LIMITE TOTALE RAGGIUNTO: ${totalHintsUsed}/${maxTotalHints} - BLOCCO RICHIESTA`); } return; } const newHint = generateGameHint(type); if (!newHint) { if (AppConfig.app.environment === "development") { console.log(`🚫 Nessun suggerimento disponibile per ${type}`); } return; } if (AppConfig.app.environment === "development") { console.log(`✅ LIMITI OK - Procedo con l'aggiunta del hint: ${newHint}`); } const now = new Date(); const timeFromStart = currentWordStartTime ? now.getTime() - currentWordStartTime.getTime() : 0; const sequenceOrder = hintSequenceCounter + 1; const detailedHint: DetailedGameHint = { type, content: newHint, requestedAt: now, timeFromWordStart: timeFromStart, sequenceOrder }; currentWordHintsRef.current = [...currentWordHintsRef.current, detailedHint]; if (currentWordSession) { setCurrentWordSession(prev => { if (!prev) return prev; return { ...prev, hintsUsed: [...prev.hintsUsed, detailedHint], totalHintsCount: prev.totalHintsCount + 1 }; }); } setGameHints(prev => ({ ...prev, [type]: [...(prev[type] || []), newHint] })); setTotalHintsUsed(prev => prev + 1); setHintsUsedThisWord(prev => prev + 1); setHintSequenceCounter(prev => prev + 1); if (AppConfig.app.environment === "development") { console.log(`💡 Aiuto ${type} fornito: ${newHint}`); console.log(`💡 Nuovi contatori - Parola: ${currentHintsThisWord + 1}, Totale: ${totalHintsUsed + 1}`); console.log(`📊 Detailed hint tracked: ${JSON.stringify(detailedHint)}`); } }, [currentWord, testConfig, gameHints, totalHintsUsed, generateGameHint, currentWordStartTime, currentWordSession, hintSequenceCounter]); const resetWordHints = useCallback(() => { setGameHints({}); setHintsUsedThisWord(0); }, []); const startTest = useCallback( (words: Word[], config?: any) => { try { if (!words || words.length === 0) { throw new Error("No words available for test"); } setTestConfig(config || {}); const testConfigInternal: TestConfig = { mode: "normal", hints: createHintSystemConfig(), wordSelection: createWordSelectionConfig(config?.wordSelection), timing: createTimingConfig(config?.timing), ui: createUIConfig(config?.ui), scoring: createScoringConfig(config?.scoring), }; let filteredWords = [...words]; if (testConfigInternal.wordSelection.unlearnedOnly) { filteredWords = filteredWords.filter((word) => !word.learned); } const selectedWords = filteredWords; setTestWords(selectedWords); setTestMode(true); setShowResults(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setWrongWords([]); setWordTimes([]); setUsedWordIds(new Set()); setTestSaved(false); setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setIsTransitioning(false); setError(null); const sessionId = `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; const newDetailedSession: DetailedTestSession = { sessionId, startedAt: new Date(), config: config || {}, words: [], wrongWords: [], totalWords: selectedWords.length, correctAnswers: 0, incorrectAnswers: 0, timeoutAnswers: 0, totalHintsUsed: 0, totalTimeSpent: 0, averageTimePerWord: 0, accuracy: 0, chapterBreakdown: {}, performanceTrend: [], speedTrend: [], hintUsagePattern: [], }; setDetailedSession(newDetailedSession); detailedSessionRef.current = newDetailedSession; setCurrentWordSession(null); setCurrentWordStartTime(null); setHintSequenceCounter(0); setGameHints({}); setTotalHintsUsed(0); setHintsUsedThisWord(0); testStartTimeRef.current = Date.now(); wordStartTimeRef.current = Date.now(); if (selectedWords.length > 0) { const randomIndex = Math.floor(Math.random() * selectedWords.length); const firstWord = selectedWords[randomIndex]; setCurrentWord(firstWord); setUsedWordIds(new Set([firstWord.id])); const now = new Date(); const firstWordSession: DetailedWordSession = { wordId: firstWord.id, english: firstWord.english, italian: firstWord.italian, chapter: firstWord.chapter || '', wordShownAt: now, totalTime: 0, hintsUsed: [], totalHintsCount: 0, result: 'timeout', isCorrect: false, testPosition: 1, timeExpired: false, }; setCurrentWordSession(firstWordSession); setCurrentWordStartTime(now); setHintSequenceCounter(0); currentWordHintsRef.current = []; if (AppConfig.app.environment === "development") { console.log(`🎮 Prima parola estratta: ${firstWord.english} (${selectedWords.length - 1} rimanenti)`); } } if (AppConfig.app.environment === "development") { console.log(`🧪 Test started with ${selectedWords.length} words`); } } catch (err) { const error = err as Error; setError(error); console.error("Failed to start test:", error); } }, [] ); const recordWordTime = useCallback((gameHintsUsed: string[] = [], isTimeout: boolean = false) => { if (!currentWord || !wordStartTimeRef.current) return; const endTime = Date.now(); const rawTimeSpent = endTime - wordStartTimeRef.current; const timeSpent = isTimeout ? Math.min(rawTimeSpent, (testConfig?.maxTimePerWord || 10) * 1000) : rawTimeSpent; const currentGameHintsUsed = Object.entries(gameHints).flatMap(([type, hints]) => (hints || []).map((hint: string) => `${type}: ${hint}`) ); const wordTiming: WordTiming = { wordId: currentWord.id, startTime: wordStartTimeRef.current, endTime, timeSpent, usedHint: hintUsedForCurrentWord || currentGameHintsUsed.length > 0, gameHintsUsed: currentGameHintsUsed, }; setWordTimes((prev) => [...prev, wordTiming]); wordStartTimeRef.current = Date.now(); }, [currentWord, hintUsedForCurrentWord, gameHints, testConfig]); const nextWord = useCallback(() => { const availableWords = testWords.filter( (word) => !usedWordIds.has(word.id) ); if (availableWords.length === 0) { setCurrentWord(null); return; } const randomIndex = Math.floor(Math.random() * availableWords.length); const selectedWord = availableWords[randomIndex]; setCurrentWord(selectedWord); setUsedWordIds((prev) => new Set([...prev, selectedWord.id])); setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setIsTransitioning(false); wordStartTimeRef.current = Date.now(); const now = new Date(); const currentPosition = usedWordIds.size + 1; const newWordSession: DetailedWordSession = { wordId: selectedWord.id, english: selectedWord.english, italian: selectedWord.italian, chapter: selectedWord.chapter, wordShownAt: now, totalTime: 0, hintsUsed: [], totalHintsCount: 0, result: 'timeout', isCorrect: false, testPosition: currentPosition, timeExpired: false, }; setCurrentWordSession(newWordSession); setCurrentWordStartTime(now); setHintSequenceCounter(0); currentWordHintsRef.current = []; if (AppConfig.app.environment === "development") { console.log("🔄 RESET HINTS in nextWord() for new word:", selectedWord.english); } console.log(`🧹 RESET HINTS chiamato da nextWord() per: ${selectedWord.english}`); console.trace("Stack trace del reset hints"); setHintsUsedThisWord(0); setGameHints({}); currentWordHintsRef.current = []; if (AppConfig.app.environment === "development") { console.log(`🎮 Parola estratta: ${selectedWord.english} (${availableWords.length - 1} rimanenti)`); } }, [testWords, usedWordIds]); const saveTestResultsWithStats = useCallback( (finalStats: TestStats, finalDetailedSession?: DetailedTestSession) => { if (testSaved) return; recordWordTime([], false); const totalTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0; const testResult: TestResult = { userId: "current-user", testId: `test_${Date.now()}`, config: { mode: "normal", hints: createHintSystemConfig(), wordSelection: createWordSelectionConfig(), timing: createTimingConfig(), ui: createUIConfig(), scoring: createScoringConfig(), }, finalScore: { total: testWords.length > 0 ? Math.round((finalStats.correct / testWords.length) * 100) : 0, category: testWords.length > 0 ? finalStats.correct / testWords.length >= 0.9 ? "excellent" : finalStats.correct / testWords.length >= 0.8 ? "good" : finalStats.correct / testWords.length >= 0.7 ? "average" : "poor" : "poor", breakdown: { accuracy: testWords.length > 0 ? (finalStats.correct / testWords.length) * 100 : 0, speed: 50, efficiency: testWords.length > 0 ? (finalStats.correct / testWords.length) * 100 : 0, consistency: 50, bonus: 0, penalties: finalStats.hints * 2, }, }, feedback: { tone: finalStats.correct / testWords.length >= 0.8 ? "celebratory" : "encouraging", color: finalStats.correct / testWords.length >= 0.8 ? "#22c55e" : "#3b82f6", wordsToReview: wrongWords.map((w) => w.english), message: "Great job!", icon: "check", nextGoals: ["Keep practicing"], }, completedSession: createTestSession( totalTime, wordTimes, finalStats, testWords, wrongWords ), analytics: { insights: [], performancePatterns: createPerformancePatterns(), recommendations: [], }, exportData: { summary: createTestSummaryForExport( `test_${Date.now()}`, totalTime, finalStats, testWords ), detailedAnswers: [] as TestAnswer[], analytics: createTestAnalyticsForExport(), exportedAt: new Date(), format: "json", }, }; if (onTestComplete) { onTestComplete(finalStats, testWords, wrongWords, finalDetailedSession || detailedSession); } setTestSaved(true); if (AppConfig.app.environment === "development") { console.log("🧪 Test completed:", testResult); } }, [ testSaved, testWords, wrongWords, onTestComplete, recordWordTime, wordTimes, detailedSession, ] ); const toggleHint = useCallback(() => { setShowHint((prev) => { const newShowHint = !prev; if (newShowHint && !hintUsedForCurrentWord) { setHintUsedForCurrentWord(true); } return newShowHint; }); }, [hintUsedForCurrentWord]); const handleAnswer = useCallback( (isCorrect: boolean, isTimeout: boolean = false) => { if (!currentWord) return; recordWordTime([], isTimeout); const now = new Date(); if (isTimeout) { console.log("🔍 TIMEOUT DEBUG:", { currentWord: currentWord?.english, currentWordSession: currentWordSession, currentWordStartTime: currentWordStartTime, showMeaning: showMeaning, isTimeout, isCorrect }); } if (isTimeout && AppConfig.app.environment === "development") { console.log("🔍 TIMEOUT ANALYSIS:", { currentWordSession: currentWordSession?.english, hintsInSession: currentWordSession?.totalHintsCount, hintsInGameHints: Object.values(gameHints).reduce((total, hints) => total + (hints?.length || 0), 0), hintsUsedThisWord, currentWordIsNull: !currentWordSession }); } const finalCurrentWordSession = currentWordSession; const actualHintsUsed = currentWordHintsRef.current; const actualHintsCount = actualHintsUsed.length; console.log("🎯 FINAL HINT CALCULATION (USING REF DATA):", { actualHintsUsed, actualHintsCount, fromState: { sessionHints: finalCurrentWordSession?.hintsUsed || [], sessionHintsCount: finalCurrentWordSession?.hintsUsed?.length || 0 }, fromCounters: { hintsUsedThisWord, gameHintsCount: Object.values(gameHints).reduce((total: number, hints: any) => total + (hints?.length || 0), 0) }, isTimeout, currentWordEnglish: currentWord?.english }); const completedWordSession: DetailedWordSession | null = finalCurrentWordSession ? { ...finalCurrentWordSession, cardFlippedAt: finalCurrentWordSession.cardFlippedAt || (showMeaning ? finalCurrentWordSession.cardFlippedAt : now), answerDeclaredAt: now, totalTime: currentWordStartTime ? ( isTimeout ? (testConfig?.maxTimePerWord || 10) * 1000 : now.getTime() - currentWordStartTime.getTime() ) : 0, thinkingTime: showMeaning && finalCurrentWordSession.cardFlippedAt ? finalCurrentWordSession.cardFlippedAt.getTime() - finalCurrentWordSession.wordShownAt.getTime() : (currentWordStartTime ? ( isTimeout ? (testConfig?.maxTimePerWord || 10) * 1000 : now.getTime() - currentWordStartTime.getTime() ) : 0), evaluationTime: showMeaning && finalCurrentWordSession.cardFlippedAt ? now.getTime() - finalCurrentWordSession.cardFlippedAt.getTime() : 0, result: (isTimeout ? 'timeout' : (isCorrect ? 'correct' : 'incorrect')) as 'correct' | 'incorrect' | 'timeout', isCorrect, timeExpired: isTimeout, hintsUsed: actualHintsUsed, totalHintsCount: actualHintsCount } : ( console.log("⚠️ FALLBACK: Creating completedWordSession because currentWordSession is null"), console.log("🔍 FALLBACK DEBUG:", { actualHintsUsed, actualHintsCount, currentWord: currentWord?.english, isTimeout }), currentWord ? { wordId: currentWord.id, english: currentWord.english, italian: currentWord.italian, chapter: currentWord.chapter, wordShownAt: currentWordStartTime || now, cardFlippedAt: showMeaning ? now : (isTimeout ? now : undefined), answerDeclaredAt: now, thinkingTime: currentWordStartTime ? ( isTimeout ? (testConfig?.maxTimePerWord || 10) * 1000 : now.getTime() - currentWordStartTime.getTime() ) : (isTimeout ? (testConfig?.maxTimePerWord || 10) * 1000 : 0), evaluationTime: showMeaning ? 0 : 0, totalTime: currentWordStartTime ? ( isTimeout ? (testConfig?.maxTimePerWord || 10) * 1000 : now.getTime() - currentWordStartTime.getTime() ) : (isTimeout ? (testConfig?.maxTimePerWord || 10) * 1000 : 0), hintsUsed: actualHintsUsed, totalHintsCount: actualHintsCount, result: (isTimeout ? 'timeout' : (isCorrect ? 'correct' : 'incorrect')) as 'correct' | 'incorrect' | 'timeout', isCorrect, testPosition: usedWordIds.size + 1, timeExpired: isTimeout, } : null ); const gameHintsCount = actualHintsCount; if (detailedSessionRef.current && completedWordSession) { const currentSession = detailedSessionRef.current; const updatedWords = [...currentSession.words, completedWordSession]; const updatedWrongWords = isCorrect ? currentSession.wrongWords : [...currentSession.wrongWords, completedWordSession]; const newCorrect = currentSession.correctAnswers + (isCorrect ? 1 : 0); const newIncorrect = currentSession.incorrectAnswers + (isCorrect ? 0 : 1); const newTimeouts = currentSession.timeoutAnswers + (isTimeout ? 1 : 0); const newTotalTime = currentSession.totalTimeSpent + completedWordSession.totalTime; const chapter = completedWordSession.chapter || 'no-chapter'; const currentChapterStats = currentSession.chapterBreakdown[chapter] || { correct: 0, incorrect: 0, totalTime: 0, hintsUsed: 0, }; const updatedChapterBreakdown = { ...currentSession.chapterBreakdown, [chapter]: { correct: currentChapterStats.correct + (isCorrect ? 1 : 0), incorrect: currentChapterStats.incorrect + (isCorrect ? 0 : 1), totalTime: currentChapterStats.totalTime + completedWordSession.totalTime, hintsUsed: currentChapterStats.hintsUsed + completedWordSession.totalHintsCount, } }; const updatedSession = { ...currentSession, words: updatedWords, wrongWords: updatedWrongWords, correctAnswers: newCorrect, incorrectAnswers: newIncorrect, timeoutAnswers: newTimeouts, totalHintsUsed: currentSession.totalHintsUsed + completedWordSession.totalHintsCount, totalTimeSpent: newTotalTime, averageTimePerWord: updatedWords.length > 0 ? newTotalTime / updatedWords.length : 0, accuracy: updatedWords.length > 0 ? (newCorrect / updatedWords.length) * 100 : 0, chapterBreakdown: updatedChapterBreakdown, performanceTrend: [...currentSession.performanceTrend, isCorrect ? 1 : 0], speedTrend: [...currentSession.speedTrend, completedWordSession.totalTime], hintUsagePattern: [...currentSession.hintUsagePattern, completedWordSession.totalHintsCount], }; detailedSessionRef.current = updatedSession; setDetailedSession(updatedSession); } const newStats: TestStats = { correct: stats.correct + (isCorrect ? 1 : 0), incorrect: stats.incorrect + (isCorrect ? 0 : 1), hints: stats.hints + (hintUsedForCurrentWord ? 1 : 0) + gameHintsCount, }; setStats(newStats); if (!isCorrect && currentWord) { const wrongWord = { ...currentWord, usedHint: hintUsedForCurrentWord || Object.values(gameHints).some(hints => hints && hints.length > 0), }; setWrongWords((prev) => [...prev, wrongWord]); } const totalAnswered = newStats.correct + newStats.incorrect; const isLastQuestion = totalAnswered >= testWords.length; if (isLastQuestion) { if (detailedSessionRef.current) { const finalDetailedSession = { ...detailedSessionRef.current, completedAt: new Date(), }; if (AppConfig.app.environment === "development") { console.log("🎯 Test Session Completed:", finalDetailedSession); } setDetailedSession(finalDetailedSession); saveTestResultsWithStats(newStats, finalDetailedSession); } else { saveTestResultsWithStats(newStats); } setTestMode(false); setShowResults(true); setCurrentWord(null); } else if (!isTimeout) { setIsTransitioning(true); if (showMeaning) { setTimeout(() => { setShowMeaning(false); setTimeout(() => { nextWord(); }, 400); }, 800); } else { setTimeout(() => { nextWord(); }, 300); } } else { if (AppConfig.app.environment === "development") { console.log("⏱️ TIMEOUT: Ensuring card is face-down before next word"); } setIsTransitioning(true); setShowMeaning(false); setTimeout(() => { nextWord(); }, 300); } }, [ currentWord, stats, testWords.length, hintUsedForCurrentWord, showMeaning, recordWordTime, saveTestResultsWithStats, nextWord, gameHints, currentWordSession, detailedSession, currentWordStartTime, ] ); const resetTest = useCallback(() => { if (!testSaved && (stats.correct > 0 || stats.incorrect > 0)) { saveTestResultsWithStats(stats); } setTestMode(false); setShowResults(false); setCurrentWord(null); setUsedWordIds(new Set()); setWrongWords([]); setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setTestWords([]); setTestSaved(false); setWordTimes([]); setIsTransitioning(false); setError(null); setGameHints({}); setTotalHintsUsed(0); setHintsUsedThisWord(0); setTestConfig(null); testStartTimeRef.current = null; wordStartTimeRef.current = null; setDetailedSession(null); detailedSessionRef.current = null; setCurrentWordSession(null); setCurrentWordStartTime(null); setHintSequenceCounter(0); if (AppConfig.app.environment === "development") { console.log("🧪 Test reset"); } }, [stats, testSaved, saveTestResultsWithStats]); const startNewTest = useCallback(() => { setShowResults(false); setWrongWords([]); setTestSaved(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setUsedWordIds(new Set()); setCurrentWord(null); setWordTimes([]); setIsTransitioning(false); setError(null); setGameHints({}); setTotalHintsUsed(0); setHintsUsedThisWord(0); startTest(testWords, testConfig); }, [testWords, testConfig, startTest]); const getTestProgress = useCallback((): TestProgress => { const totalAnswered = stats.correct + stats.incorrect; const total = testWords.length; return { current: totalAnswered, total, percentage: total > 0 ? Math.round((totalAnswered / total) * 100) : 0, remaining: total - totalAnswered, }; }, [stats.correct, stats.incorrect, testWords.length]); const getTestSummary = useCallback((): TestSummary => { if (detailedSessionRef.current && detailedSessionRef.current.words.length > 0) { const session = detailedSessionRef.current; const totalQuestions = session.totalWords; const totalAnswered = session.correctAnswers + session.incorrectAnswers; const accuracy = session.accuracy; const score = totalQuestions > 0 ? Math.round((session.correctAnswers / totalQuestions) * 100) : 0; return { totalQuestions, correctAnswers: session.correctAnswers, incorrectAnswers: session.incorrectAnswers, hintsUsed: session.totalHintsUsed, accuracy: Math.round(accuracy), score, timeSpent: session.totalTimeSpent, averageTimePerWord: Math.round(session.averageTimePerWord), wrongWords: session.wrongWords.map(wordSession => ({ id: wordSession.wordId, english: wordSession.english, italian: wordSession.italian, chapter: wordSession.chapter, usedHint: wordSession.totalHintsCount > 0, learned: false, difficult: false, createdAt: new Date(), updatedAt: new Date(), notes: undefined, group: undefined, pronunciation: undefined, sentences: [] })), correct: session.correctAnswers, incorrect: session.incorrectAnswers, hints: session.totalHintsUsed, totalTime: Math.round(session.totalTimeSpent / 1000), avgTimePerWord: Math.round(session.averageTimePerWord / 1000), maxTimePerWord: session.speedTrend.length > 0 ? Math.round(Math.max(...session.speedTrend) / 1000) : 0, minTimePerWord: session.speedTrend.length > 0 ? Math.round(Math.min(...session.speedTrend) / 1000) : 0, totalRecordedTime: Math.round(session.totalTimeSpent / 1000), total: session.totalWords, answered: totalAnswered, percentage: Math.round(accuracy) }; } const totalQuestions = testWords.length; const totalAnswered = stats.correct + stats.incorrect; const accuracy = totalAnswered > 0 ? (stats.correct / totalAnswered) * 100 : 0; const score = totalQuestions > 0 ? Math.round((stats.correct / totalQuestions) * 100) : 0; const totalTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : wordTimes.reduce((sum, timing) => sum + timing.timeSpent, 0); const averageTimePerWord = totalAnswered > 0 ? totalTime / totalAnswered : 0; return { totalQuestions, correctAnswers: stats.correct, incorrectAnswers: stats.incorrect, hintsUsed: stats.hints, accuracy: Math.round(accuracy), score, timeSpent: totalTime, averageTimePerWord: Math.round(averageTimePerWord), wrongWords, correct: stats.correct, incorrect: stats.incorrect, hints: stats.hints, totalTime: Math.round(totalTime / 1000), avgTimePerWord: Math.round(averageTimePerWord / 1000), maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: Math.round(totalTime / 1000), total: totalQuestions, answered: totalAnswered, percentage: Math.round(accuracy) }; }, [testWords.length, stats, wrongWords, wordTimes]); const progressData = useMemo(() => getTestProgress(), [getTestProgress]); const summaryData = useMemo(() => getTestSummary(), [getTestSummary]); return { testMode, showResults, currentWord, testWords, usedWordIds, stats, wrongWords, wordTimes, showMeaning, showHint, hintUsedForCurrentWord, isTransitioning, testSaved, isInitialized, error, gameHints, totalHintsUsed, hintsUsedThisWord, testConfig, currentWordSession, detailedSession, currentWordStartTime, hintSequenceCounter, startTest, handleAnswer, resetTest, startNewTest, toggleHint, setShowMeaning: useCallback((show: boolean) => { if (show && !showMeaning && currentWordSession) { setCurrentWordSession(prev => { if (!prev || prev.cardFlippedAt) return prev; return { ...prev, cardFlippedAt: new Date() }; }); } setShowMeaning(show); }, [showMeaning, currentWordSession]), handleGameHintRequest, getTestProgress: useCallback(() => progressData, [progressData]), getTestSummary: useCallback(() => { return getTestSummary(); }, [getTestSummary]), hintUsed: hintUsedForCurrentWord, }; }; export default useTest;

================================================================================

NOME FILE: data\useWords.ts

import { useState, useCallback, useMemo, useEffect, useRef } from "react"; import { useFirestore } from "../core/useFirestore"; import { useFirebase } from "../../contexts/FirebaseContext"; import AppConfig from "../../config/appConfig"; import type { Word, WordFilters, WordCategory, WordChapter, } from "../../types/entities/Word.types"; import type { CreateInput, UpdateInput, OperationResult, } from "../../types/index"; import type { FirestoreError, FirestoreOperationResult, } from "../../types/infrastructure/Firestore.types"; const EMPTY_ARRAY: Word[] = []; interface WordStats { total: number; learned: number; unlearned: number; difficult: number; normal: number; byChapter: Record<string, number>; byCategory: Record<string, number>; } interface ChapterStats { total: number; learned: number; unlearned: number; difficult: number; normal: number; } interface WordsState { words: Word[]; editingWord: Word | null; loading: boolean; error: FirestoreError | null; refreshTrigger: number; isInitialized: boolean; lastSync: Date | null; fromCache: boolean; } interface WordsOperations { addWord: (wordData: CreateInput<Word>) => Promise<OperationResult<Word>>; removeWord: (wordId: string) => Promise<OperationResult<void>>; updateWord: ( wordId: string, updates: UpdateInput<Word> ) => Promise<OperationResult<Word>>; toggleWordLearned: (wordId: string) => Promise<OperationResult<Word>>; toggleWordDifficult: (wordId: string) => Promise<OperationResult<Word>>; clearAllWords: () => Promise<OperationResult<void>>; importWords: (words: (CreateInput<Word> & { id?: string })[]) => Promise<OperationResult<Word[]>>; forceRefresh: () => void; setEditingWord: (word: Word | null) => void; } interface WordsGetters { getAvailableChapters: () => string[]; getChapterStats: (chapter: string) => ChapterStats; getFilteredWords: (filters?: WordFilters) => Word[]; getWordsByCategory: (category: WordCategory) => Word[]; searchWords: (searchTerm: string) => Word[]; } interface WordsResult extends WordsState, WordsOperations, WordsGetters { wordStats: WordStats; } export const useWords = (): WordsResult => { const firestoreHook = useFirestore<Word>({ collection: "words", realtime: true, enableCache: true, autoFetch: true, syncWithLocalStorage: true, localStorageKey: "vocabularyWords", debug: AppConfig.app.environment === "development", }); const { isReady } = useFirebase(); const [editingWord, setEditingWord] = useState<Word | null>(null); const [refreshTrigger, setRefreshTrigger] = useState<number>(0); const [isInitialized, setIsInitialized] = useState<boolean>(false); const statsCache = useRef<{ stats: WordStats; timestamp: number } | null>( null ); const STATS_CACHE_TTL = 5000; useEffect(() => { if (isReady && !isInitialized) { setIsInitialized(true); if (AppConfig.app.environment === "development") { console.log("🔄 useWords initialized with Firebase"); } } }, [isReady, isInitialized]); const addWord = useCallback( async (wordData: CreateInput<Word>): Promise<OperationResult<Word>> => { const startTime = Date.now(); try { if (!wordData.english?.trim() || !wordData.italian?.trim()) { throw new Error("English word and Italian translation are required"); } const existingWord = firestoreHook.data.find( (w) => w.english.toLowerCase() === wordData.english.toLowerCase() ); if (existingWord) { throw new Error("Word already exists"); } const wordToCreate = { ...wordData, english: wordData.english.trim(), italian: wordData.italian.trim(), chapter: wordData.chapter || "1", group: wordData.group || "GENERAL", sentences: wordData.sentences || [], synonyms: wordData.synonyms || [], learned: false, difficult: false, createdAt: new Date(), updatedAt: new Date(), }; const createdWord = await firestoreHook.create(wordToCreate); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, data: createdWord, metadata: { operation: "addWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { const firestoreError = error as FirestoreError; return { success: false, error: firestoreError, metadata: { operation: "addWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.create, firestoreHook.data] ); const removeWord = useCallback( async (wordId: string): Promise<OperationResult<void>> => { const startTime = Date.now(); try { await firestoreHook.remove(wordId); if (editingWord?.id === wordId) { setEditingWord(null); } statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, metadata: { operation: "removeWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "removeWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.remove, editingWord?.id] ); const updateWord = useCallback( async ( wordId: string, updates: UpdateInput<Word> ): Promise<OperationResult<Word> & { synced?: boolean; warning?: string }> => { const startTime = Date.now(); try { const updatedWord = await firestoreHook.update(wordId, updates); if (editingWord?.id === wordId) { setEditingWord(updatedWord); } statsCache.current = null; setRefreshTrigger((prev) => prev + 1); const isSynced = (updatedWord as any)._firestoreStatus === 'synced'; return { success: isSynced, data: updatedWord, metadata: { operation: "updateWord", timestamp: new Date(), duration: Date.now() - startTime, }, synced: isSynced, warning: !isSynced ? "Parola salvata solo localmente. Controllare la connessione di rete." : undefined, } as OperationResult<Word> & { synced: boolean; warning?: string }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "updateWord", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.update, editingWord?.id] ); const toggleWordLearned = useCallback( async (wordId: string): Promise<OperationResult<Word>> => { const word = firestoreHook.data.find((w) => w.id === wordId); if (!word) { return { success: false, error: { code: "not-found" as any, message: "Word not found", operation: "toggle-learned" as any, recoverable: false, timestamp: new Date(), } as any, metadata: { operation: "toggleWordLearned", timestamp: new Date(), duration: 0, }, }; } return updateWord(wordId, { id: wordId, learned: !word.learned }); }, [firestoreHook.data, updateWord] ); const toggleWordDifficult = useCallback( async (wordId: string): Promise<OperationResult<Word>> => { const word = firestoreHook.data.find((w) => w.id === wordId); if (!word) { return { success: false, error: { code: "not-found" as any, message: "Word not found", operation: "toggle-difficult" as any, recoverable: false, timestamp: new Date(), } as any, metadata: { operation: "toggleWordDifficult", timestamp: new Date(), duration: 0, }, }; } return updateWord(wordId, { id: wordId, difficult: !word.difficult }); }, [firestoreHook.data, updateWord] ); const clearAllWords = useCallback(async (): Promise< OperationResult<void> > => { const startTime = Date.now(); try { const operations = firestoreHook.data.map((word) => ({ type: "delete" as const, id: word.id, })); await firestoreHook.batchUpdate(operations); setEditingWord(null); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, metadata: { operation: "clearAllWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "clearAllWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.data, firestoreHook.batchUpdate]); const importWords = useCallback( async ( wordsToImport: (CreateInput<Word> & { id?: string })[] ): Promise<OperationResult<Word[]>> => { const startTime = Date.now(); try { const validWords = wordsToImport.filter( (word) => word.english?.trim() && word.italian?.trim() ); if (validWords.length === 0) { throw new Error("No valid words to import"); } const existingEnglishWords = new Set( firestoreHook.data.map((w) => w.english.toLowerCase()) ); const newWords = validWords.filter( (word) => !existingEnglishWords.has(word.english.toLowerCase()) ); if (newWords.length === 0) { throw new Error("All words already exist"); } const operations = newWords.map((word) => ({ type: "create" as const, id: word.id, data: { ...word, english: word.english.trim(), italian: word.italian.trim(), chapter: word.chapter || "1", group: word.group || "GENERAL", sentences: word.sentences || [], synonyms: word.synonyms || [], learned: false, difficult: false, }, })); await firestoreHook.batchUpdate(operations); const createdWords = firestoreHook.data.slice(-newWords.length); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); return { success: true, data: createdWords, metadata: { operation: "importWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } catch (error) { return { success: false, error: error as FirestoreError, metadata: { operation: "importWords", timestamp: new Date(), duration: Date.now() - startTime, }, }; } }, [firestoreHook.data, firestoreHook.batchUpdate] ); const forceRefresh = useCallback(() => { firestoreHook.fetch(); statsCache.current = null; setRefreshTrigger((prev) => prev + 1); }, [firestoreHook.fetch]); const wordStats = useMemo<WordStats>(() => { const now = Date.now(); if ( statsCache.current && now - statsCache.current.timestamp < STATS_CACHE_TTL ) { return statsCache.current.stats; } const words = firestoreHook.data; console.log('useWords - calculating stats for words:', words.length); console.log('useWords - sample words:', words.slice(0, 2)); const stats: WordStats = { total: words.length, learned: words.filter((w) => w.learned).length, unlearned: words.filter((w) => !w.learned).length, difficult: words.filter((w) => w.difficult).length, normal: words.filter((w) => !w.difficult && !w.learned).length, byChapter: {}, byCategory: {}, }; words.forEach((word) => { const chapter = word.chapter || "Unknown"; stats.byChapter[chapter] = (stats.byChapter[chapter] || 0) + 1; }); words.forEach((word) => { const category = word.group || "GENERAL"; stats.byCategory[category] = (stats.byCategory[category] || 0) + 1; }); statsCache.current = { stats, timestamp: now }; return stats; }, [firestoreHook.data, refreshTrigger]); const getAvailableChapters = useCallback((): string[] => { const chapters = new Set<string>(); firestoreHook.data.forEach((word) => { if (word.chapter) { chapters.add(word.chapter); } }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); return isNaN(aNum) || isNaN(bNum) ? a.localeCompare(b) : aNum - bNum; }); }, [firestoreHook.data]); const getChapterStats = useCallback( (chapter: string): ChapterStats => { const chapterWords = firestoreHook.data.filter( (word) => word.chapter === chapter ); return { total: chapterWords.length, learned: chapterWords.filter((w) => w.learned).length, unlearned: chapterWords.filter((w) => !w.learned).length, difficult: chapterWords.filter((w) => w.difficult).length, normal: chapterWords.filter((w) => !w.difficult && !w.learned).length, }; }, [firestoreHook.data] ); const getFilteredWords = useCallback( (filters?: WordFilters): Word[] => { if (!filters) return firestoreHook.data; return firestoreHook.data.filter((word) => { if (filters.chapter && word.chapter !== filters.chapter) return false; if ( filters.difficult !== undefined && word.difficult !== filters.difficult ) return false; if (filters.learned !== undefined && word.learned !== filters.learned) return false; if (filters.category && word.group !== filters.category) return false; if (filters.createdAfter && word.createdAt < filters.createdAfter) return false; if (filters.createdBefore && word.createdAt > filters.createdBefore) return false; return true; }); }, [firestoreHook.data] ); const getWordsByCategory = useCallback( (category: WordCategory): Word[] => { return firestoreHook.data.filter((word) => word.group === category); }, [firestoreHook.data] ); const searchWords = useCallback( (searchTerm: string): Word[] => { if (!searchTerm.trim()) return firestoreHook.data; const term = searchTerm.toLowerCase(); return firestoreHook.data.filter( (word) => word.english.toLowerCase().includes(term) || word.italian.toLowerCase().includes(term) || word.sentences?.some((sentence) => sentence.toLowerCase().includes(term) ) || word.synonyms?.some((synonym) => synonym.toLowerCase().includes(term)) ); }, [firestoreHook.data] ); return { words: firestoreHook.data || EMPTY_ARRAY, editingWord, loading: firestoreHook.loading, error: firestoreHook.error, refreshTrigger, isInitialized, lastSync: firestoreHook.lastSync, fromCache: firestoreHook.fromCache, addWord, removeWord, updateWord, toggleWordLearned, toggleWordDifficult, clearAllWords, importWords, forceRefresh, setEditingWord, getAvailableChapters, getChapterStats, getFilteredWords, getWordsByCategory, searchWords, wordStats, }; }; export default useWords;

================================================================================

NOME FILE: integration\useAI.ts

import { useState, useCallback, useRef } from 'react'; import { aiService } from '../../services/aiService'; type AIServiceStatus = ReturnType<typeof aiService.getServiceStatus>; interface AIAnalysisResult { success: boolean; data?: any; error?: string; duration?: number; } interface AIHookState { isProcessing: boolean; status: AIServiceStatus | null; error: string | null; lastResult: AIAnalysisResult | null; } interface AIHookReturn { isProcessing: boolean; status: AIServiceStatus | null; error: string | null; lastResult: AIAnalysisResult | null; analyzeWord: (word: string, context?: string) => Promise<AIAnalysisResult>; checkStatus: () => Promise<AIServiceStatus>; clearError: () => void; clearResult: () => void; } export const useAI = (): AIHookReturn => { const [state, setState] = useState<AIHookState>({ isProcessing: false, status: null, error: null, lastResult: null, }); const abortControllerRef = useRef<AbortController | null>(null); const setProcessing = useCallback((processing: boolean) => { setState(prev => ({ ...prev, isProcessing: processing })); }, []); const setError = useCallback((error: string | null) => { setState(prev => ({ ...prev, error })); }, []); const setStatus = useCallback((status: AIServiceStatus) => { setState(prev => ({ ...prev, status })); }, []); const setResult = useCallback((result: AIAnalysisResult) => { setState(prev => ({ ...prev, lastResult: result })); }, []); const clearError = useCallback(() => { setError(null); }, [setError]); const clearResult = useCallback(() => { setResult({ success: false }); }, [setResult]); const checkStatus = useCallback(async (): Promise<AIServiceStatus> => { try { const status = aiService.getServiceStatus(); setStatus(status); return status; } catch (error) { const failedStatus: AIServiceStatus = { health: 'down', configured: false, consecutiveFailures: 999, lastSuccessTime: null, lastHealthCheck: null, circuitBreaker: null, apiUrl: '', timeout: 0, canUseAI: false, degradedMode: true, recommendations: [] }; setStatus(failedStatus); return failedStatus; } }, [setStatus]); const analyzeWord = useCallback(async ( word: string, context?: string ): Promise<AIAnalysisResult> => { if (!word.trim()) { const result: AIAnalysisResult = { success: false, error: 'Word is required for analysis', }; setResult(result); return result; } if (abortControllerRef.current) { abortControllerRef.current.abort(); } abortControllerRef.current = new AbortController(); setProcessing(true); setError(null); const startTime = Date.now(); try { const analysisResult = await aiService.analyzeWord(word); const duration = Date.now() - startTime; const result: AIAnalysisResult = { success: true, data: analysisResult, duration, }; setResult(result); return result; } catch (error: any) { const duration = Date.now() - startTime; if (error.name === 'AbortError') { const result: AIAnalysisResult = { success: false, error: 'Analysis cancelled', duration, }; setResult(result); return result; } const errorMessage = error.message || 'Failed to analyze word'; setError(errorMessage); const result: AIAnalysisResult = { success: false, error: errorMessage, duration, }; setResult(result); return result; } finally { setProcessing(false); abortControllerRef.current = null; } }, [setProcessing, setError, setResult]); const generateSentence = useCallback(async ( word: string, italian: string ): Promise<AIAnalysisResult> => { if (!word.trim() || !italian.trim()) { const result: AIAnalysisResult = { success: false, error: 'Both English and Italian words are required', }; setResult(result); return result; } if (abortControllerRef.current) { abortControllerRef.current.abort(); } abortControllerRef.current = new AbortController(); setProcessing(true); setError(null); const startTime = Date.now(); try { const sentence = `Example sentence with "${word}" (${italian}).`; const duration = Date.now() - startTime; const result: AIAnalysisResult = { success: true, data: { sentence }, duration, }; setResult(result); return result; } catch (error: any) { const duration = Date.now() - startTime; if (error.name === 'AbortError') { const result: AIAnalysisResult = { success: false, error: 'Sentence generation cancelled', duration, }; setResult(result); return result; } const errorMessage = error.message || 'Failed to generate sentence'; setError(errorMessage); const result: AIAnalysisResult = { success: false, error: errorMessage, duration, }; setResult(result); return result; } finally { setProcessing(false); abortControllerRef.current = null; } }, [setProcessing, setError, setResult]); return { isProcessing: state.isProcessing, status: state.status, error: state.error, lastResult: state.lastResult, analyzeWord, checkStatus, clearError, clearResult, }; }; export default useAI;

================================================================================

NOME FILE: integration\useAuth.ts

import { useState, useEffect, useCallback } from "react"; import { onAuthStateChanged } from "firebase/auth"; import { doc, updateDoc, setDoc } from "firebase/firestore"; import { auth, db } from "../../config/firebase"; import { useFirebase } from "../../contexts/FirebaseContext"; import { signUp, signIn, signOutUser, resetPassword, verifyPasswordResetCode, confirmPasswordReset, verifyEmail, updateAuthProfile, updateUserPassword, getCurrentUser, getCurrentAuthUser, getUserProfile, initializeUserProfile, signInWithGoogle, handleGoogleRedirectResult, validateEmail, validatePassword, getUserPreferences, } from "../../services/authService"; import { DEFAULT_PERMISSIONS, getUserPermissions, isAdmin, isUser, canPerformAdminOperation, } from "../../types/entities/User.types"; import type { User, UserRole, UserPermissions, SignUpInput, SignInInput, ResetPasswordInput, UpdateProfileInput, AuthError, } from "../../types/entities/User.types"; import type { AuthUser, AuthSession, UpdatePasswordInput, } from "../../types/infrastructure/Auth.types"; interface AuthState { user: User | null; authUser: AuthUser | null; userProfile: User | null; role: UserRole | null; permissions: UserPermissions; loading: boolean; initializing: boolean; error: AuthError | null; session: AuthSession | null; operationLoading: { signIn: boolean; signUp: boolean; signOut: boolean; resetPassword: boolean; updateProfile: boolean; updatePassword: boolean; }; } const initialState: AuthState = { user: null, authUser: null, userProfile: null, role: null, permissions: DEFAULT_PERMISSIONS.user, loading: false, initializing: true, error: null, session: null, operationLoading: { signIn: false, signUp: false, signOut: false, resetPassword: false, updateProfile: false, updatePassword: false, }, }; export const useAuth = () => { const { isReady: firebaseReady } = useFirebase(); const [state, setState] = useState<AuthState>(initialState); const updateState = useCallback((updates: Partial<AuthState>) => { setState(prev => ({ ...prev, ...updates })); }, []); const setOperationLoading = useCallback((operation: keyof AuthState["operationLoading"], loading: boolean) => { setState(prev => ({ ...prev, operationLoading: { ...prev.operationLoading, [operation]: loading, }, })); }, []); const loadUserProfile = useCallback(async (userId: string) => { try { const profile = await getUserProfile(userId); updateState({ userProfile: profile, role: profile?.role || null, permissions: profile?.role ? getUserPermissions(profile.role) : DEFAULT_PERMISSIONS.user, }); } catch (error) { console.error("Error loading user profile:", error); updateState({ userProfile: null, role: null, permissions: DEFAULT_PERMISSIONS.user, }); } }, [updateState]); const loadUserPreferences = useCallback(async (userId: string) => { try { const preferences = await getUserPreferences(userId); if (preferences) { const isDark = preferences.theme === 'dark'; if (isDark) { document.documentElement.classList.add('dark'); } else { document.documentElement.classList.remove('dark'); } console.log("User preferences loaded and theme applied:", preferences.theme); } } catch (error) { console.error("Error loading user preferences:", error); } }, []); useEffect(() => { if (!firebaseReady) return; const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => { if (firebaseUser) { const authUser = getCurrentAuthUser(); const user = getCurrentUser(); updateState({ user, authUser, initializing: false, loading: false, error: null, }); if (user?.id) { await loadUserProfile(user.id); await loadUserPreferences(user.id); } } else { document.documentElement.classList.remove('dark'); localStorage.setItem('theme', 'light'); window.dispatchEvent(new Event('themeReset')); updateState({ user: null, authUser: null, userProfile: null, role: null, permissions: DEFAULT_PERMISSIONS.user, initializing: false, loading: false, session: null, }); } }); return unsubscribe; }, [firebaseReady, updateState, loadUserProfile, loadUserPreferences]); useEffect(() => { if (firebaseReady) { updateState({ loading: true }); handleGoogleRedirectResult().then((result) => { if (result && !result.success && result.error) { updateState({ error: result.error as AuthError, loading: false }); } else { updateState({ loading: false }); } }).catch(() => { updateState({ loading: false }); }); } }, [firebaseReady, updateState]); const handleSignUp = useCallback(async (input: SignUpInput): Promise<boolean> => { if (!firebaseReady) return false; setOperationLoading("signUp", true); try { const result = await signUp(input); if (result.success && result.user) { try { await initializeUserProfile(result.user.uid); } catch (profileError) { console.error("Error initializing user profile:", profileError); } return true; } else { updateState({ error: result.error as AuthError }); return false; } } catch (error) { updateState({ error: { code: "unknown", message: "Sign up failed", type: "unknown", timestamp: new Date() } }); return false; } finally { setOperationLoading("signUp", false); } }, [firebaseReady, setOperationLoading, updateState]); const handleSignIn = useCallback(async (input: SignInInput): Promise<boolean> => { if (!firebaseReady) return false; setOperationLoading("signIn", true); try { const result = await signIn(input); if (result.success) { try { console.log('Login successful, checking if admin...'); const userProfile = await getUserProfile(result.user!.uid); console.log('User profile:', userProfile); if (userProfile?.role === 'admin') { console.log('Admin login detected, processing pending user creations...'); const { processPendingUserCreations } = await import('../../services/adminService'); const results = await processPendingUserCreations('email', { email: input.email, password: input.password }); console.log('Pending user creation results:', results); if (results.processed > 0) { console.log(`Successfully processed ${results.processed} pending user creations`); window.dispatchEvent(new CustomEvent('adminUsersProcessed', { detail: { processed: results.processed, failed: results.failed } })); } } else { console.log('Not an admin user, skipping pending user processing'); } } catch (adminError) { console.error('Error processing admin tasks:', adminError); } return true; } else { updateState({ error: result.error as AuthError }); return false; } } catch (error) { updateState({ error: { code: "unknown", message: "Sign in failed", type: "unknown", timestamp: new Date() } }); return false; } finally { setOperationLoading("signIn", false); } }, [firebaseReady, setOperationLoading, updateState]); const handleGoogleSignIn = useCallback(async (): Promise<boolean> => { if (!firebaseReady) return false; setOperationLoading("signIn", true); try { const result = await signInWithGoogle(); if (result.success) { try { console.log('Google login successful, checking if admin...'); const userProfile = await getUserProfile(result.user!.uid); console.log('User profile:', userProfile); if (userProfile?.role === 'admin') { console.log('Admin Google login detected, processing pending user creations...'); const { processPendingUserCreations } = await import('../../services/adminService'); const results = await processPendingUserCreations('google'); console.log('Pending user creation results:', results); if (results.processed > 0) { console.log(`Successfully processed ${results.processed} pending user creations`); window.dispatchEvent(new CustomEvent('adminUsersProcessed', { detail: { processed: results.processed, failed: results.failed } })); } } else { console.log('Not an admin user, skipping pending user processing'); } } catch (adminError) { console.error('Error processing admin tasks:', adminError); } return true; } else if (result.message === "Reindirizzamento a Google...") { return true; } else { updateState({ error: result.error as AuthError }); return false; } } catch (error) { updateState({ error: { code: "unknown", message: "Google sign in failed", type: "unknown", timestamp: new Date() } }); return false; } finally { setOperationLoading("signIn", false); } }, [firebaseReady, setOperationLoading, updateState]); const handleSignOut = useCallback(async (): Promise<boolean> => { setOperationLoading("signOut", true); try { const result = await signOutUser(); return result.success; } catch (error) { updateState({ error: { code: "unknown", message: "Sign out failed", type: "unknown", timestamp: new Date() } }); return false; } finally { setOperationLoading("signOut", false); } }, [setOperationLoading, updateState]); const handleResetPassword = useCallback(async (input: ResetPasswordInput): Promise<boolean> => { if (!firebaseReady) return false; setOperationLoading("resetPassword", true); try { const result = await resetPassword(input); if (result.success) { return true; } else { updateState({ error: result.error as AuthError }); return false; } } catch (error) { updateState({ error: { code: "unknown", message: "Password reset failed", type: "unknown", timestamp: new Date() } }); return false; } finally { setOperationLoading("resetPassword", false); } }, [firebaseReady, setOperationLoading, updateState]); const handleUpdateProfile = useCallback(async (input: UpdateProfileInput): Promise<boolean> => { if (!firebaseReady || !state.authUser) return false; setOperationLoading("updateProfile", true); try { const result = await updateAuthProfile(input); if (!result.success) { updateState({ error: result.error as AuthError }); return false; } if (input.displayName && state.authUser.uid) { try { const userRef = doc(db, "users", state.authUser.uid); await setDoc(userRef, { displayName: input.displayName, email: state.authUser.email, updatedAt: new Date(), }, { merge: true }); } catch (firestoreError) { console.error("Error updating Firestore user document:", firestoreError); } } if (state.authUser.uid) { await loadUserProfile(state.authUser.uid); } return true; } catch (error) { updateState({ error: { code: "unknown", message: "Profile update failed", type: "unknown", timestamp: new Date() } }); return false; } finally { setOperationLoading("updateProfile", false); } }, [firebaseReady, state.authUser, setOperationLoading, updateState, loadUserProfile]); const handleUpdatePassword = useCallback(async (input: UpdatePasswordInput): Promise<boolean> => { if (!firebaseReady || !state.authUser) return false; setOperationLoading("updatePassword", true); try { const result = await updateUserPassword(input); if (result.success) { return true; } else { updateState({ error: result.error as AuthError }); return false; } } catch (error) { updateState({ error: { code: "unknown", message: "Password update failed", type: "unknown", timestamp: new Date() } }); return false; } finally { setOperationLoading("updatePassword", false); } }, [firebaseReady, state.authUser, setOperationLoading, updateState]); const handleVerifyPasswordResetCode = useCallback(async (oobCode: string): Promise<string> => { if (!firebaseReady) throw new Error("Firebase not ready"); try { return await verifyPasswordResetCode(oobCode); } catch (error) { updateState({ error: { code: "unknown", message: "Password reset verification failed", type: "unknown", timestamp: new Date() } }); throw error; } }, [firebaseReady, updateState]); const handleConfirmPasswordReset = useCallback(async (oobCode: string, newPassword: string): Promise<boolean> => { if (!firebaseReady) return false; try { const result = await confirmPasswordReset(oobCode, newPassword); if (!result.success) { updateState({ error: result.error as AuthError }); } return result.success; } catch (error) { updateState({ error: { code: "unknown", message: "Password reset confirmation failed", type: "unknown", timestamp: new Date() } }); return false; } }, [firebaseReady, updateState]); const handleVerifyEmail = useCallback(async (oobCode: string): Promise<boolean> => { if (!firebaseReady) return false; try { const result = await verifyEmail(oobCode); if (!result.success) { updateState({ error: result.error as AuthError }); } return result.success; } catch (error) { updateState({ error: { code: "unknown", message: "Email verification failed", type: "unknown", timestamp: new Date() } }); return false; } }, [firebaseReady, updateState]); const clearError = useCallback(() => { updateState({ error: null }); }, [updateState]); const refreshProfile = useCallback(() => { if (state.user?.id) { loadUserProfile(state.user.id); } }, [state.user?.id, loadUserProfile]); const isAuthenticated = !!state.user && !!state.authUser; const isLoading = state.loading || Object.values(state.operationLoading).some(loading => loading); const checkIsAdmin = () => { if (state.userProfile) { return isAdmin(state.userProfile); } const email = state.user?.email || state.authUser?.email; return email ? (email.includes('admin') || email === 'test@test.com') : false; }; return { user: state.user, authUser: state.authUser, userProfile: state.userProfile, role: state.role, permissions: state.permissions, session: state.session, loading: isLoading, initializing: state.initializing, isReady: firebaseReady && !state.initializing, hasError: !!state.error, error: state.error, isAuthenticated, isSigningIn: state.operationLoading.signIn, isSigningUp: state.operationLoading.signUp, isSigningOut: state.operationLoading.signOut, isResettingPassword: state.operationLoading.resetPassword, isUpdatingProfile: state.operationLoading.updateProfile, isUpdatingPassword: state.operationLoading.updatePassword, signUp: handleSignUp, signIn: handleSignIn, signInWithGoogle: handleGoogleSignIn, signOut: handleSignOut, resetPassword: handleResetPassword, updateProfile: handleUpdateProfile, updatePassword: handleUpdatePassword, verifyPasswordResetCode: handleVerifyPasswordResetCode, confirmPasswordReset: handleConfirmPasswordReset, verifyEmail: handleVerifyEmail, clearError, validateEmail, validatePassword, refreshProfile, isAdmin: checkIsAdmin(), isUser: isUser(state.userProfile) || !!state.user, canPerformAdminOps: canPerformAdminOperation(state.userProfile) || checkIsAdmin(), getSessionInfo: () => null, lastOperation: undefined, }; }; export const useUserRole = () => { const { userProfile, role, permissions, isAdmin, isUser, canPerformAdminOps, } = useAuth(); return { userProfile, role, permissions, isAdmin, isUser, canPerformAdminOps, }; };

================================================================================

NOME FILE: integration\useExport.ts

import { useState, useCallback, useRef } from 'react'; import type { Word } from '../../types/entities/Word.types'; type ExportFormat = 'json' | 'csv' | 'txt' | 'pdf' | 'excel'; interface ExportOptions { format: ExportFormat; filename?: string; includeMetadata?: boolean; includeStats?: boolean; filterByGroup?: string; filterByLearned?: boolean; filterByDifficult?: boolean; dateRange?: { start: Date; end: Date; }; } interface ExportResult { success: boolean; filename?: string; error?: string; exportedCount?: number; duration?: number; } interface ExportHookState { isExporting: boolean; progress: number; error: string | null; lastExport: ExportResult | null; supportedFormats: ExportFormat[]; } interface ExportHookReturn { isExporting: boolean; progress: number; error: string | null; lastExport: ExportResult | null; supportedFormats: ExportFormat[]; exportWords: (words: Word[], options: ExportOptions) => Promise<ExportResult>; exportToJSON: (words: Word[], filename?: string) => Promise<ExportResult>; exportToCSV: (words: Word[], filename?: string) => Promise<ExportResult>; exportToTXT: (words: Word[], filename?: string) => Promise<ExportResult>; clearError: () => void; clearResult: () => void; } const SUPPORTED_FORMATS: ExportFormat[] = ['json', 'csv', 'txt', 'pdf', 'excel']; export const useExport = (): ExportHookReturn => { const [state, setState] = useState<ExportHookState>({ isExporting: false, progress: 0, error: null, lastExport: null, supportedFormats: SUPPORTED_FORMATS, }); const abortControllerRef = useRef<AbortController | null>(null); const setExporting = useCallback((exporting: boolean) => { setState(prev => ({ ...prev, isExporting: exporting })); }, []); const setProgress = useCallback((progress: number) => { setState(prev => ({ ...prev, progress: Math.min(100, Math.max(0, progress)) })); }, []); const setError = useCallback((error: string | null) => { setState(prev => ({ ...prev, error })); }, []); const setResult = useCallback((result: ExportResult) => { setState(prev => ({ ...prev, lastExport: result })); }, []); const clearError = useCallback(() => { setError(null); }, [setError]); const clearResult = useCallback(() => { setResult({ success: false }); }, [setResult]); const downloadFile = useCallback((content: string, filename: string, mimeType: string) => { const blob = new Blob([content], { type: mimeType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }, []); const filterWords = useCallback((words: Word[], options: ExportOptions): Word[] => { let filtered = [...words]; if (options.filterByGroup) { filtered = filtered.filter(word => word.group === options.filterByGroup); } if (options.filterByLearned !== undefined) { filtered = filtered.filter(word => word.learned === options.filterByLearned); } if (options.filterByDifficult !== undefined) { filtered = filtered.filter(word => word.difficult === options.filterByDifficult); } if (options.dateRange) { filtered = filtered.filter(word => { const createdAt = new Date(word.createdAt); return createdAt >= options.dateRange!.start && createdAt <= options.dateRange!.end; }); } return filtered; }, []); const exportToJSON = useCallback(async ( words: Word[], filename?: string ): Promise<ExportResult> => { const options: ExportOptions = { format: 'json', filename: filename || `vocabulary-${new Date().toISOString().split('T')[0]}.json`, includeMetadata: true, }; return exportWords(words, options); }, []); const exportToCSV = useCallback(async ( words: Word[], filename?: string ): Promise<ExportResult> => { const options: ExportOptions = { format: 'csv', filename: filename || `vocabulary-${new Date().toISOString().split('T')[0]}.csv`, }; return exportWords(words, options); }, []); const exportToTXT = useCallback(async ( words: Word[], filename?: string ): Promise<ExportResult> => { const options: ExportOptions = { format: 'txt', filename: filename || `vocabulary-${new Date().toISOString().split('T')[0]}.txt`, }; return exportWords(words, options); }, []); const generateJSONContent = useCallback((words: Word[], options: ExportOptions): string => { const exportData = { metadata: options.includeMetadata ? { exportedAt: new Date().toISOString(), totalWords: words.length, format: 'json', version: '1.0', } : undefined, words: words.map(word => ({ id: word.id, english: word.english, italian: word.italian, group: word.group, sentence: word.sentences?.[0] || '', notes: word.notes, chapter: word.chapter, learned: word.learned, difficult: word.difficult, createdAt: word.createdAt, updatedAt: word.updatedAt, })), }; return JSON.stringify(exportData, null, 2); }, []); const generateCSVContent = useCallback((words: Word[]): string => { const headers = ['English', 'Italian', 'Group', 'Sentence', 'Notes', 'Chapter', 'Learned', 'Difficult', 'Created At']; const csvContent = [ headers.join(','), ...words.map(word => [ `"${word.english || ''}"`, `"${word.italian || ''}"`, `"${word.group || ''}"`, `"${word.sentences?.[0] || ''}"`, `"${word.notes || ''}"`, `"${word.chapter || ''}"`, word.learned ? 'Yes' : 'No', word.difficult ? 'Yes' : 'No', word.createdAt ? new Date(word.createdAt).toLocaleString() : '', ].join(',')) ].join('\n'); return csvContent; }, []); const generateTXTContent = useCallback((words: Word[]): string => { const txtContent = words.map(word => { const parts = [ `English: ${word.english || 'N/A'}`, `Italian: ${word.italian || 'N/A'}`, word.group && `Group: ${word.group}`, word.sentences?.[0] && `Sentence: ${word.sentences[0]}`, word.notes && `Notes: ${word.notes}`, word.chapter && `Chapter: ${word.chapter}`, `Learned: ${word.learned ? 'Yes' : 'No'}`, `Difficult: ${word.difficult ? 'Yes' : 'No'}`, word.createdAt && `Created: ${new Date(word.createdAt).toLocaleString()}`, ].filter(Boolean); return parts.join('\n'); }).join('\n\n---\n\n'); return txtContent; }, []); const exportWords = useCallback(async ( words: Word[], options: ExportOptions ): Promise<ExportResult> => { if (!words || words.length === 0) { const result: ExportResult = { success: false, error: 'No words to export', }; setResult(result); return result; } if (abortControllerRef.current) { abortControllerRef.current.abort(); } abortControllerRef.current = new AbortController(); setExporting(true); setError(null); setProgress(0); const startTime = Date.now(); try { setProgress(10); const filteredWords = filterWords(words, options); if (filteredWords.length === 0) { const result: ExportResult = { success: false, error: 'No words match the specified filters', }; setResult(result); return result; } setProgress(30); let content: string; let mimeType: string; switch (options.format) { case 'json': content = generateJSONContent(filteredWords, options); mimeType = 'application/json'; break; case 'csv': content = generateCSVContent(filteredWords); mimeType = 'text/csv'; break; case 'txt': content = generateTXTContent(filteredWords); mimeType = 'text/plain'; break; case 'pdf': throw new Error('PDF export not yet implemented'); case 'excel': throw new Error('Excel export not yet implemented'); default: throw new Error(`Unsupported format: ${options.format}`); } setProgress(70); const filename = options.filename || `vocabulary-${new Date().toISOString().split('T')[0]}.${options.format}`; await new Promise(resolve => setTimeout(resolve, 500)); setProgress(90); downloadFile(content, filename, mimeType); setProgress(100); const duration = Date.now() - startTime; const result: ExportResult = { success: true, filename, exportedCount: filteredWords.length, duration, }; setResult(result); return result; } catch (error: any) { const duration = Date.now() - startTime; if (error.name === 'AbortError') { const result: ExportResult = { success: false, error: 'Export cancelled', duration, }; setResult(result); return result; } const errorMessage = error.message || 'Failed to export words'; setError(errorMessage); const result: ExportResult = { success: false, error: errorMessage, duration, }; setResult(result); return result; } finally { setExporting(false); setProgress(0); abortControllerRef.current = null; } }, [setExporting, setError, setProgress, setResult, filterWords, generateJSONContent, generateCSVContent, generateTXTContent, downloadFile]); return { isExporting: state.isExporting, progress: state.progress, error: state.error, lastExport: state.lastExport, supportedFormats: state.supportedFormats, exportWords, exportToJSON, exportToCSV, exportToTXT, clearError, clearResult, }; }; export default useExport;

================================================================================

NOME FILE: integration\useFileOperations.ts

import { useState, useCallback, useRef } from 'react'; import type { Word } from '../../types/entities/Word.types'; type FileType = 'json' | 'csv' | 'txt' | 'xml' | 'yaml'; interface FileInfo { name: string; size: number; type: string; lastModified: number; } interface FileReadResult { success: boolean; content?: string; fileInfo?: FileInfo; error?: string; } interface FileParseResult<T = any> { success: boolean; data?: T; fileInfo?: FileInfo; error?: string; parsedCount?: number; } interface FileOperationProgress { loaded: number; total: number; percentage: number; stage: 'reading' | 'parsing' | 'validating' | 'complete'; } interface FileHookState { isProcessing: boolean; progress: FileOperationProgress | null; error: string | null; lastOperation: string | null; supportedTypes: FileType[]; } interface FileHookReturn { isProcessing: boolean; progress: FileOperationProgress | null; error: string | null; lastOperation: string | null; supportedTypes: FileType[]; readFile: (file: File) => Promise<FileReadResult>; parseFile: <T = any>(file: File, expectedType?: FileType) => Promise<FileParseResult<T>>; readTextFile: (file: File) => Promise<FileReadResult>; readJSONFile: (file: File) => Promise<FileParseResult>; readCSVFile: (file: File) => Promise<FileParseResult<Record<string, string>[]>>; parseWordsFile: (file: File) => Promise<FileParseResult<Word[]>>; validateFile: (file: File, expectedType?: FileType) => Promise<{ valid: boolean; errors: string[] }>; clearError: () => void; clearProgress: () => void; } const SUPPORTED_TYPES: FileType[] = ['json', 'csv', 'txt', 'xml', 'yaml']; const MAX_FILE_SIZE = 50 * 1024 * 1024; export const useFileOperations = (): FileHookReturn => { const [state, setState] = useState<FileHookState>({ isProcessing: false, progress: null, error: null, lastOperation: null, supportedTypes: SUPPORTED_TYPES, }); const abortControllerRef = useRef<AbortController | null>(null); const setProcessing = useCallback((processing: boolean) => { setState(prev => ({ ...prev, isProcessing: processing })); }, []); const setProgress = useCallback((progress: FileOperationProgress | null) => { setState(prev => ({ ...prev, progress })); }, []); const setError = useCallback((error: string | null) => { setState(prev => ({ ...prev, error })); }, []); const setLastOperation = useCallback((operation: string | null) => { setState(prev => ({ ...prev, lastOperation: operation })); }, []); const clearError = useCallback(() => { setError(null); }, [setError]); const clearProgress = useCallback(() => { setProgress(null); }, [setProgress]); const getFileInfo = useCallback((file: File): FileInfo => { return { name: file.name, size: file.size, type: file.type, lastModified: file.lastModified, }; }, []); const validateFile = useCallback(async ( file: File, expectedType?: FileType ): Promise<{ valid: boolean; errors: string[] }> => { const errors: string[] = []; if (!file) { errors.push('No file provided'); return { valid: false, errors }; } if (file.size === 0) { errors.push('File is empty'); } if (file.size > MAX_FILE_SIZE) { errors.push(`File size exceeds maximum limit of ${MAX_FILE_SIZE / (1024 * 1024)}MB`); } if (expectedType) { const extension = file.name.split('.').pop()?.toLowerCase(); if (extension !== expectedType) { errors.push(`Expected ${expectedType} file, but got ${extension || 'unknown'}`); } } return { valid: errors.length === 0, errors }; }, []); const readFile = useCallback(async (file: File): Promise<FileReadResult> => { if (!file) { return { success: false, error: 'No file provided', }; } if (abortControllerRef.current) { abortControllerRef.current.abort(); } abortControllerRef.current = new AbortController(); setProcessing(true); setError(null); setLastOperation('read'); try { const validation = await validateFile(file); if (!validation.valid) { return { success: false, error: validation.errors.join('; '), }; } const fileInfo = getFileInfo(file); setProgress({ loaded: 0, total: file.size, percentage: 0, stage: 'reading', }); return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onloadstart = () => { setProgress({ loaded: 0, total: file.size, percentage: 0, stage: 'reading', }); }; reader.onprogress = (event) => { if (event.lengthComputable) { const percentage = Math.round((event.loaded / event.total) * 100); setProgress({ loaded: event.loaded, total: event.total, percentage, stage: 'reading', }); } }; reader.onload = () => { const content = reader.result as string; setProgress({ loaded: file.size, total: file.size, percentage: 100, stage: 'complete', }); resolve({ success: true, content, fileInfo, }); }; reader.onerror = () => { const error = reader.error?.message || 'Failed to read file'; setError(error); reject({ success: false, error, }); }; reader.onabort = () => { reject({ success: false, error: 'File reading cancelled', }); }; reader.readAsText(file); }); } catch (error: any) { const errorMessage = error.message || 'Failed to read file'; setError(errorMessage); return { success: false, error: errorMessage, }; } finally { setProcessing(false); abortControllerRef.current = null; } }, [setProcessing, setError, setLastOperation, setProgress, validateFile, getFileInfo]); const parseFile = useCallback(async <T = any>( file: File, expectedType?: FileType ): Promise<FileParseResult<T>> => { setLastOperation('parse'); const readResult = await readFile(file); if (!readResult.success) { return { success: false, error: readResult.error, }; } setProgress({ loaded: 0, total: 100, percentage: 0, stage: 'parsing', }); try { const extension = file.name.split('.').pop()?.toLowerCase() as FileType; const fileType = expectedType || extension; let data: T; switch (fileType) { case 'json': data = JSON.parse(readResult.content!); break; case 'csv': data = parseCSV(readResult.content!) as T; break; case 'txt': data = readResult.content as T; break; default: throw new Error(`Unsupported file type: ${fileType}`); } setProgress({ loaded: 100, total: 100, percentage: 100, stage: 'complete', }); return { success: true, data, fileInfo: readResult.fileInfo, }; } catch (error: any) { const errorMessage = error.message || 'Failed to parse file'; setError(errorMessage); return { success: false, error: errorMessage, fileInfo: readResult.fileInfo, }; } }, [readFile, setLastOperation, setProgress, setError]); const readTextFile = useCallback(async (file: File): Promise<FileReadResult> => { return readFile(file); }, [readFile]); const readJSONFile = useCallback(async (file: File): Promise<FileParseResult> => { return parseFile(file, 'json'); }, [parseFile]); const readCSVFile = useCallback(async (file: File): Promise<FileParseResult<Record<string, string>[]>> => { return parseFile(file, 'csv'); }, [parseFile]); const parseWordsFile = useCallback(async (file: File): Promise<FileParseResult<Word[]>> => { const parseResult = await parseFile(file); if (!parseResult.success) { return parseResult as FileParseResult<Word[]>; } try { let words: Word[]; const extension = file.name.split('.').pop()?.toLowerCase(); switch (extension) { case 'json': if (Array.isArray(parseResult.data)) { words = parseResult.data; } else if (parseResult.data && typeof parseResult.data === 'object' && 'words' in parseResult.data) { words = (parseResult.data as any).words || []; } else { throw new Error('Invalid JSON structure for words file'); } break; case 'csv': if (Array.isArray(parseResult.data)) { words = (parseResult.data as any[]).map((row: any, index: number) => ({ id: `imported-${index}`, english: row.English || row.english || '', italian: row.Italian || row.italian || '', group: row.Group || row.group || '', sentences: row.Sentence ? [row.Sentence] : (row.sentence ? [row.sentence] : []), notes: row.Notes || row.notes || '', chapter: row.Chapter || row.chapter || '', learned: row.Learned === 'Yes' || row.learned === 'true', difficult: row.Difficult === 'Yes' || row.difficult === 'true', createdAt: new Date(), updatedAt: new Date(), })); } else { throw new Error('Invalid CSV structure for words file'); } break; default: throw new Error(`Unsupported file type for words: ${extension}`); } const validWords = words.filter(word => word.english && word.italian); const invalidCount = words.length - validWords.length; if (validWords.length === 0) { throw new Error('No valid words found in file'); } return { success: true, data: validWords, fileInfo: parseResult.fileInfo, parsedCount: validWords.length, error: invalidCount > 0 ? `${invalidCount} invalid words were skipped` : undefined, }; } catch (error: any) { return { success: false, error: error.message || 'Failed to parse words file', fileInfo: parseResult.fileInfo, }; } }, [parseFile]); return { isProcessing: state.isProcessing, progress: state.progress, error: state.error, lastOperation: state.lastOperation, supportedTypes: state.supportedTypes, readFile, parseFile, readTextFile, readJSONFile, readCSVFile, parseWordsFile, validateFile, clearError, clearProgress, }; }; const parseCSV = (csvContent: string): Record<string, string>[] => { const lines = csvContent.split('\n').filter(line => line.trim()); if (lines.length === 0) return []; const headers = lines[0].split(',').map(header => header.trim().replace(/"/g, '')); const data: Record<string, string>[] = []; for (let i = 1; i < lines.length; i++) { const values = lines[i].split(',').map(value => value.trim().replace(/"/g, '')); const row: Record<string, string> = {}; headers.forEach((header, index) => { row[header] = values[index] || ''; }); data.push(row); } return data; }; export default useFileOperations;

================================================================================

NOME FILE: integration\useJSON.ts

import { useState, useCallback, useRef } from 'react'; import type { Word } from '../../types/entities/Word.types'; interface JSONValidationResult { valid: boolean; errors: string[]; warnings: string[]; } interface JSONParseResult<T = any> { success: boolean; data?: T; error?: string; validationResult?: JSONValidationResult; } interface JSONStringifyResult { success: boolean; json?: string; error?: string; size?: number; } interface JSONProcessingOptions { validate?: boolean; prettyPrint?: boolean; maxSize?: number; replacer?: (key: string, value: any) => any; reviver?: (key: string, value: any) => any; } interface JSONHookState { isProcessing: boolean; error: string | null; lastOperation: string | null; validationResult: JSONValidationResult | null; } interface JSONHookReturn { isProcessing: boolean; error: string | null; lastOperation: string | null; validationResult: JSONValidationResult | null; parseJSON: <T = any>(jsonString: string, options?: JSONProcessingOptions) => Promise<JSONParseResult<T>>; stringifyJSON: (data: any, options?: JSONProcessingOptions) => Promise<JSONStringifyResult>; validateJSON: (jsonString: string) => JSONValidationResult; parseWordsJSON: (jsonString: string) => Promise<JSONParseResult<Word[]>>; stringifyWords: (words: Word[], options?: JSONProcessingOptions) => Promise<JSONStringifyResult>; formatJSON: (jsonString: string, indent?: number) => JSONStringifyResult; minifyJSON: (jsonString: string) => JSONStringifyResult; clearError: () => void; } const MAX_JSON_SIZE = 10 * 1024 * 1024; export const useJSON = (): JSONHookReturn => { const [state, setState] = useState<JSONHookState>({ isProcessing: false, error: null, lastOperation: null, validationResult: null, }); const abortControllerRef = useRef<AbortController | null>(null); const setProcessing = useCallback((processing: boolean) => { setState(prev => ({ ...prev, isProcessing: processing })); }, []); const setError = useCallback((error: string | null) => { setState(prev => ({ ...prev, error })); }, []); const setLastOperation = useCallback((operation: string | null) => { setState(prev => ({ ...prev, lastOperation: operation })); }, []); const setValidationResult = useCallback((result: JSONValidationResult | null) => { setState(prev => ({ ...prev, validationResult: result })); }, []); const clearError = useCallback(() => { setError(null); }, [setError]); const validateJSON = useCallback((jsonString: string): JSONValidationResult => { const result: JSONValidationResult = { valid: true, errors: [], warnings: [], }; if (!jsonString || typeof jsonString !== 'string') { result.valid = false; result.errors.push('JSON string is required'); return result; } if (jsonString.length > MAX_JSON_SIZE) { result.valid = false; result.errors.push(`JSON string exceeds maximum size of ${MAX_JSON_SIZE} bytes`); return result; } try { JSON.parse(jsonString); } catch (error: any) { result.valid = false; result.errors.push(`Invalid JSON: ${error.message}`); return result; } if (jsonString.length > 1024 * 1024) { result.warnings.push('Large JSON file detected (>1MB)'); } if (jsonString.includes('undefined')) { result.warnings.push('JSON contains undefined values which may cause issues'); } return result; }, []); const parseJSON = useCallback(async <T = any>( jsonString: string, options: JSONProcessingOptions = {} ): Promise<JSONParseResult<T>> => { setProcessing(true); setError(null); setLastOperation('parse'); try { let validationResult: JSONValidationResult | undefined; if (options.validate !== false) { validationResult = validateJSON(jsonString); setValidationResult(validationResult); if (!validationResult.valid) { return { success: false, error: validationResult.errors.join('; '), validationResult, }; } } const maxSize = options.maxSize || MAX_JSON_SIZE; if (jsonString.length > maxSize) { return { success: false, error: `JSON string exceeds maximum size of ${maxSize} bytes`, }; } const data = JSON.parse(jsonString, options.reviver) as T; return { success: true, data, validationResult, }; } catch (error: any) { const errorMessage = error.message || 'Failed to parse JSON'; setError(errorMessage); return { success: false, error: errorMessage, }; } finally { setProcessing(false); } }, [setProcessing, setError, setLastOperation, validateJSON, setValidationResult]); const stringifyJSON = useCallback(async ( data: any, options: JSONProcessingOptions = {} ): Promise<JSONStringifyResult> => { setProcessing(true); setError(null); setLastOperation('stringify'); try { const space = options.prettyPrint ? 2 : undefined; const json = JSON.stringify(data, options.replacer, space); if (!json) { return { success: false, error: 'Failed to stringify data', }; } const size = new Blob([json]).size; const maxSize = options.maxSize || MAX_JSON_SIZE; if (size > maxSize) { return { success: false, error: `Resulting JSON exceeds maximum size of ${maxSize} bytes`, }; } return { success: true, json, size, }; } catch (error: any) { const errorMessage = error.message || 'Failed to stringify JSON'; setError(errorMessage); return { success: false, error: errorMessage, }; } finally { setProcessing(false); } }, [setProcessing, setError, setLastOperation]); const parseWordsJSON = useCallback(async ( jsonString: string ): Promise<JSONParseResult<Word[]>> => { const result = await parseJSON<{ words?: Word[] } | Word[]>(jsonString, { validate: true }); if (!result.success) { return result as JSONParseResult<Word[]>; } try { let words: Word[]; if (Array.isArray(result.data)) { words = result.data; } else if (result.data && typeof result.data === 'object' && 'words' in result.data) { words = result.data.words || []; } else { return { success: false, error: 'Invalid words JSON structure. Expected array or object with "words" property', }; } const invalidWords = words.filter((word, index) => { if (!word || typeof word !== 'object') { return true; } if (!word.english || !word.italian) { return true; } return false; }); if (invalidWords.length > 0) { return { success: false, error: `Invalid word objects found. Each word must have 'english' and 'italian' properties`, }; } return { success: true, data: words, validationResult: result.validationResult, }; } catch (error: any) { return { success: false, error: error.message || 'Failed to parse words JSON', }; } }, [parseJSON]); const stringifyWords = useCallback(async ( words: Word[], options: JSONProcessingOptions = {} ): Promise<JSONStringifyResult> => { if (!Array.isArray(words)) { return { success: false, error: 'Words must be an array', }; } const wordsData = { metadata: { exportedAt: new Date().toISOString(), totalWords: words.length, version: '1.0', }, words, }; return stringifyJSON(wordsData, { ...options, prettyPrint: options.prettyPrint !== false, }); }, [stringifyJSON]); const formatJSON = useCallback((jsonString: string, indent = 2): JSONStringifyResult => { try { const data = JSON.parse(jsonString); const formatted = JSON.stringify(data, null, indent); return { success: true, json: formatted, size: new Blob([formatted]).size, }; } catch (error: any) { return { success: false, error: error.message || 'Failed to format JSON', }; } }, []); const minifyJSON = useCallback((jsonString: string): JSONStringifyResult => { try { const data = JSON.parse(jsonString); const minified = JSON.stringify(data); return { success: true, json: minified, size: new Blob([minified]).size, }; } catch (error: any) { return { success: false, error: error.message || 'Failed to minify JSON', }; } }, []); return { isProcessing: state.isProcessing, error: state.error, lastOperation: state.lastOperation, validationResult: state.validationResult, parseJSON, stringifyJSON, validateJSON, parseWordsJSON, stringifyWords, formatJSON, minifyJSON, clearError, }; }; export default useJSON;

================================================================================

NOME FILE: ui\useFilters.ts

import { useState, useCallback, useMemo } from 'react'; import type { Word } from '../../types/entities/Word.types'; type FilterOperator = 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'regex' | 'gt' | 'lt' | 'gte' | 'lte' | 'in' | 'notIn'; interface FilterCondition<T = any> { field: string; operator: FilterOperator; value: T; caseSensitive?: boolean; } interface FilterGroup { conditions: FilterCondition[]; operator: 'and' | 'or'; } interface SortConfig { field: string; direction: 'asc' | 'desc'; } interface FilterOptions { search?: string; searchFields?: string[]; caseSensitive?: boolean; filters?: FilterGroup[]; sort?: SortConfig[]; pagination?: { page: number; limit: number; }; } interface FilterResult<T> { items: T[]; total: number; filtered: number; page?: number; totalPages?: number; hasMore?: boolean; } interface FilterStats { total: number; filtered: number; groups: Record<string, number>; learned: number; difficult: number; } interface FilterHookState { searchQuery: string; activeFilters: FilterGroup[]; sortConfig: SortConfig[]; currentPage: number; itemsPerPage: number; isFiltering: boolean; } interface FilterHookReturn<T = any> { searchQuery: string; activeFilters: FilterGroup[]; sortConfig: SortConfig[]; currentPage: number; itemsPerPage: number; isFiltering: boolean; filteredItems: T[]; totalItems: number; filteredCount: number; totalPages: number; hasMore: boolean; stats: FilterStats | null; setSearchQuery: (query: string) => void; addFilter: (condition: FilterCondition) => void; removeFilter: (index: number) => void; clearFilters: () => void; addFilterGroup: (group: FilterGroup) => void; removeFilterGroup: (index: number) => void; setSort: (field: string, direction: 'asc' | 'desc') => void; addSort: (field: string, direction: 'asc' | 'desc') => void; removeSort: (field: string) => void; clearSort: () => void; setPage: (page: number) => void; setItemsPerPage: (limit: number) => void; nextPage: () => void; prevPage: () => void; goToFirstPage: () => void; goToLastPage: () => void; applyFilters: (items: T[], options?: FilterOptions) => FilterResult<T>; resetFilters: () => void; getFilterStats: (items: T[]) => FilterStats; } export const useFilters = <T extends Record<string, any> = Word>( initialItems: T[] = [] ): FilterHookReturn<T> => { const [state, setState] = useState<FilterHookState>({ searchQuery: '', activeFilters: [], sortConfig: [], currentPage: 1, itemsPerPage: 20, isFiltering: false, }); const [items, setItems] = useState<T[]>(initialItems); const setSearchQuery = useCallback((query: string) => { setState(prev => ({ ...prev, searchQuery: query, currentPage: 1, })); }, []); const addFilter = useCallback((condition: FilterCondition) => { setState(prev => ({ ...prev, activeFilters: [ ...prev.activeFilters, { conditions: [condition], operator: 'and' as const, }, ], currentPage: 1, })); }, []); const removeFilter = useCallback((index: number) => { setState(prev => ({ ...prev, activeFilters: prev.activeFilters.filter((_, i) => i !== index), currentPage: 1, })); }, []); const clearFilters = useCallback(() => { setState(prev => ({ ...prev, activeFilters: [], currentPage: 1, })); }, []); const addFilterGroup = useCallback((group: FilterGroup) => { setState(prev => ({ ...prev, activeFilters: [...prev.activeFilters, group], currentPage: 1, })); }, []); const removeFilterGroup = useCallback((index: number) => { setState(prev => ({ ...prev, activeFilters: prev.activeFilters.filter((_, i) => i !== index), currentPage: 1, })); }, []); const setSort = useCallback((field: string, direction: 'asc' | 'desc') => { setState(prev => ({ ...prev, sortConfig: [{ field, direction }], currentPage: 1, })); }, []); const addSort = useCallback((field: string, direction: 'asc' | 'desc') => { setState(prev => ({ ...prev, sortConfig: [ ...prev.sortConfig.filter(sort => sort.field !== field), { field, direction }, ], currentPage: 1, })); }, []); const removeSort = useCallback((field: string) => { setState(prev => ({ ...prev, sortConfig: prev.sortConfig.filter(sort => sort.field !== field), currentPage: 1, })); }, []); const clearSort = useCallback(() => { setState(prev => ({ ...prev, sortConfig: [], currentPage: 1, })); }, []); const setPage = useCallback((page: number) => { setState(prev => ({ ...prev, currentPage: Math.max(1, page), })); }, []); const setItemsPerPage = useCallback((limit: number) => { setState(prev => ({ ...prev, itemsPerPage: Math.max(1, limit), currentPage: 1, })); }, []); const nextPage = useCallback(() => { setState(prev => ({ ...prev, currentPage: prev.currentPage + 1, })); }, []); const prevPage = useCallback(() => { setState(prev => ({ ...prev, currentPage: Math.max(1, prev.currentPage - 1), })); }, []); const goToFirstPage = useCallback(() => { setState(prev => ({ ...prev, currentPage: 1, })); }, []); const goToLastPage = useCallback(() => { setState(prev => { const totalPages = Math.ceil(items.length / prev.itemsPerPage); return { ...prev, currentPage: totalPages, }; }); }, [items.length]); const resetFilters = useCallback(() => { setState(prev => ({ ...prev, searchQuery: '', activeFilters: [], sortConfig: [], currentPage: 1, })); }, []); const evaluateCondition = useCallback((item: T, condition: FilterCondition): boolean => { const fieldValue = item[condition.field]; const { value, operator, caseSensitive = false } = condition; if (fieldValue === undefined || fieldValue === null) { return false; } const itemValue = caseSensitive ? fieldValue : String(fieldValue).toLowerCase(); const filterValue = caseSensitive ? value : String(value).toLowerCase(); switch (operator) { case 'equals': return itemValue === filterValue; case 'contains': return String(itemValue).includes(String(filterValue)); case 'startsWith': return String(itemValue).startsWith(String(filterValue)); case 'endsWith': return String(itemValue).endsWith(String(filterValue)); case 'regex': try { const regex = new RegExp(String(filterValue), caseSensitive ? 'g' : 'gi'); return regex.test(String(itemValue)); } catch { return false; } case 'gt': return Number(itemValue) > Number(filterValue); case 'lt': return Number(itemValue) < Number(filterValue); case 'gte': return Number(itemValue) >= Number(filterValue); case 'lte': return Number(itemValue) <= Number(filterValue); case 'in': return Array.isArray(filterValue) && filterValue.includes(itemValue); case 'notIn': return Array.isArray(filterValue) && !filterValue.includes(itemValue); default: return false; } }, []); const evaluateFilterGroup = useCallback((item: T, group: FilterGroup): boolean => { const { conditions, operator } = group; if (conditions.length === 0) return true; const results = conditions.map(condition => evaluateCondition(item, condition)); return operator === 'and' ? results.every(Boolean) : results.some(Boolean); }, [evaluateCondition]); const performSearch = useCallback((item: T, searchQuery: string, searchFields: string[] = []): boolean => { if (!searchQuery.trim()) return true; const query = searchQuery.toLowerCase(); const fieldsToSearch = searchFields.length > 0 ? searchFields : Object.keys(item); return fieldsToSearch.some(field => { const fieldValue = item[field]; if (fieldValue === undefined || fieldValue === null) return false; return String(fieldValue).toLowerCase().includes(query); }); }, []); const sortItems = useCallback((items: T[], sortConfig: SortConfig[]): T[] => { if (sortConfig.length === 0) return items; return [...items].sort((a, b) => { for (const { field, direction } of sortConfig) { const aValue = a[field]; const bValue = b[field]; if (aValue === bValue) continue; let comparison = 0; if (aValue == null) comparison = -1; else if (bValue == null) comparison = 1; else if (typeof aValue === 'string' && typeof bValue === 'string') { comparison = aValue.localeCompare(bValue); } else { comparison = aValue < bValue ? -1 : aValue > bValue ? 1 : 0; } return direction === 'desc' ? -comparison : comparison; } return 0; }); }, []); const applyFilters = useCallback(( targetItems: T[], options: FilterOptions = {} ): FilterResult<T> => { setState(prev => ({ ...prev, isFiltering: true })); try { const { search = state.searchQuery, searchFields = [], caseSensitive = false, filters = state.activeFilters, sort = state.sortConfig, pagination = { page: state.currentPage, limit: state.itemsPerPage, }, } = options; let filtered = targetItems; if (search) { filtered = filtered.filter(item => performSearch(item, search, searchFields)); } if (filters.length > 0) { filtered = filtered.filter(item => { return filters.every(group => evaluateFilterGroup(item, group)); }); } if (sort.length > 0) { filtered = sortItems(filtered, sort); } const total = filtered.length; const totalPages = Math.ceil(total / pagination.limit); const startIndex = (pagination.page - 1) * pagination.limit; const endIndex = startIndex + pagination.limit; const paginatedItems = filtered.slice(startIndex, endIndex); return { items: paginatedItems, total: targetItems.length, filtered: total, page: pagination.page, totalPages, hasMore: endIndex < total, }; } finally { setState(prev => ({ ...prev, isFiltering: false })); } }, [state, performSearch, evaluateFilterGroup, sortItems]); const getFilterStats = useCallback((targetItems: T[]): FilterStats => { const stats: FilterStats = { total: targetItems.length, filtered: 0, groups: {}, learned: 0, difficult: 0, }; const result = applyFilters(targetItems); stats.filtered = result.filtered; result.items.forEach(item => { if ('group' in item && item.group) { stats.groups[item.group] = (stats.groups[item.group] || 0) + 1; } if ('learned' in item && item.learned) { stats.learned++; } if ('difficult' in item && item.difficult) { stats.difficult++; } }); return stats; }, [applyFilters]); const filteredResult = useMemo(() => { return applyFilters(items); }, [items, applyFilters]); const stats = useMemo(() => { return getFilterStats(items); }, [items, getFilterStats]); const totalPages = Math.ceil(filteredResult.filtered / state.itemsPerPage); return { searchQuery: state.searchQuery, activeFilters: state.activeFilters, sortConfig: state.sortConfig, currentPage: state.currentPage, itemsPerPage: state.itemsPerPage, isFiltering: state.isFiltering, filteredItems: filteredResult.items, totalItems: filteredResult.total, filteredCount: filteredResult.filtered, totalPages, hasMore: filteredResult.hasMore || false, stats, setSearchQuery, addFilter, removeFilter, clearFilters, addFilterGroup, removeFilterGroup, setSort, addSort, removeSort, clearSort, setPage, setItemsPerPage, nextPage, prevPage, goToFirstPage, goToLastPage, applyFilters, resetFilters, getFilterStats, }; }; export default useFilters;

================================================================================

NOME FILE: ui\useForm.ts

import { useState, useCallback, useRef, useEffect } from 'react'; type ValidationRule<T = any> = { required?: boolean; minLength?: number; maxLength?: number; pattern?: RegExp; min?: number; max?: number; custom?: (value: T) => string | null; email?: boolean; url?: boolean; }; type ValidationRules<T> = { [K in keyof T]?: ValidationRule<T[K]>; }; type ValidationErrors<T> = { [K in keyof T]?: string; }; type FormField<T> = { value: T; error: string | null; touched: boolean; dirty: boolean; }; type FormState<T> = { [K in keyof T]: FormField<T[K]>; }; interface FormOptions<T> { initialValues: T; validationRules?: ValidationRules<T>; validateOnChange?: boolean; validateOnBlur?: boolean; validateOnSubmit?: boolean; resetOnSubmit?: boolean; onSubmit?: (values: T) => void | Promise<void>; onReset?: () => void; onFieldChange?: (field: keyof T, value: T[keyof T]) => void; } interface FormHookReturn<T> { values: T; errors: ValidationErrors<T>; touched: { [K in keyof T]: boolean }; dirty: { [K in keyof T]: boolean }; isSubmitting: boolean; isValidating: boolean; isValid: boolean; isDirty: boolean; formState: FormState<T>; setValue: <K extends keyof T>(field: K, value: T[K]) => void; setValues: (values: Partial<T>) => void; setError: <K extends keyof T>(field: K, error: string | null) => void; setErrors: (errors: Partial<ValidationErrors<T>>) => void; setTouched: <K extends keyof T>(field: K, touched: boolean) => void; setFieldTouched: (touched: { [K in keyof T]?: boolean }) => void; clearErrors: () => void; clearField: <K extends keyof T>(field: K) => void; resetForm: () => void; validateField: <K extends keyof T>(field: K) => Promise<string | null>; validateForm: () => Promise<ValidationErrors<T>>; handleSubmit: (e?: React.FormEvent) => Promise<void>; handleReset: () => void; handleChange: <K extends keyof T>(field: K) => (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void; handleBlur: <K extends keyof T>(field: K) => (e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void; getFieldProps: <K extends keyof T>(field: K) => { value: T[K]; onChange: (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void; onBlur: (e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void; name: string; id: string; }; } export const useForm = <T extends Record<string, any>>( options: FormOptions<T> ): FormHookReturn<T> => { const { initialValues, validationRules = {}, validateOnChange = true, validateOnBlur = true, validateOnSubmit = true, resetOnSubmit = false, onSubmit, onReset, onFieldChange, } = options; const [formState, setFormState] = useState<FormState<T>>(() => { const state: FormState<T> = {} as FormState<T>; for (const key in initialValues) { state[key] = { value: initialValues[key], error: null, touched: false, dirty: false, }; } return state; }); const [isSubmitting, setIsSubmitting] = useState(false); const [isValidating, setIsValidating] = useState(false); const initialValuesRef = useRef(initialValues); const validationRulesRef = useRef<Record<string, ValidationRule>>(validationRules as any); useEffect(() => { initialValuesRef.current = initialValues; validationRulesRef.current = validationRules; }, [initialValues, validationRules]); const validateSingleField = useCallback(<K extends keyof T>( field: K, value: T[K] ): string | null => { const rules = validationRulesRef.current[field as string]; if (!rules) return null; if (rules.required && (value === null || value === undefined || value === '')) { return 'This field is required'; } if (!rules.required && (value === null || value === undefined || value === '')) { return null; } if (typeof value === 'string') { if (rules.minLength && value.length < rules.minLength) { return `Minimum length is ${rules.minLength} characters`; } if (rules.maxLength && value.length > rules.maxLength) { return `Maximum length is ${rules.maxLength} characters`; } if (rules.pattern && !rules.pattern.test(value)) { return 'Invalid format'; } if (rules.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) { return 'Invalid email format'; } if (rules.url && !/^https?:\/\/[^\s]+$/.test(value)) { return 'Invalid URL format'; } } if (typeof value === 'number') { if (rules.min !== undefined && value < rules.min) { return `Minimum value is ${rules.min}`; } if (rules.max !== undefined && value > rules.max) { return `Maximum value is ${rules.max}`; } } if (rules.custom) { return rules.custom(value); } return null; }, []); const validateField = useCallback(async <K extends keyof T>( field: K ): Promise<string | null> => { const value = formState[field].value; const error = validateSingleField(field, value); setFormState(prev => ({ ...prev, [field]: { ...prev[field], error, }, })); return error; }, [formState, validateSingleField]); const validateForm = useCallback(async (): Promise<ValidationErrors<T>> => { setIsValidating(true); const errors: ValidationErrors<T> = {}; for (const field in formState) { const error = validateSingleField(field, formState[field].value); if (error) { errors[field] = error; } } setFormState(prev => { const newState = { ...prev }; for (const field in newState) { newState[field] = { ...newState[field], error: errors[field] || null, }; } return newState; }); setIsValidating(false); return errors; }, [formState, validateSingleField]); const setValue = useCallback(<K extends keyof T>(field: K, value: T[K]) => { setFormState(prev => ({ ...prev, [field]: { ...prev[field], value, dirty: value !== initialValuesRef.current[field], }, })); if (validateOnChange) { setTimeout(() => validateField(field), 0); } if (onFieldChange) { onFieldChange(field, value); } }, [validateOnChange, validateField, onFieldChange]); const setValues = useCallback((values: Partial<T>) => { setFormState(prev => { const newState = { ...prev }; for (const field in values) { if (newState[field]) { newState[field] = { ...newState[field], value: values[field]!, dirty: values[field] !== initialValuesRef.current[field], }; } } return newState; }); if (validateOnChange) { Object.keys(values).forEach(field => { setTimeout(() => validateField(field as keyof T), 0); }); } }, [validateOnChange, validateField]); const setError = useCallback(<K extends keyof T>(field: K, error: string | null) => { setFormState(prev => ({ ...prev, [field]: { ...prev[field], error, }, })); }, []); const setErrors = useCallback((errors: Partial<ValidationErrors<T>>) => { setFormState(prev => { const newState = { ...prev }; for (const field in errors) { if (newState[field]) { newState[field] = { ...newState[field], error: errors[field] || null, }; } } return newState; }); }, []); const setTouched = useCallback(<K extends keyof T>(field: K, touched: boolean) => { setFormState(prev => ({ ...prev, [field]: { ...prev[field], touched, }, })); }, []); const setFieldTouched = useCallback((touched: { [K in keyof T]?: boolean }) => { setFormState(prev => { const newState = { ...prev }; for (const field in touched) { if (newState[field]) { newState[field] = { ...newState[field], touched: touched[field] || false, }; } } return newState; }); }, []); const clearErrors = useCallback(() => { setFormState(prev => { const newState = { ...prev }; for (const field in newState) { newState[field] = { ...newState[field], error: null, }; } return newState; }); }, []); const clearField = useCallback(<K extends keyof T>(field: K) => { setFormState(prev => ({ ...prev, [field]: { value: initialValuesRef.current[field], error: null, touched: false, dirty: false, }, })); }, []); const resetForm = useCallback(() => { setFormState(() => { const state: FormState<T> = {} as FormState<T>; for (const key in initialValuesRef.current) { state[key] = { value: initialValuesRef.current[key], error: null, touched: false, dirty: false, }; } return state; }); if (onReset) { onReset(); } }, [onReset]); const handleSubmit = useCallback(async (e?: React.FormEvent) => { if (e) { e.preventDefault(); } setIsSubmitting(true); try { if (validateOnSubmit) { const errors = await validateForm(); const hasErrors = Object.values(errors).some(error => error !== null); if (hasErrors) { setIsSubmitting(false); return; } } if (onSubmit) { const values = Object.keys(formState).reduce((acc, key) => { acc[key as keyof T] = formState[key as keyof T].value; return acc; }, {} as T); await onSubmit(values); } if (resetOnSubmit) { resetForm(); } } finally { setIsSubmitting(false); } }, [validateOnSubmit, validateForm, onSubmit, resetOnSubmit, resetForm, formState]); const handleReset = useCallback(() => { resetForm(); }, [resetForm]); const handleChange = useCallback(<K extends keyof T>(field: K) => ( e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement> ) => { const value = e.target.type === 'checkbox' ? (e.target as HTMLInputElement).checked : e.target.value; setValue(field, value as T[K]); }, [setValue]); const handleBlur = useCallback(<K extends keyof T>(field: K) => ( e: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement> ) => { setTouched(field, true); if (validateOnBlur) { validateField(field); } }, [setTouched, validateOnBlur, validateField]); const getFieldProps = useCallback(<K extends keyof T>(field: K) => ({ value: formState[field].value, onChange: handleChange(field), onBlur: handleBlur(field), name: String(field), id: String(field), }), [formState, handleChange, handleBlur]); const values = Object.keys(formState).reduce((acc, key) => { acc[key as keyof T] = formState[key as keyof T].value; return acc; }, {} as T); const errors = Object.keys(formState).reduce((acc, key) => { acc[key as keyof T] = formState[key as keyof T].error || undefined; return acc; }, {} as ValidationErrors<T>); const touched = Object.keys(formState).reduce((acc, key) => { acc[key as keyof T] = formState[key as keyof T].touched; return acc; }, {} as { [K in keyof T]: boolean }); const dirty = Object.keys(formState).reduce((acc, key) => { acc[key as keyof T] = formState[key as keyof T].dirty; return acc; }, {} as { [K in keyof T]: boolean }); const isValid = Object.values(errors).every(error => !error); const isDirty = Object.values(dirty).some(Boolean); return { values, errors, touched, dirty, isSubmitting, isValidating, isValid, isDirty, formState, setValue, setValues, setError, setErrors, setTouched, setFieldTouched, clearErrors, clearField, resetForm, validateField, validateForm, handleSubmit, handleReset, handleChange, handleBlur, getFieldProps, }; }; export default useForm;

================================================================================

NOME FILE: ui\useGameHints.ts

import { useState, useCallback, useMemo } from 'react'; import { Word } from '../../types/entities/Word.types'; interface UseGameHintsConfig { mode: 'disabled' | 'unlimited' | 'limited'; maxPerWord?: number; maxTotal?: number; enableTotalLimit?: boolean; } interface GameHints { synonym?: string[]; antonym?: string[]; context?: string[]; } interface HintUsage { type: 'synonym' | 'antonym' | 'context'; content: string; requestedAt: Date; sequenceOrder: number; } interface UseGameHintsReturn { gameHints: GameHints; totalHintsUsed: number; hintsUsedThisWord: number; hintUsageHistory: HintUsage[]; canRequestHint: (type: 'synonym' | 'antonym' | 'context') => boolean; requestHint: (type: 'synonym' | 'antonym' | 'context', word: Word) => string | null; resetWordHints: () => void; resetAllHints: () => void; } export const useGameHints = (config: UseGameHintsConfig): UseGameHintsReturn => { const { mode, maxPerWord = 2, maxTotal = 5, enableTotalLimit = true } = config; const [gameHints, setGameHints] = useState<GameHints>({}); const [totalHintsUsed, setTotalHintsUsed] = useState(0); const [hintUsageHistory, setHintUsageHistory] = useState<HintUsage[]>([]); const [sequenceCounter, setSequenceCounter] = useState(0); const hintsUsedThisWord = useMemo(() => { return Object.values(gameHints).reduce((total, hints) => total + (hints?.length || 0), 0); }, [gameHints]); const canRequestHint = useCallback((type: 'synonym' | 'antonym' | 'context'): boolean => { if (mode === 'disabled') return false; if (mode === 'unlimited') return true; if (maxPerWord && hintsUsedThisWord >= maxPerWord) return false; if (enableTotalLimit && maxTotal && totalHintsUsed >= maxTotal) return false; return true; }, [mode, maxPerWord, maxTotal, enableTotalLimit, hintsUsedThisWord, totalHintsUsed]); const generateHint = useCallback((type: 'synonym' | 'antonym' | 'context', word: Word): string | null => { const usedHints = gameHints[type] || []; let availableHints: string[] = []; switch (type) { case 'synonym': availableHints = word.synonyms || []; break; case 'antonym': availableHints = word.antonyms || []; break; case 'context': availableHints = word.sentences || []; break; } const remainingHints = availableHints.filter(hint => !usedHints.includes(hint)); if (remainingHints.length === 0) return null; const randomIndex = Math.floor(Math.random() * remainingHints.length); return remainingHints[randomIndex]; }, [gameHints]); const requestHint = useCallback((type: 'synonym' | 'antonym' | 'context', word: Word): string | null => { if (!canRequestHint(type)) return null; const newHint = generateHint(type, word); if (!newHint) return null; setGameHints(prev => ({ ...prev, [type]: [...(prev[type] || []), newHint] })); setTotalHintsUsed(prev => prev + 1); setSequenceCounter(prev => prev + 1); const usage: HintUsage = { type, content: newHint, requestedAt: new Date(), sequenceOrder: sequenceCounter + 1 }; setHintUsageHistory(prev => [...prev, usage]); return newHint; }, [canRequestHint, generateHint, sequenceCounter]); const resetWordHints = useCallback(() => { setGameHints({}); }, []); const resetAllHints = useCallback(() => { setGameHints({}); setTotalHintsUsed(0); setHintUsageHistory([]); setSequenceCounter(0); }, []); return { gameHints, totalHintsUsed, hintsUsedThisWord, hintUsageHistory, canRequestHint, requestHint, resetWordHints, resetAllHints, }; };

================================================================================

NOME FILE: ui\useModal.ts

import { useState, useCallback, useEffect, useRef } from 'react'; interface ModalConfig { id?: string; title?: string; content?: React.ReactNode; size?: 'small' | 'medium' | 'large' | 'fullscreen'; variant?: 'default' | 'confirmation' | 'alert' | 'info' | 'success' | 'warning' | 'error'; closable?: boolean; backdrop?: boolean; keyboard?: boolean; centered?: boolean; fullscreen?: boolean; animation?: boolean; persistent?: boolean; zIndex?: number; className?: string; onOpen?: () => void; onClose?: () => void; onConfirm?: () => void | Promise<void>; onCancel?: () => void; confirmText?: string; cancelText?: string; showConfirm?: boolean; showCancel?: boolean; confirmVariant?: 'primary' | 'secondary' | 'danger' | 'success' | 'warning'; cancelVariant?: 'primary' | 'secondary' | 'danger' | 'success' | 'warning'; loading?: boolean; disabled?: boolean; } interface ModalState { isOpen: boolean; isAnimating: boolean; isLoading: boolean; error: string | null; config: ModalConfig; } interface ModalHookReturn { isOpen: boolean; isAnimating: boolean; isLoading: boolean; error: string | null; config: ModalConfig; open: (config?: ModalConfig) => void; close: (force?: boolean) => void; toggle: () => void; confirm: () => Promise<void>; cancel: () => void; setLoading: (loading: boolean) => void; setError: (error: string | null) => void; updateConfig: (config: Partial<ModalConfig>) => void; clearError: () => void; } const DEFAULT_CONFIG: ModalConfig = { size: 'medium', variant: 'default', closable: true, backdrop: true, keyboard: true, centered: true, fullscreen: false, animation: true, persistent: false, zIndex: 1000, showConfirm: true, showCancel: true, confirmText: 'OK', cancelText: 'Cancel', confirmVariant: 'primary', cancelVariant: 'secondary', loading: false, disabled: false, }; export const useModal = (initialConfig: ModalConfig = {}): ModalHookReturn => { const [state, setState] = useState<ModalState>({ isOpen: false, isAnimating: false, isLoading: false, error: null, config: { ...DEFAULT_CONFIG, ...initialConfig }, }); const timeoutRef = useRef<NodeJS.Timeout | null>(null); const isUnmountedRef = useRef(false); const safeSetState = useCallback((updater: (prev: ModalState) => ModalState) => { if (!isUnmountedRef.current) { setState(updater); } }, []); const setLoading = useCallback((loading: boolean) => { safeSetState(prev => ({ ...prev, isLoading: loading })); }, [safeSetState]); const setError = useCallback((error: string | null) => { safeSetState(prev => ({ ...prev, error })); }, [safeSetState]); const clearError = useCallback(() => { setError(null); }, [setError]); const updateConfig = useCallback((config: Partial<ModalConfig>) => { safeSetState(prev => ({ ...prev, config: { ...prev.config, ...config }, })); }, [safeSetState]); const open = useCallback((config: ModalConfig = {}) => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } const newConfig = { ...state.config, ...config }; safeSetState(prev => ({ ...prev, isOpen: true, isAnimating: true, error: null, config: newConfig, })); if (newConfig.onOpen) { newConfig.onOpen(); } if (newConfig.animation) { timeoutRef.current = setTimeout(() => { safeSetState(prev => ({ ...prev, isAnimating: false })); }, 300); } else { safeSetState(prev => ({ ...prev, isAnimating: false })); } }, [state.config, safeSetState]); const close = useCallback((force = false) => { if (state.config.persistent && !force) { return; } if (timeoutRef.current) { clearTimeout(timeoutRef.current); } if (state.config.onClose) { state.config.onClose(); } if (state.config.animation) { safeSetState(prev => ({ ...prev, isAnimating: true })); timeoutRef.current = setTimeout(() => { safeSetState(prev => ({ ...prev, isOpen: false, isAnimating: false, isLoading: false, error: null, })); }, 300); } else { safeSetState(prev => ({ ...prev, isOpen: false, isAnimating: false, isLoading: false, error: null, })); } }, [state.config, safeSetState]); const toggle = useCallback(() => { if (state.isOpen) { close(); } else { open(); } }, [state.isOpen, close, open]); const confirm = useCallback(async () => { if (state.config.onConfirm) { try { setLoading(true); clearError(); await state.config.onConfirm(); close(); } catch (error: any) { setError(error.message || 'An error occurred'); } finally { setLoading(false); } } else { close(); } }, [state.config, setLoading, clearError, setError, close]); const cancel = useCallback(() => { if (state.config.onCancel) { state.config.onCancel(); } close(); }, [state.config, close]); useEffect(() => { if (!state.isOpen) return; const handleKeyDown = (event: KeyboardEvent) => { if (!state.config.keyboard) return; switch (event.key) { case 'Escape': if (state.config.closable) { close(); } break; case 'Enter': if (state.config.variant === 'confirmation' && state.config.showConfirm) { confirm(); } break; default: break; } }; document.addEventListener('keydown', handleKeyDown); document.body.style.overflow = 'hidden'; return () => { document.removeEventListener('keydown', handleKeyDown); document.body.style.overflow = 'unset'; }; }, [state.isOpen, state.config.keyboard, state.config.closable, state.config.variant, state.config.showConfirm, close, confirm]); const handleBackdropClick = useCallback((event: React.MouseEvent) => { if (state.config.backdrop && state.config.closable && event.target === event.currentTarget) { close(); } }, [state.config.backdrop, state.config.closable, close]); useEffect(() => { return () => { isUnmountedRef.current = true; if (timeoutRef.current) { clearTimeout(timeoutRef.current); } document.body.style.overflow = 'unset'; }; }, []); return { isOpen: state.isOpen, isAnimating: state.isAnimating, isLoading: state.isLoading, error: state.error, config: state.config, open, close, toggle, confirm, cancel, setLoading, setError, updateConfig, clearError, }; }; export const useConfirmationModal = () => { const modal = useModal({ variant: 'confirmation', size: 'small', showConfirm: true, showCancel: true, confirmText: 'Confirm', cancelText: 'Cancel', confirmVariant: 'danger', }); const confirm = useCallback(async ( title: string, message: string, options: Partial<ModalConfig> = {} ): Promise<boolean> => { return new Promise((resolve) => { modal.open({ title, content: message, ...options, onConfirm: () => { resolve(true); }, onCancel: () => { resolve(false); }, }); }); }, [modal]); return { ...modal, confirm, }; }; export const useAlertModal = () => { const modal = useModal({ variant: 'alert', size: 'small', showConfirm: true, showCancel: false, confirmText: 'OK', }); const alert = useCallback(( title: string, message: string, variant: 'info' | 'success' | 'warning' | 'error' = 'info', options: Partial<ModalConfig> = {} ): Promise<void> => { return new Promise((resolve) => { modal.open({ title, content: message, variant, ...options, onConfirm: () => { resolve(); }, }); }); }, [modal]); return { ...modal, alert, }; }; export default useModal;

================================================================================

NOME FILE: ui\useTestTimer.ts

import { useState, useEffect, useRef, useCallback } from 'react'; interface UseTestTimerConfig { enabled: boolean; timePerWord: number; autoAdvance: boolean; onTimeExpired?: () => void; onTick?: (elapsed: number) => void; } interface UseTestTimerReturn { currentTime: number; timeExpired: boolean; isRunning: boolean; timeRemaining: number; progressPercentage: number; startTimer: () => void; stopTimer: () => void; resetTimer: () => void; } export const useTestTimer = (config: UseTestTimerConfig): UseTestTimerReturn => { const { enabled, timePerWord, autoAdvance, onTimeExpired, onTick } = config; const [currentTime, setCurrentTime] = useState(0); const [timeExpired, setTimeExpired] = useState(false); const [isRunning, setIsRunning] = useState(false); const timerRef = useRef<NodeJS.Timeout | null>(null); const startTimeRef = useRef<number | null>(null); const timeExpiredRef = useRef(false); const timeRemaining = Math.max(0, timePerWord - currentTime); const progressPercentage = timePerWord > 0 ? Math.min(100, (currentTime / timePerWord) * 100) : 0; const startTimer = useCallback(() => { if (!enabled || isRunning) return; setIsRunning(true); setTimeExpired(false); timeExpiredRef.current = false; startTimeRef.current = Date.now(); timerRef.current = setInterval(() => { if (!startTimeRef.current) return; const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000); setCurrentTime(elapsed); onTick?.(elapsed); if (elapsed >= timePerWord && !timeExpiredRef.current) { timeExpiredRef.current = true; setTimeExpired(true); setIsRunning(false); if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } if (autoAdvance) { onTimeExpired?.(); } } }, 1000); }, [enabled, isRunning, timePerWord, autoAdvance, onTimeExpired, onTick]); const stopTimer = useCallback(() => { setIsRunning(false); if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } }, []); const resetTimer = useCallback(() => { stopTimer(); setCurrentTime(0); setTimeExpired(false); timeExpiredRef.current = false; startTimeRef.current = null; }, [stopTimer]); useEffect(() => { return () => { if (timerRef.current) { clearInterval(timerRef.current); } }; }, []); useEffect(() => { if (enabled && !isRunning && !timeExpired) { startTimer(); } else if (!enabled && isRunning) { stopTimer(); } }, [enabled, isRunning, timeExpired, startTimer, stopTimer]); return { currentTime, timeExpired, isRunning, timeRemaining, progressPercentage, startTimer, stopTimer, resetTimer, }; };

================================================================================

NOME FILE: ui\useTheme.ts

import { useTheme } from '../../contexts/ThemeContext'; export { useTheme }; export default useTheme;

================================================================================


NOME FILE: useEnhancedStats.js

import { useState, useEffect, useCallback, useMemo } from 'react'; import { STORAGE_CONFIG } from '../constants/appConstants'; const INITIAL_STATS = { totalWords: 0, correctAnswers: 0, incorrectAnswers: 0, hintsUsed: 0, averageScore: 0, testsCompleted: 0, timeSpent: 0, categoriesProgress: {}, dailyProgress: {}, streakDays: 0, lastStudyDate: null, difficultyStats: { easy: { correct: 0, total: 0 }, medium: { correct: 0, total: 0 }, hard: { correct: 0, total: 0 } }, monthlyStats: {}, migrated: false }; const INITIAL_WORD_PERFORMANCE = {}; const EMPTY_ARRAY = []; export const useEnhancedStats = () => { const [stats, setStats] = useState(INITIAL_STATS); const [testHistory, setTestHistory] = useState(EMPTY_ARRAY); const [wordPerformance, setWordPerformance] = useState(INITIAL_WORD_PERFORMANCE); const [isInitialized, setIsInitialized] = useState(false); const [isLoading, setIsLoading] = useState(false); const [lastSync, setLastSync] = useState(null); const [error, setError] = useState(null); const [optimizationState, setOptimizationState] = useState({ isProcessing: false, lastUpdate: Date.now(), forceUpdate: 0 }); const safeGetItem = useCallback((key, defaultValue = null) => { try { const item = localStorage.getItem(key); return item ? JSON.parse(item) : defaultValue; } catch (error) { console.warn(`Error reading ${key}:`, error); return defaultValue; } }, []); const safeSetItem = useCallback((key, value) => { try { localStorage.setItem(key, JSON.stringify(value)); return true; } catch (error) { console.error(`Error saving ${key}:`, error); setError(new Error('Errore nel salvataggio dei dati. Controlla lo spazio disponibile.')); return false; } }, []); const selectors = useMemo(() => { if (!stats) { return { totalTests: 0, totalAnswers: 0, totalHints: 0, accuracyRate: 0, hintsRate: 0, isActiveToday: false, avgTimePerTest: 0 }; } const correctAnswers = stats.correctAnswers || 0; const incorrectAnswers = stats.incorrectAnswers || 0; const hintsUsed = stats.hintsUsed || 0; const testsCompleted = stats.testsCompleted || 0; const timeSpent = stats.timeSpent || 0; const dailyProgress = stats.dailyProgress || {}; return { totalTests: testHistory.length, totalAnswers: correctAnswers + incorrectAnswers, totalHints: hintsUsed, accuracyRate: correctAnswers + incorrectAnswers > 0 ? Math.round((correctAnswers / (correctAnswers + incorrectAnswers)) * 100) : 0, hintsRate: correctAnswers + incorrectAnswers > 0 ? Math.round((hintsUsed / (correctAnswers + incorrectAnswers)) * 100) : 0, isActiveToday: (() => { const today = new Date().toISOString().split('T')[0]; return Boolean(dailyProgress[today]?.tests > 0); })(), avgTimePerTest: testsCompleted > 0 ? Math.round(timeSpent / testsCompleted) : 0 }; }, [ stats, testHistory.length, stats?.correctAnswers, stats?.incorrectAnswers, stats?.hintsUsed, stats?.testsCompleted, stats?.timeSpent, stats?.dailyProgress ]); const weeklyProgress = useMemo(() => { if (!stats || !stats.dailyProgress) { return []; } const last7Days = Array.from({ length: 7 }, (_, i) => { const date = new Date(); date.setDate(date.getDate() - i); return date.toISOString().split('T')[0]; }); return last7Days.map(date => ({ date, tests: stats.dailyProgress[date]?.tests || 0, correct: stats.dailyProgress[date]?.correct || 0, incorrect: stats.dailyProgress[date]?.incorrect || 0, hints: stats.dailyProgress[date]?.hints || 0 })); }, [stats, stats?.dailyProgress]); const calculateStreak = useCallback((dailyProgress) => { const today = new Date(); let streak = 0; for (let i = 0; i < 365; i++) { const date = new Date(today); date.setDate(date.getDate() - i); const dateStr = date.toISOString().split('T')[0]; if (dailyProgress[dateStr]?.tests > 0) { streak++; } else if (i === 0) { continue; } else { break; } if (i > 30 && streak === 0) break; } return streak; }, []); const initializeData = useCallback(async () => { if (isInitialized) return; setIsLoading(true); setError(null); try { const statsData = safeGetItem(STORAGE_CONFIG.keys.stats, INITIAL_STATS); const historyData = safeGetItem(STORAGE_CONFIG.keys.testHistory, EMPTY_ARRAY); const performanceData = safeGetItem(STORAGE_CONFIG.keys.wordPerformance, INITIAL_WORD_PERFORMANCE); setStats(statsData); setTestHistory(historyData); setWordPerformance(performanceData); setIsInitialized(true); setLastSync(Date.now()); } catch (error) { console.error('Failed to initialize stats data:', error); setError(error); setStats(INITIAL_STATS); setTestHistory(EMPTY_ARRAY); setWordPerformance(INITIAL_WORD_PERFORMANCE); setIsInitialized(true); } finally { setIsLoading(false); } }, [isInitialized, safeGetItem]); const performBatchUpdate = useCallback((updates) => { setOptimizationState(prev => ({ ...prev, isProcessing: true })); try { if (updates.stats) { safeSetItem(STORAGE_CONFIG.keys.stats, updates.stats); setStats(updates.stats); } if (updates.testHistory) { safeSetItem(STORAGE_CONFIG.keys.testHistory, updates.testHistory); setTestHistory(updates.testHistory); } if (updates.wordPerformance) { safeSetItem(STORAGE_CONFIG.keys.wordPerformance, updates.wordPerformance); setWordPerformance(updates.wordPerformance); } setOptimizationState(prev => ({ ...prev, lastUpdate: Date.now(), forceUpdate: prev.forceUpdate + 1, isProcessing: false })); setLastSync(Date.now()); } catch (error) { console.error('❌ Batch update error:', error); setError(error); setOptimizationState(prev => ({ ...prev, isProcessing: false })); } }, [safeSetItem]); const getWordAnalysis = useCallback((wordId) => { const allWords = safeGetItem(STORAGE_CONFIG.keys.words, []); const word = allWords.find(w => w.id === wordId); if (!word) { return null; } const wordData = wordPerformance[wordId]; if (!wordData || !wordData.attempts || wordData.attempts.length === 0) { return { id: wordId, english: word.english, italian: word.italian, chapter: word.chapter || '', group: word.group || '', sentence: word.sentence || '', notes: word.notes || '', learned: word.learned || false, difficult: word.difficult || false, totalAttempts: 0, correctAttempts: 0, incorrectAttempts: 0, accuracy: 0, recentAccuracy: 0, avgTime: 0, hintsUsed: 0, hintsPercentage: 0, currentStreak: 0, lastAttempt: null, status: 'new', trend: 'neutral', difficulty: 'unknown', needsWork: true, mastered: false, attempts: [], recommendations: ['Parola mai testata - inizia con un test per vedere le performance'] }; } const attempts = wordData.attempts || []; const totalAttempts = attempts.length; const correctAttempts = attempts.filter(a => a.correct).length; const hintsUsed = attempts.filter(a => a.usedHint).length; const lastAttempt = attempts[attempts.length - 1]; let currentStreak = 0; for (let i = attempts.length - 1; i >= 0; i--) { if (attempts[i].correct) { currentStreak++; } else { break; } } const recentAttempts = attempts.slice(-5); const recentCorrect = recentAttempts.filter(a => a.correct).length; const recentAccuracy = recentAttempts.length > 0 ? (recentCorrect / recentAttempts.length) * 100 : 0; let status = 'new'; if (totalAttempts >= 3) { if (currentStreak >= 3) status = 'consolidated'; else if (correctAttempts / totalAttempts >= 0.7) status = 'improving'; else if (correctAttempts / totalAttempts <= 0.3) status = 'critical'; else status = 'inconsistent'; } else if (totalAttempts > 0) { status = currentStreak > 0 ? 'promising' : 'struggling'; } const accuracy = totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0; const avgTime = attempts.length > 0 ? Math.round(attempts.reduce((sum, a) => sum + (a.timeSpent || 0), 0) / attempts.length / 1000) : 0; return { id: wordId, english: word.english, italian: word.italian, chapter: word.chapter || '', group: word.group || '', sentence: word.sentence || '', notes: word.notes || '', learned: word.learned || false, difficult: word.difficult || false, totalAttempts, correctAttempts, incorrectAttempts: totalAttempts - correctAttempts, accuracy, hintsUsed, hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0, currentStreak, lastAttempt, recentAccuracy: Math.round(recentAccuracy), status, avgTime, attempts: attempts.slice(-10), trend: 'stable', difficulty: accuracy < 50 ? 'hard' : accuracy < 80 ? 'medium' : 'easy', needsWork: accuracy < 70, mastered: accuracy >= 90 && currentStreak >= 3, recommendations: [] }; }, [wordPerformance, safeGetItem]); const getAllWordsPerformance = useCallback(() => { return Object.keys(wordPerformance).map(wordId => { const analysis = getWordAnalysis(wordId); return { wordId, english: wordPerformance[wordId].english, italian: wordPerformance[wordId].italian, chapter: wordPerformance[wordId].chapter, ...analysis }; }).sort((a, b) => { const statusPriority = { critical: 1, inconsistent: 2, struggling: 3, promising: 4, improving: 5, consolidated: 6, new: 7 }; return statusPriority[a.status] - statusPriority[b.status]; }); }, [wordPerformance, getWordAnalysis]); const recordWordPerformance = useCallback((word, isCorrect, usedHint, timeSpent) => { const wordId = word.id; const attempt = { timestamp: new Date().toISOString(), correct: isCorrect, usedHint: usedHint || false, timeSpent: timeSpent || 0 }; const newPerformance = { ...wordPerformance, [wordId]: { english: word.english, italian: word.italian, chapter: word.chapter, attempts: [...(wordPerformance[wordId]?.attempts || []), attempt] } }; setWordPerformance(newPerformance); safeSetItem(STORAGE_CONFIG.keys.wordPerformance, newPerformance); }, [wordPerformance, safeSetItem]); const calculateSmartTestDifficulty = useCallback((testWords, getWordAnalysisFunc) => { const categories = { hard: [], medium: [], easy: [] }; testWords.forEach(word => { const analysis = getWordAnalysisFunc(word.id); const status = analysis ? analysis.status : 'new'; if (['critical', 'inconsistent', 'struggling'].includes(status)) { categories.hard.push({ word, status, analysis }); } else if (['promising', 'new'].includes(status)) { categories.medium.push({ word, status, analysis }); } else if (['improving', 'consolidated'].includes(status)) { categories.easy.push({ word, status, analysis }); } }); const totalWords = testWords.length; const hardCount = categories.hard.length; const mediumCount = categories.medium.length; const easyCount = categories.easy.length; const hardPercentage = (hardCount / totalWords) * 100; const easyPercentage = (easyCount / totalWords) * 100; const mediumPercentage = (mediumCount / totalWords) * 100; const hardWeight = 3; const mediumWeight = 1; const easyWeight = -1; const weightedScore = (hardCount * hardWeight + mediumCount * mediumWeight + easyCount * easyWeight) / totalWords; const sizeAdjustment = totalWords > 50 ? -0.3 : totalWords < 15 ? +0.2 : 0; const adjustedScore = weightedScore + sizeAdjustment; let difficulty; let difficultyReason; if (hardPercentage >= 50 || adjustedScore >= 1.5) { difficulty = 'hard'; difficultyReason = `Test difficile: ${hardPercentage.toFixed(1)}% parole problematiche (${hardCount}/${totalWords})`; } else if (easyPercentage >= 70 || adjustedScore <= -0.5) { difficulty = 'easy'; difficultyReason = `Test facile: ${easyPercentage.toFixed(1)}% parole consolidate/miglioranti (${easyCount}/${totalWords})`; } else { difficulty = 'medium'; difficultyReason = `Test bilanciato: ${hardPercentage.toFixed(1)}% difficili, ${easyPercentage.toFixed(1)}% facili (${totalWords} parole)`; } const difficultyAnalysis = { difficulty, difficultyReason, totalWords, weightedScore: parseFloat(adjustedScore.toFixed(2)), sizeAdjustment, distribution: { hard: { count: hardCount, percentage: parseFloat(hardPercentage.toFixed(1)) }, medium: { count: mediumCount, percentage: parseFloat(mediumPercentage.toFixed(1)) }, easy: { count: easyCount, percentage: parseFloat(easyPercentage.toFixed(1)) } }, statusBreakdown: { critical: categories.hard.filter(item => item.status === 'critical').length, inconsistent: categories.hard.filter(item => item.status === 'inconsistent').length, struggling: categories.hard.filter(item => item.status === 'struggling').length, promising: categories.medium.filter(item => item.status === 'promising').length, new: categories.medium.filter(item => item.status === 'new').length, improving: categories.easy.filter(item => item.status === 'improving').length, consolidated: categories.easy.filter(item => item.status === 'consolidated').length } }; return { difficulty, difficultyAnalysis }; }, []); const handleTestComplete = useCallback((testStats, testWordsUsed, wrongWordsArray) => { const usedChapters = [...new Set(testWordsUsed.map(word => word.chapter || 'Senza Capitolo'))]; const chapterStats = {}; usedChapters.forEach(chapter => { const chapterWords = testWordsUsed.filter(word => (word.chapter || 'Senza Capitolo') === chapter ); const chapterWrongWords = wrongWordsArray.filter(word => (word.chapter || 'Senza Capitolo') === chapter ); const chapterHints = testStats.wordTimes ? testStats.wordTimes .filter(wt => chapterWords.some(cw => cw.id === wt.wordId)) .filter(wt => wt.usedHint).length : 0; chapterStats[chapter] = { totalWords: chapterWords.length, correctWords: chapterWords.length - chapterWrongWords.length, incorrectWords: chapterWrongWords.length, hintsUsed: chapterHints, percentage: chapterWords.length > 0 ? Math.round(((chapterWords.length - chapterWrongWords.length) / chapterWords.length) * 100) : 0 }; }); if (testStats.wordTimes && Array.isArray(testStats.wordTimes)) { testStats.wordTimes.forEach(wordTime => { const word = testWordsUsed.find(w => w.id === wordTime.wordId); if (word) { recordWordPerformance(word, wordTime.isCorrect, wordTime.usedHint, wordTime.timeSpent); } }); } const { difficulty, difficultyAnalysis } = calculateSmartTestDifficulty(testWordsUsed, getWordAnalysis); const testRecord = { id: Date.now(), timestamp: new Date(), totalWords: testStats.correct + testStats.incorrect, correctWords: testStats.correct, incorrectWords: testStats.incorrect, hintsUsed: testStats.hints || 0, totalTime: testStats.totalTime || 0, avgTimePerWord: testStats.avgTimePerWord || 0, percentage: Math.round((testStats.correct / (testStats.correct + testStats.incorrect)) * 100), wrongWords: [...wrongWordsArray], wordTimes: testStats.wordTimes || [], chapterStats, testParameters: { selectedChapters: usedChapters, includeLearnedWords: testWordsUsed.some(w => w.learned), totalAvailableWords: testWordsUsed.length }, testType: usedChapters.length === 1 ? 'selective' : 'complete', difficulty, difficultyAnalysis, legacyDifficulty: testWordsUsed.length < 10 ? 'easy' : testWordsUsed.length < 25 ? 'medium' : 'hard' }; const newStats = { ...stats }; newStats.testsCompleted += 1; newStats.correctAnswers += testStats.correct; newStats.incorrectAnswers += testStats.incorrect; newStats.hintsUsed += testStats.hints || 0; newStats.timeSpent += testStats.totalTime || (Math.round(Math.random() * 10) + 5); const totalAnswers = newStats.correctAnswers + newStats.incorrectAnswers; newStats.averageScore = (newStats.correctAnswers / totalAnswers) * 100; const today = new Date().toISOString().split('T')[0]; if (!newStats.dailyProgress[today]) { newStats.dailyProgress[today] = { tests: 0, correct: 0, incorrect: 0, hints: 0 }; } newStats.dailyProgress[today].tests += 1; newStats.dailyProgress[today].correct += testStats.correct; newStats.dailyProgress[today].incorrect += testStats.incorrect; newStats.dailyProgress[today].hints += testStats.hints || 0; newStats.lastStudyDate = today; newStats.streakDays = calculateStreak(newStats.dailyProgress); const newHistory = [testRecord, ...testHistory]; performBatchUpdate({ stats: newStats, testHistory: newHistory }); console.log(`✅ Test completato! Risultato: ${testRecord.percentage}% (Difficoltà: ${difficulty})`); return testRecord; }, [stats, testHistory, calculateStreak, performBatchUpdate, recordWordPerformance, calculateSmartTestDifficulty, getWordAnalysis]); const optimizedMigration = useCallback(() => { if (testHistory.length === 0) return; const migrationData = testHistory.reduce((acc, test) => { acc.correctAnswers += test.correctWords || 0; acc.incorrectAnswers += test.incorrectWords || 0; acc.hintsUsed += test.hintsUsed || 0; acc.totalWords = Math.max(acc.totalWords, test.totalWords || 0); acc.timeSpent += test.timeSpent || Math.floor(Math.random() * 6) + 5; if (test.timestamp) { const testDate = new Date(test.timestamp).toISOString().split('T')[0]; if (!acc.dailyProgress[testDate]) { acc.dailyProgress[testDate] = { tests: 0, correct: 0, incorrect: 0, hints: 0 }; } acc.dailyProgress[testDate].tests += 1; acc.dailyProgress[testDate].correct += test.correctWords || 0; acc.dailyProgress[testDate].incorrect += test.incorrectWords || 0; acc.dailyProgress[testDate].hints += test.hintsUsed || 0; if (!acc.lastStudyDate || testDate > acc.lastStudyDate) { acc.lastStudyDate = testDate; } } if (test.chapterStats) { Object.entries(test.chapterStats).forEach(([chapter, chapterData]) => { if (!acc.categoriesProgress[chapter]) { acc.categoriesProgress[chapter] = { correct: 0, total: 0, hints: 0 }; } acc.categoriesProgress[chapter].correct += chapterData.correctWords || 0; acc.categoriesProgress[chapter].total += chapterData.totalWords || 0; acc.categoriesProgress[chapter].hints += chapterData.hintsUsed || 0; }); } return acc; }, { correctAnswers: 0, incorrectAnswers: 0, hintsUsed: 0, totalWords: 0, timeSpent: 0, dailyProgress: {}, categoriesProgress: {}, lastStudyDate: null }); const migratedStats = { ...INITIAL_STATS, ...migrationData, testsCompleted: testHistory.length, averageScore: migrationData.correctAnswers + migrationData.incorrectAnswers > 0 ? (migrationData.correctAnswers / (migrationData.correctAnswers + migrationData.incorrectAnswers)) * 100 : 0, streakDays: calculateStreak(migrationData.dailyProgress), migrated: true }; performBatchUpdate({ stats: migratedStats }); console.log(`✅ Migrati ${testHistory.length} test!`); }, [testHistory, calculateStreak, performBatchUpdate]); const exportData = useCallback(() => { try { setIsLoading(true); const words = safeGetItem(STORAGE_CONFIG.keys.words, []); const exportData = { words, stats, testHistory, wordPerformance, exportDate: new Date().toISOString(), version: '2.4', dataTypes: ['words', 'stats', 'testHistory', 'wordPerformance'], totalTests: testHistory.length, totalWords: words.length, totalWordPerformance: Object.keys(wordPerformance).length, description: 'Backup completo v2.4: parole + statistiche + cronologia test + performance parole + difficoltà intelligente' }; const dataStr = JSON.stringify(exportData, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `vocabulary-complete-backup-v2.4-${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); console.log(`✅ Backup v2.4 esportato! (${words.length} parole + ${testHistory.length} test + ${Object.keys(wordPerformance).length} performance)`); } catch (error) { console.error('❌ Export failed:', error); alert(`Errore durante l'esportazione: ${error.message}`); } finally { setIsLoading(false); } }, [stats, testHistory, wordPerformance, safeGetItem]); const importData = useCallback((jsonString) => { try { setOptimizationState(prev => ({ ...prev, isProcessing: true })); setIsLoading(true); const importedData = JSON.parse(jsonString); const hasWords = importedData.words && Array.isArray(importedData.words); const hasStats = importedData.stats && typeof importedData.stats === 'object'; const hasHistory = importedData.testHistory && Array.isArray(importedData.testHistory); const hasWordPerformance = importedData.wordPerformance && typeof importedData.wordPerformance === 'object'; if (!hasWords && !hasStats && !hasHistory) { throw new Error('File non contiene dati validi (parole, statistiche o cronologia)'); } const isNewFormat = importedData.version === '2.4' && hasWords; const isEnhancedBackup = importedData.version === '2.3' && hasWordPerformance; let confirmMessage = ''; if (isNewFormat) { confirmMessage = `Backup Completo v2.4 rilevato (${importedData.words?.length || 0} parole + ${importedData.testHistory?.length || 0} test + ${Object.keys(importedData.wordPerformance || {}).length} performance).\nOK = Sostituisci tutto | Annulla = Combina`; } else if (isEnhancedBackup) { confirmMessage = `Backup Enhanced v2.3 rilevato (${importedData.testHistory?.length || 0} test + ${Object.keys(importedData.wordPerformance || {}).length} performance).\nOK = Sostituisci tutto | Annulla = Combina\n⚠️ ATTENZIONE: Non contiene parole!`; } else { confirmMessage = `Backup standard rilevato.\nOK = Sostituisci | Annulla = Combina`; } const shouldOverwrite = window.confirm(confirmMessage); let newStats = stats; let newHistory = testHistory; let newWordPerformance = wordPerformance; let importedWords = []; if (shouldOverwrite) { if (hasStats) { newStats = { ...importedData.stats, migrated: true }; } if (hasHistory) { newHistory = [...importedData.testHistory]; } if (hasWordPerformance) { newWordPerformance = { ...importedData.wordPerformance }; } if (hasWords) { importedWords = [...importedData.words]; safeSetItem(STORAGE_CONFIG.keys.words, importedWords); } const components = []; if (hasWords) components.push(`${importedWords.length} parole`); if (hasHistory) components.push(`${newHistory.length} test`); if (hasWordPerformance) components.push(`${Object.keys(newWordPerformance).length} performance`); console.log(`✅ Backup ${isNewFormat ? 'v2.4' : isEnhancedBackup ? 'v2.3' : 'standard'} importato! ${components.join(' + ')}`); } else { if (hasHistory) { const existingIds = new Set(testHistory.map(test => test.id)); const newTests = importedData.testHistory.filter(test => !existingIds.has(test.id)); newHistory = [...testHistory, ...newTests].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); } if (hasWordPerformance) { newWordPerformance = { ...wordPerformance }; Object.entries(importedData.wordPerformance).forEach(([wordId, data]) => { if (newWordPerformance[wordId]) { const existingAttempts = newWordPerformance[wordId].attempts || []; const newAttempts = data.attempts || []; const allAttempts = [...existingAttempts, ...newAttempts] .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); newWordPerformance[wordId] = { ...data, attempts: allAttempts }; } else { newWordPerformance[wordId] = data; } }); } if (hasWords) { const currentWords = safeGetItem(STORAGE_CONFIG.keys.words, []); const existingEnglish = new Set(currentWords.map(w => w.english.toLowerCase())); const newWords = importedData.words.filter(word => !existingEnglish.has(word.english.toLowerCase()) ); if (newWords.length > 0) { importedWords = [...currentWords, ...newWords]; safeSetItem(STORAGE_CONFIG.keys.words, importedWords); } else { importedWords = currentWords; } } console.log('✅ Dati combinati!'); } performBatchUpdate({ stats: newStats, testHistory: newHistory, wordPerformance: newWordPerformance }); if (hasWords) { localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString()); } alert('✅ Importazione completata con successo!'); } catch (error) { console.error('❌ Import failed:', error); alert(`Errore durante l'importazione: ${error.message}`); throw error; } finally { setIsLoading(false); setOptimizationState(prev => ({ ...prev, isProcessing: false })); } }, [stats, testHistory, wordPerformance, performBatchUpdate, safeSetItem, safeGetItem]); const clearTestHistory = useCallback(() => { try { setIsLoading(true); console.log('🗑️ Clearing test history...'); const clearedStats = { ...INITIAL_STATS, totalWords: stats.totalWords, migrated: true }; performBatchUpdate({ stats: clearedStats, testHistory: EMPTY_ARRAY, wordPerformance: INITIAL_WORD_PERFORMANCE }); console.log('✅ Test history cleared'); alert('✅ Cronologia test cancellata!'); } catch (error) { console.error('❌ Failed to clear test history:', error); alert(`Errore durante la cancellazione: ${error.message}`); } finally { setIsLoading(false); } }, [stats.totalWords, performBatchUpdate]); const refreshData = useCallback(() => { console.log('🔄 Refreshing data...'); setIsInitialized(false); }, []); const computedStats = useMemo(() => { return { ...selectors, weeklyProgress, isMigrated: stats?.migrated || false, isProcessing: optimizationState.isProcessing, forceUpdate: optimizationState.forceUpdate }; }, [selectors, weeklyProgress, stats?.migrated, optimizationState]); useEffect(() => { if (!isInitialized) { initializeData(); } }, [isInitialized, initializeData]); useEffect(() => { const shouldMigrate = stats && !stats.migrated && testHistory.length > 0 && !optimizationState.isProcessing; if (shouldMigrate) { const timeoutId = setTimeout(optimizedMigration, 500); return () => clearTimeout(timeoutId); } }, [stats?.migrated, testHistory.length, optimizationState.isProcessing, optimizedMigration]); return { stats, testHistory, wordPerformance, calculatedStats: computedStats, isInitialized, isLoading, error, lastSync, handleTestComplete, exportData, importData, clearTestHistory, refreshData, getAllWordsPerformance, getWordAnalysis, recordWordPerformance, addTestToHistory: useCallback((testResult) => { const updatedHistory = [testResult, ...testHistory]; performBatchUpdate({ testHistory: updatedHistory }); }, [testHistory, performBatchUpdate]), resetStats: useCallback(() => { if (window.confirm('⚠️ Cancellare tutto (parole, test, statistiche)?')) { localStorage.removeItem(STORAGE_CONFIG.keys.words); localStorage.removeItem('vocabularyWords_lastUpdate'); performBatchUpdate({ stats: { ...INITIAL_STATS, migrated: true }, testHistory: EMPTY_ARRAY, wordPerformance: INITIAL_WORD_PERFORMANCE }); console.log('✅ Tutti i dati cancellati (parole, test, statistiche)!'); } }, [performBatchUpdate]), clearHistoryOnly: useCallback(() => { if (window.confirm(`Cancellare ${testHistory.length} test?`)) { performBatchUpdate({ testHistory: EMPTY_ARRAY, stats: { ...INITIAL_STATS, totalWords: stats?.totalWords || 0, migrated: true } }); console.log('✅ Cronologia cancellata!'); } }, [testHistory.length, performBatchUpdate, stats?.totalWords]), ...computedStats }; };

================================================================================

NOME FILE: useLoadingState.js

import { useState, useCallback, useRef, useEffect } from 'react'; import { useNotification } from '../contexts/NotificationContext'; export const useLoadingState = (options = {}) => { const { timeout = 30000, retryAttempts = 3, retryDelay = 1000, showTimeoutWarning = true, showRetryNotifications = true } = options; const [state, setState] = useState({ isLoading: false, error: null, retryCount: 0, startTime: null, operation: null }); const timeoutRef = useRef(null); const { showWarning, showError, showSuccess } = useNotification(); const startLoading = useCallback((operationName = 'Operation') => { setState(prev => ({ ...prev, isLoading: true, error: null, startTime: Date.now(), operation: operationName })); if (showTimeoutWarning && timeout > 0) { timeoutRef.current = setTimeout(() => { showWarning(`⏱️ ${operationName} sta impiegando più tempo...`); }, timeout / 2); } }, [timeout, showTimeoutWarning, showWarning]); const stopLoading = useCallback((successMessage) => { setState(prev => { const duration = prev.startTime ? Date.now() - prev.startTime : 0; if (successMessage && duration > 2000) { showSuccess(`${successMessage} (${Math.round(duration / 1000)}s)`); } return { ...prev, isLoading: false, error: null, retryCount: 0, startTime: null, operation: null }; }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } }, [showSuccess]); const setError = useCallback((error, canRetry = true) => { setState(prev => { const newRetryCount = prev.retryCount + 1; const shouldRetry = canRetry && newRetryCount <= retryAttempts; if (shouldRetry && showRetryNotifications) { showWarning(`❌ ${error.message || error} - Tentativo ${newRetryCount}/${retryAttempts}`); } else if (!shouldRetry) { showError(error, prev.operation || 'Operation'); } return { ...prev, isLoading: false, error: error, retryCount: shouldRetry ? newRetryCount : prev.retryCount }; }); if (timeoutRef.current) { clearTimeout(timeoutRef.current); timeoutRef.current = null; } }, [retryAttempts, showRetryNotifications, showWarning, showError]); const retry = useCallback(async (operation) => { if (state.retryCount >= retryAttempts) { showError(new Error('Numero massimo tentativi raggiunto'), 'Retry'); return false; } await new Promise(resolve => setTimeout(resolve, retryDelay * state.retryCount)); try { startLoading(state.operation); const result = await operation(); stopLoading(); return result; } catch (error) { setError(error, true); return false; } }, [state.retryCount, state.operation, retryAttempts, retryDelay, startLoading, stopLoading, setError, showError]); useEffect(() => { return () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } }; }, []); return { ...state, startLoading, stopLoading, setError, retry, canRetry: state.retryCount < retryAttempts, duration: state.startTime ? Date.now() - state.startTime : 0 }; }; export const useAILoading = () => { const loadingState = useLoadingState({ timeout: 45000, retryAttempts: 2, retryDelay: 2000, showTimeoutWarning: true }); const executeAIOperation = useCallback(async (operation, operationName = 'AI Analysis') => { try { loadingState.startLoading(operationName); const timeoutPromise = new Promise((_, reject) => { setTimeout(() => reject(new Error('AI service timeout')), 45000); }); const result = await Promise.race([operation(), timeoutPromise]); loadingState.stopLoading(`✨ ${operationName} completata`); return result; } catch (error) { if (error.message.includes('timeout')) { loadingState.setError(new Error('🤖 AI timeout. Riprova o usa modalità manuale.'), true); } else if (error.message.includes('API')) { loadingState.setError(new Error('🔑 Problema API key.'), false); } else if (error.message.includes('quota')) { loadingState.setError(new Error('🚫 Limite API raggiunto.'), false); } else { loadingState.setError(error, true); } throw error; } }, [loadingState]); return { ...loadingState, executeAIOperation }; }; export const useStorageLoading = () => { const loadingState = useLoadingState({ timeout: 10000, retryAttempts: 3, retryDelay: 500, showTimeoutWarning: false }); const executeStorageOperation = useCallback(async (operation, operationName = 'Storage Operation') => { try { loadingState.startLoading(operationName); const result = await operation(); loadingState.stopLoading(); return result; } catch (error) { if (error.message.includes('quota') || error.message.includes('QuotaExceededError')) { loadingState.setError(new Error('💽 Spazio esaurito. Elimina dati vecchi.'), false); } else if (error.message.includes('localStorage')) { loadingState.setError(new Error('🔒 Accesso negato storage.'), true); } else { loadingState.setError(error, true); } throw error; } }, [loadingState]); return { ...loadingState, executeStorageOperation }; }; export const useNetworkLoading = () => { const loadingState = useLoadingState({ timeout: 20000, retryAttempts: 3, retryDelay: 1500, showTimeoutWarning: true }); const executeNetworkOperation = useCallback(async (operation, operationName = 'Network Request') => { try { loadingState.startLoading(operationName); const result = await operation(); loadingState.stopLoading(); return result; } catch (error) { if (error.message.includes('fetch') || error.message.includes('network')) { loadingState.setError(new Error('📡 Nessuna connessione.'), true); } else if (error.message.includes('timeout')) { loadingState.setError(new Error('⏱️ Timeout rete.'), true); } else if (error.message.includes('404')) { loadingState.setError(new Error('🔍 Risorsa non trovata.'), false); } else if (error.message.includes('500')) { loadingState.setError(new Error('🔧 Errore server.'), true); } else { loadingState.setError(error, true); } throw error; } }, [loadingState]); return { ...loadingState, executeNetworkOperation }; };

================================================================================

NOME FILE: useLocalStorage.js

import { useState } from 'react'; export const useLocalStorage = (key, initialValue) => { const [storedValue, setStoredValue] = useState(() => { try { const item = localStorage.getItem(key); return item ? JSON.parse(item) : initialValue; } catch (error) { console.error(`Error loading ${key} from localStorage:`, error); return initialValue; } }); const setValue = (value) => { try { const valueToStore = value instanceof Function ? value(storedValue) : value; setStoredValue(valueToStore); localStorage.setItem(key, JSON.stringify(valueToStore)); } catch (error) { console.error(`Error saving ${key} to localStorage:`, error); } }; return [storedValue, setValue]; };

================================================================================

NOME FILE: useNotification.js

import { useState, useCallback } from 'react'; export const useNotification = () => { const [message, setMessage] = useState(''); const showNotification = useCallback((msg, duration = 3000) => { setMessage(msg); setTimeout(() => setMessage(''), duration); }, []); return { message, showNotification }; };

================================================================================

NOME FILE: useOptimizedTest.js

import { useState, useCallback, useMemo, useRef, useEffect } from 'react'; export const useOptimizedTest = (onTestComplete) => { const [currentWord, setCurrentWord] = useState(null); const [usedWordIds, setUsedWordIds] = useState(new Set()); const [showMeaning, setShowMeaning] = useState(false); const [testMode, setTestMode] = useState(false); const [showResults, setShowResults] = useState(false); const [stats, setStats] = useState({ correct: 0, incorrect: 0, hints: 0 }); const [wrongWords, setWrongWords] = useState([]); const [testWords, setTestWords] = useState([]); const [testSaved, setTestSaved] = useState(false); const [wordTimes, setWordTimes] = useState([]); const [isTransitioning, setIsTransitioning] = useState(false); const testStartTimeRef = useRef(null); const wordStartTimeRef = useRef(null); const [showHint, setShowHint] = useState(false); const [hintUsedForCurrentWord, setHintUsedForCurrentWord] = useState(false); useEffect(() => { if (currentWord && testMode && !isTransitioning) { wordStartTimeRef.current = Date.now(); setHintUsedForCurrentWord(false); setShowHint(false); setShowMeaning(false); } }, [currentWord, testMode, isTransitioning]); const recordWordTime = useCallback((isCorrect, usedHint = false) => { if (wordStartTimeRef.current && currentWord) { const timeSpent = Date.now() - wordStartTimeRef.current; const wordRecord = { wordId: currentWord.id, english: currentWord.english, italian: currentWord.italian, chapter: currentWord.chapter, timeSpent, isCorrect, usedHint, timestamp: new Date().toISOString() }; setWordTimes(prev => [...prev, wordRecord]); wordStartTimeRef.current = null; } }, [currentWord]); const progressData = useMemo(() => { if (testWords.length === 0) return { current: 0, total: 0, percentage: 0, hints: 0 }; const answered = stats.correct + stats.incorrect; return { current: answered + 1, total: testWords.length, percentage: Math.round((answered / testWords.length) * 100), hints: stats.hints }; }, [stats.correct, stats.incorrect, stats.hints, testWords.length]); const summaryData = useMemo(() => { const totalAnswered = stats.correct + stats.incorrect; const accuracy = totalAnswered > 0 ? Math.round((stats.correct / totalAnswered) * 100) : 0; const totalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0; const timingStats = wordTimes.length > 0 ? { avgTimePerWord: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000), maxTimePerWord: Math.round(Math.max(...wordTimes.map(r => r.timeSpent)) / 1000), minTimePerWord: Math.round(Math.min(...wordTimes.map(r => r.timeSpent)) / 1000), totalRecordedTime: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / 1000) } : { avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; const completeSummary = { current: totalAnswered + 1, total: testWords.length, percentage: Math.round((totalAnswered / testWords.length) * 100), answered: totalAnswered, remaining: testWords.length - totalAnswered, accuracy, correct: stats.correct, incorrect: stats.incorrect, hints: stats.hints, totalTime: Math.round(totalTestTime / 1000), ...timingStats, wordTimes: [...wordTimes], testStartTime: testStartTimeRef.current, hintsPercentage: totalAnswered > 0 ? Math.round((stats.hints / totalAnswered) * 100) : 0, efficiency: totalAnswered > 0 ? Math.max(0, accuracy - Math.round((stats.hints / totalAnswered) * 100)) : 0 }; return completeSummary; }, [stats.correct, stats.incorrect, stats.hints, testWords.length, wordTimes, testStartTimeRef.current]); const getRandomUnusedWord = useCallback((wordList, usedIds) => { const unusedWords = wordList.filter(word => !usedIds.has(word.id)); if (unusedWords.length === 0) return null; const randomIndex = Math.floor(Math.random() * unusedWords.length); return unusedWords[randomIndex]; }, []); const saveTestResultsWithStats = useCallback((finalStats) => { if (!testSaved && (finalStats.correct > 0 || finalStats.incorrect > 0) && onTestComplete) { const finalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0; const timingStats = wordTimes.length > 0 ? { avgTimePerWord: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000), maxTimePerWord: Math.round(Math.max(...wordTimes.map(r => r.timeSpent)) / 1000), minTimePerWord: Math.round(Math.min(...wordTimes.map(r => r.timeSpent)) / 1000), totalRecordedTime: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / 1000) } : { avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; const enhancedStats = { ...finalStats, totalTime: Math.round(finalTestTime / 1000), ...timingStats, wordTimes: [...wordTimes] }; onTestComplete(enhancedStats, testWords, wrongWords); setTestSaved(true); } }, [testWords, wrongWords, testSaved, onTestComplete, wordTimes]); const startTest = useCallback((filteredWords = []) => { if (filteredWords.length === 0) return; setTestWords(filteredWords); setWrongWords([]); setTestSaved(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setUsedWordIds(new Set()); setWordTimes([]); setIsTransitioning(false); testStartTimeRef.current = Date.now(); wordStartTimeRef.current = null; const firstWord = getRandomUnusedWord(filteredWords, new Set()); setCurrentWord(firstWord); if (firstWord) { setUsedWordIds(new Set([firstWord.id])); } setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setTestMode(true); }, [getRandomUnusedWord]); const nextWord = useCallback(() => { const nextRandomWord = getRandomUnusedWord(testWords, usedWordIds); if (nextRandomWord) { setIsTransitioning(true); setShowMeaning(false); setTimeout(() => { setCurrentWord(nextRandomWord); setUsedWordIds(prev => new Set([...prev, nextRandomWord.id])); setShowHint(false); setHintUsedForCurrentWord(false); setTimeout(() => { setIsTransitioning(false); }, 100); }, 400); } }, [testWords, usedWordIds, getRandomUnusedWord]); const toggleHint = useCallback(() => { if (!showHint && currentWord?.sentence) { setShowHint(true); setHintUsedForCurrentWord(true); } else { setShowHint(false); } }, [showHint, currentWord]); const handleAnswer = useCallback((isCorrect) => { recordWordTime(isCorrect, hintUsedForCurrentWord); const newStats = { correct: stats.correct + (isCorrect ? 1 : 0), incorrect: stats.incorrect + (isCorrect ? 0 : 1), hints: stats.hints + (hintUsedForCurrentWord ? 1 : 0) }; setStats(newStats); if (!isCorrect && currentWord) { const wrongWord = { ...currentWord, usedHint: hintUsedForCurrentWord }; setWrongWords(prev => [...prev, wrongWord]); } const totalAnswered = newStats.correct + newStats.incorrect; const isLastQuestion = totalAnswered >= testWords.length; if (isLastQuestion) { saveTestResultsWithStats(newStats); setTestMode(false); setShowResults(true); setCurrentWord(null); } else { setTimeout(() => { nextWord(); }, showMeaning ? 1000 : 600); } }, [currentWord, showMeaning, stats, testWords.length, hintUsedForCurrentWord, recordWordTime, saveTestResultsWithStats, nextWord]); const resetTest = useCallback(() => { if (!testSaved && (stats.correct > 0 || stats.incorrect > 0)) { saveTestResultsWithStats(stats); } setTestMode(false); setShowResults(false); setCurrentWord(null); setUsedWordIds(new Set()); setWrongWords([]); setShowMeaning(false); setShowHint(false); setHintUsedForCurrentWord(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setTestWords([]); setTestSaved(false); setWordTimes([]); setIsTransitioning(false); testStartTimeRef.current = null; wordStartTimeRef.current = null; }, [stats, testSaved, saveTestResultsWithStats]); const startNewTest = useCallback(() => { setShowResults(false); setWrongWords([]); setTestSaved(false); setStats({ correct: 0, incorrect: 0, hints: 0 }); setUsedWordIds(new Set()); setCurrentWord(null); setWordTimes([]); setIsTransitioning(false); startTest(testWords); }, [startTest, testWords]); return { currentWord, usedWordIds, showMeaning, setShowMeaning, testMode, showResults, stats, wrongWords, testWords, isTransitioning, showHint, toggleHint, hintUsed: hintUsedForCurrentWord, wordTimes, startTest, handleAnswer, resetTest, startNewTest, getTestProgress: useCallback(() => progressData, [progressData]), getTestSummary: useCallback(() => summaryData, [summaryData]) }; };

================================================================================

NOME FILE: useOptimizedWords.js

import { useState, useCallback, useMemo, useEffect } from 'react'; import { useLocalStorage } from './useLocalStorage'; const EMPTY_ARRAY = []; export const useOptimizedWords = () => { const [words, setWords] = useLocalStorage('vocabularyWords', EMPTY_ARRAY); const [editingWord, setEditingWord] = useState(null); const [refreshTrigger, setRefreshTrigger] = useState(0); useEffect(() => { const handleStorageChange = (e) => { if (e.key === 'vocabularyWords' || e.key === 'vocabularyWords_lastUpdate') { forceRefresh(); } }; window.addEventListener('storage', handleStorageChange); const handleCustomRefresh = () => { forceRefresh(); }; window.addEventListener('wordsImported', handleCustomRefresh); let lastCheck = localStorage.getItem('vocabularyWords_lastUpdate'); const checkInterval = setInterval(() => { const currentCheck = localStorage.getItem('vocabularyWords_lastUpdate'); if (currentCheck && currentCheck !== lastCheck) { lastCheck = currentCheck; handleCustomRefresh(); } }, 1000); return () => { window.removeEventListener('storage', handleStorageChange); window.removeEventListener('wordsImported', handleCustomRefresh); clearInterval(checkInterval); }; }, []); const forceRefresh = useCallback(() => { try { const updatedWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]'); setWords(updatedWords); setRefreshTrigger(prev => prev + 1); } catch (error) { } }, [setWords]); const wordStats = useMemo(() => ({ total: words.length, learned: words.filter(w => w.learned).length, unlearned: words.filter(w => !w.learned).length, difficult: words.filter(w => w.difficult).length, normal: words.filter(w => !w.difficult && !w.learned).length, chapters: [...new Set(words.map(w => w.chapter).filter(Boolean))].sort(), groups: [...new Set(words.map(w => w.group).filter(Boolean))].sort() }), [words, refreshTrigger]); const wordMap = useMemo(() => { const map = {}; words.forEach(word => { if (word.id) { map[word.id] = word; } if (word.english) { map[`english_${word.english.toLowerCase()}`] = word; } }); return map; }, [words, refreshTrigger]); const batchUpdateWords = useCallback((updateFn) => { setWords(prevWords => { const newWords = updateFn(prevWords); const sortedWords = newWords.sort((a, b) => a.english.localeCompare(b.english)); try { localStorage.setItem('vocabularyWords', JSON.stringify(sortedWords)); localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString()); } catch (error) { } return sortedWords; }); setRefreshTrigger(prev => prev + 1); }, [setWords]); const addWord = useCallback((wordData) => { if (!wordData.english?.trim() || !wordData.italian?.trim()) { throw new Error('English word and Italian translation are required'); } const englishWord = wordData.english.trim().toLowerCase(); const englishKey = `english_${englishWord}`; const existingWord = wordMap[englishKey]; if (existingWord && (!editingWord || existingWord.id !== editingWord.id)) { throw new Error(`Word "${wordData.english}" already exists`); } batchUpdateWords(prevWords => { if (editingWord) { const updatedWords = prevWords.map(word => { if (word.id === editingWord.id) { const updatedWord = { ...word, ...wordData, id: editingWord.id, english: wordData.english.trim(), italian: wordData.italian.trim() }; return updatedWord; } return word; }); const foundUpdated = updatedWords.find(w => w.id === editingWord.id); if (!foundUpdated) { throw new Error('Failed to update word - word not found'); } return updatedWords; } else { const newWord = { id: `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, english: wordData.english.trim(), italian: wordData.italian.trim(), group: wordData.group?.trim() || null, sentence: wordData.sentence?.trim() || null, notes: wordData.notes?.trim() || null, chapter: wordData.chapter?.trim() || null, learned: Boolean(wordData.learned), difficult: Boolean(wordData.difficult) }; return [...prevWords, newWord]; } }); setEditingWord(null); }, [editingWord, wordMap, batchUpdateWords]); const toggleWordLearned = useCallback((id) => { const existingWord = wordMap[id]; if (!existingWord) { throw new Error('Word not found'); } batchUpdateWords(prevWords => prevWords.map(word => { if (word.id === id) { return { ...word, learned: !word.learned }; } return word; }) ); }, [wordMap, batchUpdateWords]); const toggleWordDifficult = useCallback((id) => { const existingWord = wordMap[id]; if (!existingWord) { throw new Error('Word not found'); } batchUpdateWords(prevWords => prevWords.map(word => { if (word.id === id) { return { ...word, difficult: !word.difficult }; } return word; }) ); }, [wordMap, batchUpdateWords]); const removeWord = useCallback((id) => { const existingWord = wordMap[id]; if (!existingWord) { throw new Error('Word not found'); } batchUpdateWords(prevWords => { const filteredWords = prevWords.filter(word => word.id !== id); return filteredWords; }); if (editingWord?.id === id) { setEditingWord(null); } }, [editingWord?.id, wordMap, batchUpdateWords]); const importWords = useCallback((jsonText) => { try { const importedWords = JSON.parse(jsonText.trim()); if (!Array.isArray(importedWords) || importedWords.length === 0) { throw new Error('Invalid JSON data - expected array of words'); } const validWords = importedWords .filter(word => word?.english && word?.italian) .map(word => ({ id: word.id || `word_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, english: String(word.english).trim(), italian: String(word.italian).trim(), group: word.group ? String(word.group).trim() : null, sentence: word.sentence ? String(word.sentence).trim() : null, notes: word.notes ? String(word.notes).trim() : null, chapter: word.chapter ? String(word.chapter).trim() : null, learned: Boolean(word.learned), difficult: Boolean(word.difficult) })); if (validWords.length === 0) { throw new Error('No valid words found in JSON data'); } const currentWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]'); const existingEnglish = new Set(currentWords.map(w => w.english.toLowerCase())); const newWords = validWords.filter(word => !existingEnglish.has(word.english.toLowerCase()) ); if (newWords.length === 0) { throw new Error('All words already exist in your vocabulary'); } const allWords = [...currentWords, ...newWords]; localStorage.setItem('vocabularyWords', JSON.stringify(allWords)); localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString()); setWords(allWords); setRefreshTrigger(prev => prev + 1); window.dispatchEvent(new CustomEvent('wordsImported', { detail: { count: newWords.length, total: allWords.length } })); return newWords.length; } catch (error) { throw error; } }, [setWords]); const getters = useMemo(() => ({ getWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter), getDifficultWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter && word.difficult), getAvailableChapters: () => { const chapters = new Set(); words.forEach(word => { if (word.chapter) chapters.add(word.chapter); }); return Array.from(chapters).sort((a, b) => { const aNum = parseInt(a); const bNum = parseInt(b); return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b); }); }, getChapterStats: (chapter) => { const chapterWords = words.filter(word => word.chapter === chapter); return { total: chapterWords.length, learned: chapterWords.filter(w => w.learned).length, unlearned: chapterWords.filter(w => !w.learned).length, difficult: chapterWords.filter(w => w.difficult).length, normal: chapterWords.filter(w => !w.difficult && !w.learned).length }; } }), [words, refreshTrigger]); const clearAllWords = useCallback(() => { setWords(EMPTY_ARRAY); setEditingWord(null); localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString()); setRefreshTrigger(prev => prev + 1); }, [setWords]); return { words, editingWord, setEditingWord, wordStats, addWord, removeWord, toggleWordLearned, toggleWordDifficult, clearAllWords, importWords, forceRefresh, ...getters }; };

================================================================================


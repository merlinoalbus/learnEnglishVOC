NOME FILE: AdminView.tsx

import React from "react"; import { AdminPanel } from "../components/admin/AdminPanel"; import { Card, CardContent, CardHeader, CardTitle, } from "../components/ui/card"; import { Shield, Users, Activity, Settings } from "lucide-react"; export const AdminView: React.FC = () => { return ( <div className="min-h-screen bg-gradient-to-br from-gray-50 via-white to-blue-50"> <div className="max-w-7xl mx-auto p-6 space-y-6"> } <div className="grid grid-cols-1 md:grid-cols-3 gap-6"> <Card className="bg-gradient-to-br from-blue-500 to-blue-600 text-white"> <CardHeader className="pb-2"> <CardTitle className="flex items-center gap-2 text-lg"> <Users className="w-5 h-5" /> Utenti Totali </CardTitle> </CardHeader> <CardContent> <div className="text-3xl font-bold">--</div> <p className="text-blue-100 text-sm">Caricamento...</p> </CardContent> </Card> <Card className="bg-gradient-to-br from-green-500 to-green-600 text-white"> <CardHeader className="pb-2"> <CardTitle className="flex items-center gap-2 text-lg"> <Activity className="w-5 h-5" /> Utenti Attivi </CardTitle> </CardHeader> <CardContent> <div className="text-3xl font-bold">--</div> <p className="text-green-100 text-sm">Caricamento...</p> </CardContent> </Card> <Card className="bg-gradient-to-br from-purple-500 to-purple-600 text-white"> <CardHeader className="pb-2"> <CardTitle className="flex items-center gap-2 text-lg"> <Shield className="w-5 h-5" /> Amministratori </CardTitle> </CardHeader> <CardContent> <div className="text-3xl font-bold">--</div> <p className="text-purple-100 text-sm">Caricamento...</p> </CardContent> </Card> </div>

================================================================================

NOME FILE: AuthView.tsx

import React, { useState, useEffect } from "react"; import { AuthLayout } from "../layouts/AuthLayout"; import { LoginForm } from "../components/auth/LoginForm"; import { SignUpForm } from "../components/auth/SignUpForm"; import { ForgotPasswordForm } from "../components/auth/ForgotPasswordForm"; import { useAuth } from "../hooks/integration/useAuth"; type AuthMode = "login" | "signup" | "forgot-password"; interface AuthViewProps { onAuthSuccess?: () => void; initialMode?: AuthMode; } export const AuthView: React.FC<AuthViewProps> = ({ onAuthSuccess, initialMode = "login", }) => { const [currentMode, setCurrentMode] = useState<AuthMode>(initialMode); const { isAuthenticated, isReady } = useAuth(); useEffect(() => { if (isReady && isAuthenticated) { onAuthSuccess?.(); } }, [isReady, isAuthenticated, onAuthSuccess]); const getAuthConfig = (mode: AuthMode) => { switch (mode) { case "login": return { title: "Bentornato!", subtitle: "Accedi al tuo account per continuare il tuo percorso di apprendimento", }; case "signup": return { title: "Inizia ora!", subtitle: "Crea il tuo account e inizia a migliorare il tuo inglese", }; case "forgot-password": return { title: "Recupera password", subtitle: "Ti invieremo le istruzioni per reimpostare la tua password", }; default: return getAuthConfig("login"); } }; const config = getAuthConfig(currentMode); const renderAuthForm = () => { switch (currentMode) { case "login": return ( <LoginForm onSwitchToSignUp={() => setCurrentMode("signup")} onSwitchToForgotPassword={() => setCurrentMode("forgot-password")} onLoginSuccess={onAuthSuccess} /> ); case "signup": return ( <SignUpForm onSwitchToLogin={() => setCurrentMode("login")} onSignUpSuccess={onAuthSuccess} /> ); case "forgot-password": return ( <ForgotPasswordForm onSwitchToLogin={() => setCurrentMode("login")} /> ); default: return null; } }; return ( <AuthLayout title={config.title} subtitle={config.subtitle}> {renderAuthForm()} </AuthLayout> ); };

================================================================================

NOME FILE: MainView.js

import React from 'react'; import { useAppContext } from '../contexts/AppContext'; import { useNotification } from '../contexts/NotificationContext'; import { ControlPanel } from '../components/main/ControlPanel'; import JSONManager from '../components/JSONManager'; import EnhancedAddWordForm from '../components/EnhancedAddWordForm'; import WordsList from '../components/WordsList'; export const MainView = React.memo(() => { const { words, editingWord, showWordsList, dispatch, addWord, toggleWordLearned, toggleWordDifficult, importWords, forceRefresh, getAvailableChapters, getChapterStats, wordStats } = useAppContext(); const { showSuccess, showError, showWarning } = useNotification(); const handleStartTest = React.useCallback(() => { const availableWords = words.filter(word => !word.learned); if (availableWords.length === 0) { showWarning('⚠️ Nessuna parola disponibile per il test!'); return; } dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: true }); }, [words, dispatch, showWarning]); const handleAddWord = React.useCallback((wordData) => { try { addWord(wordData); dispatch({ type: 'SET_EDITING_WORD', payload: null }); showSuccess( editingWord ? `✅ Parola "${wordData.english}" modificata!` : `✅ Parola "${wordData.english}" aggiunta!` ); } catch (error) { console.error('MainView: Error adding word:', error); showError(error, 'Add Word'); } }, [addWord, editingWord, dispatch, showSuccess, showError]); const handleRemoveWord = React.useCallback((id) => { const wordToDelete = words.find(word => word.id === id); if (wordToDelete) { dispatch({ type: 'SET_CONFIRM_DELETE', payload: wordToDelete }); } }, [words, dispatch]); const handleToggleWordLearned = React.useCallback((id) => { const word = words.find(w => w.id === id); if (word) { toggleWordLearned(id); showSuccess( word.learned ? `📖 "${word.english}" segnata come da studiare` : `✅ "${word.english}" segnata come appresa!` ); } }, [words, toggleWordLearned, showSuccess]); const handleToggleWordDifficult = React.useCallback((id) => { const word = words.find(w => w.id === id); if (word) { toggleWordDifficult(id); showSuccess( word.difficult ? `📚 "${word.english}" rimossa dalle parole difficili` : `⭐ "${word.english}" segnata come difficile!` ); } }, [words, toggleWordDifficult, showSuccess]); const handleImportWords = React.useCallback(async (jsonText) => { try { const count = await importWords(jsonText); if (forceRefresh) { setTimeout(forceRefresh, 100); } showSuccess(`✅ ${count} parole importate con successo!`); return count; } catch (error) { console.error('MainView: Import error:', error); if (error.message.includes('already exist')) { showWarning('⚠️ Tutte le parole nel JSON sono già presenti nel vocabolario.'); } else if (error.message.includes('JSON')) { showError(new Error('❌ File JSON non valido. Controlla la sintassi.'), 'Import Words'); } else { showError(error, 'Import Words'); } throw error; } }, [importWords, forceRefresh, showSuccess, showError, showWarning]); const handleEditWord = React.useCallback((word) => { if (!word || !word.id) { showError(new Error('Impossibile modificare: parola non valida'), 'Edit Word'); return; } const existingWord = words.find(w => w.id === word.id); if (!existingWord) { showError(new Error('Parola non trovata nel vocabolario'), 'Edit Word'); console.error('Word not found in words list:', word.id, 'Available IDs:', words.map(w => w.id)); if (forceRefresh) { forceRefresh(); setTimeout(() => { const refreshedWord = words.find(w => w.english === word.english); if (refreshedWord) { dispatch({ type: 'SET_EDITING_WORD', payload: refreshedWord }); } }, 500); } return; } dispatch({ type: 'SET_EDITING_WORD', payload: existingWord }); }, [words, dispatch, showError, forceRefresh]); return ( <div className="space-y-8 animate-fade-in"> <ControlPanel onStartTest={handleStartTest} onClearAllWords={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: true })} words={words} wordStats={wordStats} getAvailableChapters={getAvailableChapters} getChapterStats={getChapterStats} /> <JSONManager words={words} onImportWords={handleImportWords} /> <EnhancedAddWordForm onAddWord={handleAddWord} editingWord={editingWord} onClearForm={() => dispatch({ type: 'SET_EDITING_WORD', payload: null })} /> <WordsList words={words} onEditWord={handleEditWord} onRemoveWord={handleRemoveWord} onToggleLearned={handleToggleWordLearned} onToggleDifficult={handleToggleWordDifficult} showWordsList={showWordsList} setShowWordsList={() => dispatch({ type: 'TOGGLE_WORDS_LIST' })} /> </div> ); });

================================================================================

NOME FILE: ResultsView.js

import React from 'react'; import { useAppContext } from '../contexts/AppContext'; import TestResults from '../components/TestResults'; export const ResultsView = React.memo(() => { const { wrongWords, startNewTest, resetTest, getTestSummary } = useAppContext(); const getTestResultData = () => { const summary = getTestSummary && getTestSummary(); if (summary && (summary.correct >= 0 || summary.incorrect >= 0)) { const enhancedData = { correct: summary.correct || 0, incorrect: summary.incorrect || 0, hints: summary.hints || 0, totalTime: summary.totalTime || 0, avgTimePerWord: summary.avgTimePerWord || 0, maxTimePerWord: summary.maxTimePerWord || 0, minTimePerWord: summary.minTimePerWord || 0, totalRecordedTime: summary.totalRecordedTime || 0, total: summary.total || (summary.correct + summary.incorrect), answered: summary.answered || (summary.correct + summary.incorrect), accuracy: summary.accuracy || 0, percentage: summary.percentage || 0 }; return enhancedData; } if (wrongWords && Array.isArray(wrongWords)) { const incorrect = wrongWords.length; const fallbackData = { correct: 0, incorrect, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; return fallbackData; } const defaultData = { correct: 0, incorrect: 0, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }; return defaultData; }; const finalTestData = getTestResultData(); return ( <TestResults stats={finalTestData} wrongWords={wrongWords} onStartNewTest={startNewTest} onResetTest={resetTest} /> ); });

================================================================================

NOME FILE: StatsView.js

import React from 'react'; import { useAppContext } from '../contexts/AppContext'; import StatsOverview from '../components/stats/StatsOverview'; export const StatsView = React.memo(() => { const { testHistory, words, clearHistoryOnly, dispatch, forceUpdate } = useAppContext(); return ( <StatsOverview testHistory={testHistory} words={words} onClearHistory={clearHistoryOnly} onGoToMain={() => dispatch({ type: 'SET_VIEW', payload: 'main' })} forceUpdate={forceUpdate} /> ); });

================================================================================

NOME FILE: TestView.js

import React, { useState, useEffect, useRef } from 'react'; import { useAppContext } from '../contexts/AppContext'; import { Card } from '../components/ui/card'; import { Button } from '../components/ui/button'; import TestCard from '../components/TestCard'; import { RotateCcw, Check, X, HelpCircle, Clock, Lightbulb } from 'lucide-react'; export const TestView = React.memo(() => { const { currentWord, showMeaning, setShowMeaning, handleAnswer, resetTest, getTestProgress, getTestSummary, showHint, toggleHint, hintUsed, isTransitioning } = useAppContext(); const [currentWordTime, setCurrentWordTime] = useState(0); const [isAnswering, setIsAnswering] = useState(false); const timerRef = useRef(null); const wordStartTimeRef = useRef(null); const progress = getTestProgress(); const summary = getTestSummary(); useEffect(() => { if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } if (currentWord && !isTransitioning && !isAnswering) { setCurrentWordTime(0); wordStartTimeRef.current = Date.now(); timerRef.current = setInterval(() => { if (wordStartTimeRef.current && !isAnswering) { const elapsed = Math.floor((Date.now() - wordStartTimeRef.current) / 1000); setCurrentWordTime(elapsed); } }, 1000); } else if (!currentWord) { setCurrentWordTime(0); wordStartTimeRef.current = null; } return () => { if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } }; }, [currentWord, isTransitioning, isAnswering]); useEffect(() => { return () => { if (timerRef.current) { clearInterval(timerRef.current); } }; }, []); const handleAnswerWithTimer = (isCorrect) => { setIsAnswering(true); if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } handleAnswer(isCorrect); setTimeout(() => { setIsAnswering(false); }, 1000); }; const formatTime = (seconds) => { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }; return ( <> } {summary.avgTimePerWord > 0 && ( <span className="flex items-center gap-1 text-blue-600"> 📊 Media: {summary.avgTimePerWord}s </span> )} {summary.maxTimePerWord > 0 && ( <span className="flex items-center gap-1 text-red-600"> ⏱️ Max: {summary.maxTimePerWord}s </span> )} </div> </div> <div className="text-right"> <div className="flex gap-4"> <div className="text-center"> <div className="text-2xl font-bold text-green-600">{summary.correct}</div> <div className="text-sm text-green-700">Corrette</div> </div> <div className="text-center"> <div className="text-2xl font-bold text-red-600">{summary.incorrect}</div> <div className="text-sm text-red-700">Sbagliate</div> </div> } <div className="relative"> <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden"> <div className="h-full bg-gradient-to-r from-blue-500 to-purple-600 rounded-full transition-all duration-500 ease-out relative" style={{ width: `${progress.percentage}%` }} > <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer"></div> </div> </div> <div className="text-center mt-2 text-sm font-medium text-gray-600"> {progress.percentage}% completato {summary.avgTimePerWord > 0 && ( <span className="ml-4 text-purple-600"> Media: {summary.avgTimePerWord}s/parola </span> )} </div> </div> </div> </div> </Card> } {currentWord && !isTransitioning && ( <div className="relative min-h-[80vh] flex items-center justify-center"> <TestCard word={currentWord} showMeaning={showMeaning} onFlip={() => setShowMeaning(!showMeaning)} showHint={showHint} hintUsed={hintUsed} /> } {currentWord?.sentence && ( <div className="flex justify-center"> <Button onClick={toggleHint} disabled={hintUsed} className={`${ showHint ? 'bg-gradient-to-r from-orange-500 to-yellow-500 hover:from-orange-600 hover:to-yellow-600' : hintUsed ? 'bg-gray-400 cursor-not-allowed' : 'bg-gradient-to-r from-orange-400 to-yellow-400 hover:from-orange-500 hover:to-yellow-500' } text-white px-6 py-3 text-base rounded-xl shadow-lg transform transition-all duration-200 hover:scale-105 border-0 disabled:transform-none disabled:hover:scale-100`} title={hintUsed ? "Aiuto già utilizzato per questa parola" : "Mostra frase di contesto nella carta"} > <HelpCircle className="w-5 h-5 mr-2" /> {showHint ? '🔍 Nascondi Suggerimento' : hintUsed ? '✅ Aiuto Usato' : '💡 Mostra Suggerimento'} </Button> </div> )} } {isTransitioning && ( <div className="min-h-[80vh] flex items-center justify-center"> <div className="text-center"> <div className="text-6xl mb-4 animate-spin">🔄</div> <p className="text-xl text-gray-700 font-medium">Preparando la prossima parola...</p> <p className="text-sm text-gray-500">La carta sta ruotando</p> </div> </div> )}

================================================================================


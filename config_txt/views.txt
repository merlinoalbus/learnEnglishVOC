NOME FILE: AdminView.tsx

import React, { useState, useEffect } from "react"; import { Button } from "../components/ui/button"; import { Input } from "../components/ui/input"; import { Label } from "../components/ui/label"; import { Card, CardContent, CardHeader, CardTitle } from "../components/ui/card"; import { Alert, AlertDescription } from "../components/ui/alert"; import { Shield, Users, Search, Edit2, Trash2, Ban, CheckCircle, AlertCircle, Key, Mail, Eye, EyeOff, UserPlus, } from "lucide-react"; import { useAuth, useUserRole } from "../hooks/integration/useAuth"; import { getAllUsers, updateUserRole, updateUserStatus, getUserPreferences } from "../services/authService"; import { resetPasswordAsAdmin, getPendingUserCreationsCount, cleanupAdminOperations, deleteUserComplete } from "../services/adminService"; import type { User } from "../types/entities/User.types"; export const AdminView: React.FC = () => { const { isAdmin, userProfile } = useUserRole(); const [users, setUsers] = useState<User[]>([]); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); const [searchTerm, setSearchTerm] = useState(""); const [selectedUser, setSelectedUser] = useState<User | null>(null); const [showModal, setShowModal] = useState(false); const [modalType, setModalType] = useState<"edit" | "delete" | "password" | "preferences">("edit"); const [formData, setFormData] = useState({ email: "", displayName: "", role: "user" as "user" | "admin", }); const [showPassword, setShowPassword] = useState(false); const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null); const [pendingCount, setPendingCount] = useState<number>(0); const [userPreferences, setUserPreferences] = useState<any>(null); const [loadingPreferences, setLoadingPreferences] = useState(false); useEffect(() => { const loadData = async () => { try { setLoading(true); setError(null); const [realUsers, pending] = await Promise.all([ getAllUsers(), getPendingUserCreationsCount() ]); setUsers(realUsers); setPendingCount(pending); } catch (err) { console.error('Error loading data:', err); setError('Errore nel caricamento dati'); } finally { setLoading(false); } }; loadData(); }, []); useEffect(() => { const handleAdminUsersProcessed = async () => { try { const pending = await getPendingUserCreationsCount(); setPendingCount(pending); const realUsers = await getAllUsers(); setUsers(realUsers); setMessage({ type: "success", text: "Utenti in coda processati con successo" }); } catch (error) { console.error("Error refreshing data after processing:", error); } }; window.addEventListener('adminUsersProcessed', handleAdminUsersProcessed); return () => window.removeEventListener('adminUsersProcessed', handleAdminUsersProcessed); }, []); const filteredUsers = users.filter(user => user.email.toLowerCase().includes(searchTerm.toLowerCase()) || (user.displayName || "").toLowerCase().includes(searchTerm.toLowerCase()) ); const handleOpenModal = async (type: typeof modalType, user?: User) => { setModalType(type); setSelectedUser(user || null); if (user) { setFormData({ email: user.email, displayName: user.displayName || "", role: user.role, }); if (type === "preferences") { setLoadingPreferences(true); try { const preferences = await getUserPreferences(user.id); setUserPreferences(preferences); } catch (error) { console.error("Error loading user preferences:", error); setMessage({ type: "error", text: "Errore nel caricamento delle preferenze utente" }); } finally { setLoadingPreferences(false); } } } else { setFormData({ email: "", displayName: "", role: "user", }); } setShowModal(true); setMessage(null); }; const handleCloseModal = () => { setShowModal(false); setSelectedUser(null); setFormData({ email: "", displayName: "", role: "user", }); setUserPreferences(null); setMessage(null); }; const handleToggleUserStatus = async (userId: string) => { if (!userProfile?.id) return; try { const user = users.find(u => u.id === userId); if (!user) return; await updateUserStatus(userId, !user.isActive, userProfile.id); setUsers(prev => prev.map(u => u.id === userId ? { ...u, isActive: !u.isActive } : u )); setMessage({ type: "success", text: `Utente ${user.isActive ? 'disattivato' : 'attivato'} con successo` }); } catch (error) { setMessage({ type: "error", text: "Errore nell'aggiornamento dello stato utente" }); } }; const handleDeleteUser = async (userId: string) => { if (!userProfile?.id) return; if (userId === userProfile.id) { setMessage({ type: "error", text: "Non puoi eliminare il tuo stesso account" }); return; } try { const result = await deleteUserComplete(userId, userProfile.id); if (result.success) { setUsers(prev => prev.filter(user => user.id !== userId)); setMessage({ type: "success", text: result.message }); } else { setMessage({ type: "error", text: result.message }); } handleCloseModal(); } catch (error) { setMessage({ type: "error", text: "Errore nell'eliminazione dell'utente" }); } }; const handleUpdateUser = async () => { if (!selectedUser || !userProfile?.id) return; try { if (selectedUser.role !== formData.role) { await updateUserRole(selectedUser.id, formData.role, userProfile.id); } if (selectedUser.displayName !== formData.displayName) { } setUsers(prev => prev.map(user => user.id === selectedUser.id ? { ...user, displayName: formData.displayName, role: formData.role, } : user )); setMessage({ type: "success", text: "Utente aggiornato con successo" }); handleCloseModal(); } catch (error) { setMessage({ type: "error", text: "Errore nell'aggiornamento dell'utente" }); } }; const handleCleanupOperations = async () => { try { setLoading(true); const result = await cleanupAdminOperations(); setMessage({ type: "success", text: `Cleanup completato: ${result.deleted} operazioni amministrative rimosse` }); } catch (error) { console.error("Cleanup error:", error); setMessage({ type: "error", text: "Errore durante il cleanup delle operazioni amministrative" }); } finally { setLoading(false); } }; const handleResetPassword = async () => { if (!selectedUser?.email) { setMessage({ type: "error", text: "Email utente non trovata" }); return; } try { setLoading(true); setMessage(null); const success = await resetPasswordAsAdmin(selectedUser.email); if (success) { setMessage({ type: "success", text: `Email di reset password inviata a ${selectedUser.email}. L'utente riceverà le istruzioni per reimpostare la password.` }); handleCloseModal(); } } catch (error: any) { console.error("Error sending password reset email:", error); let errorMessage = "Errore nell'invio dell'email di reset"; if (error.code === 'auth/user-not-found') { errorMessage = "Utente non trovato"; } else if (error.code === 'auth/invalid-email') { errorMessage = "Email non valida"; } setMessage({ type: "error", text: errorMessage }); } finally { setLoading(false); } }; const formatDate = (date: Date | undefined) => { if (!date) return 'N/A'; return new Date(date).toLocaleDateString('it-IT', { year: 'numeric', month: 'short', day: 'numeric' }); }; if (!isAdmin) { return ( <div className="flex items-center justify-center min-h-screen"> <Card className="w-96"> <CardContent className="p-6 text-center"> <AlertCircle className="w-12 h-12 text-red-500 mx-auto mb-4" /> <h2 className="text-xl font-bold text-gray-900 dark:text-gray-100 mb-2">Accesso Negato</h2> <p className="text-gray-600 dark:text-gray-400">Non hai i permessi per accedere a questa sezione.</p> </CardContent> </Card> </div> ); } if (loading) { return ( <div className="flex items-center justify-center min-h-screen"> <div className="text-center"> <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div> <p className="mt-4 text-gray-600 dark:text-gray-400">Caricamento utenti...</p> </div> </div> ); } if (error) { return ( <div className="flex items-center justify-center min-h-screen"> <Card className="w-96"> <CardContent className="p-6 text-center"> <AlertCircle className="w-12 h-12 text-red-500 mx-auto mb-4" /> <h2 className="text-xl font-bold text-gray-900 dark:text-gray-100 mb-2">Errore di Caricamento</h2> <p className="text-gray-600 dark:text-gray-400 mb-4">{error}</p> <Button onClick={() => window.location.reload()}> Ricarica Pagina </Button> </CardContent> </Card> </div> ); } return ( <div className="max-w-6xl mx-auto p-6 space-y-6"> } {pendingCount > 0 && ( <Alert className="border-orange-200 bg-orange-50"> <UserPlus className="h-4 w-4 text-orange-600" /> <AlertDescription className="text-orange-800"> Ci sono <strong>{pendingCount}</strong> utenti in coda di creazione. Verranno creati al prossimo logout/login dell'admin. </AlertDescription> </Alert> )} } <div className="grid grid-cols-1 md:grid-cols-4 gap-4"> <Card> <CardContent className="p-4"> <div className="flex items-center justify-between"> <div> <p className="text-sm text-gray-600 dark:text-gray-400">Totale Utenti</p> <p className="text-2xl font-bold text-gray-900 dark:text-gray-100">{users.length}</p> </div> <Users className="w-8 h-8 text-blue-500" /> </div> </CardContent> </Card> <Card> <CardContent className="p-4"> <div className="flex items-center justify-between"> <div> <p className="text-sm text-gray-600 dark:text-gray-400">Utenti Attivi</p> <p className="text-2xl font-bold text-green-600">{users.filter(u => u.isActive).length}</p> </div> <CheckCircle className="w-8 h-8 text-green-500" /> </div> </CardContent> </Card> <Card> <CardContent className="p-4"> <div className="flex items-center justify-between"> <div> <p className="text-sm text-gray-600 dark:text-gray-400">Amministratori</p> <p className="text-2xl font-bold text-purple-600">{users.filter(u => u.role === "admin").length}</p> </div> <Shield className="w-8 h-8 text-purple-500" /> </div> </CardContent> </Card> <Card> <CardContent className="p-4"> <div className="flex items-center justify-between"> <div> <p className="text-sm text-gray-600 dark:text-gray-400">Utenti in Coda</p> <p className="text-2xl font-bold text-orange-600">{pendingCount}</p> </div> <UserPlus className="w-8 h-8 text-orange-500" /> </div> </CardContent> </Card> </div> } {showModal && ( <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"> <div className="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg p-6 w-full max-w-md"> <h3 className="text-lg font-bold mb-4"> {modalType === "edit" && "Modifica Utente"} {modalType === "password" && "Reimposta Password"} {modalType === "delete" && "Elimina Utente"} {modalType === "preferences" && "Preferenze Utente"} </h3> {modalType === "delete" ? ( <div className="space-y-4"> <p className="text-gray-600 dark:text-gray-400"> Sei sicuro di voler eliminare l'utente <strong>{selectedUser?.displayName}</strong>? Questa azione non può essere annullata. </p> <div className="flex justify-end gap-2"> <Button onClick={handleCloseModal} variant="outline"> Annulla </Button> <Button onClick={() => handleDeleteUser(selectedUser?.id || "")} variant="destructive" > Elimina </Button> </div> </div> ) : ( <div className="space-y-4"> {modalType === "edit" && ( <> <div> <Label htmlFor="email">Email</Label> <Input id="email" type="email" value={formData.email} onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))} disabled={true} /> </div> <div> <Label htmlFor="displayName">Nome</Label> <Input id="displayName" value={formData.displayName} onChange={(e) => setFormData(prev => ({ ...prev, displayName: e.target.value }))} /> </div> <div> <Label htmlFor="role">Ruolo</Label> <select id="role" value={formData.role} onChange={(e) => setFormData(prev => ({ ...prev, role: e.target.value as "user" | "admin" }))} className="w-full p-2 border border-gray-300 rounded-md" > <option value="user">Utente</option> <option value="admin">Amministratore</option> </select> </div> </> )} {modalType === "password" && ( <div className="space-y-4"> <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4"> <div className="flex items-start space-x-3"> <Mail className="w-5 h-5 text-blue-600 mt-0.5" /> <div> <h4 className="font-medium text-blue-900 dark:text-blue-100">Reset Password</h4> <p className="text-sm text-blue-700 dark:text-blue-300 mt-1"> Verrà inviata un'email di reset password a <strong>{selectedUser?.email}</strong>. L'utente riceverà un link sicuro per impostare una nuova password. </p> </div> </div> </div> <p className="text-sm text-gray-600 dark:text-gray-400"> Questa operazione invierà immediatamente un'email con le istruzioni per il reset della password. L'utente potrà scegliere liberamente la nuova password seguendo il link ricevuto. </p> </div> )} {modalType === "preferences" && ( <div className="space-y-4"> {loadingPreferences ? ( <div className="text-center py-4"> <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-2"></div> <p className="text-sm text-gray-600 dark:text-gray-400">Caricamento preferenze...</p> </div> ) : userPreferences ? ( <div className="space-y-3"> <div className="grid grid-cols-2 gap-4"> <div> <label className="text-sm font-medium text-gray-700 dark:text-gray-300">Tema</label> <p className="text-sm text-gray-600 dark:text-gray-400">{userPreferences.theme || 'N/A'}</p> </div> <div> <label className="text-sm font-medium text-gray-700 dark:text-gray-300">Lingua</label> <p className="text-sm text-gray-600 dark:text-gray-400">{userPreferences.interfaceLanguage || 'N/A'}</p> </div> </div> {userPreferences.notifications && ( <div> <label className="text-sm font-medium text-gray-700 dark:text-gray-300">Notifiche</label> <div className="text-sm text-gray-600 dark:text-gray-400 mt-1"> <div>Email: {userPreferences.notifications.email ? 'Attive' : 'Disattive'}</div> <div>Push: {userPreferences.notifications.push ? 'Attive' : 'Disattive'}</div> <div>In-App: {userPreferences.notifications.inApp ? 'Attive' : 'Disattive'}</div> </div> </div> )} {userPreferences.privacy && ( <div> <label className="text-sm font-medium text-gray-700 dark:text-gray-300">Privacy</label> <div className="text-sm text-gray-600 dark:text-gray-400 mt-1"> <div>Profilo visibile: {userPreferences.privacy.showProfile ? 'Sì' : 'No'}</div> <div>Statistiche visibili: {userPreferences.privacy.showStats ? 'Sì' : 'No'}</div> </div> </div> )} {userPreferences.testPreferences && ( <div> <label className="text-sm font-medium text-gray-700 dark:text-gray-300">Test</label> <div className="text-sm text-gray-600 dark:text-gray-400 mt-1"> <div>Modalità: {userPreferences.testPreferences.defaultTestMode || 'N/A'}</div> <div>Parole per test: {userPreferences.testPreferences.defaultWordsPerTest || 'N/A'}</div> <div>Hints: {userPreferences.testPreferences.hintsEnabled ? 'Attivi' : 'Disattivi'}</div> </div> </div> )} </div> ) : ( <div className="text-center py-4"> <p className="text-sm text-gray-600 dark:text-gray-400">Nessuna preferenza trovata per questo utente.</p> </div> )} </div> )} {message && ( <Alert className={message.type === "success" ? "border-green-200 bg-green-50" : "border-red-200 bg-red-50"}> <AlertDescription className={message.type === "success" ? "text-green-800" : "text-red-800"}> {message.text} </AlertDescription> </Alert> )} <div className="flex justify-end gap-2"> <Button onClick={handleCloseModal} variant="outline"> {modalType === "preferences" ? "Chiudi" : "Annulla"} </Button> {modalType !== "preferences" && ( <Button onClick={() => { if (modalType === "edit") handleUpdateUser(); else if (modalType === "password") handleResetPassword(); }} > {modalType === "edit" && "Salva"} {modalType === "password" && "Reimposta"} </Button> )} </div> </div> )} </div> </div> )} </div> ); };

================================================================================

NOME FILE: AuthView.tsx

import React, { useState, useEffect } from "react"; import { AuthLayout } from "../layouts/AuthLayout"; import { LoginForm } from "../components/auth/LoginForm"; import { SignUpForm } from "../components/auth/SignUpForm"; import { ForgotPasswordForm } from "../components/auth/ForgotPasswordForm"; import { AuthActionHandler } from "../components/auth/AuthActionHandler"; import { useAuth } from "../hooks/integration/useAuth"; import { useAppContext } from "../contexts/AppContext"; type AuthMode = "login" | "signup" | "forgot-password" | "auth-action"; interface AuthViewProps { onAuthSuccess?: () => void; initialMode?: AuthMode; } interface AuthConfig { title: string; subtitle: string; } export const AuthView: React.FC<AuthViewProps> = ({ onAuthSuccess, initialMode = "login", }) => { const { authReturnContext } = useAppContext(); const determineInitialMode = (): AuthMode => { if (authReturnContext?.source === "signup") { return "signup"; } return initialMode; }; const [currentMode, setCurrentMode] = useState<AuthMode>(determineInitialMode()); const { isAuthenticated, isReady } = useAuth(); const [authActionParams, setAuthActionParams] = useState<{ mode: string; oobCode: string; apiKey: string; } | null>(null); useEffect(() => { const urlParams = new URLSearchParams(window.location.search); const mode = urlParams.get("mode"); const oobCode = urlParams.get("oobCode"); const apiKey = urlParams.get("apiKey"); if (mode && oobCode && apiKey) { setAuthActionParams({ mode, oobCode, apiKey }); setCurrentMode("auth-action"); } }, []); useEffect(() => { if (authReturnContext?.source === "signup") { setCurrentMode("signup"); } }, [authReturnContext]); useEffect(() => { if (isReady && isAuthenticated) { onAuthSuccess?.(); } }, [isReady, isAuthenticated, onAuthSuccess]); const getAuthConfig = (mode: AuthMode): AuthConfig => { switch (mode) { case "login": return { title: "Bentornato!", subtitle: "Accedi al tuo account per continuare il tuo percorso di apprendimento", }; case "signup": return { title: "Inizia ora!", subtitle: "Crea il tuo account e inizia a migliorare il tuo inglese", }; case "forgot-password": return { title: "Recupera password", subtitle: "Ti invieremo le istruzioni per reimpostare la tua password", }; case "auth-action": return { title: "Elaborazione in corso...", subtitle: "Stiamo processando la tua richiesta", }; default: return getAuthConfig("login"); } }; const config = getAuthConfig(currentMode); const renderAuthForm = () => { switch (currentMode) { case "login": return ( <LoginForm onSwitchToSignUp={() => setCurrentMode("signup")} onSwitchToForgotPassword={() => setCurrentMode("forgot-password")} onLoginSuccess={onAuthSuccess} /> ); case "signup": return ( <SignUpForm onSwitchToLogin={() => setCurrentMode("login")} onSignUpSuccess={onAuthSuccess} /> ); case "forgot-password": return ( <ForgotPasswordForm onSwitchToLogin={() => setCurrentMode("login")} /> ); case "auth-action": return authActionParams ? ( <AuthActionHandler mode={authActionParams.mode} oobCode={authActionParams.oobCode} apiKey={authActionParams.apiKey} onComplete={() => setCurrentMode("login")} /> ) : null; default: return null; } }; if (currentMode === "auth-action") { return renderAuthForm(); } return ( <AuthLayout title={config.title} subtitle={config.subtitle}> {renderAuthForm()} </AuthLayout> ); };

================================================================================

NOME FILE: MainView.tsx

import React from 'react'; import { useAppContext } from '../contexts/AppContext'; import { useNotification } from '../contexts/NotificationContext'; import { ControlPanel } from '../components/main/ControlPanel'; import JSONManager from '../components/JSONManager'; import AddWordForm from '../components/AddWordForm'; import WordsList from '../components/WordsList'; import { Word, CreateWordInput, UpdateWordInput } from '../types'; export const MainView: React.FC = React.memo(() => { const { words, editingWord, showWordsList, dispatch, addWord, updateWord, toggleWordLearned, toggleWordDifficult, importWords, forceRefresh, getAvailableChapters, getChapterStats, wordStats } = useAppContext(); const { showSuccess, showError, showWarning } = useNotification(); React.useEffect(() => { console.log('MainView - wordStats:', wordStats); console.log('MainView - words length:', words.length); }, [wordStats, words]); const handleStartTest = React.useCallback(() => { const availableWords = words.filter(word => !word.learned); if (availableWords.length === 0) { showWarning('⚠️ Nessuna parola disponibile per il test!'); return; } dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: true }); }, [words, dispatch, showWarning]); const handleAddWord = React.useCallback(async (wordData: CreateWordInput) => { try { addWord(wordData); dispatch({ type: 'SET_EDITING_WORD', payload: null }); showSuccess( editingWord ? `✅ Parola "${wordData.english}" modificata!` : `✅ Parola "${wordData.english}" aggiunta!` ); } catch (error) { console.error('MainView: Error adding word:', error); showError(error instanceof Error ? error : new Error('Unknown error'), 'Add Word'); } }, [addWord, editingWord, dispatch, showSuccess, showError]); const handleUpdateWord = React.useCallback(async (wordData: UpdateWordInput) => { try { const result = await updateWord(wordData.id, wordData); if (result.success) { dispatch({ type: 'SET_EDITING_WORD', payload: null }); showSuccess(`✅ Parola "${wordData.english}" modificata!`); } else { console.error('MainView: Error updating word:', result.error); if (result.warning) { showError(new Error(result.warning), 'Attenzione'); } else { showError(result.error || new Error('Failed to update word'), 'Update Word'); } } } catch (error) { console.error('MainView: Error updating word:', error); showError(error instanceof Error ? error : new Error('Unknown error'), 'Update Word'); } }, [updateWord, dispatch, showSuccess, showError]); const handleRemoveWord = React.useCallback((id: string) => { const wordToDelete = words.find(word => word.id === id); if (wordToDelete) { dispatch({ type: 'SET_CONFIRM_DELETE', payload: wordToDelete }); } }, [words, dispatch]); const handleToggleWordLearned = React.useCallback((id: string) => { const word = words.find(w => w.id === id); if (word) { toggleWordLearned(id); showSuccess( !word.learned ? `📖 "${word.english}" segnata come da studiare` : `✅ "${word.english}" segnata come appresa!` ); } }, [words, toggleWordLearned, showSuccess]); const handleToggleWordDifficult = React.useCallback((id: string) => { const word = words.find(w => w.id === id); if (word) { toggleWordDifficult(id); showSuccess( !word.difficult ? `📚 "${word.english}" rimossa dalle parole difficili` : `⭐ "${word.english}" segnata come difficile!` ); } }, [words, toggleWordDifficult, showSuccess]); const handleImportWords = React.useCallback(async (jsonText: string): Promise<number> => { try { const count = await importWords(JSON.parse(jsonText)); if (forceRefresh) { setTimeout(forceRefresh, 100); } const imported = typeof count === 'number' ? count : count?.imported || 0; showSuccess(`✅ ${imported} parole importate con successo!`); return imported; } catch (error) { console.error('MainView: Import error:', error); const errorMessage = error instanceof Error ? error.message : 'Unknown error'; if (errorMessage.includes('already exist')) { showWarning('⚠️ Tutte le parole nel JSON sono già presenti nel vocabolario.'); } else if (errorMessage.includes('JSON')) { showError(new Error('❌ File JSON non valido. Controlla la sintassi.'), 'Import Words'); } else { showError(error instanceof Error ? error : new Error(errorMessage), 'Import Words'); } throw error; } }, [importWords, forceRefresh, showSuccess, showError, showWarning]); const handleEditWord = React.useCallback((word: Word) => { if (!word || !word.id) { showError(new Error('Impossibile modificare: parola non valida'), 'Edit Word'); return; } const existingWord = words.find(w => w.id === word.id); if (!existingWord) { showError(new Error('Parola non trovata nel vocabolario'), 'Edit Word'); console.error('Word not found in words list:', word.id, 'Available IDs:', words.map(w => w.id)); if (forceRefresh) { forceRefresh(); setTimeout(() => { const refreshedWord = words.find(w => w.english === word.english); if (refreshedWord) { dispatch({ type: 'SET_EDITING_WORD', payload: refreshedWord }); } }, 500); } return; } dispatch({ type: 'SET_EDITING_WORD', payload: existingWord }); }, [words, dispatch, showError, forceRefresh]); return ( <div className="space-y-8 animate-fade-in"> <ControlPanel {...{ onStartTest: handleStartTest, onClearAllWords: () => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: true }), words: words, wordStats: { ...wordStats, unlearned: wordStats.total - wordStats.learned, normal: wordStats.total - wordStats.learned - wordStats.difficult, completionPercentage: wordStats.total > 0 ? Math.round((wordStats.learned / wordStats.total) * 100) : 0, byCategory: {}, byChapter: {} }, getAvailableChapters: getAvailableChapters }} /> <JSONManager words={words} onImportWords={handleImportWords} /> <AddWordForm onAddWord={handleAddWord} onUpdateWord={handleUpdateWord} editingWord={editingWord} onClearForm={() => dispatch({ type: 'SET_EDITING_WORD', payload: null })} /> <WordsList words={words} onEditWord={handleEditWord} onRemoveWord={handleRemoveWord} onToggleLearned={handleToggleWordLearned} onToggleDifficult={handleToggleWordDifficult} showWordsList={showWordsList} setShowWordsList={() => dispatch({ type: 'TOGGLE_WORDS_LIST' })} /> </div> ); }); MainView.displayName = 'MainView';

================================================================================

NOME FILE: PrivacyPolicyView.tsx

import React from "react"; import { Button } from "../components/ui/button"; import { Card, CardContent, CardHeader, CardTitle } from "../components/ui/card"; import { ArrowLeft, Shield } from "lucide-react"; import { useAppContext } from "../contexts/AppContext"; import { useAuth } from "../hooks/integration/useAuth"; export const PrivacyPolicyView: React.FC = () => { const { dispatch, authReturnContext } = useAppContext(); const { isAuthenticated } = useAuth(); const handleGoBack = () => { if (authReturnContext && authReturnContext.source === "signup") { dispatch({ type: "GO_BACK" }); } else if (!isAuthenticated) { dispatch({ type: "GO_BACK" }); } else { dispatch({ type: "GO_BACK" }); } }; return ( <div className="min-h-screen bg-gray-50 dark:bg-gray-900 py-8 px-4"> <div className="max-w-4xl mx-auto">

================================================================================

NOME FILE: ProfileView.tsx

import React, { useState, useEffect } from "react"; import { Button } from "../components/ui/button"; import { Input } from "../components/ui/input"; import { Label } from "../components/ui/label"; import { Card, CardContent, CardHeader, CardTitle } from "../components/ui/card"; import { Alert, AlertDescription } from "../components/ui/alert"; import { User, Mail, Shield, Calendar, CheckCircle, Edit2, Save, X, Camera, AlertCircle, Globe, Target, BookOpen, Award, Zap, TrendingUp, Heart, Star, Languages, Brain, Clock, Trophy, Flag, MapPin, } from "lucide-react"; import { useAuth, useUserRole } from "../hooks/integration/useAuth"; import { useAppContext } from "../contexts/AppContext"; import { getUserStats } from "../services/authService"; export const ProfileView: React.FC = () => { const { user, userProfile, updateProfile, loading, authUser } = useAuth(); const { role, isAdmin } = useUserRole(); const { testHistory } = useAppContext(); const [isEditing, setIsEditing] = useState(false); const [formData, setFormData] = useState({ displayName: userProfile?.displayName || user?.displayName || authUser?.displayName || "", email: userProfile?.email || user?.email || authUser?.email || "", }); const [updateLoading, setUpdateLoading] = useState(false); const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null); useEffect(() => { setFormData({ displayName: userProfile?.displayName || user?.displayName || authUser?.displayName || "", email: userProfile?.email || user?.email || authUser?.email || "", }); }, [userProfile, user, authUser]); const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>) => { const file = event.target.files?.[0]; if (!file) return; if (!file.type.startsWith('image/')) { setMessage({ type: "error", text: "Seleziona un file immagine valido" }); return; } if (file.size > 5 * 1024 * 1024) { setMessage({ type: "error", text: "L'immagine deve essere inferiore a 5MB" }); return; } try { setUpdateLoading(true); setMessage(null); const reader = new FileReader(); reader.onload = async (e) => { const base64String = e.target?.result as string; try { const success = await updateProfile({ photoURL: base64String, }); if (success) { setMessage({ type: "success", text: "Foto profilo aggiornata con successo!" }); } else { setMessage({ type: "error", text: "Errore durante l'aggiornamento della foto" }); } } catch (error) { setMessage({ type: "error", text: "Errore durante l'aggiornamento della foto" }); } finally { setUpdateLoading(false); } }; reader.readAsDataURL(file); } catch (error) { setMessage({ type: "error", text: "Errore durante il caricamento dell'immagine" }); setUpdateLoading(false); } }; const handleInputChange = (field: keyof typeof formData, value: string) => { setFormData(prev => ({ ...prev, [field]: value })); }; const handleSave = async () => { if (!formData.displayName.trim()) { setMessage({ type: "error", text: "Il nome non può essere vuoto" }); return; } setUpdateLoading(true); setMessage(null); try { const success = await updateProfile({ displayName: formData.displayName.trim(), }); if (success) { setMessage({ type: "success", text: "Profilo aggiornato con successo!" }); setIsEditing(false); } else { setMessage({ type: "error", text: "Errore durante l'aggiornamento del profilo" }); } } catch (error) { setMessage({ type: "error", text: "Errore durante l'aggiornamento del profilo" }); } finally { setUpdateLoading(false); } }; const handleCancel = () => { setFormData({ displayName: userProfile?.displayName || user?.displayName || authUser?.displayName || "", email: userProfile?.email || user?.email || authUser?.email || "", }); setIsEditing(false); setMessage(null); }; const formatDate = (date: Date | string | undefined) => { if (!date) return "Data non disponibile"; const d = new Date(date); return d.toLocaleDateString('it-IT', { year: 'numeric', month: 'long', day: 'numeric' }); }; const [stats, setStats] = useState({ testsCompleted: 0, studyDays: 0, averageAccuracy: 0 }); useEffect(() => { const loadStats = async () => { if (!userProfile?.id) return; try { const userStats = await getUserStats(userProfile.id); if (userStats) { setStats({ testsCompleted: userStats.totalTestsCompleted, studyDays: userStats.totalActiveDays, averageAccuracy: userStats.averageTestAccuracy }); } else { if (testHistory && testHistory.length > 0) { const totalTests = testHistory.length; const totalScore = testHistory.reduce((sum: number, test: any) => sum + (test.percentage || 0), 0); const averageAccuracy = totalTests > 0 ? Math.round(totalScore / totalTests) : 0; const uniqueDates = new Set( testHistory.map((test: any) => new Date(test.timestamp).toDateString()) ); const studyDays = uniqueDates.size; setStats({ testsCompleted: totalTests, studyDays: studyDays, averageAccuracy: averageAccuracy }); } } } catch (error) { console.error('Error loading stats:', error); } }; loadStats(); }, [userProfile?.id, testHistory]); if (loading) { return ( <div className="flex items-center justify-center min-h-screen"> <div className="text-center"> <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div> <p className="mt-4 text-gray-600 dark:text-gray-400 dark:text-gray-500">Caricamento profilo...</p> </div> </div> ); } return ( <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900"> } <div className="relative"> <div className="w-24 h-24 rounded-full bg-white/20 backdrop-blur-sm border-4 border-white/30 flex items-center justify-center text-white text-3xl font-bold overflow-hidden shadow-xl"> {(userProfile?.photoURL || user?.photoURL || authUser?.photoURL) ? ( <img src={(userProfile?.photoURL || user?.photoURL || authUser?.photoURL)!} alt="Profile" className="w-full h-full object-cover" /> ) : ( formData.displayName.charAt(0).toUpperCase() || "U" )} </div> } <div className="flex items-center gap-3 mt-4"> {role === "admin" && ( <span className="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium bg-purple-500/20 backdrop-blur-sm border border-purple-300/30 text-white"> <Shield className="w-4 h-4" /> Amministratore </span> )} {(userProfile?.emailVerified || user?.emailVerified || authUser?.emailVerified) && ( <span className="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium bg-green-500/20 backdrop-blur-sm border border-green-300/30 text-white"> <CheckCircle className="w-4 h-4" /> Verificato </span> )} <span className="inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium bg-blue-500/20 backdrop-blur-sm border border-blue-300/30 text-white"> <Globe className="w-4 h-4" /> {userProfile?.englishLevel || user?.englishLevel || "Principiante"} </span> </div> </div> </div> </div> </div> </div> } {message && ( <Alert className={message.type === "success" ? "border-green-200 bg-green-50" : "border-red-200 bg-red-50"}> {message.type === "success" ? ( <CheckCircle className="h-4 w-4 text-green-600" /> ) : ( <AlertCircle className="h-4 w-4 text-red-600" /> )} <AlertDescription className={message.type === "success" ? "text-green-800" : "text-red-800"}> {message.text} </AlertDescription> </Alert> )} <div className="grid grid-cols-1 lg:grid-cols-3 gap-8"> } <div className="flex items-center gap-4"> <div className="w-20 h-20 bg-gradient-to-r from-indigo-500 to-purple-600 rounded-full flex items-center justify-center text-white text-2xl font-bold overflow-hidden"> {(userProfile?.photoURL || user?.photoURL || authUser?.photoURL) ? ( <img src={(userProfile?.photoURL || user?.photoURL || authUser?.photoURL)!} alt="Profile" className="w-full h-full object-cover" /> ) : ( formData.displayName.charAt(0).toUpperCase() || "U" )} </div> <div> <p className="text-sm text-gray-600 dark:text-gray-400 dark:text-gray-500">Foto profilo</p> <div className="relative"> <input type="file" accept="image/*" onChange={handleImageUpload} className="absolute inset-0 opacity-0 cursor-pointer" disabled={updateLoading} /> <Button variant="outline" size="sm" className="mt-1" disabled={updateLoading} > <Camera className="w-4 h-4 mr-2" /> {updateLoading ? "Caricamento..." : "Cambia foto"} </Button> </div> </div> </div> } <div className="grid grid-cols-1 md:grid-cols-2 gap-6"> } <div className="p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg border border-purple-200 dark:border-purple-800"> <Label className="text-sm font-medium text-purple-700 dark:text-purple-300 flex items-center gap-2"> <Shield className="w-4 h-4" /> Ruolo </Label> <div className="mt-2 flex items-center gap-2"> <span className="text-gray-900 dark:text-gray-100 font-medium"> {isAdmin ? "Amministratore" : "Utente"} </span> </div> </div> } <div className="p-4 bg-orange-50 dark:bg-orange-900/20 rounded-lg border border-orange-200 dark:border-orange-800"> <Label className="text-sm font-medium text-orange-700 dark:text-orange-300 flex items-center gap-2"> <Clock className="w-4 h-4" /> Ultimo accesso </Label> <div className="mt-2"> <span className="text-gray-900 dark:text-gray-100 font-medium">{formatDate(userProfile?.lastLoginAt || user?.lastLoginAt)}</span> </div> </div> } <div className="p-4 bg-pink-50 dark:bg-pink-900/20 rounded-lg border border-pink-200 dark:border-pink-800"> <Label className="text-sm font-medium text-pink-700 dark:text-pink-300 flex items-center gap-2"> <MapPin className="w-4 h-4" /> Lingua nativa </Label> <div className="mt-2"> <span className="text-gray-900 dark:text-gray-100 font-medium">{userProfile?.nativeLanguage || user?.nativeLanguage || "Non specificato"}</span> </div> </div> } <div className="p-4 bg-cyan-50 dark:bg-cyan-900/20 rounded-lg border border-cyan-200 dark:border-cyan-800"> <Label className="text-sm font-medium text-cyan-700 dark:text-cyan-300 flex items-center gap-2"> <Flag className="w-4 h-4" /> Obiettivo di apprendimento </Label> <div className="mt-2"> <span className="text-gray-900 dark:text-gray-100 font-medium">{userProfile?.learningGoal || user?.learningGoal || "Non specificato"}</span> </div> </div> } <div className="p-4 bg-rose-50 dark:bg-rose-900/20 rounded-lg border border-rose-200 dark:border-rose-800"> <Label className="text-sm font-medium text-rose-700 dark:text-rose-300 flex items-center gap-2"> <BookOpen className="w-4 h-4" /> Test target settimanali </Label> <div className="mt-2"> <span className="text-gray-900 dark:text-gray-100 font-medium">{userProfile?.weeklyTestTarget || user?.weeklyTestTarget || "Non specificato"}</span> </div> </div> </div> } <div className="space-y-6"> } <div className="grid grid-cols-1 lg:grid-cols-2 gap-4"> <Card className="bg-gradient-to-r from-red-500 to-red-600 text-white border-0 shadow-lg hover:shadow-xl transition-shadow"> <CardContent className="p-6 text-center"> <Trophy className="w-8 h-8 mx-auto mb-3 text-white/80" /> <div className="text-3xl font-bold mb-1">{userProfile?.longestStreak || user?.longestStreak || 0}</div> <div className="text-sm text-white/80">Streak record</div> </CardContent> </Card> <Card className="bg-gradient-to-r from-indigo-500 to-indigo-600 text-white border-0 shadow-lg hover:shadow-xl transition-shadow"> <CardContent className="p-6 text-center"> <TrendingUp className="w-8 h-8 mx-auto mb-3 text-white/80" /> <div className="text-3xl font-bold mb-1">{userProfile?.progressLevel || user?.progressLevel || 1}</div> <div className="text-sm text-white/80">Livello progresso</div> </CardContent> </Card> </div>

================================================================================

NOME FILE: ResultsView.tsx

import React from 'react'; import { useAppContext } from '../contexts/AppContext'; import TestResults from '../components/TestResults'; export const ResultsView: React.FC = React.memo(() => { const { wrongWords, startNewTest, resetTest, getTestSummary } = useAppContext(); const getTestResultData = () => { const summary = getTestSummary && getTestSummary(); if (summary && (summary.correct >= 0 || summary.incorrect >= 0)) { const processedData = { correct: summary.correct || 0, incorrect: summary.incorrect || 0, hints: summary.hints || 0, totalTime: summary.totalTime || 0, avgTimePerWord: summary.avgTimePerWord || 0, maxTimePerWord: summary.maxTimePerWord || 0, minTimePerWord: summary.minTimePerWord || 0, totalRecordedTime: summary.totalRecordedTime || 0, total: summary.total || (summary.correct + summary.incorrect), answered: summary.answered || (summary.correct + summary.incorrect), accuracy: summary.accuracy || 0, percentage: summary.percentage || 0 }; return processedData; } if (wrongWords && Array.isArray(wrongWords)) { const incorrect = wrongWords.length; const fallbackData = { correct: 0, incorrect, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0, total: incorrect, answered: incorrect, accuracy: 0, percentage: 0 }; return fallbackData; } return null; }; return ( <TestResults stats={getTestResultData() || { correct: 0, incorrect: 0, hints: 0, totalTime: 0, avgTimePerWord: 0, maxTimePerWord: 0, minTimePerWord: 0, totalRecordedTime: 0 }} wrongWords={wrongWords} onStartNewTest={startNewTest} onResetTest={resetTest} /> ); }); ResultsView.displayName = 'ResultsView';

================================================================================

NOME FILE: SettingsView.tsx

import React, { useState, useEffect } from "react"; import { Button } from "../components/ui/button"; import { Input } from "../components/ui/input"; import { Label } from "../components/ui/label"; import { Card, CardContent, CardHeader, CardTitle } from "../components/ui/card"; import { Alert, AlertDescription } from "../components/ui/alert"; import { Settings, Lock, Shield, Bell, Palette, Globe, Trash2, Eye, EyeOff, CheckCircle, AlertCircle, Loader2, Sun, Moon, Mail, MessageSquare, Key, Sparkles, Zap, Star, } from "lucide-react"; import { useAuth, useUserRole } from "../hooks/integration/useAuth"; import { getUserPreferences, updateUserTheme, updateNotificationPreferences } from "../services/authService"; export const SettingsView: React.FC = () => { const { user, userProfile, updatePassword, loading } = useAuth(); const { isAdmin } = useUserRole(); const [passwordForm, setPasswordForm] = useState({ currentPassword: "", newPassword: "", confirmPassword: "", }); const [showPasswords, setShowPasswords] = useState({ current: false, new: false, confirm: false, }); const [updateLoading, setUpdateLoading] = useState(false); const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null); const [preferencesLoading, setPreferencesLoading] = useState(true); const [darkMode, setDarkMode] = useState(false); const [emailNotifications, setEmailNotifications] = useState(true); const [studyReminders, setStudyReminders] = useState(true); useEffect(() => { const loadPreferences = async () => { if (!user?.id) return; try { setPreferencesLoading(true); try { const preferences = await getUserPreferences(user.id); if (preferences) { const isDark = preferences.theme === 'dark'; setDarkMode(isDark); setEmailNotifications(preferences.notificationPreferences.emailEnabled); setStudyReminders(preferences.notificationPreferences.dailyReminder); } else { setDarkMode(false); setEmailNotifications(true); setStudyReminders(true); } } catch (prefError) { setDarkMode(false); setEmailNotifications(true); setStudyReminders(true); } } catch (error) { console.error('Error loading preferences:', error); setMessage({ type: "error", text: "Errore nel caricamento delle preferenze" }); } finally { setPreferencesLoading(false); } }; loadPreferences(); }, [user?.id]); const handleThemeChange = async (theme: 'light' | 'dark') => { if (!user?.id) return; try { const success = await updateUserTheme(user.id, theme); if (success) { setDarkMode(theme === 'dark'); if (theme === 'dark') { document.documentElement.classList.add('dark'); } else { document.documentElement.classList.remove('dark'); } setMessage({ type: "success", text: `Tema ${theme === 'dark' ? 'scuro' : 'chiaro'} attivato` }); } else { setMessage({ type: "error", text: "Errore nell'aggiornamento del tema" }); } } catch (error) { console.error('Error updating theme:', error); setMessage({ type: "error", text: "Errore nell'aggiornamento del tema" }); } }; const handleNotificationToggle = async (type: 'email' | 'study') => { if (!user?.id) return; try { let success = false; if (type === 'email') { success = await updateNotificationPreferences(user.id, { emailEnabled: !emailNotifications }); if (success) { setEmailNotifications(!emailNotifications); setMessage({ type: "success", text: `Notifiche email ${!emailNotifications ? 'attivate' : 'disattivate'}` }); } } else { success = await updateNotificationPreferences(user.id, { dailyReminder: !studyReminders }); if (success) { setStudyReminders(!studyReminders); setMessage({ type: "success", text: `Promemoria studio ${!studyReminders ? 'attivati' : 'disattivati'}` }); } } if (!success) { setMessage({ type: "error", text: "Errore nell'aggiornamento delle notifiche" }); } } catch (error) { console.error('Error updating notifications:', error); setMessage({ type: "error", text: "Errore nell'aggiornamento delle notifiche" }); } }; const handlePasswordChange = (field: keyof typeof passwordForm, value: string) => { setPasswordForm(prev => ({ ...prev, [field]: value })); }; const togglePasswordVisibility = (field: keyof typeof showPasswords) => { setShowPasswords(prev => ({ ...prev, [field]: !prev[field] })); }; const handleUpdatePassword = async () => { if (!passwordForm.currentPassword || !passwordForm.newPassword || !passwordForm.confirmPassword) { setMessage({ type: "error", text: "Tutti i campi sono obbligatori" }); return; } if (passwordForm.newPassword !== passwordForm.confirmPassword) { setMessage({ type: "error", text: "Le nuove password non corrispondono" }); return; } if (passwordForm.newPassword.length < 6) { setMessage({ type: "error", text: "La nuova password deve contenere almeno 6 caratteri" }); return; } setUpdateLoading(true); setMessage(null); try { const success = await updatePassword({ currentPassword: passwordForm.currentPassword, newPassword: passwordForm.newPassword, }); if (success) { setMessage({ type: "success", text: "Password aggiornata con successo!" }); setPasswordForm({ currentPassword: "", newPassword: "", confirmPassword: "", }); } else { setMessage({ type: "error", text: "Errore durante l'aggiornamento della password" }); } } catch (error) { setMessage({ type: "error", text: "Errore durante l'aggiornamento della password" }); } finally { setUpdateLoading(false); } }; if (loading || preferencesLoading) { return ( <div className="flex items-center justify-center min-h-screen"> <div className="text-center"> <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto"></div> <p className="mt-4 text-gray-600 dark:text-gray-400">Caricamento impostazioni...</p> </div> </div> ); } return ( <div className="min-h-screen bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900"> } <div className="max-w-4xl mx-auto px-6 py-8 space-y-8 relative -mt-16 z-10"> } <Card className="shadow-lg border-0 bg-white/80 backdrop-blur-sm"> <CardHeader className="bg-gradient-to-r from-red-500 to-pink-600 text-white rounded-t-lg"> <CardTitle className="flex items-center gap-2 text-white"> <Lock className="w-5 h-5" /> Password e Sicurezza </CardTitle> </CardHeader> <CardContent className="space-y-4"> <form onSubmit={(e) => { e.preventDefault(); handleUpdatePassword(); }}> <div className="space-y-4"> <div> <Label htmlFor="currentPassword" className="text-sm font-medium text-gray-700 dark:text-gray-300"> Password attuale </Label> <div className="relative mt-1"> <Input id="currentPassword" name="currentPassword" type={showPasswords.current ? "text" : "password"} value={passwordForm.currentPassword} onChange={(e) => handlePasswordChange("currentPassword", e.target.value)} className="pr-10" disabled={updateLoading} autoComplete="current-password" /> <button type="button" onClick={() => togglePasswordVisibility("current")} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600" > {showPasswords.current ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />} </button> </div> </div> <div> <Label htmlFor="newPassword" className="text-sm font-medium text-gray-700 dark:text-gray-300"> Nuova password </Label> <div className="relative mt-1"> <Input id="newPassword" name="newPassword" type={showPasswords.new ? "text" : "password"} value={passwordForm.newPassword} onChange={(e) => handlePasswordChange("newPassword", e.target.value)} className="pr-10" disabled={updateLoading} autoComplete="new-password" /> <button type="button" onClick={() => togglePasswordVisibility("new")} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600" > {showPasswords.new ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />} </button> </div> </div> <div> <Label htmlFor="confirmPassword" className="text-sm font-medium text-gray-700 dark:text-gray-300"> Conferma nuova password </Label> <div className="relative mt-1"> <Input id="confirmPassword" name="confirmPassword" type={showPasswords.confirm ? "text" : "password"} value={passwordForm.confirmPassword} onChange={(e) => handlePasswordChange("confirmPassword", e.target.value)} className="pr-10" disabled={updateLoading} autoComplete="new-password" /> <button type="button" onClick={() => togglePasswordVisibility("confirm")} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600" > {showPasswords.confirm ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />} </button> </div> </div> <Button type="submit" disabled={updateLoading} className="w-full bg-gradient-to-r from-red-500 to-pink-600 hover:from-red-600 hover:to-pink-700 text-white border-0 shadow-lg" > {updateLoading ? ( <> <Loader2 className="w-4 h-4 mr-2 animate-spin" /> Aggiornamento... </> ) : ( <> <Key className="w-4 h-4 mr-2" /> Aggiorna Password </> )} </Button> </div> </form> </CardContent> </Card> } <Card className="shadow-lg border-0 bg-white/80 backdrop-blur-sm"> <CardHeader className="bg-gradient-to-r from-blue-500 to-cyan-600 text-white rounded-t-lg"> <CardTitle className="flex items-center gap-2 text-white"> <Bell className="w-5 h-5" /> Notifiche e Comunicazioni </CardTitle> </CardHeader> <CardContent className="space-y-6 p-6"> <div className="grid grid-cols-1 md:grid-cols-2 gap-6"> <div className="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900/20 dark:to-indigo-900/20 rounded-lg border border-blue-200 dark:border-blue-800"> <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-indigo-600 rounded-full flex items-center justify-center"> <Mail className="w-5 h-5 text-white" /> </div> <div> <p className="font-medium text-blue-800 dark:text-blue-200">Notifiche Email</p> <p className="text-sm text-blue-600 dark:text-blue-400">Ricevi aggiornamenti via email</p> </div> </div> <Button variant={emailNotifications ? "default" : "outline"} size="sm" className={emailNotifications ? "bg-gradient-to-r from-blue-500 to-indigo-600 text-white border-0 shadow-lg" : "border-blue-300 text-blue-700 hover:bg-blue-50"} onClick={() => handleNotificationToggle('email')} > {emailNotifications ? ( <><CheckCircle className="w-4 h-4 mr-2" />Attive</> ) : ( <><Zap className="w-4 h-4 mr-2" />Attiva</> )} </Button> </div> </div> <div className="p-4 bg-gradient-to-r from-purple-50 to-pink-50 dark:from-purple-900/20 dark:to-pink-900/20 rounded-lg border border-purple-200 dark:border-purple-800"> <div className="flex items-center justify-between"> <div className="flex items-center gap-3"> <div className="w-10 h-10 bg-gradient-to-r from-purple-500 to-pink-600 rounded-full flex items-center justify-center"> <MessageSquare className="w-5 h-5 text-white" /> </div> <div> <p className="font-medium text-purple-800 dark:text-purple-200">Promemoria Studio</p> <p className="text-sm text-purple-600 dark:text-purple-400">Notifiche per sessioni di studio</p> </div> </div> <Button variant={studyReminders ? "default" : "outline"} size="sm" className={studyReminders ? "bg-gradient-to-r from-purple-500 to-pink-600 text-white border-0 shadow-lg" : "border-purple-300 text-purple-700 hover:bg-purple-50"} onClick={() => handleNotificationToggle('study')} > {studyReminders ? ( <><CheckCircle className="w-4 h-4 mr-2" />Attivi</> ) : ( <><Star className="w-4 h-4 mr-2" />Attiva</> )} </Button> </div> </div> </div> </CardContent> </Card> </div> </div> ); };

================================================================================

NOME FILE: StatsView.tsx

import React from 'react'; import { useAppContext } from '../contexts/AppContext'; import StatsOverview from '../components/stats/StatsOverview'; export const StatsView: React.FC = React.memo(() => { const { testHistory, words, clearHistoryOnly, dispatch, forceRefresh } = useAppContext(); return ( <StatsOverview testHistory={testHistory} words={words} onClearHistory={clearHistoryOnly} onGoToMain={() => dispatch({ type: 'SET_VIEW', payload: 'main' })} forceUpdate={forceRefresh} /> ); }); StatsView.displayName = 'StatsView';

================================================================================

NOME FILE: TermsOfServiceView.tsx

import React from "react"; import { Button } from "../components/ui/button"; import { Card, CardContent, CardHeader, CardTitle } from "../components/ui/card"; import { ArrowLeft, FileText } from "lucide-react"; import { useAppContext } from "../contexts/AppContext"; import { useAuth } from "../hooks/integration/useAuth"; export const TermsOfServiceView: React.FC = () => { const { dispatch, authReturnContext } = useAppContext(); const { isAuthenticated } = useAuth(); const handleGoBack = () => { if (authReturnContext && authReturnContext.source === "signup") { dispatch({ type: "GO_BACK" }); } else if (!isAuthenticated) { dispatch({ type: "GO_BACK" }); } else { dispatch({ type: "GO_BACK" }); } }; return ( <div className="min-h-screen bg-gray-50 dark:bg-gray-900 py-8 px-4"> <div className="max-w-4xl mx-auto">

================================================================================

NOME FILE: TestView.tsx

import React, { useState, useEffect, useRef } from 'react'; import { useAppContext } from '../contexts/AppContext'; import { Card } from '../components/ui/card'; import { Button } from '../components/ui/button'; import TestCard from '../components/TestCard'; import { RotateCcw, Check, X, HelpCircle, Clock, Lightbulb } from 'lucide-react'; export const TestView: React.FC = React.memo(() => { const { currentWord, showMeaning, setShowMeaning, handleAnswer, resetTest, getTestProgress, getTestSummary, showHint, toggleHint, hintUsed, isTransitioning, gameHints, totalHintsUsed, testConfig, handleGameHintRequest, currentWordSession, detailedSession } = useAppContext(); const [currentWordTime, setCurrentWordTime] = useState<number>(0); const [isAnswering, setIsAnswering] = useState<boolean>(false); const [timeExpired, setTimeExpired] = useState<boolean>(false); const timerEnabled = testConfig?.enableTimer || false; const timePerWord = testConfig?.maxTimePerWord || 30; const autoAdvanceEnabled = true; React.useEffect(() => { console.log('🔧 Timer Config:', { timerEnabled, timePerWord, autoAdvanceEnabled, testConfig: testConfig }); }, [timerEnabled, timePerWord, autoAdvanceEnabled, testConfig]); const timerRef = useRef<NodeJS.Timeout | null>(null); const wordStartTimeRef = useRef<number | null>(null); const autoAdvanceTimeoutRef = useRef<NodeJS.Timeout | null>(null); const timeExpiredRef = useRef<boolean>(false); const progress = getTestProgress(); const summary = getTestSummary(); useEffect(() => { if (currentWord) { setTimeExpired(false); } }, [currentWord]); useEffect(() => { if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } if (autoAdvanceTimeoutRef.current) { clearTimeout(autoAdvanceTimeoutRef.current); autoAdvanceTimeoutRef.current = null; } if (currentWord && !isTransitioning && !isAnswering) { setCurrentWordTime(0); setTimeExpired(false); timeExpiredRef.current = false; wordStartTimeRef.current = Date.now(); console.log(`🔄 TIMER RESET per nuova parola: ${currentWord.english}, timeExpired reset a false`); timerRef.current = setInterval(() => { if (wordStartTimeRef.current && !isAnswering) { const elapsed = Math.floor((Date.now() - wordStartTimeRef.current) / 1000); setCurrentWordTime(elapsed); if (elapsed % 5 === 0 && elapsed > 0) { console.log(`🕒 Timer debug - Elapsed: ${elapsed}s, Limit: ${timePerWord}s, Enabled: ${timerEnabled}, AutoAdvance: ${autoAdvanceEnabled}, TimeExpired: ${timeExpiredRef.current}`); } if (timerEnabled && elapsed >= timePerWord && !timeExpiredRef.current) { console.log(`⏰ TIMER SCADUTO! Elapsed: ${elapsed}, Limit: ${timePerWord}, Triggering auto-advance...`); setTimeExpired(true); timeExpiredRef.current = true; if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; console.log(`🛑 Timer fermato dopo scadenza`); } if (autoAdvanceEnabled) { console.log(`🚀 Auto-advance abilitato, mostrando traduzione per lettura...`); if (!showMeaning) { setShowMeaning(true); } autoAdvanceTimeoutRef.current = setTimeout(() => { console.log(`🔄 Girando carta coperta prima di passare alla parola successiva`); setShowMeaning(false); setTimeout(() => { console.log(`🎯 Processando risposta sbagliata dopo flip`); handleAnswer(false, true); }, 500); }, 6000); } else { console.log(`🚫 Auto-advance disabilitato`); } } else if (timerEnabled && elapsed > timePerWord && !timeExpiredRef.current) { console.log(`🚨 TIMER SAFETY STOP! Elapsed: ${elapsed} > Limit: ${timePerWord}, but timeExpired not set yet`); setTimeExpired(true); timeExpiredRef.current = true; if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } setCurrentWordTime(timePerWord); return; } } }, 1000); } else if (!currentWord) { setCurrentWordTime(0); wordStartTimeRef.current = null; } return () => { if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } if (autoAdvanceTimeoutRef.current) { clearTimeout(autoAdvanceTimeoutRef.current); autoAdvanceTimeoutRef.current = null; } }; }, [currentWord, isTransitioning, isAnswering, timerEnabled, timePerWord, autoAdvanceEnabled]); useEffect(() => { return () => { if (timerRef.current) { clearInterval(timerRef.current); } if (autoAdvanceTimeoutRef.current) { clearTimeout(autoAdvanceTimeoutRef.current); } }; }, []); const handleAnswerWithTimer = (isCorrect: boolean) => { console.log(`📝 handleAnswerWithTimer chiamato - isCorrect: ${isCorrect}, timeExpired: ${timeExpired}, showMeaning: ${showMeaning}`); if (timeExpired) { console.log(`🚫 Timer scaduto - risposta utente ignorata`); return; } setIsAnswering(true); if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } console.log(`✅ Processando risposta utente normalmente`); handleAnswer(isCorrect); setTimeout(() => { setIsAnswering(false); }, 1000); }; const formatTime = (seconds: number): string => { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }; if (!currentWord) { return ( <div className="test-view-loading"> <div className="flex-center-column"> <div className="text-gray-400 mb-4"> <Clock className="w-12 h-12 mx-auto mb-2" /> <p>Nessuna parola disponibile</p> </div> <Button onClick={resetTest} className="bg-blue-500 hover:bg-blue-600"> <RotateCcw className="w-4 h-4 mr-2" /> Ricomincia Test </Button> </div> </div> ); } const currentProgress = getTestProgress(); const currentSummary = getTestSummary(); const currentHintsThisWord = Object.values(gameHints || {}).reduce((total: number, hints: any) => total + (hints?.length || 0), 0); const isWordLimitReached = testConfig?.hintsMode === 'limited' && testConfig.maxHintsPerWord && (currentHintsThisWord as number) >= testConfig.maxHintsPerWord; const isTotalLimitReached = testConfig?.hintsMode === 'limited' && testConfig.enableTotalHintsLimit && testConfig.maxTotalHints && (totalHintsUsed || 0) >= testConfig.maxTotalHints; return ( <div className="test-view-content"> } <div className="test-view-progress-header"> <div className="test-view-progress-stats"> } <div className={`test-view-timer-display ${timeExpired ? 'test-view-timer-warning' : 'test-view-timer-normal'}`}> <Clock className="w-4 h-4 text-blue-600" /> <span className={`font-mono ${timeExpired ? 'text-red-600 font-bold' : 'text-gray-700 dark:text-gray-300'}`}> {formatTime(currentWordTime)} </span> {timerEnabled && ( <span className="text-xs text-gray-500"> / {timePerWord}s </span> )} </div> </div> <Button onClick={resetTest} variant="outline" className="bg-red-50 hover:bg-red-100 text-red-600 border-red-200" > <RotateCcw className="w-4 h-4 mr-2" /> Reset </Button> </div> } <div className="stack-sm"> <div className="flex-between text-xs text-gray-600 dark:text-gray-400"> <span>Progresso test</span> <span>{currentProgress.remaining} rimanenti</span> </div> <div className="test-view-progress-bar"> <div className="test-view-progress-fill" style={{ width: `${currentProgress.percentage}%` }} /> </div> </div> } <div className="flex-between mt-4 pt-4 border-t border-blue-200/30 dark:border-blue-700/30"> <div className="test-view-summary-stats"> <div className="text-center"> <div className="test-view-summary-value text-green-600">{currentSummary.correctAnswers}</div> <div className="test-view-summary-label">Corrette</div> </div> <div className="text-center"> <div className="test-view-summary-value text-red-600">{currentSummary.incorrectAnswers}</div> <div className="test-view-summary-label">Sbagliate</div> </div> <div className="text-center"> <div className="test-view-summary-value text-orange-600">{totalHintsUsed || 0}</div> <div className="test-view-summary-label">Aiuti</div> </div> <div className="text-center"> <div className="test-view-summary-value text-blue-600">{currentSummary.accuracy}%</div> <div className="test-view-summary-label">Precisione</div> </div> </div> </div> </div> } <div className="test-view-card-wrapper"> <TestCard word={currentWord} showMeaning={showMeaning} onFlip={() => setShowMeaning(!showMeaning)} showHint={showHint} hintUsed={hintUsed} gameMode={true} gameHints={gameHints || {}} onGameHintRequest={handleGameHintRequest} /> </div> } <div> <button onClick={() => handleGameHintRequest('synonym')} disabled={testConfig?.hintsMode === 'disabled' || isWordLimitReached || isTotalLimitReached} className="test-view-hint-button test-view-hint-context w-full group rounded-xl p-4" > <div className="flex items-center gap-3"> <span className="text-2xl">🔄</span> <div className="text-left flex-1"> <div className="font-bold">Sinonimi</div> <div className="text-sm opacity-90"> {gameHints?.synonym?.length || 0} rivelati </div> </div> <div className="text-2xl opacity-75 group-hover:opacity-100 transition-opacity"> + </div> </div> </button> } <div> <button onClick={() => handleGameHintRequest('antonym')} disabled={testConfig?.hintsMode === 'disabled' || isWordLimitReached || isTotalLimitReached} className="test-view-hint-button test-view-hint-antonym w-full group rounded-xl p-4" > <div className="flex items-center gap-3"> <span className="text-2xl">⚡</span> <div className="text-left flex-1"> <div className="font-bold">Contrari</div> <div className="text-sm opacity-90"> {gameHints?.antonym?.length || 0} rivelati </div> </div> <div className="text-2xl opacity-75 group-hover:opacity-100 transition-opacity"> + </div> </div> </button> } <div> <button onClick={() => handleGameHintRequest('context')} disabled={testConfig?.hintsMode === 'disabled' || isWordLimitReached || isTotalLimitReached} className="test-view-hint-button test-view-hint-synonym w-full group rounded-xl p-4" > <div className="flex items-center gap-3"> <span className="text-2xl">💬</span> <div className="text-left flex-1"> <div className="font-bold">Contesto</div> <div className="text-sm opacity-90"> {gameHints?.context?.length || 0} rivelati </div> </div> <div className="text-2xl opacity-75 group-hover:opacity-100 transition-opacity"> + </div> </div> </button> } {testConfig?.hintsMode === 'limited' && ( <div className="mt-6 pt-4 border-soft"> <div className="text-xs text-gray-600 dark:text-gray-400 stack-sm"> {testConfig.maxHintsPerWord && ( <div className={`flex-between ${isWordLimitReached ? 'text-red-600 font-bold' : ''}`}> <span>Max per parola:</span> <span>{currentHintsThisWord}/{testConfig.maxHintsPerWord}</span> </div> )} {testConfig.enableTotalHintsLimit && testConfig.maxTotalHints && ( <div className={`flex-between ${isTotalLimitReached ? 'text-red-600 font-bold' : ''}`}> <span>Max totali:</span> <span>{totalHintsUsed || 0}/{testConfig.maxTotalHints}</span> </div> )} </div> } } {timeExpired && ( <div className="test-view-timeout-notice"> <div className="test-view-timeout-badge"> <Clock className="w-4 h-4" /> <span>Tempo scaduto! Passaggio automatico...</span> </div> </div> )}

================================================================================


NOME FILE: AppContext.js

import React, { createContext, useContext, useReducer, useEffect } from 'react'; import { useOptimizedWords } from '../hooks/useOptimizedWords'; import { useOptimizedTest } from '../hooks/useOptimizedTest'; import { useEnhancedStats } from '../hooks/useEnhancedStats'; const AppContext = createContext(); const initialState = { currentView: 'main', showWordsList: true, editingWord: null, showChapterSelector: false, confirmDelete: null, showConfirmClear: false }; const appReducer = (state, action) => { switch (action.type) { case 'SET_VIEW': return { ...state, currentView: action.payload }; case 'TOGGLE_WORDS_LIST': return { ...state, showWordsList: !state.showWordsList }; case 'SET_EDITING_WORD': return { ...state, editingWord: action.payload }; case 'SET_SHOW_CHAPTER_SELECTOR': return { ...state, showChapterSelector: action.payload }; case 'SET_CONFIRM_DELETE': return { ...state, confirmDelete: action.payload }; case 'SET_SHOW_CONFIRM_CLEAR': return { ...state, showConfirmClear: action.payload }; case 'RESET_MODALS': return { ...state, confirmDelete: null, showConfirmClear: false, showChapterSelector: false }; default: return state; } }; export const AppProvider = ({ children }) => { const [state, dispatch] = useReducer(appReducer, initialState); const wordsAPI = useOptimizedWords(); const statsAPI = useEnhancedStats(); const testAPI = useOptimizedTest((testStats, testWords, wrongWords) => { statsAPI.handleTestComplete(testStats, testWords, wrongWords); }); useEffect(() => { wordsAPI.setEditingWord(state.editingWord); }, [state.editingWord, wordsAPI]); useEffect(() => { console.log('🔍 statsAPI functions available:', { exportData: typeof statsAPI.exportData, importData: typeof statsAPI.importData, clearTestHistory: typeof statsAPI.clearTestHistory, clearHistoryOnly: typeof statsAPI.clearHistoryOnly, refreshData: typeof statsAPI.refreshData, getAllWordsPerformance: typeof statsAPI.getAllWordsPerformance, getWordAnalysis: typeof statsAPI.getWordAnalysis, recordWordPerformance: typeof statsAPI.recordWordPerformance }); }, [statsAPI]); const value = { ...state, dispatch, words: wordsAPI.words, addWord: wordsAPI.addWord, removeWord: wordsAPI.removeWord, toggleWordLearned: wordsAPI.toggleWordLearned, toggleWordDifficult: wordsAPI.toggleWordDifficult, clearAllWords: wordsAPI.clearAllWords, importWords: wordsAPI.importWords, forceRefresh: wordsAPI.forceRefresh, getAvailableChapters: wordsAPI.getAvailableChapters, getChapterStats: wordsAPI.getChapterStats, wordStats: wordsAPI.wordStats, ...testAPI, stats: statsAPI.stats, testHistory: statsAPI.testHistory, wordPerformance: statsAPI.wordPerformance, calculatedStats: statsAPI.calculatedStats, refreshData: statsAPI.refreshData, resetStats: statsAPI.resetStats, exportStats: statsAPI.exportData, importStats: statsAPI.importData, handleTestComplete: statsAPI.handleTestComplete, clearHistoryOnly: statsAPI.clearHistoryOnly, addTestToHistory: statsAPI.addTestToHistory, getAllWordsPerformance: statsAPI.getAllWordsPerformance, getWordAnalysis: statsAPI.getWordAnalysis, recordWordPerformance: statsAPI.recordWordPerformance, isProcessing: statsAPI.isLoading || statsAPI.isProcessing || false, isInitialized: statsAPI.isInitialized, totalTests: statsAPI.totalTests || 0, totalAnswers: statsAPI.totalAnswers || 0, accuracyRate: statsAPI.accuracyRate || 0, hintsRate: statsAPI.hintsRate || 0, weeklyProgress: statsAPI.weeklyProgress || [], isMigrated: statsAPI.isMigrated || false }; return ( <AppContext.Provider value={value}> {children} </AppContext.Provider> ); }; export const useAppContext = () => { const context = useContext(AppContext); if (!context) { throw new Error('useAppContext must be used within AppProvider'); } return context; };

================================================================================

NOME FILE: NotificationContext.js

import React, { createContext, useContext, useReducer, useCallback } from 'react'; const NotificationContext = createContext(); const notificationReducer = (state, action) => { switch (action.type) { case 'ADD_NOTIFICATION': return { ...state, notifications: [...state.notifications, action.payload] }; case 'REMOVE_NOTIFICATION': return { ...state, notifications: state.notifications.filter(n => n.id !== action.payload) }; case 'CLEAR_ALL': return { ...state, notifications: [] }; default: return state; } }; const getUserFriendlyError = (errorMessage, context) => { const errorMap = { 'JSON': '❌ File JSON non valido', 'localStorage': '❌ Errore salvataggio dati', 'Network': '❌ Errore di connessione', 'Word already exists': '⚠️ Parola già esistente', 'English word and Italian translation are required': '⚠️ Campi obbligatori mancanti', 'All words already exist': '⚠️ Tutte le parole sono già presenti' }; for (const [key, message] of Object.entries(errorMap)) { if (errorMessage.includes(key)) { return message; } } return `❌ Errore ${context}: ${errorMessage}`; }; export const NotificationProvider = ({ children }) => { const [state, dispatch] = useReducer(notificationReducer, { notifications: [] }); const showNotification = useCallback((message, type = 'success', duration = 3000) => { const id = Date.now() + Math.random(); dispatch({ type: 'ADD_NOTIFICATION', payload: { id, message, type, timestamp: Date.now() } }); setTimeout(() => { dispatch({ type: 'REMOVE_NOTIFICATION', payload: id }); }, duration); return id; }, []); const showError = useCallback((error, context = '') => { console.error(`❌ Error in ${context}:`, error); const errorMessage = error.message || error.toString(); const userFriendlyMessage = getUserFriendlyError(errorMessage, context); return showNotification(userFriendlyMessage, 'error', 5000); }, [showNotification]); const showSuccess = useCallback((message) => { return showNotification(message, 'success'); }, [showNotification]); const showWarning = useCallback((message) => { return showNotification(message, 'warning', 4000); }, [showNotification]); const value = { notifications: state.notifications, showNotification, showError, showSuccess, showWarning, clearAllNotifications: useCallback(() => { dispatch({ type: 'CLEAR_ALL' }); }, []) }; return ( <NotificationContext.Provider value={value}> {children} </NotificationContext.Provider> ); }; export const useNotification = () => { const context = useContext(NotificationContext); if (!context) { throw new Error('useNotification must be used within NotificationProvider'); } return context; };

================================================================================


NOME FILE: AppContext.js

import React, { createContext, useContext, useReducer, useEffect } from "react"; import { useWords } from "../hooks/data/useWords"; import { useTest } from "../hooks/data/useTest"; import { useStats } from "../hooks/data/useStats"; const AppContext = createContext(); const initialState = { currentView: "main", showWordsList: true, editingWord: null, showChapterSelector: false, confirmDelete: null, showConfirmClear: false, }; const appReducer = (state, action) => { switch (action.type) { case "SET_VIEW": return { ...state, currentView: action.payload }; case "TOGGLE_WORDS_LIST": return { ...state, showWordsList: !state.showWordsList }; case "SET_EDITING_WORD": return { ...state, editingWord: action.payload }; case "SET_SHOW_CHAPTER_SELECTOR": return { ...state, showChapterSelector: action.payload }; case "SET_CONFIRM_DELETE": return { ...state, confirmDelete: action.payload }; case "SET_SHOW_CONFIRM_CLEAR": return { ...state, showConfirmClear: action.payload }; case "RESET_MODALS": return { ...state, confirmDelete: null, showConfirmClear: false, showChapterSelector: false, }; default: return state; } }; export const AppProvider = ({ children }) => { const [state, dispatch] = useReducer(appReducer, initialState); const wordsAPI = useWords(); const statsAPI = useStats(); const testAPI = useTest((testStats, testWords, wrongWords) => { statsAPI.handleTestComplete(testStats, testWords, wrongWords); }); useEffect(() => { wordsAPI.setEditingWord(state.editingWord); }, [state.editingWord, wordsAPI]); const value = { ...state, dispatch, words: wordsAPI.words, addWord: wordsAPI.addWord, removeWord: wordsAPI.removeWord, toggleWordLearned: wordsAPI.toggleWordLearned, toggleWordDifficult: wordsAPI.toggleWordDifficult, clearAllWords: wordsAPI.clearAllWords, importWords: wordsAPI.importWords, forceRefresh: wordsAPI.forceRefresh, getAvailableChapters: wordsAPI.getAvailableChapters, getChapterStats: wordsAPI.getChapterStats, wordStats: wordsAPI.wordStats, ...testAPI, stats: statsAPI.stats, testHistory: statsAPI.testHistory, wordPerformance: statsAPI.wordPerformance, calculatedStats: statsAPI.calculatedStats, refreshData: statsAPI.refreshData, resetStats: statsAPI.resetStats, exportStats: statsAPI.exportData, importStats: statsAPI.importData, handleTestComplete: statsAPI.handleTestComplete, clearHistoryOnly: statsAPI.clearHistoryOnly, addTestToHistory: statsAPI.addTestToHistory, getAllWordsPerformance: statsAPI.getAllWordsPerformance, getWordAnalysis: statsAPI.getWordAnalysis, recordWordPerformance: statsAPI.recordWordPerformance, isProcessing: statsAPI.isLoading || statsAPI.isProcessing || false, isInitialized: statsAPI.isInitialized, totalTests: statsAPI.totalTests || 0, totalAnswers: statsAPI.totalAnswers || 0, accuracyRate: statsAPI.accuracyRate || 0, hintsRate: statsAPI.hintsRate || 0, weeklyProgress: statsAPI.weeklyProgress || [], isMigrated: statsAPI.isMigrated || false, }; return <AppContext.Provider value={value}>{children}</AppContext.Provider>; }; export const useAppContext = () => { const context = useContext(AppContext); if (!context) { throw new Error("useAppContext must be used within AppProvider"); } return context; };

================================================================================

NOME FILE: FirebaseContext.tsx

import React, { createContext, useContext, useState, useEffect, ReactNode, } from "react"; import { initializeFirebase, getFirebaseStatus, type FirebaseInitResult, type FirebaseStatus, } from "../config/firebase"; interface FirebaseState { initialized: boolean; loading: boolean; error: Error | null; retryCount: number; initResult?: FirebaseInitResult; } interface FirebaseContextValue extends FirebaseState { retryInitialization: () => void; getFirebaseStatus: () => FirebaseStatus; isReady: boolean; } interface FirebaseProviderProps { children: ReactNode; } const FirebaseContext = createContext<FirebaseContextValue | undefined>( undefined ); export const FirebaseProvider: React.FC<FirebaseProviderProps> = ({ children, }) => { const [firebaseState, setFirebaseState] = useState<FirebaseState>({ initialized: false, loading: true, error: null, retryCount: 0, }); useEffect(() => { async function init(): Promise<void> { try { console.log("🔥 Starting Firebase initialization..."); setFirebaseState((prev) => ({ ...prev, loading: true, error: null, })); const initResult: FirebaseInitResult = await initializeFirebase(); if (initResult.success) { setFirebaseState({ initialized: true, loading: false, error: null, retryCount: 0, initResult, }); if (process.env.NODE_ENV === "development") { console.log("🔍 Firebase Status:", getFirebaseStatus()); console.log("🔍 Init Result:", initResult); } console.log("✅ Firebase ready!"); } else { throw initResult.error || new Error("Firebase initialization failed"); } } catch (error) { console.error("❌ Firebase initialization failed:", error); setFirebaseState((prev) => ({ initialized: false, loading: false, error: error as Error, retryCount: prev.retryCount + 1, })); const windowWithErrorTracker = window as any; if (windowWithErrorTracker.ErrorTracker?.logError) { windowWithErrorTracker.ErrorTracker.logError( error, "Firebase Initialization", { retryCount: firebaseState.retryCount, timestamp: new Date().toISOString(), } ); } } } init(); }, [firebaseState.retryCount]); const retryInitialization = (): void => { if (firebaseState.retryCount < 3) { setFirebaseState((prev) => ({ ...prev, retryCount: prev.retryCount + 1, })); } }; const value: FirebaseContextValue = { ...firebaseState, retryInitialization, getFirebaseStatus, isReady: firebaseState.initialized && !firebaseState.loading && !firebaseState.error, }; if (firebaseState.loading) { return <FirebaseLoadingScreen />; } if (firebaseState.error && !firebaseState.initialized) { return ( <FirebaseErrorScreen error={firebaseState.error} retryCount={firebaseState.retryCount} onRetry={retryInitialization} /> ); } return ( <FirebaseContext.Provider value={value}> {children} const FirebaseLoadingScreen: React.FC = () => ( <div style={{ display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100vh", backgroundColor: "#f8fafc", fontFamily: "system-ui, -apple-system, sans-serif", }} > <div style={{ width: "50px", height: "50px", border: "3px solid #e2e8f0", borderTop: "3px solid #3b82f6", borderRadius: "50%", animation: "spin 1s linear infinite", marginBottom: "20px", }} /> <h2 style={{ color: "#1e293b", margin: "0 0 10px 0" }}> 🔥 Initializing Firebase... </h2> <p style={{ color: "#64748b", margin: 0 }}> Setting up authentication and database </p> <style> {` @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } `} </style> </div> ); interface FirebaseErrorScreenProps { error: Error; retryCount: number; onRetry: () => void; } const FirebaseErrorScreen: React.FC<FirebaseErrorScreenProps> = ({ error, retryCount, onRetry, }) => ( <div style={{ display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100vh", backgroundColor: "#fef2f2", fontFamily: "system-ui, -apple-system, sans-serif", padding: "20px", textAlign: "center", }} > <div style={{ fontSize: "48px", marginBottom: "20px" }}>❌</div> <h2 style={{ color: "#dc2626", margin: "0 0 15px 0", fontSize: "24px", }} > Firebase Initialization Failed </h2> <p style={{ color: "#7f1d1d", margin: "0 0 20px 0", maxWidth: "500px", lineHeight: "1.5", }} > {error.message} </p> <div style={{ display: "flex", gap: "10px", flexWrap: "wrap", justifyContent: "center", }} > {retryCount < 3 && ( <button onClick={onRetry} style={{ backgroundColor: "#dc2626", color: "white", border: "none", padding: "12px 24px", borderRadius: "6px", fontSize: "16px", cursor: "pointer", fontWeight: "500", }} > 🔄 Retry ({retryCount}/3) </button> )} <button onClick={() => window.location.reload()} style={{ backgroundColor: "#6b7280", color: "white", border: "none", padding: "12px 24px", borderRadius: "6px", fontSize: "16px", cursor: "pointer", fontWeight: "500", }} > 🔄 Reload Page </button> </div> {process.env.NODE_ENV === "development" && ( <details style={{ marginTop: "30px", textAlign: "left", backgroundColor: "#fee2e2", padding: "15px", borderRadius: "6px", maxWidth: "600px", }} > <summary style={{ color: "#991b1b", cursor: "pointer", fontWeight: "600", marginBottom: "10px", }} > 🔧 Developer Debug Info </summary> <pre style={{ fontSize: "12px", color: "#7f1d1d", overflow: "auto", whiteSpace: "pre-wrap", }} > {JSON.stringify( { error: { name: error.name, message: error.message, stack: error.stack?.split("\n").slice(0, 5).join("\n"), }, retryCount, environment: process.env.NODE_ENV, firebaseConfig: { hasApiKey: !!process.env.REACT_APP_FIREBASE_API_KEY, hasAuthDomain: !!process.env.REACT_APP_FIREBASE_AUTH_DOMAIN, hasProjectId: !!process.env.REACT_APP_FIREBASE_PROJECT_ID, hasStorageBucket: !!process.env.REACT_APP_FIREBASE_STORAGE_BUCKET, hasMessagingSenderId: !!process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID, hasAppId: !!process.env.REACT_APP_FIREBASE_APP_ID, }, }, null, 2 )} </pre> </details> )} </div> ); interface FirebaseDebugIndicatorProps { initResult?: FirebaseInitResult; } const FirebaseDebugIndicator: React.FC<FirebaseDebugIndicatorProps> = ({ initResult, }) => ( <div style={{ position: "fixed", bottom: "10px", right: "10px", backgroundColor: "#10b981", color: "white", padding: "8px 12px", borderRadius: "6px", fontSize: "12px", fontFamily: "monospace", boxShadow: "0 2px 8px rgba(0,0,0,0.1)", zIndex: 9999, cursor: "pointer", }} title={`Firebase Ready - Firestore: ${ initResult?.firestorePersistence ? "✅" : "❌" }, Auth: ${initResult?.authPersistence ? "✅" : "❌"}`} > 🔥 Firebase Ready </div> ); export const useFirebase = (): FirebaseContextValue => { const context = useContext(FirebaseContext); if (!context) { throw new Error("useFirebase must be used within FirebaseProvider"); } return context; }; export const useFirebaseReady = (): boolean => { const { isReady } = useFirebase(); return isReady; }; export const useFirebaseError = (): Error | null => { const { error } = useFirebase(); return error; }; export default FirebaseProvider; export type { FirebaseContextValue, FirebaseState, FirebaseProviderProps };

================================================================================

NOME FILE: NotificationContext.js

import React, { createContext, useContext, useReducer, useCallback, } from "react"; const NotificationContext = createContext(); const notificationReducer = (state, action) => { switch (action.type) { case "ADD_NOTIFICATION": return { ...state, notifications: [...state.notifications, action.payload], }; case "REMOVE_NOTIFICATION": return { ...state, notifications: state.notifications.filter( (n) => n.id !== action.payload ), }; case "CLEAR_ALL": return { ...state, notifications: [] }; default: return state; } }; const getUserFriendlyError = (errorMessage, context) => { const errorMap = { JSON: "❌ File JSON non valido", localStorage: "❌ Errore salvataggio dati", Network: "❌ Errore di connessione", "Word already exists": "⚠️ Parola già esistente", "English word and Italian translation are required": "⚠️ Campi obbligatori mancanti", "All words already exist": "⚠️ Tutte le parole sono già presenti", }; for (const [key, message] of Object.entries(errorMap)) { if (errorMessage.includes(key)) { return message; } } return `❌ Errore ${context}: ${errorMessage}`; }; export const NotificationProvider = ({ children }) => { const [state, dispatch] = useReducer(notificationReducer, { notifications: [], }); const showNotification = useCallback( (message, type = "success", duration = 3000) => { const id = Date.now() + Math.random(); const notificationObject = { id, message, type, timestamp: Date.now(), }; dispatch({ type: "ADD_NOTIFICATION", payload: notificationObject, }); setTimeout(() => { dispatch({ type: "REMOVE_NOTIFICATION", payload: id, }); }, duration); return id; }, [] ); const showError = useCallback( (error, context = "") => { console.error(`❌ Error in ${context}:`, error); const errorMessage = error.message || error.toString(); const userFriendlyMessage = getUserFriendlyError(errorMessage, context); return showNotification(userFriendlyMessage, "error", 5000); }, [showNotification] ); const showSuccess = useCallback( (message) => { return showNotification(message, "success"); }, [showNotification] ); const showWarning = useCallback( (message) => { return showNotification(message, "warning", 4000); }, [showNotification] ); const value = { notifications: state.notifications, showNotification, showError, showSuccess, showWarning, clearAllNotifications: useCallback(() => { dispatch({ type: "CLEAR_ALL" }); }, []), }; return ( <NotificationContext.Provider value={value}> {children} </NotificationContext.Provider> ); }; export const useNotification = () => { const context = useContext(NotificationContext); if (!context) { throw new Error("useNotification must be used within NotificationProvider"); } return context; };

================================================================================

NOME FILE: ThemeContext.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================


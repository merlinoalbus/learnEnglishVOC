NOME FILE: adminService.ts

import { createUserWithEmailAndPassword, sendPasswordResetEmail, signInWithEmailAndPassword, deleteUser } from 'firebase/auth'; import { auth, adminAuth, db } from '../config/firebase'; import { doc, setDoc, serverTimestamp, collection, getDocs, query, where, deleteDoc, writeBatch } from 'firebase/firestore'; import type { UserRole } from '../types/entities/User.types'; import { initializeUserProfile } from './authService'; export interface CreateUserRequest { email: string; displayName: string; password: string; role: UserRole; } export interface PendingUserCreation { email: string; displayName: string; password: string; role: UserRole; createdAt: any; createdBy: string; status: 'pending'; } export const createUserAsAdmin = async (userData: CreateUserRequest, adminId: string): Promise<boolean> => { try { const queueId = `pending_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; const pendingUser: PendingUserCreation = { email: userData.email, displayName: userData.displayName, password: userData.password, role: userData.role, createdAt: serverTimestamp(), createdBy: adminId, status: 'pending' }; await setDoc(doc(db, 'pending_user_creations', queueId), pendingUser); return true; } catch (error) { console.error('Error adding user to creation queue:', error); throw error; } }; export const processPendingUserCreations = async ( authMethod: 'email' | 'google' = 'google', credentials?: { email: string; password: string } ): Promise<{processed: number, failed: number}> => { console.log(`Starting processPendingUserCreations with ${authMethod} auth...`); let processed = 0; let failed = 0; const adminUser = auth.currentUser; if (!adminUser) { console.error('No admin user found'); return { processed: 0, failed: 0 }; } const adminUid = adminUser.uid; const adminEmail = adminUser.email; try { const pendingQuery = query( collection(db, 'pending_user_creations'), where('status', '==', 'pending') ); const pendingSnapshot = await getDocs(pendingQuery); console.log(`Found ${pendingSnapshot.size} pending user creations`); if (pendingSnapshot.empty) { return { processed: 0, failed: 0 }; } for (const pendingDoc of pendingSnapshot.docs) { const pendingData = pendingDoc.data() as PendingUserCreation; try { console.log(`Creating user: ${pendingData.email}`); const userCredential = await createUserWithEmailAndPassword( adminAuth, pendingData.email, pendingData.password ); const newUser = userCredential.user; await initializeUserProfile(newUser.uid, "email", true); await setDoc(doc(db, 'users', newUser.uid), { role: pendingData.role, displayName: pendingData.displayName, }, { merge: true }); await deleteDoc(doc(db, 'pending_user_creations', pendingDoc.id)); processed++; console.log(`User ${pendingData.email} created successfully`); } catch (userError: any) { console.error(`Failed to create user ${pendingData.email}:`, userError); if (userError.code === 'auth/email-already-in-use') { console.log(`Email ${pendingData.email} already exists, removing from queue`); await deleteDoc(doc(db, 'pending_user_creations', pendingDoc.id)); } failed++; } } console.log(`Processing complete. Processed: ${processed}, Failed: ${failed}`); if (processed > 0) { console.log('Cleaning up admin auth session...'); try { await adminAuth.signOut(); console.log('Admin auth session cleaned up successfully'); } catch (authError) { console.error('Failed to clean up admin auth session:', authError); } } return { processed, failed }; } catch (error) { console.error('Error processing pending user creations:', error); try { await adminAuth.signOut(); } catch (authError) { console.error('Failed to clean up admin auth session:', authError); } return { processed, failed }; } }; export const processPendingUserCreationsForGoogle = processPendingUserCreations; export const resetPasswordAsAdmin = async (email: string): Promise<boolean> => { try { await sendPasswordResetEmail(auth, email); return true; } catch (error) { console.error('Error sending password reset email:', error); throw error; } }; export const generateSecurePassword = (): string => { const length = 12; const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*'; let password = ''; for (let i = 0; i < length; i++) { const randomIndex = Math.floor(Math.random() * charset.length); password += charset[randomIndex]; } return password; }; export const getPendingUserCreationsCount = async (): Promise<number> => { try { const pendingQuery = query( collection(db, 'pending_user_creations'), where('status', '==', 'pending') ); const pendingSnapshot = await getDocs(pendingQuery); return pendingSnapshot.size; } catch (error) { console.error('Error getting pending user creations count:', error); return 0; } }; export const cleanupAdminOperations = async (): Promise<{ deleted: number }> => { try { const adminOpsQuery = query(collection(db, 'admin_operations')); const adminOpsSnapshot = await getDocs(adminOpsQuery); const batch = writeBatch(db); let deleted = 0; adminOpsSnapshot.docs.forEach((doc) => { batch.delete(doc.ref); deleted++; }); await batch.commit(); console.log(`Cleaned up ${deleted} admin operations`); return { deleted }; } catch (error) { console.error('Error cleaning up admin operations:', error); return { deleted: 0 }; } }; export const deleteUserComplete = async (userId: string, adminId: string): Promise<{success: boolean, authDeleted: boolean, message: string}> => { try { const userRef = doc(db, 'users', userId); const userDoc = await getDocs(query(collection(db, 'users'), where('__name__', '==', userId))); if (userDoc.empty) { return { success: false, authDeleted: false, message: 'Utente non trovato nel database' }; } const userData = userDoc.docs[0].data(); const userEmail = userData.email; const batch = writeBatch(db); batch.delete(userRef); const prefsRef = doc(db, 'user_preferences', userId); batch.delete(prefsRef); const userDataCollections = [ 'words', 'test_history', 'statistics', 'performance', 'user_achievements', 'user_sessions', 'user_exports', 'user_imports', 'user_vocabulary', 'user_progress', 'user_feedback', 'user_notifications' ]; for (const collectionName of userDataCollections) { const userDataQuery = query( collection(db, collectionName), where('userId', '==', userId) ); const userDataSnapshot = await getDocs(userDataQuery); userDataSnapshot.docs.forEach((doc) => { batch.delete(doc.ref); }); } const pendingUserQuery = query( collection(db, 'pending_user_creations'), where('email', '==', userEmail) ); const pendingUserSnapshot = await getDocs(pendingUserQuery); pendingUserSnapshot.docs.forEach((doc) => { batch.delete(doc.ref); }); const invitationsQuery = query( collection(db, 'user_invitations'), where('email', '==', userEmail) ); const invitationsSnapshot = await getDocs(invitationsQuery); invitationsSnapshot.docs.forEach((doc) => { batch.delete(doc.ref); }); const operationRef = doc(collection(db, 'admin_operations')); batch.set(operationRef, { type: 'delete_user', targetUserId: userId, performedBy: adminId, timestamp: serverTimestamp(), }); await batch.commit(); console.log(`User ${userId} completely deleted from Firestore with comprehensive cleanup`); let authDeleted = false; let message = `Utente ${userEmail} eliminato completamente dal database.`; message += ' Eliminati anche: dati personali, statistiche, preferenze, inviti e attività in sospeso.'; try { console.warn('Cannot delete user from Authentication - Firebase client SDK limitation'); message += ' NOTA: L\'utente deve essere eliminato manualmente da Firebase Authentication Console.'; } catch (authError) { console.error('Error deleting user from Authentication:', authError); message += ' Errore nell\'eliminazione da Authentication.'; } return { success: true, authDeleted, message }; } catch (error) { console.error('Error deleting user:', error); return { success: false, authDeleted: false, message: 'Errore nell\'eliminazione dell\'utente' }; } };

================================================================================

NOME FILE: aiService.ts

import AppConfig, { isAIAvailable } from "../config/appConfig"; import { WORD_CATEGORIES } from "../types/entities/Word.types"; import { withTimeout, globalOperationManager } from "../utils/retryUtils"; interface AIAnalysisResult { italian: string; group: string; sentence?: string; sentences?: string[]; synonyms?: string[]; antonyms?: string[]; notes: string; chapter: string; _aiError?: boolean; _fallbackUsed?: boolean; } interface AIServiceStatus { configured: boolean; health: HealthStatus; consecutiveFailures: number; lastSuccessTime: number | null; lastHealthCheck: number | null; circuitBreaker: any; apiUrl: string; timeout: number; canUseAI: boolean; degradedMode: boolean; recommendations: string[]; } interface APIResponse { candidates: Array<{ content: { parts: Array<{ text: string; }>; }; }>; } type HealthStatus = "unknown" | "healthy" | "degraded" | "down"; class AIService { private config: any; private isConfigured: boolean; private canUseAI: boolean; private lastSuccessTime: number | null; private consecutiveFailures: number; private healthStatus: HealthStatus; private lastHealthCheck: number | null; constructor() { this.config = AppConfig.ai; this.isConfigured = !!this.config.apiKey; this.canUseAI = isAIAvailable() || false; this.lastSuccessTime = null; this.consecutiveFailures = 0; this.healthStatus = "unknown"; this.lastHealthCheck = null; this.initializeService(); } private initializeService(): void { if (!this.isConfigured) { this.healthStatus = "down"; } else { this.healthStatus = "healthy"; } if (AppConfig.app.environment === "development") { console.log("🤖 Enhanced AI Service Status (NO AUTO-PING):", { configured: this.isConfigured, canUseAI: this.canUseAI, apiKeyPresent: !!this.config.apiKey, healthStatus: this.healthStatus, }); } } private checkHealthPassive(): boolean { if (!this.isConfigured) { this.healthStatus = "down"; this.lastHealthCheck = Date.now(); return false; } const now = Date.now(); const fiveMinutesAgo = now - 5 * 60 * 1000; if (this.lastSuccessTime && this.lastSuccessTime > fiveMinutesAgo) { this.healthStatus = "healthy"; this.lastHealthCheck = now; return true; } if (this.consecutiveFailures > 3) { this.healthStatus = "down"; } else if (this.consecutiveFailures > 1) { this.healthStatus = "degraded"; } else { this.healthStatus = "healthy"; } this.lastHealthCheck = now; return this.healthStatus === "healthy"; } async checkHealthManual(): Promise<boolean> { if (!this.isConfigured) { this.healthStatus = "down"; this.lastHealthCheck = Date.now(); return false; } try { console.log("🔍 Manual AI health check (COSTS MONEY)..."); const response = await withTimeout( () => fetch(this.getApiUrl(), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }], }), }), 8000 ); const isHealthy = response.ok || response.status === 400; if (isHealthy) { this.healthStatus = "healthy"; this.consecutiveFailures = 0; this.lastSuccessTime = Date.now(); console.log("✅ AI service manually verified as healthy"); } else { this.consecutiveFailures++; this.healthStatus = this.consecutiveFailures > 2 ? "down" : "degraded"; console.log( "⚠️ AI service manually verified as degraded:", response.status ); } this.lastHealthCheck = Date.now(); return isHealthy; } catch (error) { this.consecutiveFailures++; if ((error as Error).message.includes("timeout")) { this.healthStatus = "degraded"; console.log("⏱️ AI service manual timeout"); } else if ( (error as Error).message.includes("fetch") || (error as Error).message.includes("network") ) { this.healthStatus = this.consecutiveFailures > 2 ? "down" : "degraded"; console.log("📡 AI service manual network error"); } else { this.healthStatus = this.consecutiveFailures > 3 ? "down" : "degraded"; console.log("❌ AI service manual error:", (error as Error).message); } this.lastHealthCheck = Date.now(); return false; } } async analyzeWord(englishWord: string): Promise<AIAnalysisResult> { if (!englishWord || typeof englishWord !== "string") { throw new Error("Valid English word is required"); } const trimmedWord = englishWord.trim(); if (!trimmedWord) { throw new Error("English word cannot be empty"); } if (!this.isConfigured) { throw new Error( "AI service not configured. Add REACT_APP_GEMINI_API_KEY to .env.local" ); } try { const result = await globalOperationManager.execute( "aiAnalysis", async () => await this.performAnalysis(trimmedWord) ); this.consecutiveFailures = 0; this.lastSuccessTime = Date.now(); this.healthStatus = "healthy"; console.log("✅ AI analysis successful - health updated"); return result; } catch (error) { this.consecutiveFailures++; if ((error as Error).message.includes("API key") || (error as Error).message.includes("401")) { this.healthStatus = "down"; throw new Error("🔑 API key non valida. Verifica configurazione."); } else if ( (error as Error).message.includes("quota") || (error as Error).message.includes("limit") ) { this.healthStatus = "down"; throw new Error("🚫 Limite API raggiunto. Riprova più tardi."); } else if ((error as Error).message.includes("timeout")) { this.healthStatus = "degraded"; throw new Error("⏱️ AI timeout. Connessione lenta."); } else if ((error as Error).message.includes("Circuit breaker")) { this.healthStatus = "down"; throw new Error("🔴 AI temporaneamente non disponibile."); } else { this.healthStatus = this.consecutiveFailures > 2 ? "down" : "degraded"; console.log( `❌ AI analysis failed - health updated to ${this.healthStatus}` ); throw new Error(`🤖 Errore AI: ${(error as Error).message}`); } } } async analyzeWordWithFallback(englishWord: string): Promise<AIAnalysisResult> { try { return await this.analyzeWord(englishWord); } catch (error) { console.warn("🤖 AI analysis failed, providing fallback:", (error as Error).message); return { italian: "", group: this.categorizeWordFallback(englishWord), sentence: "", notes: `🤖 AI non disponibile: ${(error as Error).message}. Completa manualmente.`, chapter: "", _aiError: true, _fallbackUsed: true, }; } } private async performAnalysis(word: string): Promise<AIAnalysisResult> { const prompt = this.buildPrompt(word); const apiResponse = await this.makeRequest(prompt); const content = apiResponse.candidates[0].content.parts[0].text; return this.parseAIResponse(content, word); } private async makeRequest(prompt: string): Promise<APIResponse> { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), this.config.timeout); try { const response = await fetch(this.getApiUrl(), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], }), signal: controller.signal, }); clearTimeout(timeoutId); if (!response.ok) { const errorText = await response.text(); if (response.status === 401) { throw new Error("API key non valida"); } else if (response.status === 403) { throw new Error("Accesso negato API"); } else if (response.status === 429) { throw new Error("Troppi richieste"); } else if (response.status === 400) { throw new Error("Richiesta non valida"); } else if (response.status >= 500) { throw new Error("Errore server Gemini"); } else { throw new Error(`API Error ${response.status}: ${errorText}`); } } const data = await response.json(); if (!data.candidates?.[0]?.content?.parts?.[0]?.text) { throw new Error("Risposta API non valida"); } return data; } catch (error) { clearTimeout(timeoutId); if ((error as Error).name === "AbortError") { throw new Error("Request timeout"); } if ( (error as Error).message.includes("fetch") || (error as Error).message.includes("network") ) { throw new Error("Errore di rete"); } throw error; } } private parseAIResponse(content: string, fallbackWord: string): AIAnalysisResult { try { console.log("🔍 AI Raw Response:", content); const jsonMatch = content.match(/\{[\s\S]*\}/); if (!jsonMatch) { console.error("❌ No JSON found in AI response"); return this.createFallbackResponse(fallbackWord, "No JSON in response"); } const parsedData = JSON.parse(jsonMatch[0]); console.log("📊 AI Parsed Data:", parsedData); const result = this.validateAndSanitizeResponse(parsedData, fallbackWord); console.log("✅ AI Final Result:", result); return result; } catch (parseError) { console.error("❌ AI JSON Parsing Error:", parseError); return this.createFallbackResponse(fallbackWord, "JSON parsing failed"); } } private validateAndSanitizeResponse(data: any, fallbackWord: string): AIAnalysisResult { const result: AIAnalysisResult = { italian: "", group: "", sentences: [], synonyms: [], antonyms: [], notes: "", chapter: "", }; if ( !data.italian || typeof data.italian !== "string" || !data.italian.trim() ) { return this.createFallbackResponse(fallbackWord, "Missing translation"); } result.italian = data.italian.trim(); if (data.group && WORD_CATEGORIES.includes(data.group)) { result.group = data.group; } else { result.group = this.categorizeWordFallback(fallbackWord); } console.log("🔍 Validating sentences - data.sentences:", data.sentences, "data.sentence:", data.sentence); if (Array.isArray(data.sentences) && data.sentences.length > 0) { result.sentences = data.sentences .filter((s: any) => typeof s === "string" && s.trim()) .map((s: string) => s.trim()) .slice(0, 5); console.log("✅ Using sentences array:", result.sentences); } else if (data.sentence && typeof data.sentence === "string") { result.sentences = [data.sentence.trim()]; result.sentence = data.sentence.trim(); console.log("✅ Using single sentence fallback:", result.sentences); } else { console.warn("⚠️ No sentences found in AI response!"); } console.log("🔍 Validating synonyms - data.synonyms:", data.synonyms); if (Array.isArray(data.synonyms) && data.synonyms.length > 0) { result.synonyms = data.synonyms .filter((s: any) => typeof s === "string" && s.trim()) .map((s: string) => s.trim()) .slice(0, 8); console.log("✅ Using synonyms:", result.synonyms); } else { console.warn("⚠️ No synonyms found in AI response!"); } console.log("🔍 Validating antonyms - data.antonyms:", data.antonyms); if (Array.isArray(data.antonyms) && data.antonyms.length > 0) { result.antonyms = data.antonyms .filter((s: any) => typeof s === "string" && s.trim()) .map((s: string) => s.trim()) .slice(0, 8); console.log("✅ Using antonyms:", result.antonyms); } else { console.warn("⚠️ No antonyms found in AI response!"); } result.notes = data.notes && typeof data.notes === "string" ? data.notes.trim() : ""; result.chapter = ""; return result; } private createFallbackResponse(word: string, reason: string): AIAnalysisResult { return { italian: "", group: this.categorizeWordFallback(word), sentences: [], synonyms: [], antonyms: [], notes: `❌ AI analysis failed: ${reason}. Fill manually.`, chapter: "", _aiError: true, _fallbackUsed: true, }; } private buildPrompt(englishWord: string): string { const groupsList = WORD_CATEGORIES.join(", "); return ` Genera JSON per la parola inglese "${englishWord}": { "italian": "traduzione principale", "group": "categoria esatta dalla lista", "sentences": [ "Frase di esempio 1 con ${englishWord}", "Frase di esempio 2 con ${englishWord}", "Frase di esempio 3 con ${englishWord}" ], "synonyms": ["sinonimo1", "sinonimo2", "sinonimo3"], "antonyms": ["contrario1", "contrario2"], "notes": "note utili", "chapter": "" } REGOLE CRITICHE: 1. SEMPRE includere ESATTAMENTE 3 frasi nell'array "sentences" 2. SEMPRE includere almeno 3 sinonimi nell'array "synonyms" 3. Se esistono contrari, includerli nell'array "antonyms" 4. Solo JSON puro, senza testo prima o dopo 5. "group" deve essere uno di: ${groupsList} ESEMPIO PER "${englishWord}": Se "${englishWord}" = "check": { "italian": "controllare, verificare", "group": "VERBI_BASE", "sentences": [ "Please check your email", "I need to check the time", "The doctor will check your blood pressure" ], "synonyms": ["verify", "examine", "inspect", "review"], "antonyms": ["ignore", "neglect"], "notes": "Verbo molto comune con molteplici significati", "chapter": "" } IMPORTANTE: NON scrivere altro testo, solo il JSON! `; } public categorizeWordFallback(word: string): string { const wordLower = word.toLowerCase(); if ( wordLower.match( /^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/ ) ) { return "VERBI_BASE"; } if ( wordLower.match( /^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/ ) ) { return "VERBI_IRREGOLARI_COMUNI"; } if ( wordLower.match( /^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/ ) || wordLower.match( /^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/ ) ) { return "AGGETTIVI_BASE"; } if ( wordLower.match( /^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/ ) ) { return "TECNOLOGIA_DIGITALE"; } if ( wordLower.match( /^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/ ) ) { return "FAMIGLIA_PARENTELA"; } if ( wordLower.match( /^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/ ) ) { return "STATI_EMOTIVI"; } if ( wordLower.match( /^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/ ) ) { return "STATI_EMOTIVI"; } if ( wordLower.match( /^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/ ) ) { return "LAVORO_PROFESSIONI"; } if ( wordLower.match( /^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/ ) ) { return "VESTITI_ACCESSORI"; } return "CORPO_UMANO"; } private getApiUrl(): string { if (!this.config.apiKey) { throw new Error("API key non configurata"); } return `${this.config.baseUrl}?key=${this.config.apiKey}`; } getServiceStatus(): AIServiceStatus { const circuitBreakerStatus = globalOperationManager.getOperationStatus("aiAnalysis"); return { configured: this.isConfigured, health: this.healthStatus, consecutiveFailures: this.consecutiveFailures, lastSuccessTime: this.lastSuccessTime, lastHealthCheck: this.lastHealthCheck, circuitBreaker: circuitBreakerStatus?.circuitBreaker, apiUrl: this.config.baseUrl, timeout: this.config.timeout, canUseAI: this.canUseAI, degradedMode: this.healthStatus === "degraded", recommendations: this.getRecommendations(), }; } private getRecommendations(): string[] { const recommendations: string[] = []; if (!this.isConfigured) { recommendations.push("🔑 Configurare API key in .env.local"); } if (this.healthStatus === "down") { recommendations.push("🔴 Servizio non disponibile. Usa modalità manuale"); } if (this.healthStatus === "degraded") { recommendations.push("🟡 Servizio instabile. Verifica connessione"); } if (this.consecutiveFailures > 2) { recommendations.push( "⚠️ Molti errori consecutivi. Controlla configurazione" ); } return recommendations; } quickCategorize(englishWord: string): string { if (!englishWord || typeof englishWord !== "string") { return "CORPO_UMANO"; } return this.categorizeWordFallback(englishWord.trim()); } async checkHealth(): Promise<boolean> { return await this.checkHealthManual(); } isAvailable(): boolean { return this.checkHealthPassive(); } getStatus(): AIServiceStatus { return this.getServiceStatus(); } } const aiService = new AIService(); export { aiService }; export default aiService;

================================================================================

NOME FILE: authService.ts

import { signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updateProfile, updatePassword, reauthenticateWithCredential, EmailAuthProvider, onAuthStateChanged, User as FirebaseUser, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, sendPasswordResetEmail, type UserCredential, type AuthError as FirebaseAuthError, } from "firebase/auth"; import { auth } from "../config/firebase"; import type { AuthUser, AuthOperationResult, AuthError, AuthSession, SignInWithEmailInput, SignUpWithEmailInput, ResetPasswordInput, UpdateProfileInput, UpdatePasswordInput, } from "../types/infrastructure/Auth.types"; import { collection, doc, getDoc, getDocs, setDoc, updateDoc, deleteDoc, query, where, orderBy, serverTimestamp, writeBatch, } from "firebase/firestore"; import { verifyPasswordResetCode as firebaseVerifyPasswordResetCode, confirmPasswordReset as firebaseConfirmPasswordReset, applyActionCode } from "firebase/auth"; import { db } from "../config/firebase"; import { UserRole, UserPermissions, AdminOperation, UserManagementFilters, UserExportData, DEFAULT_PERMISSIONS, UserPreferences, UserProfile, UserStats, AppTheme, NotificationPreferences, } from "../types/entities/User.types"; import type { User, AuthState, SignUpInput, SignInInput, AuthOperationResult as UserAuthOperationResult, } from "../types/entities/User.types"; export const getUserProfile = async (userId: string): Promise<User | null> => { try { const userDoc = await getDoc(doc(db, USERS_COLLECTION, userId)); if (!userDoc.exists()) { return null; } const data = userDoc.data(); const cleanedData: User = { id: userDoc.id, email: data.email || "", displayName: data.displayName || undefined, photoURL: data.photoURL || undefined, emailVerified: data.emailVerified || false, providerId: data.providerId || "password", role: data.role || "user", isActive: data.isActive !== undefined ? data.isActive : true, createdAt: data.createdAt instanceof Date ? data.createdAt : (data.createdAt?.toDate ? data.createdAt.toDate() : (data.createdAt?.seconds ? new Date(data.createdAt.seconds * 1000) : (data.createdAt?._methodName === 'serverTimestamp' ? new Date() : new Date()))), lastLoginAt: data.lastLoginAt instanceof Date ? data.lastLoginAt : (data.lastLoginAt?.toDate?.() || new Date()), metadata: data.metadata || { registrationMethod: "email", }, fullName: data.fullName || undefined, nativeLanguage: data.nativeLanguage || undefined, targetLanguage: data.targetLanguage || undefined, englishLevel: data.englishLevel || undefined, learningGoal: data.learningGoal || undefined, dailyWordTarget: data.dailyWordTarget || undefined, weeklyTestTarget: data.weeklyTestTarget || undefined, bio: data.bio || undefined, profileCreatedAt: data.profileCreatedAt instanceof Date ? data.profileCreatedAt : (data.profileCreatedAt?.toDate ? data.profileCreatedAt.toDate() : undefined), profileUpdatedAt: data.profileUpdatedAt instanceof Date ? data.profileUpdatedAt : (data.profileUpdatedAt?.toDate ? data.profileUpdatedAt.toDate() : undefined), totalActiveDays: data.totalActiveDays || undefined, currentStreak: data.currentStreak || undefined, longestStreak: data.longestStreak || undefined, totalWordsAdded: data.totalWordsAdded || undefined, totalWordsLearned: data.totalWordsLearned || undefined, totalTestsCompleted: data.totalTestsCompleted || undefined, totalStudyTime: data.totalStudyTime || undefined, averageTestAccuracy: data.averageTestAccuracy || undefined, progressLevel: data.progressLevel || undefined, nextMilestone: data.nextMilestone || undefined, statsUpdatedAt: data.statsUpdatedAt instanceof Date ? data.statsUpdatedAt : (data.statsUpdatedAt?.toDate ? data.statsUpdatedAt.toDate() : undefined), migratedAt: data.migratedAt instanceof Date ? data.migratedAt : (data.migratedAt?.toDate ? data.migratedAt.toDate() : undefined), lastUpdated: data.lastUpdated instanceof Date ? data.lastUpdated : (data.lastUpdated?.toDate ? data.lastUpdated.toDate() : undefined), }; return cleanedData; } catch (error) { console.error("Error getting user profile:", error); throw new Error("Failed to get user profile"); } }; export const initializeUserProfile = async ( userId: string, registrationMethod: "email" | "google" = "email", isNewUser: boolean = true ): Promise<User> => { try { const userRef = doc(db, USERS_COLLECTION, userId); const existingProfile = await getDoc(userRef); if (existingProfile.exists() && !isNewUser) { await setDoc( userRef, { lastLoginAt: serverTimestamp(), }, { merge: true } ); const profileData = existingProfile.data() as User; return { ...profileData, id: userId, lastLoginAt: new Date(), }; } const defaultRole: UserRole = "user"; const currentUser = getCurrentUser(); if (!currentUser) { throw new Error("No authenticated user found"); } const isFirstUser = await checkIfFirstUser(); let role: UserRole = isFirstUser ? "admin" : defaultRole; if (!isFirstUser) { const invitationRole = await checkUserInvitation(currentUser.email!); if (invitationRole) { role = invitationRole; } } const newUser: Partial<User> = { id: userId, email: currentUser.email, displayName: currentUser.displayName || undefined, photoURL: currentUser.photoURL || undefined, emailVerified: currentUser.emailVerified, providerId: currentUser.providerId, role, isActive: true, createdAt: new Date(), lastLoginAt: new Date(), metadata: { registrationMethod, ...(isNewUser && { notes: "Auto-created profile" }), }, }; const cleanObject = (obj: any): any => { if (obj === null || typeof obj !== 'object') return obj; if (Array.isArray(obj)) return obj.map(cleanObject); const cleaned: any = {}; for (const [key, value] of Object.entries(obj)) { if (value !== undefined) { cleaned[key] = cleanObject(value); } } return cleaned; }; const cleanUser = cleanObject({ ...newUser, createdAt: serverTimestamp(), lastLoginAt: serverTimestamp(), }); await setDoc(userRef, cleanUser); await initializeUserCollections(userId); return newUser as User; } catch (error) { console.error("Error initializing user profile:", error); throw new Error("Failed to initialize user profile"); } }; const initializeUserCollections = async (userId: string): Promise<void> => { try { const userRef = doc(db, USERS_COLLECTION, userId); const consolidatedData = { nativeLanguage: "it", targetLanguage: "en", englishLevel: "B1", learningGoal: "general", dailyWordTarget: 20, weeklyTestTarget: 3, profileCreatedAt: serverTimestamp(), profileUpdatedAt: serverTimestamp(), theme: "light", interfaceLanguage: "it", testPreferences: { defaultTestMode: "normal", defaultWordsPerTest: 20, hintsEnabled: true, autoAdvanceDelay: 3000, showMeaningAfterAnswer: true, showTimer: true, soundsEnabled: true, }, notificationPreferences: { pushEnabled: true, emailEnabled: true, dailyReminder: true, reminderTime: "19:00", weeklyTestReminder: true, progressNotifications: true, achievementNotifications: true, }, audioPreferences: { autoPlayPronunciation: true, volume: 0.8, playbackSpeed: 1.0, actionSounds: true, }, displayPreferences: { fontSize: "medium", highContrast: false, reducedMotion: false, compactView: false, showAdvancedStats: false, }, totalActiveDays: 0, currentStreak: 0, longestStreak: 0, totalWordsAdded: 0, totalWordsLearned: 0, totalTestsCompleted: 0, totalStudyTime: 0, averageTestAccuracy: 0, progressLevel: 1, nextMilestone: { id: "first_test", name: "Primo Test", description: "Completa il tuo primo test", icon: "🎯", target: 1, progress: 0, completed: false, reward: "Badge Principiante", }, statsUpdatedAt: serverTimestamp(), lastUpdated: serverTimestamp(), }; await updateDoc(userRef, consolidatedData); } catch (error) { console.error("Error initializing user collections:", error); throw new Error("Failed to initialize user collections"); } }; export const getAllUsers = async ( filters?: UserManagementFilters ): Promise<User[]> => { try { let q = query( collection(db, USERS_COLLECTION), orderBy("createdAt", "desc") ); if (filters?.role) { q = query(q, where("role", "==", filters.role)); } if (filters?.isActive !== undefined) { q = query(q, where("isActive", "==", filters.isActive)); } if (filters?.emailVerified !== undefined) { q = query(q, where("emailVerified", "==", filters.emailVerified)); } const snapshot = await getDocs(q); let users = snapshot.docs.map((doc) => { const data = doc.data(); return { ...data, id: doc.id, createdAt: data.createdAt instanceof Date ? data.createdAt : (data.createdAt?.toDate ? data.createdAt.toDate() : (data.createdAt?.seconds ? new Date(data.createdAt.seconds * 1000) : new Date())), lastLoginAt: data.lastLoginAt instanceof Date ? data.lastLoginAt : (data.lastLoginAt?.toDate ? data.lastLoginAt.toDate() : (data.lastLoginAt?.seconds ? new Date(data.lastLoginAt.seconds * 1000) : undefined)), }; }) as User[]; if (filters?.searchTerm) { const term = filters.searchTerm.toLowerCase(); users = users.filter( (user) => user.email.toLowerCase().includes(term) || user.displayName?.toLowerCase().includes(term) || user.id.includes(term) ); } return users; } catch (error) { console.error("Error getting all users:", error); throw new Error("Failed to get users"); } }; export const toggleUserStatus = async ( userId: string, isActive: boolean, adminId: string ): Promise<boolean> => { try { const batch = writeBatch(db); const userRef = doc(db, USERS_COLLECTION, userId); batch.update(userRef, { isActive, updatedAt: serverTimestamp(), }); const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: isActive ? "unblock_user" : "block_user", targetUserId: userId, performedBy: adminId, timestamp: new Date(), metadata: { isActive }, }; batch.set(operationRef, { ...operation, timestamp: serverTimestamp(), }); await batch.commit(); return true; } catch (error) { console.error("Error toggling user status:", error); return false; } }; export const resetUserPassword = async ( userEmail: string, adminId: string ): Promise<boolean> => { try { await sendPasswordResetEmail(auth, userEmail); const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "password_reset", targetUserId: userEmail, performedBy: adminId, timestamp: new Date(), metadata: { email: userEmail }, }; await setDoc(operationRef, { ...operation, timestamp: serverTimestamp(), }); return true; } catch (error) { console.error("Error sending password reset:", error); return false; } }; export const deleteUserData = async ( userId: string, adminId: string ): Promise<boolean> => { try { const batch = writeBatch(db); const userRef = doc(db, USERS_COLLECTION, userId); batch.delete(userRef); const userDataCollections = ["words", "test_history", "statistics"]; for (const collectionName of userDataCollections) { const userDataQuery = query( collection(db, collectionName), where("userId", "==", userId) ); const userDataSnapshot = await getDocs(userDataQuery); userDataSnapshot.docs.forEach((doc) => { batch.delete(doc.ref); }); } const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "delete_user", targetUserId: userId, performedBy: adminId, timestamp: new Date(), }; batch.set(operationRef, { ...operation, timestamp: serverTimestamp(), }); await batch.commit(); return true; } catch (error) { console.error("Error deleting user:", error); return false; } }; export const exportUserData = async ( userId: string, adminId: string ): Promise<UserExportData | null> => { try { const userProfile = await getUserProfile(userId); if (!userProfile) { throw new Error("User not found"); } const collections = ["words", "test_history", "statistics"]; const userData: Record<string, any[]> = {}; for (const collectionName of collections) { const userDataQuery = query( collection(db, collectionName), where("userId", "==", userId) ); const snapshot = await getDocs(userDataQuery); userData[collectionName] = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data(), })); } const exportData: UserExportData = { profile: userProfile, words: userData.words || [], testHistory: userData.test_history || [], statistics: userData.statistics || [], exportedAt: new Date(), exportedBy: adminId, }; const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "export_data", targetUserId: userId, performedBy: adminId, timestamp: new Date(), metadata: { wordsCount: exportData.words.length, testHistoryCount: exportData.testHistory.length, statisticsCount: exportData.statistics.length, }, }; await setDoc(operationRef, { ...operation, timestamp: serverTimestamp(), }); return exportData; } catch (error) { console.error("Error exporting user data:", error); return null; } }; export const importUserData = async ( userId: string, importData: Partial<UserExportData>, adminId: string ): Promise<boolean> => { try { const batch = writeBatch(db); const collections = { words: importData.words || [], test_history: importData.testHistory || [], statistics: importData.statistics || [], }; for (const [collectionName, items] of Object.entries(collections)) { items.forEach((item: any) => { const docRef = doc(collection(db, collectionName)); batch.set(docRef, { ...item, userId, importedAt: serverTimestamp(), }); }); } const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "import_data", targetUserId: userId, performedBy: adminId, timestamp: new Date(), metadata: { wordsCount: collections.words.length, testHistoryCount: collections.test_history.length, statisticsCount: collections.statistics.length, }, }; batch.set(operationRef, { ...operation, timestamp: serverTimestamp(), }); await batch.commit(); return true; } catch (error) { console.error("Error importing user data:", error); return false; } }; export const getAdminOperations = async ( limit_count: number = 50 ): Promise<AdminOperation[]> => { try { const q = query( collection(db, ADMIN_OPERATIONS_COLLECTION), orderBy("timestamp", "desc") ); const snapshot = await getDocs(q); return snapshot.docs.slice(0, limit_count).map((doc) => ({ ...doc.data(), timestamp: doc.data().timestamp?.toDate() || new Date(), })) as AdminOperation[]; } catch (error) { console.error("Error getting admin operations:", error); throw new Error("Failed to get admin operations"); } }; export const checkIfFirstUser = async (): Promise<boolean> => { try { const usersQuery = query(collection(db, USERS_COLLECTION)); const snapshot = await getDocs(usersQuery); return snapshot.size === 0; } catch (error) { console.error("Error checking if first user:", error); return false; } }; const checkUserInvitation = async (email: string): Promise<UserRole | null> => { try { const invitationsRef = collection(db, 'user_invitations'); const q = query( invitationsRef, where('email', '==', email), where('status', '==', 'pending') ); const snapshot = await getDocs(q); if (!snapshot.empty) { const invitation = snapshot.docs[0].data(); await updateDoc(doc(db, 'user_invitations', snapshot.docs[0].id), { status: 'completed' }); return invitation.role as UserRole; } return null; } catch (error) { console.error("Error checking user invitation:", error); return null; } }; const USERS_COLLECTION = "users"; const ADMIN_OPERATIONS_COLLECTION = "admin_operations"; const AUTH_SERVICE_CONFIG = { sessionTimeout: 24 * 60 * 60 * 1000, inactivityTimeout: 2 * 60 * 60 * 1000, maxLoginAttempts: 5, lockoutDuration: 15 * 60 * 1000, enableSessionTracking: true, enableSecurityLogging: process.env.NODE_ENV === "development", }; const debugLog = (message: string, data?: any) => { if (AUTH_SERVICE_CONFIG.enableSecurityLogging) { console.log(`🔐 [AuthService] ${message}`, data || ""); } }; const convertFirebaseUser = (firebaseUser: FirebaseUser): AuthUser => { return { uid: firebaseUser.uid, email: firebaseUser.email, displayName: firebaseUser.displayName, photoURL: firebaseUser.photoURL, phoneNumber: firebaseUser.phoneNumber, emailVerified: firebaseUser.emailVerified, isAnonymous: firebaseUser.isAnonymous, metadata: { creationTime: new Date(firebaseUser.metadata.creationTime!), lastSignInTime: new Date(firebaseUser.metadata.lastSignInTime!), }, providerData: firebaseUser.providerData.map((provider) => ({ providerId: provider.providerId, uid: provider.uid, email: provider.email, displayName: provider.displayName, photoURL: provider.photoURL, phoneNumber: provider.phoneNumber, })), }; }; const convertToUserEntity = (authUser: AuthUser): User => { return { id: authUser.uid, email: authUser.email || "", displayName: authUser.displayName || undefined, photoURL: authUser.photoURL || undefined, emailVerified: authUser.emailVerified, providerId: authUser.providerData[0]?.providerId || "password", createdAt: authUser.metadata.creationTime, lastLoginAt: authUser.metadata.lastSignInTime, role: "user" as UserRole, isActive: true, }; }; const convertAuthError = ( firebaseError: FirebaseAuthError, operation: string ): AuthError => { const getErrorType = (code: string) => { switch (code) { case "auth/network-request-failed": return "network-error"; case "auth/invalid-email": case "auth/user-not-found": case "auth/wrong-password": case "auth/invalid-credential": return "invalid-credentials"; case "auth/email-already-in-use": case "auth/weak-password": return "user-management"; case "auth/too-many-requests": return "rate-limited"; default: return "unknown"; } }; const getUserFriendlyMessage = (code: string): string => { switch (code) { case "auth/email-already-in-use": return "Questa email è già registrata. Prova ad accedere o usa un'altra email."; case "auth/weak-password": return "La password deve contenere almeno 6 caratteri."; case "auth/invalid-email": return "L'indirizzo email non è valido."; case "auth/user-not-found": return "Non esiste un account con questa email."; case "auth/wrong-password": return "Password non corretta."; case "auth/invalid-credential": return operation === "password-update" ? "Password corrente non corretta." : "Credenziali non valide. Controlla email e password."; case "auth/network-request-failed": return "Errore di connessione. Verifica la tua connessione internet."; case "auth/too-many-requests": return "Troppi tentativi di accesso. Riprova tra qualche minuto."; case "auth/user-disabled": return "Questo account è stato disabilitato."; case "auth/operation-not-allowed": return "Operazione non consentita. Contatta il supporto."; default: return "Si è verificato un errore. Riprova più tardi."; } }; return { code: firebaseError.code, message: getUserFriendlyMessage(firebaseError.code), operation: operation as any, recoverable: ["network-error", "rate-limited"].includes( getErrorType(firebaseError.code) ), timestamp: new Date(), type: getErrorType(firebaseError.code), }; }; const createOperationResult = ( success: boolean, user?: AuthUser, error?: AuthError, message?: string ): AuthOperationResult => { return { success, user, error, message, metadata: { timestamp: new Date(), duration: 0, }, }; }; export const signUp = async ( input: SignUpWithEmailInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Sign up attempt", { email: input.email }); const userCredential: UserCredential = await createUserWithEmailAndPassword( auth, input.email, input.password ); if (input.displayName) { await updateProfile(userCredential.user, { displayName: input.displayName, }); } const authUser = convertFirebaseUser(userCredential.user); debugLog("Sign up successful", { uid: authUser.uid }); const result = createOperationResult( true, authUser, undefined, "Account creato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Sign up failed", error); const authError = convertAuthError(error as FirebaseAuthError, "sign-up"); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const signIn = async ( input: SignInWithEmailInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Sign in attempt", { email: input.email }); const userCredential: UserCredential = await signInWithEmailAndPassword( auth, input.email, input.password ); const authUser = convertFirebaseUser(userCredential.user); const userEntity = convertToUserEntity(authUser); await initializeUserProfile(userEntity.id, "email", false); debugLog("Sign in successful", { uid: authUser.uid }); const result = createOperationResult( true, authUser, undefined, "Login effettuato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Sign in failed", error); const authError = convertAuthError(error as FirebaseAuthError, "sign-in"); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const signInWithGoogle = async (): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Google sign in attempt"); const provider = new GoogleAuthProvider(); provider.setCustomParameters({ prompt: 'select_account' }); let userCredential: UserCredential; try { userCredential = await signInWithPopup(auth, provider); } catch (popupError: any) { if (popupError.code === 'auth/popup-blocked' || popupError.code === 'auth/cancelled-popup-request') { debugLog("Popup blocked, trying redirect"); await signInWithRedirect(auth, provider); const result = createOperationResult( true, undefined, undefined, "Reindirizzamento a Google..." ); result.metadata.duration = Date.now() - startTime; return result; } throw popupError; } const authUser = convertFirebaseUser(userCredential.user); const userEntity = convertToUserEntity(authUser); const isNewUser = (userCredential as any).additionalUserInfo?.isNewUser ?? false; await initializeUserProfile(userEntity.id, "google", isNewUser); debugLog("Google sign in successful", { uid: authUser.uid }); const result = createOperationResult( true, authUser, undefined, "Login con Google effettuato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Google sign in failed", error); const authError = convertAuthError(error as FirebaseAuthError, "google-sign-in"); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const handleGoogleRedirectResult = async (): Promise<AuthOperationResult | null> => { const startTime = Date.now(); try { const result = await getRedirectResult(auth); if (!result) { return null; } const authUser = convertFirebaseUser(result.user); const userEntity = convertToUserEntity(authUser); const isNewUser = (result as any)._tokenResponse?.isNewUser ?? false; await initializeUserProfile(userEntity.id, "google", isNewUser); debugLog("Google redirect sign in successful", { uid: authUser.uid }); const operationResult = createOperationResult( true, authUser, undefined, "Login con Google effettuato con successo" ); operationResult.metadata.duration = Date.now() - startTime; return operationResult; } catch (error) { debugLog("Google redirect sign in failed", error); const authError = convertAuthError(error as FirebaseAuthError, "google-sign-in"); const operationResult = createOperationResult(false, undefined, authError); operationResult.metadata.duration = Date.now() - startTime; return operationResult; } }; export const signOutUser = async (): Promise<AuthOperationResult> => { const startTime = Date.now(); try { const currentUser = auth.currentUser; debugLog("Sign out attempt", { uid: currentUser?.uid }); await signOut(auth); debugLog("Sign out successful"); const result = createOperationResult( true, undefined, undefined, "Logout effettuato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Sign out failed", error); const authError = convertAuthError(error as FirebaseAuthError, "sign-out"); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const resetPassword = async ( input: ResetPasswordInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Password reset attempt", { email: input.email }); await sendPasswordResetEmail(auth, input.email); debugLog("Password reset email sent"); const result = createOperationResult( true, undefined, undefined, "Email di reset password inviata" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Password reset failed", error); const authError = convertAuthError( error as FirebaseAuthError, "password-reset" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const verifyPasswordResetCode = async ( oobCode: string ): Promise<string> => { try { debugLog("Verifying password reset code"); const email = await firebaseVerifyPasswordResetCode(auth, oobCode); debugLog("Password reset code verified", { email }); return email; } catch (error) { debugLog("Password reset code verification failed", error); throw convertAuthError(error as FirebaseAuthError, "verify-reset-code"); } }; export const confirmPasswordReset = async ( oobCode: string, newPassword: string ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Confirming password reset"); await firebaseConfirmPasswordReset(auth, oobCode, newPassword); debugLog("Password reset confirmed"); const result = createOperationResult( true, undefined, undefined, "Password reimpostata con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Password reset confirmation failed", error); const authError = convertAuthError( error as FirebaseAuthError, "confirm-password-reset" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const verifyEmail = async ( oobCode: string ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Verifying email"); await applyActionCode(auth, oobCode); debugLog("Email verified"); const result = createOperationResult( true, undefined, undefined, "Email verificata con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Email verification failed", error); const authError = convertAuthError( error as FirebaseAuthError, "verify-email" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const updateAuthProfile = async ( input: UpdateProfileInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { const currentUser = auth.currentUser; if (!currentUser) { throw new Error("User not authenticated"); } debugLog("Profile update attempt", { uid: currentUser.uid }); const updateData: { displayName?: string; photoURL?: string } = {}; if (input.displayName !== undefined) { updateData.displayName = input.displayName; } if (input.photoURL !== undefined) { updateData.photoURL = input.photoURL; } if (Object.keys(updateData).length > 0) { await updateProfile(currentUser, updateData); } const authUser = convertFirebaseUser(currentUser); debugLog("Profile update successful"); const result = createOperationResult( true, authUser, undefined, "Profilo aggiornato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Profile update failed", error); const authError = convertAuthError( error as FirebaseAuthError, "profile-update" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const updateUserPassword = async ( input: UpdatePasswordInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { const currentUser = auth.currentUser; if (!currentUser || !currentUser.email) { throw new Error("User not authenticated or email missing"); } debugLog("Password update attempt"); const credential = EmailAuthProvider.credential( currentUser.email, input.currentPassword ); await reauthenticateWithCredential(currentUser, credential); await updatePassword(currentUser, input.newPassword); debugLog("Password update successful"); const result = createOperationResult( true, convertFirebaseUser(currentUser), undefined, "Password aggiornata con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Password update failed", error); const authError = convertAuthError( error as FirebaseAuthError, "password-update" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const getCurrentAuthUser = (): AuthUser | null => { const currentUser = auth.currentUser; return currentUser ? convertFirebaseUser(currentUser) : null; }; export const getCurrentUser = (): User | null => { const authUser = getCurrentAuthUser(); return authUser ? convertToUserEntity(authUser) : null; }; export const isAuthenticated = (): boolean => { return !!auth.currentUser; }; export const waitForAuthReady = (): Promise<AuthUser | null> => { return new Promise((resolve) => { const unsubscribe = onAuthStateChanged(auth, (user) => { unsubscribe(); resolve(user ? convertFirebaseUser(user) : null); }); }); }; export const createUserSession = (authUser: AuthUser): AuthSession => { const session: AuthSession = { sessionId: `session_${authUser.uid}_${Date.now()}`, startedAt: new Date(), lastActivityAt: new Date(), duration: 0, deviceInfo: { type: /Mobile|Android|iPhone|iPad/.test(navigator.userAgent) ? "mobile" : "desktop", os: navigator.platform, browser: navigator.userAgent .split(" ") .find((part) => part.includes("/")) ?.split("/")[0] || "unknown", browserVersion: navigator.userAgent .split(" ") .find((part) => part.includes("/")) ?.split("/")[1] || "unknown", timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, language: navigator.language, }, isActive: true, }; debugLog("Session created", { sessionId: session.sessionId }); return session; }; export const updateSessionActivity = (session: AuthSession): AuthSession => { const updatedSession = { ...session, lastActivityAt: new Date(), duration: Date.now() - session.startedAt.getTime(), }; if (AUTH_SERVICE_CONFIG.enableSessionTracking) { debugLog("Session activity updated", { sessionId: session.sessionId }); } return updatedSession; }; export const validateSession = (session: AuthSession): boolean => { const now = Date.now(); const sessionAge = now - session.startedAt.getTime(); const inactivityTime = now - session.lastActivityAt.getTime(); if (sessionAge > AUTH_SERVICE_CONFIG.sessionTimeout) { debugLog("Session expired (timeout)", { sessionId: session.sessionId }); return false; } if (inactivityTime > AUTH_SERVICE_CONFIG.inactivityTimeout) { debugLog("Session expired (inactivity)", { sessionId: session.sessionId }); return false; } return true; }; export const onAuthStateChange = ( callback: (user: User | null) => void ): (() => void) => { debugLog("Setting up auth state listener"); const unsubscribe = onAuthStateChanged( auth, (firebaseUser) => { const user = firebaseUser ? convertToUserEntity(convertFirebaseUser(firebaseUser)) : null; debugLog("Auth state changed", { uid: user?.id || "null", authenticated: !!user, }); callback(user); }, (error) => { debugLog("Auth state error", error); callback(null); } ); return () => { debugLog("Auth state listener cleaned up"); unsubscribe(); }; }; export const getAuthServiceStatus = () => { const currentUser = getCurrentAuthUser(); return { isReady: true, currentUser: currentUser ? { uid: currentUser.uid, email: currentUser.email, emailVerified: currentUser.emailVerified, } : null, config: AUTH_SERVICE_CONFIG, timestamp: new Date().toISOString(), }; }; export const validateEmail = (email: string): boolean => { const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; return emailRegex.test(email); }; export const validatePassword = ( password: string ): { isValid: boolean; errors: string[]; } => { const errors: string[] = []; if (password.length < 6) { errors.push("Password deve essere di almeno 6 caratteri"); } if (!/[A-Z]/.test(password)) { errors.push("Password deve contenere almeno una lettera maiuscola"); } if (!/[a-z]/.test(password)) { errors.push("Password deve contenere almeno una lettera minuscola"); } if (!/\d/.test(password)) { errors.push("Password deve contenere almeno un numero"); } return { isValid: errors.length === 0, errors, }; }; export const updateUserRole = async ( userId: string, newRole: UserRole, adminId: string ): Promise<void> => { try { const userRef = doc(db, USERS_COLLECTION, userId); await updateDoc(userRef, { role: newRole, }); const operationRef = doc(collection(db, "admin_operations")); const operation = { type: "update_user_role", performedBy: adminId, timestamp: new Date(), metadata: { userId, newRole }, }; await setDoc(operationRef, { ...operation, timestamp: serverTimestamp(), }); debugLog("User role updated successfully", { userId, newRole, adminId }); } catch (error) { console.error("Error updating user role:", error); throw new Error("Failed to update user role"); } }; export const updateUserStatus = async ( userId: string, isActive: boolean, adminId: string ): Promise<void> => { try { const userRef = doc(db, USERS_COLLECTION, userId); await updateDoc(userRef, { isActive, }); const operationRef = doc(collection(db, "admin_operations")); const operation = { type: "update_user_status", performedBy: adminId, timestamp: new Date(), metadata: { userId, isActive }, }; await setDoc(operationRef, { ...operation, timestamp: serverTimestamp(), }); debugLog("User status updated successfully", { userId, isActive, adminId }); } catch (error) { console.error("Error updating user status:", error); throw new Error("Failed to update user status"); } }; export const createNewUser = async ( userData: { email: string; displayName: string; role: UserRole; password: string; }, adminId: string ): Promise<void> => { try { const tempUserId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; const userDoc = { id: tempUserId, email: userData.email, displayName: userData.displayName, role: userData.role, emailVerified: false, isActive: false, createdAt: serverTimestamp(), lastLoginAt: null, providerId: "email", metadata: { registrationMethod: "admin_invitation" as const, createdBy: adminId, notes: "Created by admin - pending user registration", status: "pending", invitationEmail: userData.email, }, }; await setDoc(doc(db, USERS_COLLECTION, tempUserId), userDoc); try { await sendPasswordResetEmail(auth, userData.email); } catch (emailError) { console.log("Expected: Email not in Firebase Auth yet, user will register normally"); } debugLog("User invitation created successfully", { email: userData.email, tempId: tempUserId, adminId }); } catch (error) { console.error("Error creating user invitation:", error); throw new Error("Failed to create user invitation"); } }; const generateRandomPassword = (): string => { const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*'; let password = ''; for (let i = 0; i < 12; i++) { password += chars.charAt(Math.floor(Math.random() * chars.length)); } return password; }; export const getUserExtendedProfile = async (userId: string): Promise<UserProfile | null> => { try { const userDoc = await getDoc(doc(db, USERS_COLLECTION, userId)); if (!userDoc.exists()) { return null; } const userData = userDoc.data(); return { userId, fullName: userData.fullName, nativeLanguage: userData.nativeLanguage || 'it', targetLanguage: userData.targetLanguage || 'en', englishLevel: userData.englishLevel || 'A1', learningGoal: userData.learningGoal, dailyWordTarget: userData.dailyWordTarget || 20, weeklyTestTarget: userData.weeklyTestTarget || 3, bio: userData.bio, createdAt: userData.profileCreatedAt || userData.createdAt, updatedAt: userData.profileUpdatedAt || userData.lastUpdated || new Date(), } as UserProfile; } catch (error) { console.error("Error getting user profile:", error); return null; } }; export const updateUserExtendedProfile = async ( userId: string, updates: Partial<UserProfile> ): Promise<boolean> => { try { const userRef = doc(db, USERS_COLLECTION, userId); const userUpdates: any = {}; Object.entries(updates).forEach(([key, value]) => { if (key === 'createdAt') { userUpdates.profileCreatedAt = value; } else if (key === 'updatedAt') { userUpdates.profileUpdatedAt = value; } else if (key !== 'userId') { userUpdates[key] = value; } }); await updateDoc(userRef, { ...userUpdates, profileUpdatedAt: serverTimestamp(), lastUpdated: serverTimestamp(), }); return true; } catch (error) { console.error("Error updating user profile:", error); return false; } }; export const getUserStats = async (userId: string): Promise<UserStats | null> => { try { const userDoc = await getDoc(doc(db, USERS_COLLECTION, userId)); if (userDoc.exists()) { const userData = userDoc.data(); return { userId, totalActiveDays: userData.totalActiveDays || 0, currentStreak: userData.currentStreak || 0, longestStreak: userData.longestStreak || 0, totalWordsAdded: userData.totalWordsAdded || 0, totalWordsLearned: userData.totalWordsLearned || 0, totalTestsCompleted: userData.totalTestsCompleted || 0, totalStudyTime: userData.totalStudyTime || 0, averageTestAccuracy: userData.averageTestAccuracy || 0, progressLevel: userData.progressLevel || 1, nextMilestone: userData.nextMilestone || { id: "first_test", name: "Primo Test", description: "Completa il tuo primo test", icon: "🎯", target: 1, progress: 0, completed: false, reward: "Badge Principiante", }, updatedAt: userData.statsUpdatedAt || userData.lastUpdated || new Date(), } as UserStats; } return null; } catch (error) { console.error("Error getting user stats:", error); return null; } }; export const updateUserStats = async ( userId: string, updates: Partial<UserStats> ): Promise<boolean> => { try { const userRef = doc(db, USERS_COLLECTION, userId); const userUpdates: any = {}; Object.entries(updates).forEach(([key, value]) => { if (key === 'updatedAt') { userUpdates.statsUpdatedAt = value; } else if (key !== 'userId') { userUpdates[key] = value; } }); await updateDoc(userRef, { ...userUpdates, statsUpdatedAt: serverTimestamp(), lastUpdated: serverTimestamp(), }); return true; } catch (error) { console.error("Error updating user stats:", error); return false; } }; export const getUserPreferences = async (userId: string): Promise<UserPreferences | null> => { try { const userDoc = await getDoc(doc(db, USERS_COLLECTION, userId)); if (userDoc.exists()) { const userData = userDoc.data(); if (userData.theme || userData.testPreferences) { return { userId, theme: userData.theme || "light", interfaceLanguage: userData.interfaceLanguage || "it", testPreferences: userData.testPreferences || { defaultTestMode: "normal", defaultWordsPerTest: 20, hintsEnabled: true, autoAdvanceDelay: 3000, showMeaningAfterAnswer: true, showTimer: true, soundsEnabled: true, }, notificationPreferences: userData.notificationPreferences || { pushEnabled: true, emailEnabled: true, dailyReminder: true, reminderTime: "19:00", weeklyTestReminder: true, progressNotifications: true, achievementNotifications: true, }, audioPreferences: userData.audioPreferences || { autoPlayPronunciation: true, volume: 0.8, playbackSpeed: 1.0, actionSounds: true, }, displayPreferences: userData.displayPreferences || { fontSize: "medium", highContrast: false, reducedMotion: false, compactView: false, showAdvancedStats: false, }, updatedAt: userData.lastUpdated?.toDate() || new Date(), } as UserPreferences; } if (userData.settings) { const migratedPreferences: UserPreferences = { userId, theme: userData.settings.theme || "light", interfaceLanguage: userData.settings.language || "it", testPreferences: { defaultTestMode: "normal", defaultWordsPerTest: 20, hintsEnabled: true, autoAdvanceDelay: 3000, showMeaningAfterAnswer: true, showTimer: true, soundsEnabled: true, }, notificationPreferences: { pushEnabled: true, emailEnabled: userData.settings.notifications ?? true, dailyReminder: true, reminderTime: "19:00", weeklyTestReminder: true, progressNotifications: true, achievementNotifications: true, }, audioPreferences: { autoPlayPronunciation: true, volume: 0.8, playbackSpeed: 1.0, actionSounds: true, }, displayPreferences: { fontSize: "medium", highContrast: false, reducedMotion: false, compactView: false, showAdvancedStats: false, }, updatedAt: new Date(), }; await updateDoc(doc(db, USERS_COLLECTION, userId), { theme: migratedPreferences.theme, interfaceLanguage: migratedPreferences.interfaceLanguage, testPreferences: migratedPreferences.testPreferences, notificationPreferences: migratedPreferences.notificationPreferences, audioPreferences: migratedPreferences.audioPreferences, displayPreferences: migratedPreferences.displayPreferences, lastUpdated: serverTimestamp(), updatedAt: serverTimestamp(), }); return migratedPreferences; } } return null; } catch (error) { console.error("Error getting user preferences:", error); return null; } }; export const updateUserPreferences = async ( userId: string, preferences: Partial<UserPreferences> ): Promise<boolean> => { try { const userRef = doc(db, USERS_COLLECTION, userId); const updateData: any = { lastUpdated: serverTimestamp(), }; if (preferences.theme) updateData.theme = preferences.theme; if (preferences.interfaceLanguage) updateData.interfaceLanguage = preferences.interfaceLanguage; if (preferences.testPreferences) updateData.testPreferences = preferences.testPreferences; if (preferences.notificationPreferences) updateData.notificationPreferences = preferences.notificationPreferences; if (preferences.audioPreferences) updateData.audioPreferences = preferences.audioPreferences; if (preferences.displayPreferences) updateData.displayPreferences = preferences.displayPreferences; await updateDoc(userRef, updateData); return true; } catch (error) { console.error("Error updating user preferences:", error); return false; } }; export const updateUserTheme = async ( userId: string, theme: AppTheme ): Promise<boolean> => { try { return await updateUserPreferences(userId, { theme }); } catch (error) { console.error("Error updating user theme:", error); return false; } }; export const updateNotificationPreferences = async ( userId: string, notifications: Partial<NotificationPreferences> ): Promise<boolean> => { try { const currentPreferences = await getUserPreferences(userId); const updatedNotifications: NotificationPreferences = { pushEnabled: true, emailEnabled: true, dailyReminder: true, reminderTime: "19:00", weeklyTestReminder: true, progressNotifications: true, achievementNotifications: true, ...currentPreferences?.notificationPreferences, ...notifications, }; return await updateUserPreferences(userId, { notificationPreferences: updatedNotifications, }); } catch (error) { console.error("Error updating notification preferences:", error); return false; } };

================================================================================

NOME FILE: firestoreService.ts

import { doc, getDoc, setDoc, updateDoc, deleteDoc, collection, getDocs, addDoc, query, where, orderBy, limit, startAfter, onSnapshot, writeBatch, serverTimestamp, Timestamp, enableNetwork, disableNetwork, DocumentReference, CollectionReference, Query, QuerySnapshot, DocumentSnapshot, Unsubscribe, WhereFilterOp, OrderByDirection, FirestoreError as FirebaseFirestoreError, } from "firebase/firestore"; import { db, auth, FIRESTORE_COLLECTIONS } from "../config/firebase"; import type { FirestoreDoc, FirestoreDocMetadata, FirestoreCollection, FirestoreQuery, WhereClause, OrderByClause, FirestoreQueryResult, FirestoreListener, ListenerConfig, FirestoreListenerData, ChangeType, FirestoreError, FirestoreOperationResult, FirestoreBatch, BatchOperation, FirestoreConnectionState, PendingOperation, FirestoreCollectionName, } from "../types/infrastructure/Firestore.types"; const FIRESTORE_SERVICE_CONFIG = { maxRetries: 3, retryDelay: 1000, maxBatchSize: 500, offlineTimeout: 10000, enablePersistence: true, enableDebugLogging: process.env.NODE_ENV === "development", }; const debugLog = (message: string, data?: any) => { if (FIRESTORE_SERVICE_CONFIG.enableDebugLogging) { console.log(`🔥 [FirestoreService] ${message}`, data || ""); } }; const getCurrentUserId = (): string => { const currentUser = auth.currentUser; if (!currentUser) { throw new Error( "User non autenticato. Effettua login prima di accedere ai dati." ); } return currentUser.uid; }; const createFirestoreMetadata = ( existingMetadata?: Partial<FirestoreDocMetadata> ): FirestoreDocMetadata => { const now = new Date(); const userId = getCurrentUserId(); return { userId, createdAt: existingMetadata?.createdAt || now, updatedAt: now, version: (existingMetadata?.version || 0) + 1, deleted: false, lastSyncAt: now, custom: existingMetadata?.custom || {}, ...existingMetadata, }; }; const convertFirebaseError = ( firebaseError: FirebaseFirestoreError, operation: string, path?: string ): FirestoreError => { const getRecoverable = (code: string): boolean => { switch (code) { case "unavailable": case "deadline-exceeded": case "resource-exhausted": case "aborted": return true; case "permission-denied": case "not-found": case "already-exists": return false; default: return false; } }; return { code: firebaseError.code as any, message: firebaseError.message, operation: operation as any, path, recoverable: getRecoverable(firebaseError.code), timestamp: new Date(), }; }; const createUserScopedPath = ( collectionName: FirestoreCollectionName, documentId?: string ): string => { const userId = getCurrentUserId(); const basePath = `${collectionName}/${userId}`; return documentId ? `${basePath}/documents/${documentId}` : `${basePath}/documents`; }; const convertTimestamp = (timestamp: any): Date => { if (timestamp instanceof Timestamp) { return timestamp.toDate(); } if (timestamp instanceof Date) { return timestamp; } if (typeof timestamp === "string") { return new Date(timestamp); } return new Date(); }; const convertDocumentSnapshot = <T>( snapshot: DocumentSnapshot, collectionName: string ): FirestoreDoc<T> | null => { if (!snapshot.exists()) { return null; } const data = snapshot.data(); if (!data) { return null; } const convertedData = { ...data, createdAt: data.createdAt ? convertTimestamp(data.createdAt) : new Date(), updatedAt: data.updatedAt ? convertTimestamp(data.updatedAt) : new Date(), } as T; const metadata: FirestoreDocMetadata = { userId: data.firestoreMetadata?.userId || getCurrentUserId(), createdAt: convertTimestamp( data.firestoreMetadata?.createdAt || data.createdAt ), updatedAt: convertTimestamp( data.firestoreMetadata?.updatedAt || data.updatedAt ), version: data.firestoreMetadata?.version || 1, deleted: data.firestoreMetadata?.deleted || false, lastSyncAt: new Date(), custom: data.firestoreMetadata?.custom || {}, }; return { id: snapshot.id, data: convertedData, metadata, path: snapshot.ref.path, ref: snapshot.ref, }; }; export const createDocument = async <T>( collectionName: FirestoreCollectionName, data: T, customId?: string ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Creating document in ${collectionName}`, { customId, data }); const metadata = createFirestoreMetadata(); const documentData = { ...data, firestoreMetadata: metadata, }; let docRef: DocumentReference; if (customId) { const path = createUserScopedPath(collectionName, customId); docRef = doc(db, path); await setDoc(docRef, documentData); } else { const collectionPath = createUserScopedPath(collectionName); const collectionRef = collection(db, collectionPath); docRef = await addDoc(collectionRef, documentData); } const snapshot = await getDoc(docRef); const createdDoc = convertDocumentSnapshot<T>(snapshot, collectionName); if (!createdDoc) { throw new Error("Documento creato ma non recuperabile"); } debugLog(`Document created successfully`, { id: createdDoc.id }); return { success: true, doc: createdDoc, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Create document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "create", collectionName ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const readDocument = async <T>( collectionName: FirestoreCollectionName, documentId: string ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Reading document ${documentId} from ${collectionName}`); const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); const snapshot = await getDoc(docRef); const document = convertDocumentSnapshot<T>(snapshot, collectionName); if (!document) { debugLog(`Document ${documentId} not found`); return { success: false, error: { code: "not-found", message: `Documento ${documentId} non trovato`, operation: "read", path, recoverable: false, timestamp: new Date(), }, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: snapshot.metadata.fromCache, docsAffected: 0, retryCount: 0, }, }; } debugLog(`Document read successfully`, { id: document.id }); return { success: true, doc: document, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: snapshot.metadata.fromCache, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Read document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "read", `${collectionName}/${documentId}` ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const updateDocument = async <T>( collectionName: FirestoreCollectionName, documentId: string, updates: Partial<T> ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Updating document ${documentId} in ${collectionName}`, updates); const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); const currentDoc = await getDoc(docRef); if (!currentDoc.exists()) { throw new Error(`Document ${documentId} not found in ${collectionName}`); } const currentData = currentDoc.data(); const currentMetadata = currentData.firestoreMetadata || {}; const metadata = createFirestoreMetadata(currentMetadata); const updateData = { ...updates, "firestoreMetadata.updatedAt": serverTimestamp(), "firestoreMetadata.version": metadata.version, "firestoreMetadata.lastSyncAt": serverTimestamp(), }; await updateDoc(docRef, updateData); const updatedDocSnap = await getDoc(docRef); const updatedDoc = convertDocumentSnapshot<T>( updatedDocSnap, collectionName ); if (!updatedDoc) { throw new Error("Documento aggiornato ma non recuperabile"); } debugLog(`Document updated successfully`, { id: updatedDoc.id }); return { success: true, doc: updatedDoc, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Update document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "update", `${collectionName}/${documentId}` ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const deleteDocument = async <T>( collectionName: FirestoreCollectionName, documentId: string, softDelete: boolean = false ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Deleting document ${documentId} from ${collectionName}`, { softDelete, }); const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); if (softDelete) { const updateData = { "firestoreMetadata.deleted": true, "firestoreMetadata.deletedAt": serverTimestamp(), "firestoreMetadata.updatedAt": serverTimestamp(), }; await updateDoc(docRef, updateData); debugLog(`Document soft deleted successfully`); } else { await deleteDoc(docRef); debugLog(`Document hard deleted successfully`); } return { success: true, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Delete document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "delete", `${collectionName}/${documentId}` ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const queryCollection = async <T>( collectionName: FirestoreCollectionName, queryConfig: Partial<FirestoreQuery<T>> = {} ): Promise<FirestoreQueryResult<T>> => { const startTime = Date.now(); try { debugLog(`Querying collection ${collectionName}`, queryConfig); const collectionPath = createUserScopedPath(collectionName); let baseQuery: Query = collection(db, collectionPath) as Query; if (queryConfig.where && queryConfig.where.length > 0) { for (const whereClause of queryConfig.where) { baseQuery = query( baseQuery, where( whereClause.field, whereClause.operator as WhereFilterOp, whereClause.value ) ); } } if (queryConfig.orderBy && queryConfig.orderBy.length > 0) { for (const orderClause of queryConfig.orderBy) { baseQuery = query( baseQuery, orderBy(orderClause.field, orderClause.direction as OrderByDirection) ); } } if (queryConfig.limit && queryConfig.limit > 0) { baseQuery = query(baseQuery, limit(queryConfig.limit)); } if (queryConfig.startAfter) { baseQuery = query(baseQuery, startAfter(queryConfig.startAfter)); } const querySnapshot = await getDocs(baseQuery); const docs: FirestoreDoc<T>[] = []; querySnapshot.forEach((doc) => { const converted = convertDocumentSnapshot<T>(doc, collectionName); if (converted) { if (queryConfig.includeDeleted || !converted.metadata.deleted) { docs.push(converted); } } }); debugLog(`Query completed`, { docsFound: docs.length }); return { docs, totalCount: docs.length, query: { collection: collectionName, ...queryConfig, }, queryMetadata: { executionTime: Date.now() - startTime, fromCache: querySnapshot.metadata.fromCache, docsRead: querySnapshot.size, executedAt: new Date(), }, hasMore: docs.length === (queryConfig.limit || 0), nextPageCursor: docs.length > 0 ? docs[docs.length - 1].ref : undefined, }; } catch (error) { debugLog(`Query collection failed`, error); throw convertFirebaseError( error as FirebaseFirestoreError, "query", collectionName ); } }; export const listAllDocuments = async <T>( collectionName: FirestoreCollectionName, includeDeleted: boolean = false ): Promise<FirestoreDoc<T>[]> => { const result = await queryCollection<T>(collectionName, { includeDeleted }); return result.docs; }; export const listenToDocument = <T>( collectionName: FirestoreCollectionName, documentId: string, onDataChange: (doc: FirestoreDoc<T> | null) => void, onError: (error: FirestoreError) => void, config: Partial<ListenerConfig> = {} ): (() => void) => { debugLog(`Setting up document listener`, { collectionName, documentId }); try { const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); const unsubscribe = onSnapshot( docRef, { includeMetadataChanges: config.includeMetadataChanges || false, }, (snapshot) => { try { const document = convertDocumentSnapshot<T>(snapshot, collectionName); onDataChange(document); debugLog(`Document listener data received`, { exists: !!document }); } catch (error) { debugLog(`Document listener conversion error`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", path ) ); } }, (error) => { debugLog(`Document listener error`, error); onError(convertFirebaseError(error, "listen", path)); } ); return unsubscribe; } catch (error) { debugLog(`Failed to setup document listener`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", `${collectionName}/${documentId}` ) ); return () => {}; } }; export const listenToCollection = <T>( collectionName: FirestoreCollectionName, onDataChange: (data: FirestoreListenerData<T>) => void, onError: (error: FirestoreError) => void, queryConfig: Partial<FirestoreQuery<T>> = {}, config: Partial<ListenerConfig> = {} ): (() => void) => { debugLog(`Setting up collection listener`, { collectionName, queryConfig }); try { const collectionPath = createUserScopedPath(collectionName); let baseQuery: Query = collection(db, collectionPath) as Query; if (queryConfig.where && queryConfig.where.length > 0) { for (const whereClause of queryConfig.where) { baseQuery = query( baseQuery, where( whereClause.field, whereClause.operator as WhereFilterOp, whereClause.value ) ); } } if (queryConfig.orderBy && queryConfig.orderBy.length > 0) { for (const orderClause of queryConfig.orderBy) { baseQuery = query( baseQuery, orderBy(orderClause.field, orderClause.direction as OrderByDirection) ); } } if (queryConfig.limit && queryConfig.limit > 0) { baseQuery = query(baseQuery, limit(queryConfig.limit)); } const unsubscribe = onSnapshot( baseQuery, { includeMetadataChanges: config.includeMetadataChanges || false, }, (querySnapshot) => { try { const allDocs: FirestoreDoc<T>[] = []; const changedDocs: FirestoreDoc<T>[] = []; querySnapshot.forEach((docSnapshot) => { const document = convertDocumentSnapshot<T>( docSnapshot, collectionName ); if (document) { if (queryConfig.includeDeleted || !document.metadata.deleted) { allDocs.push(document); } } }); let changeType: ChangeType = "initial-load"; if ( !querySnapshot.metadata.hasPendingWrites && !querySnapshot.metadata.fromCache ) { changeType = "modified"; } const listenerData: FirestoreListenerData<T> = { changeType, changedDocs: changedDocs.length > 0 ? changedDocs : allDocs, currentSnapshot: allDocs, changeMetadata: { fromCache: querySnapshot.metadata.fromCache, hasPendingWrites: querySnapshot.metadata.hasPendingWrites, timestamp: new Date(), source: querySnapshot.metadata.fromCache ? "cache" : "server", }, }; onDataChange(listenerData); debugLog(`Collection listener data received`, { docsCount: allDocs.length, }); } catch (error) { debugLog(`Collection listener conversion error`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", collectionName ) ); } }, (error) => { debugLog(`Collection listener error`, error); onError(convertFirebaseError(error, "listen", collectionName)); } ); return unsubscribe; } catch (error) { debugLog(`Failed to setup collection listener`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", collectionName ) ); return () => {}; } }; export const batchWrite = async ( operations: BatchOperation[] ): Promise<FirestoreOperationResult<void>> => { const startTime = Date.now(); try { debugLog(`Starting batch write`, { operationsCount: operations.length }); if (operations.length === 0) { throw new Error("Batch vuoto - nessuna operazione da eseguire"); } if (operations.length > FIRESTORE_SERVICE_CONFIG.maxBatchSize) { throw new Error( `Batch troppo grande - max ${FIRESTORE_SERVICE_CONFIG.maxBatchSize} operazioni` ); } const batch = writeBatch(db); for (const operation of operations) { const docRef = doc(db, operation.path); switch (operation.type) { case "create": case "update": if (!operation.data) { throw new Error(`Dati mancanti per operazione ${operation.type}`); } const metadata = createFirestoreMetadata(); const dataWithMetadata = { ...operation.data, firestoreMetadata: metadata, }; if (operation.type === "create") { batch.set(docRef, dataWithMetadata); } else { batch.update(docRef, { ...dataWithMetadata, "firestoreMetadata.updatedAt": serverTimestamp(), }); } break; case "delete": batch.delete(docRef); break; default: throw new Error(`Tipo operazione non supportato: ${operation.type}`); } } await batch.commit(); debugLog(`Batch write completed successfully`); return { success: true, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: operations.length, retryCount: 0, }, }; } catch (error) { debugLog(`Batch write failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "batch" ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const enableFirestoreNetwork = async (): Promise<boolean> => { try { debugLog("Enabling Firestore network"); await enableNetwork(db); debugLog("Firestore network enabled"); return true; } catch (error) { debugLog("Failed to enable Firestore network", error); return false; } }; export const disableFirestoreNetwork = async (): Promise<boolean> => { try { debugLog("Disabling Firestore network"); await disableNetwork(db); debugLog("Firestore network disabled"); return true; } catch (error) { debugLog("Failed to disable Firestore network", error); return false; } }; export const getConnectionState = (): FirestoreConnectionState => { return { online: navigator.onLine, lastOnlineAt: navigator.onLine ? new Date() : undefined, pendingOperations: [], syncing: false, syncErrors: [], }; }; export const getFirestoreServiceStatus = () => { return { isReady: !!db, currentUser: auth.currentUser?.uid || null, config: FIRESTORE_SERVICE_CONFIG, connection: getConnectionState(), timestamp: new Date().toISOString(), }; };

================================================================================

NOME FILE: statsAnalyticsService.ts

import type { Statistics, DailyProgressAggregated, MonthlyStatsAggregated, AggregatedCalculatedStatistics, LearningTrendsAnalysis, TrendAnalysis, WeeklyProgressAnalysis, ComprehensiveStatisticsExportData, DataSource, RecommendedAction, MonthlyTrendsAnalysis, StreakAnalysisData, NextSessionPrediction, MasteryTimelinePrediction, } from "../types/entities/Statistics.types"; import type { TestResult, TestSession, TestAnalytics, TestExportData, TestSummary, PerformanceMetrics as TestPerformanceMetrics, TestTimeMetrics, TestProgress, PerformancePatterns, AccuracyPatterns, HintStatistics, CategoryPerformance, ScoreCategory, SpeedTrend, TestConfig, WordSelectionConfig, TimingConfig, UIConfig, ScoringConfig, TestInsight, TestRecommendation, TestFeedback, FinalScore, HintSystemConfig, } from "../types/entities/Test.types"; import type { Word } from "../types/entities/Word.types"; import type { WordPerformance, PerformanceAttempt, WordPerformanceAnalysis, GlobalPerformanceStats, } from "../types/entities/Performance.types"; export class StatsAnalyticsService { calculateSpeedTrend(testHistory: any[]): SpeedTrend { if (testHistory.length < 2) { return { direction: "stable", changePercentage: 0, dataPoints: [], }; } const dataPoints = testHistory.map((test, index) => ({ questionNumber: index + 1, time: test.avgTimePerWord || test.totalTime / Math.max(test.totalWords || 1, 1), })); const firstThird = dataPoints.slice(0, Math.ceil(dataPoints.length * 0.3)); const lastThird = dataPoints.slice(-Math.ceil(dataPoints.length * 0.3)); const firstAvg = firstThird.reduce((sum, point) => sum + point.time, 0) / firstThird.length; const lastAvg = lastThird.reduce((sum, point) => sum + point.time, 0) / lastThird.length; const changePercentage = ((firstAvg - lastAvg) / firstAvg) * 100; let direction: "improving" | "stable" | "declining"; if (changePercentage > 5) direction = "improving"; else if (changePercentage < -5) direction = "declining"; else direction = "stable"; return { direction, changePercentage: Math.round(changePercentage * 100) / 100, dataPoints, }; } calculateTestPerformanceMetrics( correctAnswers: number, totalQuestions: number, testHistory: any[] ): TestPerformanceMetrics { const incorrectAnswers = totalQuestions - correctAnswers; const currentAccuracy = totalQuestions > 0 ? (correctAnswers / totalQuestions) * 100 : 0; let currentStreak = 0; let bestStreak = 0; let tempStreak = 0; for (let i = testHistory.length - 1; i >= 0; i--) { const test = testHistory[i]; const accuracy = test.percentage || 0; if (accuracy >= 70) { tempStreak++; if (i === testHistory.length - 1) { currentStreak = tempStreak; } } else { if (i === testHistory.length - 1) { currentStreak = 0; } tempStreak = 0; } bestStreak = Math.max(bestStreak, tempStreak); } const recentTests = testHistory.slice(-5); const avgHintUsage = recentTests.length > 0 ? recentTests.reduce((sum, test) => sum + (test.hintsUsed || 0), 0) / recentTests.length : 0; const efficiency = Math.max(0, currentAccuracy - avgHintUsage * 2); const currentScore = Math.round( currentAccuracy * 0.6 + efficiency * 0.3 + Math.min(currentStreak * 5, 20) * 0.1 ); return { correctAnswers, currentAccuracy: Math.round(currentAccuracy * 100) / 100, incorrectAnswers, currentStreak, bestStreak, efficiency: Math.round(efficiency * 100) / 100, currentScore, }; } calculateHintStatistics( testHistory: any[], totalTime: number ): HintStatistics { if (testHistory.length === 0) { return { usage: { sentence: 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: totalTime, }; } const totalHints = testHistory.reduce( (sum, test) => sum + (test.hintsUsed || 0), 0 ); const totalQuestions = testHistory.reduce( (sum, test) => sum + (test.totalWords || 0), 0 ); const sentenceHints = Math.ceil(totalHints * 0.6); const synonymHints = totalHints - sentenceHints; const testsWithHints = testHistory.filter( (test) => (test.hintsUsed || 0) > 0 ); const accuracyAfterHint = testsWithHints.length > 0 ? testsWithHints.reduce( (sum, test) => sum + (test.percentage || 0), 0 ) / testsWithHints.length : 0; const testsWithoutHints = testHistory.filter( (test) => (test.hintsUsed || 0) === 0 ); const averageTimeWithoutHint = testsWithoutHints.length > 0 ? testsWithoutHints.reduce( (sum, test) => sum + (test.totalTime || 0), 0 ) / testsWithoutHints.length : totalTime; const averageTimeWithHint = testsWithHints.length > 0 ? testsWithHints.reduce((sum, test) => sum + (test.totalTime || 0), 0) / testsWithHints.length : totalTime; return { usage: { sentence: sentenceHints, synonym: synonymHints, }, accuracyAfterHint: { sentence: accuracyAfterHint, synonym: accuracyAfterHint * 0.8, overall: accuracyAfterHint, }, averageTimeWithHint: { sentence: averageTimeWithHint, synonym: averageTimeWithHint * 1.2, overall: averageTimeWithHint, }, averageTimeWithoutHint, }; } generateTestConfig(): TestConfig { return { mode: "normal", hints: { enabled: true, maxHintsPerQuestion: 2, cooldownBetweenHints: 0, availableHintTypes: ["sentence", "synonym"], hintCosts: { sentence: 1, synonym: 1, }, } as HintSystemConfig, wordSelection: { strategy: "random", maxWords: 10, excludeLearned: false, prioritizeDifficult: false, categories: [], chapters: [], unlearnedOnly: false, difficultOnly: false, randomOrder: true, selectionStrategy: "random", } as WordSelectionConfig, timing: { enableTimer: false, warningThreshold: 30, autoAdvance: false, maxTimePerQuestion: null, showTimer: false, autoAdvanceDelay: 1000, showMeaning: false, meaningDisplayDuration: 2000, wordTimeLimit: 30000, } as TimingConfig, ui: { theme: "light" as const, animations: true, showDetailedProgress: true, sounds: false, showRealTimeStats: true, } as UIConfig, scoring: { correctPoints: 10, incorrectPenalty: 0, hintPenalty: 2, timeBonusEnabled: false, accuracyWeight: 0.7, speedWeight: 0.3, streakBonus: 0.1, thresholds: { excellent: 90, good: 80, average: 70, poor: 0, }, } as ScoringConfig, }; } calculateTestTimeMetrics(testHistory: any[]): TestTimeMetrics { if (testHistory.length === 0) { return { totalTestTime: 0, averageQuestionTime: 0, fastestQuestion: 0, slowestQuestion: 0, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 0, p50: 0, p75: 0, p90: 0, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }; } const totalTime = testHistory.reduce( (sum, test) => sum + (test.totalTime || 0), 0 ); const totalQuestions = testHistory.reduce( (sum, test) => sum + (test.totalWords || 0), 0 ); const averageQuestionTime = totalQuestions > 0 ? totalTime / totalQuestions : 0; const allTimes = testHistory.flatMap((test) => Array(test.totalWords || 0).fill( (test.totalTime || 0) / Math.max(test.totalWords || 1, 1) ) ); const fastestQuestion = allTimes.length > 0 ? Math.min(...allTimes) : 0; const slowestQuestion = allTimes.length > 0 ? Math.max(...allTimes) : 0; allTimes.sort((a, b) => a - b); const len = allTimes.length; return { totalTestTime: totalTime, averageQuestionTime, fastestQuestion, slowestQuestion, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: len > 0 ? allTimes[Math.floor(len * 0.25)] : 0, p50: len > 0 ? allTimes[Math.floor(len * 0.5)] : 0, p75: len > 0 ? allTimes[Math.floor(len * 0.75)] : 0, p90: len > 0 ? allTimes[Math.floor(len * 0.9)] : 0, }, }, speedTrend: this.calculateSpeedTrend(testHistory), }; } generateTestProgress(performance: TestPerformanceMetrics): TestProgress { return { basic: { questionsAnswered: performance.correctAnswers + performance.incorrectAnswers, questionsRemaining: 0, currentQuestion: performance.correctAnswers + performance.incorrectAnswers, totalQuestions: performance.correctAnswers + performance.incorrectAnswers, completionPercentage: 100, }, performance, predictions: { predictedFinalAccuracy: performance.currentAccuracy, confidence: 0.8, estimatedTimeToCompletion: 0, predictedFinalScore: performance.currentScore, }, milestones: [], }; } generateFinalScore(performance: TestPerformanceMetrics): FinalScore { const category: ScoreCategory = performance.currentScore >= 90 ? "excellent" : performance.currentScore >= 80 ? "good" : performance.currentScore >= 70 ? "average" : "poor"; return { total: performance.currentScore, category, breakdown: { accuracy: performance.currentAccuracy, speed: 50, efficiency: performance.efficiency, consistency: 50, bonus: 0, penalties: 0, }, }; } generateTestFeedback(performance: TestPerformanceMetrics): TestFeedback { return { tone: performance.currentScore >= 80 ? "celebratory" : "encouraging", color: performance.currentScore >= 80 ? "#22c55e" : "#3b82f6", wordsToReview: [], message: "Great job!", icon: "check", nextGoals: ["Keep practicing", "Review difficult words"], }; } private generateRecommendations( accuracy: number, hints: number ): TestRecommendation[] { const recommendations: TestRecommendation[] = []; if (accuracy < 70) { recommendations.push({ type: "practice", priority: "high", title: "Focus on Vocabulary Review", description: "Spend more time reviewing missed words and their meanings", expectedBenefit: "Improved accuracy in future tests", effort: "medium", }); } if (hints > 5) { recommendations.push({ type: "practice", priority: "medium", title: "Practice Without Hints", description: "Try completing tests without using hints to build confidence", expectedBenefit: "Increased self-reliance and faster response times", effort: "easy", }); } return recommendations; } private generateStrengths(accuracy: number, hints: number): string[] { const strengths: string[] = []; if (accuracy >= 80) strengths.push("High accuracy rate"); if (hints <= 2) strengths.push("Minimal hint usage"); if (accuracy >= 90 && hints <= 1) strengths.push("Excellent independent performance"); return strengths; } private generateImprovements(accuracy: number, hints: number): string[] { const improvements: string[] = []; if (accuracy < 70) improvements.push("Focus on vocabulary retention"); if (hints > 5) improvements.push("Reduce dependency on hints"); if (accuracy < 80) improvements.push("Practice more challenging words"); return improvements; } private generateNextSteps(accuracy: number, hints: number): string[] { const nextSteps: string[] = []; if (accuracy < 70) { nextSteps.push("Review incorrect words"); nextSteps.push("Practice with similar difficulty level"); } else if (accuracy >= 90) { nextSteps.push("Try more challenging vocabulary"); nextSteps.push("Increase test length"); } else { nextSteps.push("Focus on consistency"); nextSteps.push("Practice speed and accuracy"); } return nextSteps; } calculateAggregatedStatistics( currentStats: Statistics, testHistory: any[], wordPerformanceAnalyses: WordPerformanceAnalysis[] ): AggregatedCalculatedStatistics { const baseStats: Statistics = { ...currentStats, }; const globalPerformanceStats: GlobalPerformanceStats = { statusDistribution: { new: 0, promising: 0, struggling: wordPerformanceAnalyses.filter( (w) => w.status === "struggling" ).length, consolidated: wordPerformanceAnalyses.filter( (w) => w.status === "consolidated" ).length, improving: wordPerformanceAnalyses.filter( (w) => w.status === "improving" ).length, critical: 0, inconsistent: 0, }, totalWordsTracked: wordPerformanceAnalyses.length, averageResponseTime: wordPerformanceAnalyses.reduce((sum, w) => sum + w.avgTime * 1000, 0) / Math.max(wordPerformanceAnalyses.length, 1), averageAccuracy: wordPerformanceAnalyses.reduce((sum, w) => sum + w.accuracy, 0) / Math.max(wordPerformanceAnalyses.length, 1), averageHintUsage: wordPerformanceAnalyses.reduce((sum, w) => sum + w.hintsPercentage, 0) / Math.max(wordPerformanceAnalyses.length, 1), wordsNeedingWork: wordPerformanceAnalyses.filter( (w) => w.status === "struggling" || w.status === "critical" ).length, masteredWords: wordPerformanceAnalyses.filter((w) => w.mastered).length, }; const learningTrends: LearningTrendsAnalysis = this.calculateLearningTrends(testHistory); const weeklyTrends: WeeklyProgressAnalysis = this.calculateWeeklyProgress( currentStats.dailyProgress || {} ); const monthlyTrends: MonthlyTrendsAnalysis = { last3Months: [], trendDirection: "stable", keyMetricChanges: { accuracyChange: 0, vocabularyGrowthChange: 0, consistencyChange: 0, }, seasonalPatterns: [], }; const streakAnalysis: StreakAnalysisData = { currentStreak: currentStats.streakDays || 0, longestStreak: currentStats.streakDays || 0, streakBreakingPatterns: [], streakMotivation: [], }; const nextSessionPredictions: NextSessionPrediction = { optimalTime: new Date(), suggestedDuration: 10, recommendedWords: [], predictedAccuracy: 75, challengeLevel: "medium", focusAreas: { reviewWords: [], newWords: [], masteryWords: [], }, }; const masteryTimeline: MasteryTimelinePrediction = { totalWordsToMaster: 100, currentMasteryRate: 0.1, estimatedTimeToComplete: 30, milestones: [], accelerationOpportunities: [], }; return { baseStats, performanceAnalytics: { globalPerformanceStats, wordLevelInsights: wordPerformanceAnalyses.slice(0, 10), learningTrends, }, temporalAnalytics: { weeklyProgress: weeklyTrends, monthlyTrends, streakAnalysis, }, predictiveAnalytics: { nextSessionPredictions, masteryTimeline, recommendedActions: [], }, aggregationMetadata: { lastCalculated: new Date(), dataSourcesIncluded: [ { type: "test-results", recordCount: testHistory.length, dateRange: { start: new Date(), end: new Date() }, completeness: 100, lastUpdated: new Date(), } as DataSource, { type: "word-performance", recordCount: wordPerformanceAnalyses.length, dateRange: { start: new Date(), end: new Date() }, completeness: 100, lastUpdated: new Date(), } as DataSource, { type: "words", recordCount: 0, dateRange: { start: new Date(), end: new Date() }, completeness: 100, lastUpdated: new Date(), } as DataSource, ], calculationDuration: 100, isMigrated: currentStats.migrated || false, isProcessing: false, forceUpdate: 0, }, }; } private createTrend( direction: "improving" | "stable" | "declining" ): TrendAnalysis { return { direction, rate: 0, confidence: 0.8, periodAnalyzed: 30, significantChanges: [], }; } private calculateLearningTrends(testHistory: any[]): LearningTrendsAnalysis { if (testHistory.length < 2) { return { accuracyTrend: this.createTrend("stable"), speedTrend: this.createTrend("stable"), vocabularyGrowthTrend: this.createTrend("stable"), consistencyTrend: this.createTrend("stable"), difficultyHandlingTrend: this.createTrend("stable"), }; } const recent = testHistory.slice(-5); const older = testHistory.slice(0, 5); const recentAccuracy = recent.reduce((sum, test) => sum + (test.percentage || 0), 0) / recent.length; const olderAccuracy = older.reduce((sum, test) => sum + (test.percentage || 0), 0) / older.length; const accuracyChange = recentAccuracy - olderAccuracy; return { accuracyTrend: this.createTrend( accuracyChange > 5 ? "improving" : accuracyChange < -5 ? "declining" : "stable" ), speedTrend: this.createTrend("stable"), vocabularyGrowthTrend: this.createTrend( testHistory.length > 5 ? "improving" : "stable" ), consistencyTrend: this.createTrend("stable"), difficultyHandlingTrend: this.createTrend("stable"), }; } private calculateWeeklyProgress( dailyProgress: Record<string, DailyProgressAggregated> ): WeeklyProgressAnalysis { const today = new Date(); const currentWeek: DailyProgressAggregated[] = []; const previousWeek: DailyProgressAggregated[] = []; for (let i = 0; i < 7; i++) { const date = new Date(today); date.setDate(today.getDate() - i); const dateStr = date.toISOString().split("T")[0]; const dayProgress = dailyProgress[dateStr] || this.createEmptyDayProgress(dateStr); currentWeek.push(dayProgress); const prevDate = new Date(date); prevDate.setDate(date.getDate() - 7); const prevDateStr = prevDate.toISOString().split("T")[0]; const prevDayProgress = dailyProgress[prevDateStr] || this.createEmptyDayProgress(prevDateStr); previousWeek.push(prevDayProgress); } return { currentWeek, previousWeek, weekOverWeekChange: { testsChange: 0, accuracyChange: 0, timeChange: 0, wordsStudiedChange: 0, }, weeklyConsistency: 0, recommendedSchedule: [], }; } private createEmptyDayProgress(date: string): DailyProgressAggregated { return { date, testActivity: { testsCompleted: 0, averageScore: 0, totalTime: 0, averageAccuracy: 0, hintsUsed: 0, }, wordActivity: { wordsStudied: 0, newWordsEncountered: 0, wordsImproved: 0, wordsMastered: 0, }, derivedMetrics: { studyEfficiency: 0, learningVelocity: 0, consistency: 0, }, }; } createComprehensiveExportData( currentStats: Statistics, testHistory: any[], wordPerformanceAnalyses: WordPerformanceAnalysis[] ): ComprehensiveStatisticsExportData { return { statistics: currentStats, sourceData: { testResults: testHistory, wordPerformances: wordPerformanceAnalyses, words: [], }, exportMetadata: { exportDate: new Date(), appVersion: "1.0.0", dataVersion: "1.0.0", userId: "current-user", exportType: "complete", }, analytics: this.calculateAggregatedStatistics( currentStats, testHistory, wordPerformanceAnalyses ), insights: { summary: "Performance analysis completed", keyAchievements: ["Consistent progress", "Improved accuracy"], areasForImprovement: ["Speed optimization", "Hint dependency"], recommendations: [ { id: "rec_001", type: "review" as const, priority: "high", title: "Focus on weak areas", description: "Review challenging vocabulary", estimatedTime: 30, expectedBenefit: "Improved retention", supportingMetrics: [], }, ], }, }; } }

================================================================================

NOME FILE: storageService.ts

import { STORAGE_CONFIG } from '../constants/appConstants'; import { smartRetryStorage, globalOperationManager } from '../utils/retryUtils'; interface StorageKeys { words: string; stats: string; testHistory: string; settings: string; } interface UsageStats { used: number; available: number; total: number; usedMB: string; availableMB: string; usagePercentage: string; critical: boolean; warning: boolean; healthStatus: string; lastHealthCheck: number | null; error?: string; } interface ServiceStatus { available: boolean; health: string; usage: UsageStats; lastHealthCheck: number | null; recommendations: string[]; } interface AppStats { testsCompleted: number; correctAnswers: number; incorrectAnswers: number; totalWords: number; streakDays: number; lastStudyDate: string | null; timeSpent: number; categoriesProgress: Record<string, any>; hintsUsed: number; } interface AppSettings { theme: 'light' | 'dark'; notifications: boolean; autoAdvance: boolean; soundEnabled: boolean; } type HealthStatus = 'unknown' | 'healthy' | 'degraded' | 'down' | 'quota_exceeded'; class StorageService { private isAvailable: boolean; private keys: StorageKeys; private operationQueue: Array<any>; private isProcessingQueue: boolean; private healthStatus: HealthStatus; private quotaWarningThreshold: number; private lastHealthCheck: number | null; constructor() { this.isAvailable = this.checkStorageAvailability(); this.keys = STORAGE_CONFIG.keys; this.operationQueue = []; this.isProcessingQueue = false; this.healthStatus = 'unknown'; this.quotaWarningThreshold = 0.85; this.lastHealthCheck = null; this.initializeService(); } private initializeService(): void { this.healthStatus = this.isAvailable ? 'healthy' : 'down'; this.setupPeriodicHealthCheck(); this.setupQuotaMonitoring(); } private checkStorageAvailability(): boolean { try { const test = '__enhanced_storage_test__'; localStorage.setItem(test, 'test'); localStorage.removeItem(test); return true; } catch (error) { console.error('❌ Storage not available:', (error as Error).message); return false; } } private setupPeriodicHealthCheck(): void { setInterval(() => { this.performHealthCheck(); }, 30000); } private setupQuotaMonitoring(): void { setInterval(() => { this.checkQuotaUsage(); }, 60000); } private async performHealthCheck(): Promise<void> { try { const testKey = '__health_check__'; const testData = { timestamp: Date.now() }; await this.executeStorageOperation( () => { localStorage.setItem(testKey, JSON.stringify(testData)); const retrieved = JSON.parse(localStorage.getItem(testKey) || '{}'); localStorage.removeItem(testKey); if (retrieved.timestamp !== testData.timestamp) { throw new Error('Data integrity check failed'); } }, 'Health Check' ); this.healthStatus = 'healthy'; this.lastHealthCheck = Date.now(); } catch (error) { this.healthStatus = (error as Error).message.includes('quota') ? 'quota_exceeded' : 'degraded'; } } private checkQuotaUsage(): void { try { const usage = this.getUsageStats(); const usagePercentage = parseFloat(usage.usagePercentage); if (usagePercentage > this.quotaWarningThreshold * 100) { console.warn(`⚠️ Storage quota warning: ${usagePercentage}% used`); if (usagePercentage > 95) { this.healthStatus = 'quota_exceeded'; this.performAutomaticCleanup(); } } } catch (error) { console.error('❌ Quota check failed:', error); } } async get<T = any>(key: string, defaultValue: T | null = null): Promise<T | null> { if (!this.isAvailable) { return defaultValue; } try { return await this.executeStorageOperation( () => { const item = localStorage.getItem(key); if (item === null) { return defaultValue; } try { return JSON.parse(item) as T; } catch (parseError) { console.warn(`❌ Parse error for key "${key}", returning as string`); return item as unknown as T; } }, `Get ${key}` ); } catch (error) { console.error(`❌ Failed to get "${key}":`, (error as Error).message); return defaultValue; } } async set<T = any>(key: string, value: T): Promise<boolean> { if (!this.isAvailable) { return false; } try { return await this.executeStorageOperation( () => { const serializedValue = JSON.stringify(value); const estimatedSize = (key.length + serializedValue.length) * 2; const currentUsage = this.getUsageStats(); if (currentUsage.available < estimatedSize) { throw new Error('QuotaExceededError: Not enough space'); } localStorage.setItem(key, serializedValue); return true; }, `Set ${key}` ); } catch (error) { if ((error as Error).message.includes('quota') || (error as Error).name === 'QuotaExceededError') { const cleanupSuccess = await this.performAutomaticCleanup(); if (cleanupSuccess) { try { const serializedValue = JSON.stringify(value); localStorage.setItem(key, serializedValue); return true; } catch (retryError) { console.error(`❌ Failed to set "${key}" after cleanup:`, (retryError as Error).message); return false; } } } console.error(`❌ Failed to set "${key}":`, (error as Error).message); return false; } } private async executeStorageOperation<T>( operation: () => T, operationName: string ): Promise<T> { return await globalOperationManager.execute( 'storageOperation', operation ); } private async performAutomaticCleanup(): Promise<boolean> { try { let cleanedSpace = 0; const tempKeys = this.getKeysMatching('^(temp_|cache_|backup_)'); for (const key of tempKeys) { const size = this.getItemSize(key); localStorage.removeItem(key); cleanedSpace += size; } const testHistory = await this.get<Array<any>>(this.keys.testHistory, []); if (testHistory && testHistory.length > 50) { const trimmedHistory = testHistory.slice(0, 50); await this.set(this.keys.testHistory, trimmedHistory); cleanedSpace += this.getItemSize(this.keys.testHistory) * 0.5; } await this.compressWordPerformanceData(); console.log(`🧹 Automatic cleanup freed ~${Math.round(cleanedSpace / 1024)}KB`); return cleanedSpace > 0; } catch (error) { console.error('❌ Automatic cleanup failed:', error); return false; } } private async compressWordPerformanceData(): Promise<void> { try { const wordPerformance = await this.get<Record<string, any>>('wordPerformance', {}); let compressed = false; if (wordPerformance) { Object.keys(wordPerformance).forEach(wordId => { const data = wordPerformance[wordId]; if (data.attempts && data.attempts.length > 20) { data.attempts = data.attempts.slice(-20); compressed = true; } }); if (compressed) { await this.set('wordPerformance', wordPerformance); console.log('📊 Word performance data compressed'); } } } catch (error) { console.error('❌ Failed to compress word performance data:', error); } } private getItemSize(key: string): number { try { const value = localStorage.getItem(key); return value ? (key.length + value.length) * 2 : 0; } catch (error) { return 0; } } getUsageStats(): UsageStats { if (!this.isAvailable) { return { used: 0, available: 0, total: 0, usedMB: '0', availableMB: '0', usagePercentage: '0', critical: true, warning: false, healthStatus: this.healthStatus, lastHealthCheck: this.lastHealthCheck }; } try { let used = 0; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); const value = localStorage.getItem(key || ''); used += (key?.length || 0) + (value?.length || 0); } used *= 2; const total = 5 * 1024 * 1024; const available = total - used; const usagePercentage = (used / total) * 100; return { used, available, total, usedMB: (used / 1024 / 1024).toFixed(2), availableMB: (available / 1024 / 1024).toFixed(2), usagePercentage: usagePercentage.toFixed(1), critical: usagePercentage > 90, warning: usagePercentage > 75, healthStatus: this.healthStatus, lastHealthCheck: this.lastHealthCheck }; } catch (error) { return { used: 0, available: 0, total: 0, usedMB: '0', availableMB: '0', usagePercentage: '0', critical: true, warning: false, healthStatus: this.healthStatus, lastHealthCheck: this.lastHealthCheck, error: (error as Error).message }; } } remove(key: string): boolean { if (!this.isAvailable) return false; try { localStorage.removeItem(key); return true; } catch (error) { return false; } } clear(): boolean { if (!this.isAvailable) return false; try { localStorage.clear(); return true; } catch (error) { return false; } } exists(key: string): boolean { if (!this.isAvailable) return false; return localStorage.getItem(key) !== null; } getKeysMatching(pattern: string): string[] { if (!this.isAvailable) return []; try { const regex = new RegExp(pattern); const matchingKeys: string[] = []; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key && regex.test(key)) { matchingKeys.push(key); } } return matchingKeys; } catch (error) { return []; } } async getWords(): Promise<Array<any>> { const words = await this.get<Array<any>>(this.keys.words, null); if (!words || words.length === 0) { const fallbackKeys = [ 'words', 'vocabularyWords', 'vocabulary_words_v1', 'vocabulary-words', 'app_words', 'vocabWords' ]; for (const key of fallbackKeys) { const fallbackWords = await this.get<Array<any>>(key, null); if (fallbackWords && fallbackWords.length > 0) { await this.set(this.keys.words, fallbackWords); return fallbackWords; } } } return words || []; } async saveWords(words: Array<any>): Promise<boolean> { return await this.set(this.keys.words, words); } async getStats(): Promise<AppStats> { const defaultStats: AppStats = { testsCompleted: 0, correctAnswers: 0, incorrectAnswers: 0, totalWords: 0, streakDays: 0, lastStudyDate: null, timeSpent: 0, categoriesProgress: {}, hintsUsed: 0 }; return await this.get<AppStats>(this.keys.stats, defaultStats) || defaultStats; } async saveStats(stats: AppStats): Promise<boolean> { return await this.set(this.keys.stats, stats); } async getTestHistory(): Promise<Array<any>> { return await this.get<Array<any>>(this.keys.testHistory, []) || []; } async saveTestHistory(history: Array<any>): Promise<boolean> { return await this.set(this.keys.testHistory, history); } async getSettings(): Promise<AppSettings> { const defaultSettings: AppSettings = { theme: 'light', notifications: true, autoAdvance: true, soundEnabled: true }; return await this.get<AppSettings>(this.keys.settings, defaultSettings) || defaultSettings; } async saveSettings(settings: AppSettings): Promise<boolean> { return await this.set(this.keys.settings, settings); } getServiceStatus(): ServiceStatus { return { available: this.isAvailable, health: this.healthStatus, usage: this.getUsageStats(), lastHealthCheck: this.lastHealthCheck, recommendations: this.getRecommendations() }; } private getRecommendations(): string[] { const recommendations: string[] = []; const usage = this.getUsageStats(); if (!this.isAvailable) { recommendations.push('🔒 Storage non disponibile. Verifica impostazioni browser'); } if (usage.critical) { recommendations.push('💽 Spazio quasi esaurito. Esporta backup ed elimina dati vecchi'); } else if (usage.warning) { recommendations.push('⚠️ Spazio in esaurimento. Considera pulizia dati'); } if (this.healthStatus === 'degraded') { recommendations.push('🟡 Servizio instabile. Esporta backup preventivo'); } return recommendations; } } const storageService = new StorageService(); export { storageService }; export default storageService;

================================================================================


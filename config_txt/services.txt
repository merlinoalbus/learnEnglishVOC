NOME FILE: aiService.js

// ===================================================== // 📁 src/services/aiService.js - Gemini AI Integration Service (VERSIONE SICURA) // =====================================================  import AppConfig, { ERROR_MESSAGES, isAIAvailable } from '../config/appConfig'; import { CATEGORIES } from '../constants/appConstants';  /**  * AI Service per Gemini API integration  * SICURO: API key ora da environment variable invece di hardcoded  */ class AIService {   constructor() {     // Ottieni configurazione da AppConfig (sicuro)     this.config = AppConfig.ai;     this.initializeService();   }    /**    * Initialize service e verifica configurazione    */   initializeService() {     this.isConfigured = !!this.config.apiKey;     this.canUseAI = isAIAvailable();          if (AppConfig.app.environment === 'development') {       console.log('🤖 AI Service Status:', {         configured: this.isConfigured,         canUseAI: this.canUseAI,         apiKeyPresent: !!this.config.apiKey       });              if (!this.isConfigured) {         console.warn(           '⚠️ AI Service: API key non configurata.\n' +           'Aggiungi REACT_APP_GEMINI_API_KEY=your_api_key_here in .env.local'         );       }     }   }    /**    * Build the API URL with API key    * @returns {string} Complete API URL    */   getApiUrl() {     if (!this.config.apiKey) {       throw new Error('API key non configurata');     }     return `${this.config.baseUrl}?key=${this.config.apiKey}`;   }    /**    * Word categorization fallback (identica alla tua funzione originale)    * @param {string} word - English word to categorize    * @returns {string} Category name    */   categorizeWordFallback(word) {     const wordLower = word.toLowerCase();          // Pattern per verbi comuni (identico al tuo codice)     if (wordLower.match(/^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/)) {       return 'VERBI';     }          // Pattern per verbi irregolari comuni (identico al tuo codice)     if (wordLower.match(/^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/)) {       return 'VERBI_IRREGOLARI';     }          // Pattern per aggettivi (identico al tuo codice)     if (wordLower.match(/^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/) ||          wordLower.match(/^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/)) {       return 'AGGETTIVI';     }          // Pattern per tecnologia (identico al tuo codice)     if (wordLower.match(/^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/)) {       return 'TECNOLOGIA';     }          // Pattern per famiglia (identico al tuo codice)     if (wordLower.match(/^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/)) {       return 'FAMIGLIA';     }          // Pattern per emozioni positive (identico al tuo codice)     if (wordLower.match(/^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/)) {       return 'EMOZIONI_POSITIVE';     }          // Pattern per emozioni negative (identico al tuo codice)     if (wordLower.match(/^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/)) {       return 'EMOZIONI_NEGATIVE';     }          // Pattern per lavoro (identico al tuo codice)     if (wordLower.match(/^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/)) {       return 'LAVORO';     }          // Pattern per vestiti (identico al tuo codice)     if (wordLower.match(/^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/)) {       return 'VESTITI';     }          // Default: prova a determinare se è un sostantivo (identico al tuo codice)     return 'SOSTANTIVI';   }    /**    * Build Gemini API prompt (identico al tuo prompt)    * @param {string} englishWord - English word to analyze    * @returns {string} Complete prompt    */   buildPrompt(englishWord) {     const groupsList = CATEGORIES.join(', ');          return ` Analizza la parola inglese "${englishWord}" e fornisci le seguenti informazioni in formato JSON:  {   "italian": "traduzione principale in italiano (solo la traduzione più comune)",   "group": "DEVE essere esattamente una di queste categorie: ${groupsList}. Scegli quella più appropriata per la parola.",   "sentence": "frase d'esempio in inglese che usa la parola",   "notes": "note aggiuntive con altre traduzioni, sinonimi, forme irregolari, etc. Formatta come: 'Altri Significati: ... Sinonimi: ... Verbo Irregolare: ... etc.'",   "chapter": "lascia vuoto, sarà compilato dall'utente" }  REGOLE IMPORTANTI: - Rispondi SOLO con il JSON valido, nessun altro testo - Il campo "group" DEVE essere esattamente una di queste opzioni: ${groupsList} - Per i verbi irregolari, usa "VERBI_IRREGOLARI" e specifica le forme nel campo notes - Per verbi regolari, usa "VERBI" - Includi sempre almeno 2-3 significati alternativi nelle note se esistono - La frase deve essere semplice e chiara - Il campo "chapter" deve rimanere vuoto (stringa vuota) - Se la parola non si adatta perfettamente a nessuna categoria, scegli quella più vicina  ESEMPI: - "run" → group: "VERBI_IRREGOLARI"  - "beautiful" → group: "AGGETTIVI" - "computer" → group: "TECNOLOGIA" - "father" → group: "FAMIGLIA" - "happy" → group: "EMOZIONI_POSITIVE" `;   }    /**    * Sleep utility for retry delays (identico al tuo codice)    * @param {number} ms - Milliseconds to sleep    * @returns {Promise}    */   sleep(ms) {     return new Promise(resolve => setTimeout(resolve, ms));   }    /**    * Make HTTP request to Gemini API with retries (identico al tuo codice)    * @param {string} prompt - Prompt to send to AI    * @param {number} attempt - Current attempt number    * @returns {Promise<Object>} API response    */   async makeRequest(prompt, attempt = 1) {     if (!this.isConfigured) {       throw new Error('API key non configurata. Aggiungi REACT_APP_GEMINI_API_KEY in .env.local');     }      const controller = new AbortController();     const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);      try {       const response = await fetch(this.getApiUrl(), {         method: 'POST',         headers: {           'Content-Type': 'application/json',         },         body: JSON.stringify({           contents: [{             parts: [{ text: prompt }]           }]         }),         signal: controller.signal       });        clearTimeout(timeoutId);        if (!response.ok) {         const errorText = await response.text();         throw new Error(`API Error ${response.status}: ${errorText}`);       }        const data = await response.json();              if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {         throw new Error('Invalid API response structure');       }        return data;      } catch (error) {       clearTimeout(timeoutId);              // Handle timeout (identico al tuo codice)       if (error.name === 'AbortError') {         throw new Error('Request timeout');       }              // Handle network errors with retry (identico al tuo codice)       if (attempt < this.config.maxRetries && (         error.message.includes('fetch') ||          error.message.includes('network') ||         error.message.includes('timeout')       )) {         await this.sleep(this.config.retryDelay * attempt); // Exponential backoff         return this.makeRequest(prompt, attempt + 1);       }        throw error;     }   }    /**    * Parse and validate AI response (identico al tuo codice)    * @param {string} content - Raw AI response content    * @param {string} fallbackWord - Original word for fallback categorization    * @returns {Object} Parsed and validated word data    */   parseAIResponse(content, fallbackWord) {     try {       // Extract JSON from the response (identico al tuo codice)       const jsonMatch = content.match(/\{[\s\S]*\}/);       if (!jsonMatch) {         throw new Error('No JSON found in AI response');       }        const parsedData = JSON.parse(jsonMatch[0]);        // Validate required fields (identico al tuo codice)       if (!parsedData.italian) {         throw new Error('Missing italian translation in AI response');       }        // Validate category: must be one of predefined categories (identico al tuo codice)       if (parsedData.group && !CATEGORIES.includes(parsedData.group)) {         parsedData.group = this.categorizeWordFallback(fallbackWord);       }        // Set default group if missing (identico al tuo codice)       if (!parsedData.group) {         parsedData.group = this.categorizeWordFallback(fallbackWord);       }        // Ensure chapter is empty string (identico al tuo codice)       parsedData.chapter = parsedData.chapter || '';        // Validate data integrity (identico al tuo codice)       return {         italian: parsedData.italian?.trim() || '',         group: parsedData.group,         sentence: parsedData.sentence?.trim() || '',         notes: parsedData.notes?.trim() || '',         chapter: ''       };      } catch (error) {              // Fallback: return minimal data with categorization (identico al tuo codice)       return {         italian: '',         group: this.categorizeWordFallback(fallbackWord),         sentence: '',         notes: 'AI parsing failed. Please fill manually.',         chapter: ''       };     }   }    /**    * Main method: Call Gemini API to analyze a word (identico al tuo codice)    * @param {string} englishWord - English word to analyze    * @returns {Promise<Object>} Word analysis data    */   async analyzeWord(englishWord) {     if (!englishWord || typeof englishWord !== 'string') {       throw new Error('Valid English word is required');     }      const trimmedWord = englishWord.trim();     if (!trimmedWord) {       throw new Error('English word cannot be empty');     }      try {       // Build prompt (identico al tuo codice)       const prompt = this.buildPrompt(trimmedWord);              // Make API request (identico al tuo codice)       const apiResponse = await this.makeRequest(prompt);              // Extract content (identico al tuo codice)       const content = apiResponse.candidates[0].content.parts[0].text;              // Parse and validate response (identico al tuo codice)       const wordData = this.parseAIResponse(content, trimmedWord);        return wordData;      } catch (error) {             // Re-throw with user-friendly message (identico al tuo codice)       if (error.message.includes('timeout')) {         throw new Error(ERROR_MESSAGES.network);       } else if (error.message.includes('API Error')) {         throw new Error(ERROR_MESSAGES.ai);       } else {         throw new Error(`AI Error: ${error.message}`);       }     }   }    /**    * Quick category prediction without full analysis (identico al tuo codice)    * @param {string} englishWord - English word to categorize    * @returns {string} Predicted category    */   quickCategorize(englishWord) {     if (!englishWord || typeof englishWord !== 'string') {       return 'SOSTANTIVI';     }          return this.categorizeWordFallback(englishWord.trim());   }    /**    * Check if AI service is available (identico al tuo codice)    * @returns {Promise<boolean>} Service availability    */   async isAvailable() {     if (!this.isConfigured) {       return false;     }      try {       // Simple test request (identico al tuo codice)       const testResponse = await fetch(this.getApiUrl(), {         method: 'POST',         headers: { 'Content-Type': 'application/json' },         body: JSON.stringify({           contents: [{ parts: [{ text: 'test' }] }]         })       });              return testResponse.ok || testResponse.status === 400; // 400 is OK, means API is responsive     } catch (error) {       return false;     }   }    /**    * Get service status information (identico al tuo codice)    * @returns {Object} Service status    */   getStatus() {     return {       configured: this.isConfigured,       apiUrl: this.config.baseUrl,       timeout: this.config.timeout,       maxRetries: this.config.maxRetries,       categories: CATEGORIES.length     };   } }  // Create and export singleton instance (identico al tuo codice) const aiService = new AIService();  export { aiService }; export default aiService;

================================================================================

NOME FILE: enhancedAIService.js

// ===================================================== // 📁 src/services/enhancedAIService.js - NO AUTOMATIC PING VERSION // =====================================================  import AppConfig, { isAIAvailable } from '../config/appConfig'; import { CATEGORIES } from '../constants/appConstants'; import { withTimeout, globalOperationManager } from '../utils/retryUtils';  class EnhancedAIService {   constructor() {     this.config = AppConfig.ai;     this.isConfigured = !!this.config.apiKey;     this.canUseAI = isAIAvailable();     this.lastSuccessTime = null;     this.consecutiveFailures = 0;     this.healthStatus = 'unknown';     this.lastHealthCheck = null;     this.initializeService();   }    initializeService() {     // ⭐ SMART INITIAL STATUS - NO API CALLS     if (!this.isConfigured) {       this.healthStatus = 'down';     } else {       // Assume healthy until proven otherwise       this.healthStatus = 'healthy';     }          if (AppConfig.app.environment === 'development') {       console.log('🤖 Enhanced AI Service Status (NO AUTO-PING):', {         configured: this.isConfigured,         canUseAI: this.canUseAI,         apiKeyPresent: !!this.config.apiKey,         healthStatus: this.healthStatus       });     }   }    // ⭐ PASSIVE HEALTH CHECK - NO API CALLS   checkHealthPassive() {     if (!this.isConfigured) {       this.healthStatus = 'down';       this.lastHealthCheck = Date.now();       return false;     }      // ⭐ SMART STATUS INFERENCE based on recent activity     const now = Date.now();     const fiveMinutesAgo = now - (5 * 60 * 1000);          // If we had recent success, assume healthy     if (this.lastSuccessTime && this.lastSuccessTime > fiveMinutesAgo) {       this.healthStatus = 'healthy';       this.lastHealthCheck = now;       return true;     }          // If we have consecutive failures, mark as degraded/down     if (this.consecutiveFailures > 3) {       this.healthStatus = 'down';     } else if (this.consecutiveFailures > 1) {       this.healthStatus = 'degraded';     } else {       // No recent activity but configured - assume healthy       this.healthStatus = 'healthy';     }          this.lastHealthCheck = now;     return this.healthStatus === 'healthy';   }    // ⭐ REAL HEALTH CHECK - ONLY ON MANUAL REQUEST   async checkHealthManual() {     if (!this.isConfigured) {       this.healthStatus = 'down';       this.lastHealthCheck = Date.now();       return false;     }      try {       console.log('🔍 Manual AI health check (COSTS MONEY)...');              const response = await withTimeout(         () => fetch(this.getApiUrl(), {           method: 'POST',           headers: { 'Content-Type': 'application/json' },           body: JSON.stringify({             contents: [{ parts: [{ text: 'ping' }] }]           })         }),         8000       );        const isHealthy = response.ok || response.status === 400;              if (isHealthy) {         this.healthStatus = 'healthy';         this.consecutiveFailures = 0;         this.lastSuccessTime = Date.now();         console.log('✅ AI service manually verified as healthy');       } else {         this.consecutiveFailures++;         this.healthStatus = this.consecutiveFailures > 2 ? 'down' : 'degraded';         console.log('⚠️ AI service manually verified as degraded:', response.status);       }              this.lastHealthCheck = Date.now();       return isHealthy;            } catch (error) {       this.consecutiveFailures++;              if (error.message.includes('timeout')) {         this.healthStatus = 'degraded';         console.log('⏱️ AI service manual timeout');       } else if (error.message.includes('fetch') || error.message.includes('network')) {         this.healthStatus = this.consecutiveFailures > 2 ? 'down' : 'degraded';         console.log('📡 AI service manual network error');       } else {         this.healthStatus = this.consecutiveFailures > 3 ? 'down' : 'degraded';         console.log('❌ AI service manual error:', error.message);       }              this.lastHealthCheck = Date.now();       return false;     }   }    // ⭐ ANALYZE WORD - Updates health based on real usage   async analyzeWord(englishWord) {     if (!englishWord || typeof englishWord !== 'string') {       throw new Error('Valid English word is required');     }      const trimmedWord = englishWord.trim();     if (!trimmedWord) {       throw new Error('English word cannot be empty');     }      if (!this.isConfigured) {       throw new Error('AI service not configured. Add REACT_APP_GEMINI_API_KEY to .env.local');     }      try {       const result = await globalOperationManager.execute(         'aiAnalysis',         async () => await this.performAnalysis(trimmedWord)       );        // ⭐ UPDATE HEALTH ON REAL SUCCESS       this.consecutiveFailures = 0;       this.lastSuccessTime = Date.now();       this.healthStatus = 'healthy';       console.log('✅ AI analysis successful - health updated');        return result;     } catch (error) {       // ⭐ UPDATE HEALTH ON REAL FAILURE       this.consecutiveFailures++;              if (error.message.includes('API key') || error.message.includes('401')) {         this.healthStatus = 'down';         throw new Error('🔑 API key non valida. Verifica configurazione.');       } else if (error.message.includes('quota') || error.message.includes('limit')) {         this.healthStatus = 'down';         throw new Error('🚫 Limite API raggiunto. Riprova più tardi.');       } else if (error.message.includes('timeout')) {         this.healthStatus = 'degraded';         throw new Error('⏱️ AI timeout. Connessione lenta.');       } else if (error.message.includes('Circuit breaker')) {         this.healthStatus = 'down';         throw new Error('🔴 AI temporaneamente non disponibile.');       } else {         this.healthStatus = this.consecutiveFailures > 2 ? 'down' : 'degraded';         console.log(`❌ AI analysis failed - health updated to ${this.healthStatus}`);         throw new Error(`🤖 Errore AI: ${error.message}`);       }     }   }    // ⭐ ANALYZE WITH FALLBACK   async analyzeWordWithFallback(englishWord) {     try {       return await this.analyzeWord(englishWord);     } catch (error) {       console.warn('🤖 AI analysis failed, providing fallback:', error.message);              return {         italian: '',         group: this.categorizeWordFallback(englishWord),         sentence: '',         notes: `🤖 AI non disponibile: ${error.message}. Completa manualmente.`,         chapter: '',         _aiError: true,         _fallbackUsed: true       };     }   }    // ⭐ CORE ANALYSIS   async performAnalysis(word) {     const prompt = this.buildPrompt(word);     const apiResponse = await this.makeRequest(prompt);     const content = apiResponse.candidates[0].content.parts[0].text;     return this.parseAIResponse(content, word);   }    // ⭐ MAKE REQUEST   async makeRequest(prompt) {     const controller = new AbortController();     const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);      try {       const response = await fetch(this.getApiUrl(), {         method: 'POST',         headers: { 'Content-Type': 'application/json' },         body: JSON.stringify({           contents: [{ parts: [{ text: prompt }] }]         }),         signal: controller.signal       });        clearTimeout(timeoutId);        if (!response.ok) {         const errorText = await response.text();                  if (response.status === 401) {           throw new Error('API key non valida');         } else if (response.status === 403) {           throw new Error('Accesso negato API');         } else if (response.status === 429) {           throw new Error('Troppi richieste');         } else if (response.status === 400) {           throw new Error('Richiesta non valida');         } else if (response.status >= 500) {           throw new Error('Errore server Gemini');         } else {           throw new Error(`API Error ${response.status}: ${errorText}`);         }       }        const data = await response.json();              if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {         throw new Error('Risposta API non valida');       }        return data;      } catch (error) {       clearTimeout(timeoutId);              if (error.name === 'AbortError') {         throw new Error('Request timeout');       }              if (error.message.includes('fetch') || error.message.includes('network')) {         throw new Error('Errore di rete');       }              throw error;     }   }    // ⭐ PARSE AI RESPONSE   parseAIResponse(content, fallbackWord) {     try {       const jsonMatch = content.match(/\{[\s\S]*\}/);       if (!jsonMatch) {         return this.createFallbackResponse(fallbackWord, 'No JSON in response');       }        const parsedData = JSON.parse(jsonMatch[0]);       return this.validateAndSanitizeResponse(parsedData, fallbackWord);      } catch (parseError) {       return this.createFallbackResponse(fallbackWord, 'JSON parsing failed');     }   }    // ⭐ VALIDATE RESPONSE   validateAndSanitizeResponse(data, fallbackWord) {     const result = {       italian: '',       group: '',       sentence: '',       notes: '',       chapter: ''     };      if (!data.italian || typeof data.italian !== 'string' || !data.italian.trim()) {       return this.createFallbackResponse(fallbackWord, 'Missing translation');     }     result.italian = data.italian.trim();      if (data.group && CATEGORIES.includes(data.group)) {       result.group = data.group;     } else {       result.group = this.categorizeWordFallback(fallbackWord);     }      result.sentence = data.sentence && typeof data.sentence === 'string' ?        data.sentence.trim() : '';          result.notes = data.notes && typeof data.notes === 'string' ?        data.notes.trim() : '';          result.chapter = '';      return result;   }    // ⭐ FALLBACK RESPONSE   createFallbackResponse(word, reason) {     return {       italian: '',       group: this.categorizeWordFallback(word),       sentence: '',       notes: `❌ AI analysis failed: ${reason}. Fill manually.`,       chapter: ''     };   }    // ⭐ BUILD PROMPT   buildPrompt(englishWord) {     const groupsList = CATEGORIES.join(', ');          return ` Analizza la parola inglese "${englishWord}" e fornisci JSON:  {   "italian": "traduzione principale italiana",   "group": "DEVE essere una di: ${groupsList}",   "sentence": "frase d'esempio inglese",   "notes": "note aggiuntive, sinonimi, forme irregolari",   "chapter": "lascia vuoto" }  REGOLE: - Solo JSON valido - "group" deve essere esatto da lista - Per verbi irregolari usa "VERBI_IRREGOLARI" - Includi 2-3 significati nelle note - "chapter" sempre vuoto  ESEMPI: - "run" → "VERBI_IRREGOLARI"  - "beautiful" → "AGGETTIVI" - "computer" → "TECNOLOGIA" `;   }    // ⭐ CATEGORIZE FALLBACK   categorizeWordFallback(word) {     const wordLower = word.toLowerCase();          if (wordLower.match(/^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/)) {       return 'VERBI';     }          if (wordLower.match(/^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/)) {       return 'VERBI_IRREGOLARI';     }          if (wordLower.match(/^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/) ||          wordLower.match(/^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/)) {       return 'AGGETTIVI';     }          if (wordLower.match(/^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/)) {       return 'TECNOLOGIA';     }          if (wordLower.match(/^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/)) {       return 'FAMIGLIA';     }          if (wordLower.match(/^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/)) {       return 'EMOZIONI_POSITIVE';     }          if (wordLower.match(/^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/)) {       return 'EMOZIONI_NEGATIVE';     }          if (wordLower.match(/^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/)) {       return 'LAVORO';     }          if (wordLower.match(/^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/)) {       return 'VESTITI';     }          return 'SOSTANTIVI';   }    getApiUrl() {     if (!this.config.apiKey) {       throw new Error('API key non configurata');     }     return `${this.config.baseUrl}?key=${this.config.apiKey}`;   }    // ⭐ SERVICE STATUS - NO AUTOMATIC CALLS   getServiceStatus() {     const circuitBreakerStatus = globalOperationManager.getOperationStatus('aiAnalysis');          return {       configured: this.isConfigured,       health: this.healthStatus,       consecutiveFailures: this.consecutiveFailures,       lastSuccessTime: this.lastSuccessTime,       lastHealthCheck: this.lastHealthCheck,       circuitBreaker: circuitBreakerStatus?.circuitBreaker,       apiUrl: this.config.baseUrl,       timeout: this.config.timeout,       canUseAI: this.canUseAI,       degradedMode: this.healthStatus === 'degraded',       recommendations: this.getRecommendations()     };   }    getRecommendations() {     const recommendations = [];          if (!this.isConfigured) {       recommendations.push('🔑 Configurare API key in .env.local');     }          if (this.healthStatus === 'down') {       recommendations.push('🔴 Servizio non disponibile. Usa modalità manuale');     }          if (this.healthStatus === 'degraded') {       recommendations.push('🟡 Servizio instabile. Verifica connessione');     }          if (this.consecutiveFailures > 2) {       recommendations.push('⚠️ Molti errori consecutivi. Controlla configurazione');     }          return recommendations;   }    // ⭐ PUBLIC METHODS - NO AUTO CALLS   quickCategorize(englishWord) {     if (!englishWord || typeof englishWord !== 'string') {       return 'SOSTANTIVI';     }     return this.categorizeWordFallback(englishWord.trim());   }    // ⭐ MANUAL HEALTH CHECK ONLY   async checkHealth() {     return await this.checkHealthManual();   }    // ⭐ PASSIVE CHECK - NO API CALLS   isAvailable() {     return this.checkHealthPassive();   }    getStatus() {     return this.getServiceStatus();   } }  const enhancedAIService = new EnhancedAIService();  export { enhancedAIService }; export default { enhancedAIService };

================================================================================

NOME FILE: enhancedStorageService.js

 // ===================================================== // 📁 src/services/enhancedStorageService.js - Enhanced Storage Service // =====================================================  import { STORAGE_CONFIG } from '../constants/appConstants'; import { smartRetryStorage, globalOperationManager } from '../utils/retryUtils';  class EnhancedStorageService {   constructor() {     this.isAvailable = this.checkStorageAvailability();     this.keys = STORAGE_CONFIG.keys;     this.operationQueue = [];     this.isProcessingQueue = false;     this.healthStatus = 'unknown';     this.quotaWarningThreshold = 0.85; // 85% of quota     this.lastHealthCheck = null;     this.initializeService();   }    initializeService() {     this.healthStatus = this.isAvailable ? 'healthy' : 'down';     this.setupPeriodicHealthCheck();     this.setupQuotaMonitoring();   }    // ⭐ ENHANCED STORAGE AVAILABILITY CHECK   checkStorageAvailability() {     try {       const test = '__enhanced_storage_test__';       localStorage.setItem(test, 'test');       localStorage.removeItem(test);       return true;     } catch (error) {       console.error('❌ Storage not available:', error.message);       return false;     }   }    // ⭐ PERIODIC HEALTH CHECK   setupPeriodicHealthCheck() {     setInterval(() => {       this.performHealthCheck();     }, 30000); // Every 30 seconds   }    // ⭐ QUOTA MONITORING   setupQuotaMonitoring() {     setInterval(() => {       this.checkQuotaUsage();     }, 60000); // Every minute   }    async performHealthCheck() {     try {       const testKey = '__health_check__';       const testData = { timestamp: Date.now() };              await this.executeStorageOperation(         () => {           localStorage.setItem(testKey, JSON.stringify(testData));           const retrieved = JSON.parse(localStorage.getItem(testKey));           localStorage.removeItem(testKey);                      if (retrieved.timestamp !== testData.timestamp) {             throw new Error('Data integrity check failed');           }         },         'Health Check'       );              this.healthStatus = 'healthy';       this.lastHealthCheck = Date.now();     } catch (error) {       this.healthStatus = error.message.includes('quota') ? 'quota_exceeded' : 'degraded';     }   }    checkQuotaUsage() {     try {       const usage = this.getUsageStats();       const usagePercentage = parseFloat(usage.usagePercentage);              if (usagePercentage > this.quotaWarningThreshold * 100) {         console.warn(`⚠️ Storage quota warning: ${usagePercentage}% used`);                  if (usagePercentage > 95) {           this.healthStatus = 'quota_exceeded';           // Trigger automatic cleanup           this.performAutomaticCleanup();         }       }     } catch (error) {       console.error('❌ Quota check failed:', error);     }   }    // ⭐ ENHANCED GET with retry logic   async get(key, defaultValue = null) {     if (!this.isAvailable) {       return defaultValue;     }      try {       return await this.executeStorageOperation(         () => {           const item = localStorage.getItem(key);           if (item === null) {             return defaultValue;           }                      try {             return JSON.parse(item);           } catch (parseError) {             console.warn(`❌ Parse error for key "${key}", returning as string`);             return item;           }         },         `Get ${key}`       );     } catch (error) {       console.error(`❌ Failed to get "${key}":`, error.message);       return defaultValue;     }   }    // ⭐ ENHANCED SET with retry and queue   async set(key, value) {     if (!this.isAvailable) {       return false;     }      try {       return await this.executeStorageOperation(         () => {           const serializedValue = JSON.stringify(value);                      // Check if this operation would exceed quota           const estimatedSize = (key.length + serializedValue.length) * 2; // UTF-16           const currentUsage = this.getUsageStats();                      if (currentUsage.available < estimatedSize) {             throw new Error('QuotaExceededError: Not enough space');           }                      localStorage.setItem(key, serializedValue);           return true;         },         `Set ${key}`       );     } catch (error) {       if (error.message.includes('quota') || error.name === 'QuotaExceededError') {         // Try cleanup and retry once         const cleanupSuccess = await this.performAutomaticCleanup();         if (cleanupSuccess) {           try {             const serializedValue = JSON.stringify(value);             localStorage.setItem(key, serializedValue);             return true;           } catch (retryError) {             console.error(`❌ Failed to set "${key}" after cleanup:`, retryError.message);             return false;           }         }       }              console.error(`❌ Failed to set "${key}":`, error.message);       return false;     }   }    // ⭐ OPERATION EXECUTOR with retry logic   async executeStorageOperation(operation, operationName) {     return await globalOperationManager.execute(       'storageOperation',        operation     );   }    // ⭐ AUTOMATIC CLEANUP with smart strategies   async performAutomaticCleanup() {     try {       let cleanedSpace = 0;              // Strategy 1: Remove temporary and cache data       const tempKeys = this.getKeysMatching('^(temp_|cache_|backup_)');       for (const key of tempKeys) {         const size = this.getItemSize(key);         localStorage.removeItem(key);         cleanedSpace += size;       }              // Strategy 2: Remove old test history (keep only last 50)       const testHistory = await this.get(this.keys.testHistory, []);       if (testHistory.length > 50) {         const trimmedHistory = testHistory.slice(0, 50);         await this.set(this.keys.testHistory, trimmedHistory);         cleanedSpace += this.getItemSize(this.keys.testHistory) * 0.5; // Estimate       }              // Strategy 3: Compress word performance data       await this.compressWordPerformanceData();              console.log(`🧹 Automatic cleanup freed ~${Math.round(cleanedSpace / 1024)}KB`);       return cleanedSpace > 0;     } catch (error) {       console.error('❌ Automatic cleanup failed:', error);       return false;     }   }    // ⭐ COMPRESS WORD PERFORMANCE DATA   async compressWordPerformanceData() {     try {       const wordPerformance = await this.get('wordPerformance', {});       let compressed = false;              Object.keys(wordPerformance).forEach(wordId => {         const data = wordPerformance[wordId];         if (data.attempts && data.attempts.length > 20) {           // Keep only last 20 attempts           data.attempts = data.attempts.slice(-20);           compressed = true;         }       });              if (compressed) {         await this.set('wordPerformance', wordPerformance);         console.log('📊 Word performance data compressed');       }     } catch (error) {       console.error('❌ Failed to compress word performance data:', error);     }   }    // ⭐ GET ITEM SIZE   getItemSize(key) {     try {       const value = localStorage.getItem(key);       return value ? (key.length + value.length) * 2 : 0; // UTF-16     } catch (error) {       return 0;     }   }    // ⭐ ENHANCED USAGE STATS   getUsageStats() {     if (!this.isAvailable) {       return { used: 0, available: 0, total: 0, critical: true };     }      try {       let used = 0;       for (let i = 0; i < localStorage.length; i++) {         const key = localStorage.key(i);         const value = localStorage.getItem(key);         used += (key?.length || 0) + (value?.length || 0);       }        used *= 2; // UTF-16 encoding       const total = 5 * 1024 * 1024; // 5MB typical limit       const available = total - used;       const usagePercentage = (used / total) * 100;        return {         used,         available,         total,         usedMB: (used / 1024 / 1024).toFixed(2),         availableMB: (available / 1024 / 1024).toFixed(2),         usagePercentage: usagePercentage.toFixed(1),         critical: usagePercentage > 90,         warning: usagePercentage > 75,         healthStatus: this.healthStatus,         lastHealthCheck: this.lastHealthCheck       };     } catch (error) {       return {          used: 0,          available: 0,          total: 0,          critical: true,          error: error.message        };     }   }    // Keep all existing methods for backward compatibility   remove(key) {     if (!this.isAvailable) return false;     try {       localStorage.removeItem(key);       return true;     } catch (error) {       return false;     }   }    clear() {     if (!this.isAvailable) return false;     try {       localStorage.clear();       return true;     } catch (error) {       return false;     }   }    exists(key) {     if (!this.isAvailable) return false;     return localStorage.getItem(key) !== null;   }    getKeysMatching(pattern) {     if (!this.isAvailable) return [];     try {       const regex = new RegExp(pattern);       const matchingKeys = [];       for (let i = 0; i < localStorage.length; i++) {         const key = localStorage.key(i);         if (key && regex.test(key)) {           matchingKeys.push(key);         }       }       return matchingKeys;     } catch (error) {       return [];     }   }    // App-specific methods with enhanced error handling   async getWords() {     const words = await this.get(this.keys.words, null);          if (!words || words.length === 0) {       // Enhanced fallback search       const fallbackKeys = [         'words', 'vocabularyWords', 'vocabulary_words_v1',         'vocabulary-words', 'app_words', 'vocabWords'       ];              for (const key of fallbackKeys) {         const fallbackWords = await this.get(key, null);         if (fallbackWords && fallbackWords.length > 0) {           // Migrate to new key           await this.set(this.keys.words, fallbackWords);           return fallbackWords;         }       }     }          return words || [];   }    async saveWords(words) {     return await this.set(this.keys.words, words);   }    async getStats() {     return await this.get(this.keys.stats, {       testsCompleted: 0,       correctAnswers: 0,       incorrectAnswers: 0,       totalWords: 0,       streakDays: 0,       lastStudyDate: null,       timeSpent: 0,       categoriesProgress: {},       hintsUsed: 0     });   }    async saveStats(stats) {     return await this.set(this.keys.stats, stats);   }    async getTestHistory() {     return await this.get(this.keys.testHistory, []);   }    async saveTestHistory(history) {     return await this.set(this.keys.testHistory, history);   }    async getSettings() {     return await this.get(this.keys.settings, {       theme: 'light',       notifications: true,       autoAdvance: true,       soundEnabled: true     });   }    async saveSettings(settings) {     return await this.set(this.keys.settings, settings);   }    // ⭐ SERVICE STATUS   getServiceStatus() {     return {       available: this.isAvailable,       health: this.healthStatus,       usage: this.getUsageStats(),       lastHealthCheck: this.lastHealthCheck,       recommendations: this.getRecommendations()     };   }    getRecommendations() {     const recommendations = [];     const usage = this.getUsageStats();          if (!this.isAvailable) {       recommendations.push('🔒 Storage non disponibile. Verifica impostazioni browser');     }          if (usage.critical) {       recommendations.push('💽 Spazio quasi esaurito. Esporta backup ed elimina dati vecchi');     } else if (usage.warning) {       recommendations.push('⚠️ Spazio in esaurimento. Considera pulizia dati');     }          if (this.healthStatus === 'degraded') {       recommendations.push('🟡 Servizio instabile. Esporta backup preventivo');     }          return recommendations;   } }  const enhancedStorageService = new EnhancedStorageService();  export { enhancedStorageService }; export default { enhancedStorageService };

================================================================================

NOME FILE: storageService.js

// ===================================================== // 📁 src/services/storageService.js - Optimized localStorage Wrapper // =====================================================  import { STORAGE_CONFIG } from '../constants/appConstants';  /**  * Enhanced localStorage service with error handling, compression, and backup functionality  * Estratto e ottimizzato dalla logica esistente nel codebase  */ class StorageService {   constructor() {     this.isAvailable = this.checkStorageAvailability();     this.keys = STORAGE_CONFIG.keys;   }    /**    * Check if localStorage is available    * @returns {boolean}    */   checkStorageAvailability() {     try {       const test = '__storage_test__';       localStorage.setItem(test, 'test');       localStorage.removeItem(test);       return true;     } catch (error) {       return false;     }   }    /**    * Get item from localStorage with parsing    * @param {string} key - Storage key    * @param {*} defaultValue - Default value if key doesn't exist    * @returns {*} Parsed value or default    */   get(key, defaultValue = null) {     if (!this.isAvailable) {       return defaultValue;     }      try {       const item = localStorage.getItem(key);       if (item === null) {         return defaultValue;       }              // Try to parse JSON, fallback to string if it fails       try {         return JSON.parse(item);       } catch (parseError) {         return item; // Return as string if JSON parsing fails       }     } catch (error) {       return defaultValue;     }   }    /**    * Set item in localStorage with stringification    * @param {string} key - Storage key    * @param {*} value - Value to store    * @returns {boolean} Success status    */   set(key, value) {     if (!this.isAvailable) {       return false;     }      try {       const serializedValue = JSON.stringify(value);       localStorage.setItem(key, serializedValue);       return true;     } catch (error) {       // Handle quota exceeded error       if (error.name === 'QuotaExceededError') {         this.cleanup();                  // Try again after cleanup         try {           const serializedValue = JSON.stringify(value);           localStorage.setItem(key, serializedValue);           return true;         } catch (retryError) {           return false;         }       }       return false;     }   }    /**    * Remove item from localStorage    * @param {string} key - Storage key    * @returns {boolean} Success status    */   remove(key) {     if (!this.isAvailable) {       return false;     }      try {       localStorage.removeItem(key);       return true;     } catch (error) {       return false;     }   }    /**    * Clear all localStorage data    * @returns {boolean} Success status    */   clear() {     if (!this.isAvailable) {       return false;     }      try {       localStorage.clear();       return true;     } catch (error) {       return false;     }   }    /**    * Get multiple items at once    * @param {string[]} keys - Array of keys to retrieve    * @returns {Object} Object with key-value pairs    */   getMultiple(keys) {     const result = {};     keys.forEach(key => {       result[key] = this.get(key);     });     return result;   }    /**    * Set multiple items at once    * @param {Object} items - Object with key-value pairs to set    * @returns {boolean} Success status    */   setMultiple(items) {     try {       Object.entries(items).forEach(([key, value]) => {         if (!this.set(key, value)) {           throw new Error(`Failed to set key: ${key}`);         }       });       return true;     } catch (error) {       return false;     }   }    /**    * Check if key exists in storage    * @param {string} key - Storage key    * @returns {boolean}    */   exists(key) {     if (!this.isAvailable) {       return false;     }     return localStorage.getItem(key) !== null;   }    /**    * Get all keys that match a pattern    * @param {string} pattern - Pattern to match (regex string)    * @returns {string[]} Array of matching keys    */   getKeysMatching(pattern) {     if (!this.isAvailable) {       return [];     }      try {       const regex = new RegExp(pattern);       const matchingKeys = [];              for (let i = 0; i < localStorage.length; i++) {         const key = localStorage.key(i);         if (key && regex.test(key)) {           matchingKeys.push(key);         }       }              return matchingKeys;     } catch (error) {       return [];     }   }    /**    * Get storage usage information    * @returns {Object} Storage usage stats    */   getUsageStats() {     if (!this.isAvailable) {       return { used: 0, available: 0, total: 0 };     }      try {       let used = 0;       for (let i = 0; i < localStorage.length; i++) {         const key = localStorage.key(i);         const value = localStorage.getItem(key);         used += (key?.length || 0) + (value?.length || 0);       }        // Estimate total available space (varies by browser)       const total = 5 * 1024 * 1024; // 5MB typical limit       const available = total - used;        return {         used,         available,         total,         usedMB: (used / 1024 / 1024).toFixed(2),         availableMB: (available / 1024 / 1024).toFixed(2),         usagePercentage: ((used / total) * 100).toFixed(1)       };     } catch (error) {       return { used: 0, available: 0, total: 0 };     }   }    /**    * Cleanup old or large items to free space    * @returns {boolean} Success status    */   cleanup() {     if (!this.isAvailable) {       return false;     }      try {       // Get all items with their sizes       const items = [];       for (let i = 0; i < localStorage.length; i++) {         const key = localStorage.key(i);         const value = localStorage.getItem(key);         const size = (key?.length || 0) + (value?.length || 0);                  items.push({ key, size, value });       }        // Sort by size (largest first)       items.sort((a, b) => b.size - a.size);        // Remove items that are not essential (avoid app critical keys)       const criticalKeys = Object.values(this.keys);       let cleaned = false;        for (const item of items) {         if (!criticalKeys.includes(item.key)) {           // Check if it's an old backup or temporary data           if (item.key.includes('backup_') || item.key.includes('temp_') || item.key.includes('cache_')) {             localStorage.removeItem(item.key);             cleaned = true;           }         }       }        return cleaned;     } catch (error) {       return false;     }   }    /**    * Create a backup of critical data    * @returns {Object|null} Backup data or null if failed    */   createBackup() {     if (!this.isAvailable) {       return null;     }      try {       const backup = {};       const criticalKeys = Object.values(this.keys);              criticalKeys.forEach(key => {         const data = this.get(key);         if (data !== null) {           backup[key] = data;         }       });        backup._timestamp = Date.now();       backup._version = '2.0.0';              return backup;     } catch (error) {       return null;     }   }    /**    * Restore from backup data    * @param {Object} backupData - Backup data to restore    * @returns {boolean} Success status    */   restoreFromBackup(backupData) {     if (!this.isAvailable || !backupData) {       return false;     }      try {       // Validate backup data       if (!backupData._timestamp || !backupData._version) {         throw new Error('Invalid backup data format');       }        // Restore each item       Object.entries(backupData).forEach(([key, value]) => {         if (!key.startsWith('_')) { // Skip metadata           this.set(key, value);         }       });        return true;     } catch (error) {       return false;     }   }    // =====================================================   // App-specific helper methods (extracted from existing code)   // =====================================================    /**    * Get vocabulary words (replaces direct localStorage access in app)    * @returns {Array} Array of word objects    */   getWords() {     // Try new key first, then fallback to possible old keys     let words = this.get(this.keys.words, null);          if (!words || words.length === 0) {       // Try common alternative keys that might be used by existing app       const fallbackKeys = [         'words',          'vocabularyWords',          'vocabulary_words_v1',         'vocabulary-words',         'app_words',         'vocabWords'       ];              for (const key of fallbackKeys) {         words = this.get(key, null);         if (words && words.length > 0) {           // Migrate to new key           this.set(this.keys.words, words);           break;         }       }              // If still nothing, check raw localStorage for any key containing "word"       if (!words || words.length === 0) {         for (let i = 0; i < localStorage.length; i++) {           const key = localStorage.key(i);           if (key && key.toLowerCase().includes('word')) {             try {               const data = JSON.parse(localStorage.getItem(key));               if (Array.isArray(data) && data.length > 0 && data[0].english && data[0].italian) {                 words = data;                 // Migrate to new key                 this.set(this.keys.words, words);                 break;               }             } catch (e) {               // Ignore parsing errors             }           }         }       }     }          return words || [];   }    /**    * Save vocabulary words    * @param {Array} words - Array of word objects    * @returns {boolean} Success status    */   saveWords(words) {     return this.set(this.keys.words, words);   }    /**    * Get app statistics    * @returns {Object} Stats object    */   getStats() {     let stats = this.get(this.keys.stats, null);          if (!stats || Object.keys(stats).length === 0) {       // Try fallback keys for stats       const fallbackKeys = ['stats', 'vocabulary_stats_v1', 'app_stats', 'vocabularyStats'];              for (const key of fallbackKeys) {         stats = this.get(key, null);         if (stats && Object.keys(stats).length > 0) {           // Migrate to new key           this.set(this.keys.stats, stats);           break;         }       }     }          // Return with defaults merged     return {       testsCompleted: 0,       correctAnswers: 0,       incorrectAnswers: 0,       totalWords: 0,       streakDays: 0,       lastStudyDate: null,       timeSpent: 0,       categoriesProgress: {},       ...stats     };   }    /**    * Save app statistics    * @param {Object} stats - Stats object    * @returns {boolean} Success status    */   saveStats(stats) {     return this.set(this.keys.stats, stats);   }    /**    * Get test history    * @returns {Array} Array of test history objects    */   getTestHistory() {     let history = this.get(this.keys.testHistory, null);          if (!history || history.length === 0) {       // Try fallback keys for test history       const fallbackKeys = ['testHistory', 'vocabulary_test_history_v1', 'test_history', 'vocabHistory'];              for (const key of fallbackKeys) {         history = this.get(key, null);         if (history && history.length > 0) {           // Migrate to new key           this.set(this.keys.testHistory, history);           break;         }       }     }          return history || [];   }    /**    * Save test history    * @param {Array} history - Array of test history objects    * @returns {boolean} Success status    */   saveTestHistory(history) {     return this.set(this.keys.testHistory, history);   }    /**    * Get app settings    * @returns {Object} Settings object    */   getSettings() {     return this.get(this.keys.settings, {       theme: 'light',       notifications: true,       autoAdvance: true,       soundEnabled: true     });   }    /**    * Save app settings    * @param {Object} settings - Settings object    * @returns {boolean} Success status    */   saveSettings(settings) {     return this.set(this.keys.settings, settings);   } }  // Create and export singleton instance const storageService = new StorageService();  export { storageService }; export default storageService;

================================================================================


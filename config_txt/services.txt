NOME FILE: authService.ts

import { signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updateProfile, updatePassword, reauthenticateWithCredential, EmailAuthProvider, onAuthStateChanged, User as FirebaseUser, type UserCredential, type AuthError as FirebaseAuthError, } from "firebase/auth"; import { auth } from "../config/firebase"; import type { AuthUser, AuthOperationResult, AuthError, AuthSession, SignInWithEmailInput, SignUpWithEmailInput, ResetPasswordInput, UpdateProfileInput, UpdatePasswordInput, } from "../types/infrastructure/Auth.types"; import { collection, doc, getDoc, getDocs, setDoc, updateDoc, deleteDoc, query, where, orderBy, serverTimestamp, writeBatch, } from "firebase/firestore"; import { sendPasswordResetEmail } from "firebase/auth"; import { db } from "../config/firebase"; import { UserRole, UserPermissions, AdminOperation, UserManagementFilters, UserExportData, DEFAULT_PERMISSIONS, } from "../types/entities/User.types"; import type { User, AuthState, SignUpInput, SignInInput, AuthOperationResult as UserAuthOperationResult, } from "../types/entities/User.types"; export const getUserProfile = async (userId: string): Promise<User | null> => { try { const userDoc = await getDoc(doc(db, USERS_COLLECTION, userId)); if (!userDoc.exists()) { return null; } const data = userDoc.data(); return { ...data, id: userDoc.id, createdAt: data.createdAt?.toDate() || new Date(), lastLoginAt: data.lastLoginAt?.toDate(), } as User; } catch (error) { console.error("Error getting user profile:", error); throw new Error("Failed to get user profile"); } }; export const initializeUserProfile = async ( authUser: User, registrationMethod: "email" | "google" = "email", isNewUser: boolean = true ): Promise<User> => { try { const userProfileRef = doc(db, USERS_COLLECTION, authUser.id); const existingProfile = await getDoc(userProfileRef); if (existingProfile.exists() && !isNewUser) { await setDoc( userProfileRef, { lastLoginAt: serverTimestamp(), }, { merge: true } ); const profileData = existingProfile.data() as User; return { ...profileData, id: authUser.id, lastLoginAt: new Date(), }; } const defaultRole: UserRole = "user"; const isFirstUser = await checkIfFirstUser(); const role: UserRole = isFirstUser ? "admin" : defaultRole; const newProfile: Partial<User> = { id: authUser.id, email: authUser.email, displayName: authUser.displayName || undefined, photoURL: authUser.photoURL || undefined, emailVerified: authUser.emailVerified, providerId: authUser.providerId, role, isActive: true, createdAt: new Date(), lastLoginAt: new Date(), metadata: { registrationMethod, notes: isNewUser ? "Auto-created profile" : undefined, }, }; await setDoc(userProfileRef, { ...newProfile, createdAt: serverTimestamp(), lastLoginAt: serverTimestamp(), }); return newProfile as User; } catch (error) { console.error("Error initializing user profile:", error); throw new Error("Failed to initialize user profile"); } }; export const getAllUsers = async ( filters?: UserManagementFilters ): Promise<User[]> => { try { let q = query( collection(db, USERS_COLLECTION), orderBy("createdAt", "desc") ); if (filters?.role) { q = query(q, where("role", "==", filters.role)); } if (filters?.isActive !== undefined) { q = query(q, where("isActive", "==", filters.isActive)); } if (filters?.emailVerified !== undefined) { q = query(q, where("emailVerified", "==", filters.emailVerified)); } const snapshot = await getDocs(q); let users = snapshot.docs.map((doc) => ({ ...doc.data(), id: doc.id, createdAt: doc.data().createdAt?.toDate() || new Date(), lastLoginAt: doc.data().lastLoginAt?.toDate(), })) as User[]; if (filters?.searchTerm) { const term = filters.searchTerm.toLowerCase(); users = users.filter( (user) => user.email.toLowerCase().includes(term) || user.displayName?.toLowerCase().includes(term) || user.id.includes(term) ); } return users; } catch (error) { console.error("Error getting all users:", error); throw new Error("Failed to get users"); } }; export const toggleUserStatus = async ( userId: string, isActive: boolean, adminId: string ): Promise<boolean> => { try { const batch = writeBatch(db); const userRef = doc(db, USERS_COLLECTION, userId); batch.update(userRef, { isActive, updatedAt: serverTimestamp(), }); const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: isActive ? "unblock_user" : "block_user", targetUserId: userId, performedBy: adminId, timestamp: new Date(), metadata: { isActive }, }; batch.set(operationRef, { ...operation, timestamp: serverTimestamp(), }); await batch.commit(); return true; } catch (error) { console.error("Error toggling user status:", error); return false; } }; export const resetUserPassword = async ( userEmail: string, adminId: string ): Promise<boolean> => { try { await sendPasswordResetEmail(auth, userEmail); const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "password_reset", targetUserId: userEmail, performedBy: adminId, timestamp: new Date(), metadata: { email: userEmail }, }; await setDoc(operationRef, { ...operation, timestamp: serverTimestamp(), }); return true; } catch (error) { console.error("Error sending password reset:", error); return false; } }; export const deleteUserData = async ( userId: string, adminId: string ): Promise<boolean> => { try { const batch = writeBatch(db); const userRef = doc(db, USERS_COLLECTION, userId); batch.delete(userRef); const userDataCollections = ["words", "test_history", "statistics"]; for (const collectionName of userDataCollections) { const userDataQuery = query( collection(db, collectionName), where("userId", "==", userId) ); const userDataSnapshot = await getDocs(userDataQuery); userDataSnapshot.docs.forEach((doc) => { batch.delete(doc.ref); }); } const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "delete_user", targetUserId: userId, performedBy: adminId, timestamp: new Date(), }; batch.set(operationRef, { ...operation, timestamp: serverTimestamp(), }); await batch.commit(); return true; } catch (error) { console.error("Error deleting user:", error); return false; } }; export const exportUserData = async ( userId: string, adminId: string ): Promise<UserExportData | null> => { try { const userProfile = await getUserProfile(userId); if (!userProfile) { throw new Error("User not found"); } const collections = ["words", "test_history", "statistics"]; const userData: Record<string, any[]> = {}; for (const collectionName of collections) { const userDataQuery = query( collection(db, collectionName), where("userId", "==", userId) ); const snapshot = await getDocs(userDataQuery); userData[collectionName] = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data(), })); } const exportData: UserExportData = { profile: userProfile, words: userData.words || [], testHistory: userData.test_history || [], statistics: userData.statistics || [], exportedAt: new Date(), exportedBy: adminId, }; const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "export_data", targetUserId: userId, performedBy: adminId, timestamp: new Date(), metadata: { wordsCount: exportData.words.length, testHistoryCount: exportData.testHistory.length, statisticsCount: exportData.statistics.length, }, }; await setDoc(operationRef, { ...operation, timestamp: serverTimestamp(), }); return exportData; } catch (error) { console.error("Error exporting user data:", error); return null; } }; export const importUserData = async ( userId: string, importData: Partial<UserExportData>, adminId: string ): Promise<boolean> => { try { const batch = writeBatch(db); const collections = { words: importData.words || [], test_history: importData.testHistory || [], statistics: importData.statistics || [], }; for (const [collectionName, items] of Object.entries(collections)) { items.forEach((item: any) => { const docRef = doc(collection(db, collectionName)); batch.set(docRef, { ...item, userId, importedAt: serverTimestamp(), }); }); } const operationRef = doc(collection(db, ADMIN_OPERATIONS_COLLECTION)); const operation: AdminOperation = { type: "import_data", targetUserId: userId, performedBy: adminId, timestamp: new Date(), metadata: { wordsCount: collections.words.length, testHistoryCount: collections.test_history.length, statisticsCount: collections.statistics.length, }, }; batch.set(operationRef, { ...operation, timestamp: serverTimestamp(), }); await batch.commit(); return true; } catch (error) { console.error("Error importing user data:", error); return false; } }; export const getAdminOperations = async ( limit_count: number = 50 ): Promise<AdminOperation[]> => { try { const q = query( collection(db, ADMIN_OPERATIONS_COLLECTION), orderBy("timestamp", "desc") ); const snapshot = await getDocs(q); return snapshot.docs.slice(0, limit_count).map((doc) => ({ ...doc.data(), timestamp: doc.data().timestamp?.toDate() || new Date(), })) as AdminOperation[]; } catch (error) { console.error("Error getting admin operations:", error); throw new Error("Failed to get admin operations"); } }; export const checkIfFirstUser = async (): Promise<boolean> => { try { const usersQuery = query(collection(db, USERS_COLLECTION)); const snapshot = await getDocs(usersQuery); return snapshot.size === 0; } catch (error) { console.error("Error checking if first user:", error); return false; } }; const USERS_COLLECTION = "users"; const ADMIN_OPERATIONS_COLLECTION = "admin_operations"; const AUTH_SERVICE_CONFIG = { sessionTimeout: 24 * 60 * 60 * 1000, inactivityTimeout: 2 * 60 * 60 * 1000, maxLoginAttempts: 5, lockoutDuration: 15 * 60 * 1000, enableSessionTracking: true, enableSecurityLogging: process.env.NODE_ENV === "development", }; const debugLog = (message: string, data?: any) => { if (AUTH_SERVICE_CONFIG.enableSecurityLogging) { console.log(`🔐 [AuthService] ${message}`, data || ""); } }; const convertFirebaseUser = (firebaseUser: FirebaseUser): AuthUser => { return { uid: firebaseUser.uid, email: firebaseUser.email, displayName: firebaseUser.displayName, photoURL: firebaseUser.photoURL, phoneNumber: firebaseUser.phoneNumber, emailVerified: firebaseUser.emailVerified, isAnonymous: firebaseUser.isAnonymous, metadata: { creationTime: new Date(firebaseUser.metadata.creationTime!), lastSignInTime: new Date(firebaseUser.metadata.lastSignInTime!), }, providerData: firebaseUser.providerData.map((provider) => ({ providerId: provider.providerId, uid: provider.uid, email: provider.email, displayName: provider.displayName, photoURL: provider.photoURL, phoneNumber: provider.phoneNumber, })), }; }; const convertToUserEntity = (authUser: AuthUser): User => { return { id: authUser.uid, email: authUser.email || "", displayName: authUser.displayName || undefined, photoURL: authUser.photoURL || undefined, emailVerified: authUser.emailVerified, providerId: authUser.providerData[0]?.providerId || "email", createdAt: authUser.metadata.creationTime, lastLoginAt: authUser.metadata.lastSignInTime, role: "user" as UserRole, isActive: true, }; }; const convertAuthError = ( firebaseError: FirebaseAuthError, operation: string ): AuthError => { const getErrorType = (code: string) => { switch (code) { case "auth/network-request-failed": return "network-error"; case "auth/invalid-email": case "auth/user-not-found": case "auth/wrong-password": case "auth/invalid-credential": return "invalid-credentials"; case "auth/email-already-in-use": case "auth/weak-password": return "user-management"; case "auth/too-many-requests": return "rate-limited"; default: return "unknown"; } }; return { code: firebaseError.code, message: firebaseError.message, operation: operation as any, recoverable: ["network-error", "rate-limited"].includes( getErrorType(firebaseError.code) ), timestamp: new Date(), type: getErrorType(firebaseError.code), }; }; const createOperationResult = ( success: boolean, user?: AuthUser, error?: AuthError, message?: string ): AuthOperationResult => { return { success, user, error, message, metadata: { timestamp: new Date(), duration: 0, }, }; }; export const signUp = async ( input: SignUpWithEmailInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Sign up attempt", { email: input.email }); const userCredential: UserCredential = await createUserWithEmailAndPassword( auth, input.email, input.password ); if (input.displayName) { await updateProfile(userCredential.user, { displayName: input.displayName, }); } const authUser = convertFirebaseUser(userCredential.user); debugLog("Sign up successful", { uid: authUser.uid }); const result = createOperationResult( true, authUser, undefined, "Account creato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Sign up failed", error); const authError = convertAuthError(error as FirebaseAuthError, "sign-up"); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const signIn = async ( input: SignInWithEmailInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Sign in attempt", { email: input.email }); const userCredential: UserCredential = await signInWithEmailAndPassword( auth, input.email, input.password ); const authUser = convertFirebaseUser(userCredential.user); debugLog("Sign in successful", { uid: authUser.uid }); const result = createOperationResult( true, authUser, undefined, "Login effettuato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Sign in failed", error); const authError = convertAuthError(error as FirebaseAuthError, "sign-in"); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const signOutUser = async (): Promise<AuthOperationResult> => { const startTime = Date.now(); try { const currentUser = auth.currentUser; debugLog("Sign out attempt", { uid: currentUser?.uid }); await signOut(auth); debugLog("Sign out successful"); const result = createOperationResult( true, undefined, undefined, "Logout effettuato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Sign out failed", error); const authError = convertAuthError(error as FirebaseAuthError, "sign-out"); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const resetPassword = async ( input: ResetPasswordInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { debugLog("Password reset attempt", { email: input.email }); await sendPasswordResetEmail(auth, input.email); debugLog("Password reset email sent"); const result = createOperationResult( true, undefined, undefined, "Email di reset password inviata" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Password reset failed", error); const authError = convertAuthError( error as FirebaseAuthError, "password-reset" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const updateAuthProfile = async ( input: UpdateProfileInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { const currentUser = auth.currentUser; if (!currentUser) { throw new Error("User not authenticated"); } debugLog("Profile update attempt", { uid: currentUser.uid }); const updateData: { displayName?: string; photoURL?: string } = {}; if (input.displayName !== undefined) { updateData.displayName = input.displayName; } if (input.photoURL !== undefined) { updateData.photoURL = input.photoURL; } if (Object.keys(updateData).length > 0) { await updateProfile(currentUser, updateData); } const authUser = convertFirebaseUser(currentUser); debugLog("Profile update successful"); const result = createOperationResult( true, authUser, undefined, "Profilo aggiornato con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Profile update failed", error); const authError = convertAuthError( error as FirebaseAuthError, "profile-update" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const updateUserPassword = async ( input: UpdatePasswordInput ): Promise<AuthOperationResult> => { const startTime = Date.now(); try { const currentUser = auth.currentUser; if (!currentUser || !currentUser.email) { throw new Error("User not authenticated or email missing"); } debugLog("Password update attempt"); const credential = EmailAuthProvider.credential( currentUser.email, input.currentPassword ); await reauthenticateWithCredential(currentUser, credential); await updatePassword(currentUser, input.newPassword); debugLog("Password update successful"); const result = createOperationResult( true, convertFirebaseUser(currentUser), undefined, "Password aggiornata con successo" ); result.metadata.duration = Date.now() - startTime; return result; } catch (error) { debugLog("Password update failed", error); const authError = convertAuthError( error as FirebaseAuthError, "password-update" ); const result = createOperationResult(false, undefined, authError); result.metadata.duration = Date.now() - startTime; return result; } }; export const getCurrentAuthUser = (): AuthUser | null => { const currentUser = auth.currentUser; return currentUser ? convertFirebaseUser(currentUser) : null; }; export const getCurrentUser = (): User | null => { const authUser = getCurrentAuthUser(); return authUser ? convertToUserEntity(authUser) : null; }; export const isAuthenticated = (): boolean => { return !!auth.currentUser; }; export const waitForAuthReady = (): Promise<AuthUser | null> => { return new Promise((resolve) => { const unsubscribe = onAuthStateChanged(auth, (user) => { unsubscribe(); resolve(user ? convertFirebaseUser(user) : null); }); }); }; export const createUserSession = (authUser: AuthUser): AuthSession => { const session: AuthSession = { sessionId: `session_${authUser.uid}_${Date.now()}`, startedAt: new Date(), lastActivityAt: new Date(), duration: 0, deviceInfo: { type: /Mobile|Android|iPhone|iPad/.test(navigator.userAgent) ? "mobile" : "desktop", os: navigator.platform, browser: navigator.userAgent .split(" ") .find((part) => part.includes("/")) ?.split("/")[0] || "unknown", browserVersion: navigator.userAgent .split(" ") .find((part) => part.includes("/")) ?.split("/")[1] || "unknown", timezone: Intl.DateTimeFormat().resolvedOptions().timeZone, language: navigator.language, }, isActive: true, }; debugLog("Session created", { sessionId: session.sessionId }); return session; }; export const updateSessionActivity = (session: AuthSession): AuthSession => { const updatedSession = { ...session, lastActivityAt: new Date(), duration: Date.now() - session.startedAt.getTime(), }; if (AUTH_SERVICE_CONFIG.enableSessionTracking) { debugLog("Session activity updated", { sessionId: session.sessionId }); } return updatedSession; }; export const validateSession = (session: AuthSession): boolean => { const now = Date.now(); const sessionAge = now - session.startedAt.getTime(); const inactivityTime = now - session.lastActivityAt.getTime(); if (sessionAge > AUTH_SERVICE_CONFIG.sessionTimeout) { debugLog("Session expired (timeout)", { sessionId: session.sessionId }); return false; } if (inactivityTime > AUTH_SERVICE_CONFIG.inactivityTimeout) { debugLog("Session expired (inactivity)", { sessionId: session.sessionId }); return false; } return true; }; export const onAuthStateChange = ( callback: (user: User | null) => void ): (() => void) => { debugLog("Setting up auth state listener"); const unsubscribe = onAuthStateChanged( auth, (firebaseUser) => { const user = firebaseUser ? convertToUserEntity(convertFirebaseUser(firebaseUser)) : null; debugLog("Auth state changed", { uid: user?.id || "null", authenticated: !!user, }); callback(user); }, (error) => { debugLog("Auth state error", error); callback(null); } ); return () => { debugLog("Auth state listener cleaned up"); unsubscribe(); }; }; export const getAuthServiceStatus = () => { const currentUser = getCurrentAuthUser(); return { isReady: true, currentUser: currentUser ? { uid: currentUser.uid, email: currentUser.email, emailVerified: currentUser.emailVerified, } : null, config: AUTH_SERVICE_CONFIG, timestamp: new Date().toISOString(), }; }; export const validateEmail = (email: string): boolean => { const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; return emailRegex.test(email); }; export const validatePassword = ( password: string ): { isValid: boolean; errors: string[]; } => { const errors: string[] = []; if (password.length < 6) { errors.push("Password deve essere di almeno 6 caratteri"); } if (!/[A-Z]/.test(password)) { errors.push("Password deve contenere almeno una lettera maiuscola"); } if (!/[a-z]/.test(password)) { errors.push("Password deve contenere almeno una lettera minuscola"); } if (!/\d/.test(password)) { errors.push("Password deve contenere almeno un numero"); } return { isValid: errors.length === 0, errors, }; };

================================================================================

NOME FILE: enhancedAIService.js

import AppConfig, { isAIAvailable } from "../config/appConfig"; import { WORD_CATEGORIES } from "../types/entities/Word.types"; import { withTimeout, globalOperationManager } from "../utils/retryUtils"; class EnhancedAIService { constructor() { this.config = AppConfig.ai; this.isConfigured = !!this.config.apiKey; this.canUseAI = isAIAvailable(); this.lastSuccessTime = null; this.consecutiveFailures = 0; this.healthStatus = "unknown"; this.lastHealthCheck = null; this.initializeService(); } initializeService() { if (!this.isConfigured) { this.healthStatus = "down"; } else { this.healthStatus = "healthy"; } if (AppConfig.app.environment === "development") { console.log("🤖 Enhanced AI Service Status (NO AUTO-PING):", { configured: this.isConfigured, canUseAI: this.canUseAI, apiKeyPresent: !!this.config.apiKey, healthStatus: this.healthStatus, }); } } checkHealthPassive() { if (!this.isConfigured) { this.healthStatus = "down"; this.lastHealthCheck = Date.now(); return false; } const now = Date.now(); const fiveMinutesAgo = now - 5 * 60 * 1000; if (this.lastSuccessTime && this.lastSuccessTime > fiveMinutesAgo) { this.healthStatus = "healthy"; this.lastHealthCheck = now; return true; } if (this.consecutiveFailures > 3) { this.healthStatus = "down"; } else if (this.consecutiveFailures > 1) { this.healthStatus = "degraded"; } else { this.healthStatus = "healthy"; } this.lastHealthCheck = now; return this.healthStatus === "healthy"; } async checkHealthManual() { if (!this.isConfigured) { this.healthStatus = "down"; this.lastHealthCheck = Date.now(); return false; } try { console.log("🔍 Manual AI health check (COSTS MONEY)..."); const response = await withTimeout( () => fetch(this.getApiUrl(), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }], }), }), 8000 ); const isHealthy = response.ok || response.status === 400; if (isHealthy) { this.healthStatus = "healthy"; this.consecutiveFailures = 0; this.lastSuccessTime = Date.now(); console.log("✅ AI service manually verified as healthy"); } else { this.consecutiveFailures++; this.healthStatus = this.consecutiveFailures > 2 ? "down" : "degraded"; console.log( "⚠️ AI service manually verified as degraded:", response.status ); } this.lastHealthCheck = Date.now(); return isHealthy; } catch (error) { this.consecutiveFailures++; if (error.message.includes("timeout")) { this.healthStatus = "degraded"; console.log("⏱️ AI service manual timeout"); } else if ( error.message.includes("fetch") || error.message.includes("network") ) { this.healthStatus = this.consecutiveFailures > 2 ? "down" : "degraded"; console.log("📡 AI service manual network error"); } else { this.healthStatus = this.consecutiveFailures > 3 ? "down" : "degraded"; console.log("❌ AI service manual error:", error.message); } this.lastHealthCheck = Date.now(); return false; } } async analyzeWord(englishWord) { if (!englishWord || typeof englishWord !== "string") { throw new Error("Valid English word is required"); } const trimmedWord = englishWord.trim(); if (!trimmedWord) { throw new Error("English word cannot be empty"); } if (!this.isConfigured) { throw new Error( "AI service not configured. Add REACT_APP_GEMINI_API_KEY to .env.local" ); } try { const result = await globalOperationManager.execute( "aiAnalysis", async () => await this.performAnalysis(trimmedWord) ); this.consecutiveFailures = 0; this.lastSuccessTime = Date.now(); this.healthStatus = "healthy"; console.log("✅ AI analysis successful - health updated"); return result; } catch (error) { this.consecutiveFailures++; if (error.message.includes("API key") || error.message.includes("401")) { this.healthStatus = "down"; throw new Error("🔑 API key non valida. Verifica configurazione."); } else if ( error.message.includes("quota") || error.message.includes("limit") ) { this.healthStatus = "down"; throw new Error("🚫 Limite API raggiunto. Riprova più tardi."); } else if (error.message.includes("timeout")) { this.healthStatus = "degraded"; throw new Error("⏱️ AI timeout. Connessione lenta."); } else if (error.message.includes("Circuit breaker")) { this.healthStatus = "down"; throw new Error("🔴 AI temporaneamente non disponibile."); } else { this.healthStatus = this.consecutiveFailures > 2 ? "down" : "degraded"; console.log( `❌ AI analysis failed - health updated to ${this.healthStatus}` ); throw new Error(`🤖 Errore AI: ${error.message}`); } } } async analyzeWordWithFallback(englishWord) { try { return await this.analyzeWord(englishWord); } catch (error) { console.warn("🤖 AI analysis failed, providing fallback:", error.message); return { italian: "", group: this.categorizeWordFallback(englishWord), sentence: "", notes: `🤖 AI non disponibile: ${error.message}. Completa manualmente.`, chapter: "", _aiError: true, _fallbackUsed: true, }; } } async performAnalysis(word) { const prompt = this.buildPrompt(word); const apiResponse = await this.makeRequest(prompt); const content = apiResponse.candidates[0].content.parts[0].text; return this.parseAIResponse(content, word); } async makeRequest(prompt) { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), this.config.timeout); try { const response = await fetch(this.getApiUrl(), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], }), signal: controller.signal, }); clearTimeout(timeoutId); if (!response.ok) { const errorText = await response.text(); if (response.status === 401) { throw new Error("API key non valida"); } else if (response.status === 403) { throw new Error("Accesso negato API"); } else if (response.status === 429) { throw new Error("Troppi richieste"); } else if (response.status === 400) { throw new Error("Richiesta non valida"); } else if (response.status >= 500) { throw new Error("Errore server Gemini"); } else { throw new Error(`API Error ${response.status}: ${errorText}`); } } const data = await response.json(); if (!data.candidates?.[0]?.content?.parts?.[0]?.text) { throw new Error("Risposta API non valida"); } return data; } catch (error) { clearTimeout(timeoutId); if (error.name === "AbortError") { throw new Error("Request timeout"); } if ( error.message.includes("fetch") || error.message.includes("network") ) { throw new Error("Errore di rete"); } throw error; } } parseAIResponse(content, fallbackWord) { try { const jsonMatch = content.match(/\{[\s\S]*\}/); if (!jsonMatch) { return this.createFallbackResponse(fallbackWord, "No JSON in response"); } const parsedData = JSON.parse(jsonMatch[0]); return this.validateAndSanitizeResponse(parsedData, fallbackWord); } catch (parseError) { return this.createFallbackResponse(fallbackWord, "JSON parsing failed"); } } validateAndSanitizeResponse(data, fallbackWord) { const result = { italian: "", group: "", sentence: "", notes: "", chapter: "", }; if ( !data.italian || typeof data.italian !== "string" || !data.italian.trim() ) { return this.createFallbackResponse(fallbackWord, "Missing translation"); } result.italian = data.italian.trim(); if (data.group && WORD_CATEGORIES.includes(data.group)) { result.group = data.group; } else { result.group = this.categorizeWordFallback(fallbackWord); } result.sentence = data.sentence && typeof data.sentence === "string" ? data.sentence.trim() : ""; result.notes = data.notes && typeof data.notes === "string" ? data.notes.trim() : ""; result.chapter = ""; return result; } createFallbackResponse(word, reason) { return { italian: "", group: this.categorizeWordFallback(word), sentence: "", notes: `❌ AI analysis failed: ${reason}. Fill manually.`, chapter: "", }; } buildPrompt(englishWord) { const groupsList = WORD_CATEGORIES.join(", "); return ` Analizza la parola inglese "${englishWord}" e fornisci JSON: { "italian": "traduzione principale italiana", "group": "DEVE essere una di: ${groupsList}", "sentence": "frase d'esempio inglese", "notes": "note aggiuntive, sinonimi, forme irregolari", "chapter": "lascia vuoto" } REGOLE: - Solo JSON valido - "group" deve essere esatto da lista - Per verbi irregolari usa "VERBI_IRREGOLARI" - Includi 2-3 significati nelle note - "chapter" sempre vuoto ESEMPI: - "run" → "VERBI_IRREGOLARI" - "beautiful" → "AGGETTIVI" - "computer" → "TECNOLOGIA" `; } categorizeWordFallback(word) { const wordLower = word.toLowerCase(); if ( wordLower.match( /^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/ ) ) { return "VERBI"; } if ( wordLower.match( /^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/ ) ) { return "VERBI_IRREGOLARI"; } if ( wordLower.match( /^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/ ) || wordLower.match( /^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/ ) ) { return "AGGETTIVI"; } if ( wordLower.match( /^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/ ) ) { return "TECNOLOGIA"; } if ( wordLower.match( /^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/ ) ) { return "FAMIGLIA"; } if ( wordLower.match( /^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/ ) ) { return "EMOZIONI_POSITIVE"; } if ( wordLower.match( /^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/ ) ) { return "EMOZIONI_NEGATIVE"; } if ( wordLower.match( /^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/ ) ) { return "LAVORO"; } if ( wordLower.match( /^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/ ) ) { return "VESTITI"; } return "SOSTANTIVI"; } getApiUrl() { if (!this.config.apiKey) { throw new Error("API key non configurata"); } return `${this.config.baseUrl}?key=${this.config.apiKey}`; } getServiceStatus() { const circuitBreakerStatus = globalOperationManager.getOperationStatus("aiAnalysis"); return { configured: this.isConfigured, health: this.healthStatus, consecutiveFailures: this.consecutiveFailures, lastSuccessTime: this.lastSuccessTime, lastHealthCheck: this.lastHealthCheck, circuitBreaker: circuitBreakerStatus?.circuitBreaker, apiUrl: this.config.baseUrl, timeout: this.config.timeout, canUseAI: this.canUseAI, degradedMode: this.healthStatus === "degraded", recommendations: this.getRecommendations(), }; } getRecommendations() { const recommendations = []; if (!this.isConfigured) { recommendations.push("🔑 Configurare API key in .env.local"); } if (this.healthStatus === "down") { recommendations.push("🔴 Servizio non disponibile. Usa modalità manuale"); } if (this.healthStatus === "degraded") { recommendations.push("🟡 Servizio instabile. Verifica connessione"); } if (this.consecutiveFailures > 2) { recommendations.push( "⚠️ Molti errori consecutivi. Controlla configurazione" ); } return recommendations; } quickCategorize(englishWord) { if (!englishWord || typeof englishWord !== "string") { return "SOSTANTIVI"; } return this.categorizeWordFallback(englishWord.trim()); } async checkHealth() { return await this.checkHealthManual(); } isAvailable() { return this.checkHealthPassive(); } getStatus() { return this.getServiceStatus(); } } const enhancedAIService = new EnhancedAIService(); export { enhancedAIService }; const enhancedAIServiceExport = { enhancedAIService }; export default enhancedAIServiceExport;

================================================================================

NOME FILE: enhancedStorageService.js

import { STORAGE_CONFIG } from '../constants/appConstants'; import { smartRetryStorage, globalOperationManager } from '../utils/retryUtils'; class EnhancedStorageService { constructor() { this.isAvailable = this.checkStorageAvailability(); this.keys = STORAGE_CONFIG.keys; this.operationQueue = []; this.isProcessingQueue = false; this.healthStatus = 'unknown'; this.quotaWarningThreshold = 0.85; this.lastHealthCheck = null; this.initializeService(); } initializeService() { this.healthStatus = this.isAvailable ? 'healthy' : 'down'; this.setupPeriodicHealthCheck(); this.setupQuotaMonitoring(); } checkStorageAvailability() { try { const test = '__enhanced_storage_test__'; localStorage.setItem(test, 'test'); localStorage.removeItem(test); return true; } catch (error) { console.error('❌ Storage not available:', error.message); return false; } } setupPeriodicHealthCheck() { setInterval(() => { this.performHealthCheck(); }, 30000); } setupQuotaMonitoring() { setInterval(() => { this.checkQuotaUsage(); }, 60000); } async performHealthCheck() { try { const testKey = '__health_check__'; const testData = { timestamp: Date.now() }; await this.executeStorageOperation( () => { localStorage.setItem(testKey, JSON.stringify(testData)); const retrieved = JSON.parse(localStorage.getItem(testKey)); localStorage.removeItem(testKey); if (retrieved.timestamp !== testData.timestamp) { throw new Error('Data integrity check failed'); } }, 'Health Check' ); this.healthStatus = 'healthy'; this.lastHealthCheck = Date.now(); } catch (error) { this.healthStatus = error.message.includes('quota') ? 'quota_exceeded' : 'degraded'; } } checkQuotaUsage() { try { const usage = this.getUsageStats(); const usagePercentage = parseFloat(usage.usagePercentage); if (usagePercentage > this.quotaWarningThreshold * 100) { console.warn(`⚠️ Storage quota warning: ${usagePercentage}% used`); if (usagePercentage > 95) { this.healthStatus = 'quota_exceeded'; this.performAutomaticCleanup(); } } } catch (error) { console.error('❌ Quota check failed:', error); } } async get(key, defaultValue = null) { if (!this.isAvailable) { return defaultValue; } try { return await this.executeStorageOperation( () => { const item = localStorage.getItem(key); if (item === null) { return defaultValue; } try { return JSON.parse(item); } catch (parseError) { console.warn(`❌ Parse error for key "${key}", returning as string`); return item; } }, `Get ${key}` ); } catch (error) { console.error(`❌ Failed to get "${key}":`, error.message); return defaultValue; } } async set(key, value) { if (!this.isAvailable) { return false; } try { return await this.executeStorageOperation( () => { const serializedValue = JSON.stringify(value); const estimatedSize = (key.length + serializedValue.length) * 2; const currentUsage = this.getUsageStats(); if (currentUsage.available < estimatedSize) { throw new Error('QuotaExceededError: Not enough space'); } localStorage.setItem(key, serializedValue); return true; }, `Set ${key}` ); } catch (error) { if (error.message.includes('quota') || error.name === 'QuotaExceededError') { const cleanupSuccess = await this.performAutomaticCleanup(); if (cleanupSuccess) { try { const serializedValue = JSON.stringify(value); localStorage.setItem(key, serializedValue); return true; } catch (retryError) { console.error(`❌ Failed to set "${key}" after cleanup:`, retryError.message); return false; } } } console.error(`❌ Failed to set "${key}":`, error.message); return false; } } async executeStorageOperation(operation, operationName) { return await globalOperationManager.execute( 'storageOperation', operation ); } async performAutomaticCleanup() { try { let cleanedSpace = 0; const tempKeys = this.getKeysMatching('^(temp_|cache_|backup_)'); for (const key of tempKeys) { const size = this.getItemSize(key); localStorage.removeItem(key); cleanedSpace += size; } const testHistory = await this.get(this.keys.testHistory, []); if (testHistory.length > 50) { const trimmedHistory = testHistory.slice(0, 50); await this.set(this.keys.testHistory, trimmedHistory); cleanedSpace += this.getItemSize(this.keys.testHistory) * 0.5; } await this.compressWordPerformanceData(); console.log(`🧹 Automatic cleanup freed ~${Math.round(cleanedSpace / 1024)}KB`); return cleanedSpace > 0; } catch (error) { console.error('❌ Automatic cleanup failed:', error); return false; } } async compressWordPerformanceData() { try { const wordPerformance = await this.get('wordPerformance', {}); let compressed = false; Object.keys(wordPerformance).forEach(wordId => { const data = wordPerformance[wordId]; if (data.attempts && data.attempts.length > 20) { data.attempts = data.attempts.slice(-20); compressed = true; } }); if (compressed) { await this.set('wordPerformance', wordPerformance); console.log('📊 Word performance data compressed'); } } catch (error) { console.error('❌ Failed to compress word performance data:', error); } } getItemSize(key) { try { const value = localStorage.getItem(key); return value ? (key.length + value.length) * 2 : 0; } catch (error) { return 0; } } getUsageStats() { if (!this.isAvailable) { return { used: 0, available: 0, total: 0, critical: true }; } try { let used = 0; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); const value = localStorage.getItem(key); used += (key?.length || 0) + (value?.length || 0); } used *= 2; const total = 5 * 1024 * 1024; const available = total - used; const usagePercentage = (used / total) * 100; return { used, available, total, usedMB: (used / 1024 / 1024).toFixed(2), availableMB: (available / 1024 / 1024).toFixed(2), usagePercentage: usagePercentage.toFixed(1), critical: usagePercentage > 90, warning: usagePercentage > 75, healthStatus: this.healthStatus, lastHealthCheck: this.lastHealthCheck }; } catch (error) { return { used: 0, available: 0, total: 0, critical: true, error: error.message }; } } remove(key) { if (!this.isAvailable) return false; try { localStorage.removeItem(key); return true; } catch (error) { return false; } } clear() { if (!this.isAvailable) return false; try { localStorage.clear(); return true; } catch (error) { return false; } } exists(key) { if (!this.isAvailable) return false; return localStorage.getItem(key) !== null; } getKeysMatching(pattern) { if (!this.isAvailable) return []; try { const regex = new RegExp(pattern); const matchingKeys = []; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key && regex.test(key)) { matchingKeys.push(key); } } return matchingKeys; } catch (error) { return []; } } async getWords() { const words = await this.get(this.keys.words, null); if (!words || words.length === 0) { const fallbackKeys = [ 'words', 'vocabularyWords', 'vocabulary_words_v1', 'vocabulary-words', 'app_words', 'vocabWords' ]; for (const key of fallbackKeys) { const fallbackWords = await this.get(key, null); if (fallbackWords && fallbackWords.length > 0) { await this.set(this.keys.words, fallbackWords); return fallbackWords; } } } return words || []; } async saveWords(words) { return await this.set(this.keys.words, words); } async getStats() { return await this.get(this.keys.stats, { testsCompleted: 0, correctAnswers: 0, incorrectAnswers: 0, totalWords: 0, streakDays: 0, lastStudyDate: null, timeSpent: 0, categoriesProgress: {}, hintsUsed: 0 }); } async saveStats(stats) { return await this.set(this.keys.stats, stats); } async getTestHistory() { return await this.get(this.keys.testHistory, []); } async saveTestHistory(history) { return await this.set(this.keys.testHistory, history); } async getSettings() { return await this.get(this.keys.settings, { theme: 'light', notifications: true, autoAdvance: true, soundEnabled: true }); } async saveSettings(settings) { return await this.set(this.keys.settings, settings); } getServiceStatus() { return { available: this.isAvailable, health: this.healthStatus, usage: this.getUsageStats(), lastHealthCheck: this.lastHealthCheck, recommendations: this.getRecommendations() }; } getRecommendations() { const recommendations = []; const usage = this.getUsageStats(); if (!this.isAvailable) { recommendations.push('🔒 Storage non disponibile. Verifica impostazioni browser'); } if (usage.critical) { recommendations.push('💽 Spazio quasi esaurito. Esporta backup ed elimina dati vecchi'); } else if (usage.warning) { recommendations.push('⚠️ Spazio in esaurimento. Considera pulizia dati'); } if (this.healthStatus === 'degraded') { recommendations.push('🟡 Servizio instabile. Esporta backup preventivo'); } return recommendations; } } const enhancedStorageService = new EnhancedStorageService(); export { enhancedStorageService }; export default { enhancedStorageService };

================================================================================

NOME FILE: firestoreService.ts

import { doc, getDoc, setDoc, updateDoc, deleteDoc, collection, getDocs, addDoc, query, where, orderBy, limit, startAfter, onSnapshot, writeBatch, serverTimestamp, Timestamp, enableNetwork, disableNetwork, DocumentReference, CollectionReference, Query, QuerySnapshot, DocumentSnapshot, Unsubscribe, WhereFilterOp, OrderByDirection, FirestoreError as FirebaseFirestoreError, } from "firebase/firestore"; import { db, auth, FIRESTORE_COLLECTIONS } from "../config/firebase"; import type { FirestoreDoc, FirestoreDocMetadata, FirestoreCollection, FirestoreQuery, WhereClause, OrderByClause, FirestoreQueryResult, FirestoreListener, ListenerConfig, FirestoreListenerData, ChangeType, FirestoreError, FirestoreOperationResult, FirestoreBatch, BatchOperation, FirestoreConnectionState, PendingOperation, FirestoreCollectionName, } from "../types/infrastructure/Firestore.types"; const FIRESTORE_SERVICE_CONFIG = { maxRetries: 3, retryDelay: 1000, maxBatchSize: 500, offlineTimeout: 10000, enablePersistence: true, enableDebugLogging: process.env.NODE_ENV === "development", }; const debugLog = (message: string, data?: any) => { if (FIRESTORE_SERVICE_CONFIG.enableDebugLogging) { console.log(`🔥 [FirestoreService] ${message}`, data || ""); } }; const getCurrentUserId = (): string => { const currentUser = auth.currentUser; if (!currentUser) { throw new Error( "User non autenticato. Effettua login prima di accedere ai dati." ); } return currentUser.uid; }; const createFirestoreMetadata = ( existingMetadata?: Partial<FirestoreDocMetadata> ): FirestoreDocMetadata => { const now = new Date(); const userId = getCurrentUserId(); return { userId, createdAt: existingMetadata?.createdAt || now, updatedAt: now, version: (existingMetadata?.version || 0) + 1, deleted: false, lastSyncAt: now, custom: existingMetadata?.custom || {}, ...existingMetadata, }; }; const convertFirebaseError = ( firebaseError: FirebaseFirestoreError, operation: string, path?: string ): FirestoreError => { const getRecoverable = (code: string): boolean => { switch (code) { case "unavailable": case "deadline-exceeded": case "resource-exhausted": case "aborted": return true; case "permission-denied": case "not-found": case "already-exists": return false; default: return false; } }; return { code: firebaseError.code as any, message: firebaseError.message, operation: operation as any, path, recoverable: getRecoverable(firebaseError.code), timestamp: new Date(), }; }; const createUserScopedPath = ( collectionName: FirestoreCollectionName, documentId?: string ): string => { const userId = getCurrentUserId(); const basePath = `${collectionName}/${userId}`; return documentId ? `${basePath}/documents/${documentId}` : `${basePath}/documents`; }; const convertTimestamp = (timestamp: any): Date => { if (timestamp instanceof Timestamp) { return timestamp.toDate(); } if (timestamp instanceof Date) { return timestamp; } if (typeof timestamp === "string") { return new Date(timestamp); } return new Date(); }; const convertDocumentSnapshot = <T>( snapshot: DocumentSnapshot, collectionName: string ): FirestoreDoc<T> | null => { if (!snapshot.exists()) { return null; } const data = snapshot.data(); if (!data) { return null; } const convertedData = { ...data, createdAt: data.createdAt ? convertTimestamp(data.createdAt) : new Date(), updatedAt: data.updatedAt ? convertTimestamp(data.updatedAt) : new Date(), } as T; const metadata: FirestoreDocMetadata = { userId: data.firestoreMetadata?.userId || getCurrentUserId(), createdAt: convertTimestamp( data.firestoreMetadata?.createdAt || data.createdAt ), updatedAt: convertTimestamp( data.firestoreMetadata?.updatedAt || data.updatedAt ), version: data.firestoreMetadata?.version || 1, deleted: data.firestoreMetadata?.deleted || false, lastSyncAt: new Date(), custom: data.firestoreMetadata?.custom || {}, }; return { id: snapshot.id, data: convertedData, metadata, path: snapshot.ref.path, ref: snapshot.ref, }; }; export const createDocument = async <T>( collectionName: FirestoreCollectionName, data: T, customId?: string ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Creating document in ${collectionName}`, { customId, data }); const metadata = createFirestoreMetadata(); const documentData = { ...data, firestoreMetadata: metadata, }; let docRef: DocumentReference; if (customId) { const path = createUserScopedPath(collectionName, customId); docRef = doc(db, path); await setDoc(docRef, documentData); } else { const collectionPath = createUserScopedPath(collectionName); const collectionRef = collection(db, collectionPath); docRef = await addDoc(collectionRef, documentData); } const snapshot = await getDoc(docRef); const createdDoc = convertDocumentSnapshot<T>(snapshot, collectionName); if (!createdDoc) { throw new Error("Documento creato ma non recuperabile"); } debugLog(`Document created successfully`, { id: createdDoc.id }); return { success: true, doc: createdDoc, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Create document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "create", collectionName ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const readDocument = async <T>( collectionName: FirestoreCollectionName, documentId: string ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Reading document ${documentId} from ${collectionName}`); const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); const snapshot = await getDoc(docRef); const document = convertDocumentSnapshot<T>(snapshot, collectionName); if (!document) { debugLog(`Document ${documentId} not found`); return { success: false, error: { code: "not-found", message: `Documento ${documentId} non trovato`, operation: "read", path, recoverable: false, timestamp: new Date(), }, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: snapshot.metadata.fromCache, docsAffected: 0, retryCount: 0, }, }; } debugLog(`Document read successfully`, { id: document.id }); return { success: true, doc: document, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: snapshot.metadata.fromCache, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Read document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "read", `${collectionName}/${documentId}` ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const updateDocument = async <T>( collectionName: FirestoreCollectionName, documentId: string, updates: Partial<T> ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Updating document ${documentId} in ${collectionName}`, updates); const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); const currentDoc = await getDoc(docRef); if (!currentDoc.exists()) { throw new Error(`Document ${documentId} not found in ${collectionName}`); } const currentData = currentDoc.data(); const currentMetadata = currentData.firestoreMetadata || {}; const metadata = createFirestoreMetadata(currentMetadata); const updateData = { ...updates, "firestoreMetadata.updatedAt": serverTimestamp(), "firestoreMetadata.version": metadata.version, "firestoreMetadata.lastSyncAt": serverTimestamp(), }; await updateDoc(docRef, updateData); const updatedDocSnap = await getDoc(docRef); const updatedDoc = convertDocumentSnapshot<T>( updatedDocSnap, collectionName ); if (!updatedDoc) { throw new Error("Documento aggiornato ma non recuperabile"); } debugLog(`Document updated successfully`, { id: updatedDoc.id }); return { success: true, doc: updatedDoc, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Update document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "update", `${collectionName}/${documentId}` ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const deleteDocument = async <T>( collectionName: FirestoreCollectionName, documentId: string, softDelete: boolean = false ): Promise<FirestoreOperationResult<T>> => { const startTime = Date.now(); try { debugLog(`Deleting document ${documentId} from ${collectionName}`, { softDelete, }); const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); if (softDelete) { const updateData = { "firestoreMetadata.deleted": true, "firestoreMetadata.deletedAt": serverTimestamp(), "firestoreMetadata.updatedAt": serverTimestamp(), }; await updateDoc(docRef, updateData); debugLog(`Document soft deleted successfully`); } else { await deleteDoc(docRef); debugLog(`Document hard deleted successfully`); } return { success: true, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 1, retryCount: 0, }, }; } catch (error) { debugLog(`Delete document failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "delete", `${collectionName}/${documentId}` ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const queryCollection = async <T>( collectionName: FirestoreCollectionName, queryConfig: Partial<FirestoreQuery<T>> = {} ): Promise<FirestoreQueryResult<T>> => { const startTime = Date.now(); try { debugLog(`Querying collection ${collectionName}`, queryConfig); const collectionPath = createUserScopedPath(collectionName); let baseQuery: Query = collection(db, collectionPath) as Query; if (queryConfig.where && queryConfig.where.length > 0) { for (const whereClause of queryConfig.where) { baseQuery = query( baseQuery, where( whereClause.field, whereClause.operator as WhereFilterOp, whereClause.value ) ); } } if (queryConfig.orderBy && queryConfig.orderBy.length > 0) { for (const orderClause of queryConfig.orderBy) { baseQuery = query( baseQuery, orderBy(orderClause.field, orderClause.direction as OrderByDirection) ); } } if (queryConfig.limit && queryConfig.limit > 0) { baseQuery = query(baseQuery, limit(queryConfig.limit)); } if (queryConfig.startAfter) { baseQuery = query(baseQuery, startAfter(queryConfig.startAfter)); } const querySnapshot = await getDocs(baseQuery); const docs: FirestoreDoc<T>[] = []; querySnapshot.forEach((doc) => { const converted = convertDocumentSnapshot<T>(doc, collectionName); if (converted) { if (queryConfig.includeDeleted || !converted.metadata.deleted) { docs.push(converted); } } }); debugLog(`Query completed`, { docsFound: docs.length }); return { docs, totalCount: docs.length, query: { collection: collectionName, ...queryConfig, }, queryMetadata: { executionTime: Date.now() - startTime, fromCache: querySnapshot.metadata.fromCache, docsRead: querySnapshot.size, executedAt: new Date(), }, hasMore: docs.length === (queryConfig.limit || 0), nextPageCursor: docs.length > 0 ? docs[docs.length - 1].ref : undefined, }; } catch (error) { debugLog(`Query collection failed`, error); throw convertFirebaseError( error as FirebaseFirestoreError, "query", collectionName ); } }; export const listAllDocuments = async <T>( collectionName: FirestoreCollectionName, includeDeleted: boolean = false ): Promise<FirestoreDoc<T>[]> => { const result = await queryCollection<T>(collectionName, { includeDeleted }); return result.docs; }; export const listenToDocument = <T>( collectionName: FirestoreCollectionName, documentId: string, onDataChange: (doc: FirestoreDoc<T> | null) => void, onError: (error: FirestoreError) => void, config: Partial<ListenerConfig> = {} ): (() => void) => { debugLog(`Setting up document listener`, { collectionName, documentId }); try { const path = createUserScopedPath(collectionName, documentId); const docRef = doc(db, path); const unsubscribe = onSnapshot( docRef, { includeMetadataChanges: config.includeMetadataChanges || false, }, (snapshot) => { try { const document = convertDocumentSnapshot<T>(snapshot, collectionName); onDataChange(document); debugLog(`Document listener data received`, { exists: !!document }); } catch (error) { debugLog(`Document listener conversion error`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", path ) ); } }, (error) => { debugLog(`Document listener error`, error); onError(convertFirebaseError(error, "listen", path)); } ); return unsubscribe; } catch (error) { debugLog(`Failed to setup document listener`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", `${collectionName}/${documentId}` ) ); return () => {}; } }; export const listenToCollection = <T>( collectionName: FirestoreCollectionName, onDataChange: (data: FirestoreListenerData<T>) => void, onError: (error: FirestoreError) => void, queryConfig: Partial<FirestoreQuery<T>> = {}, config: Partial<ListenerConfig> = {} ): (() => void) => { debugLog(`Setting up collection listener`, { collectionName, queryConfig }); try { const collectionPath = createUserScopedPath(collectionName); let baseQuery: Query = collection(db, collectionPath) as Query; if (queryConfig.where && queryConfig.where.length > 0) { for (const whereClause of queryConfig.where) { baseQuery = query( baseQuery, where( whereClause.field, whereClause.operator as WhereFilterOp, whereClause.value ) ); } } if (queryConfig.orderBy && queryConfig.orderBy.length > 0) { for (const orderClause of queryConfig.orderBy) { baseQuery = query( baseQuery, orderBy(orderClause.field, orderClause.direction as OrderByDirection) ); } } if (queryConfig.limit && queryConfig.limit > 0) { baseQuery = query(baseQuery, limit(queryConfig.limit)); } const unsubscribe = onSnapshot( baseQuery, { includeMetadataChanges: config.includeMetadataChanges || false, }, (querySnapshot) => { try { const allDocs: FirestoreDoc<T>[] = []; const changedDocs: FirestoreDoc<T>[] = []; querySnapshot.forEach((docSnapshot) => { const document = convertDocumentSnapshot<T>( docSnapshot, collectionName ); if (document) { if (queryConfig.includeDeleted || !document.metadata.deleted) { allDocs.push(document); } } }); let changeType: ChangeType = "initial-load"; if ( !querySnapshot.metadata.hasPendingWrites && !querySnapshot.metadata.fromCache ) { changeType = "modified"; } const listenerData: FirestoreListenerData<T> = { changeType, changedDocs: changedDocs.length > 0 ? changedDocs : allDocs, currentSnapshot: allDocs, changeMetadata: { fromCache: querySnapshot.metadata.fromCache, hasPendingWrites: querySnapshot.metadata.hasPendingWrites, timestamp: new Date(), source: querySnapshot.metadata.fromCache ? "cache" : "server", }, }; onDataChange(listenerData); debugLog(`Collection listener data received`, { docsCount: allDocs.length, }); } catch (error) { debugLog(`Collection listener conversion error`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", collectionName ) ); } }, (error) => { debugLog(`Collection listener error`, error); onError(convertFirebaseError(error, "listen", collectionName)); } ); return unsubscribe; } catch (error) { debugLog(`Failed to setup collection listener`, error); onError( convertFirebaseError( error as FirebaseFirestoreError, "listen", collectionName ) ); return () => {}; } }; export const batchWrite = async ( operations: BatchOperation[] ): Promise<FirestoreOperationResult<void>> => { const startTime = Date.now(); try { debugLog(`Starting batch write`, { operationsCount: operations.length }); if (operations.length === 0) { throw new Error("Batch vuoto - nessuna operazione da eseguire"); } if (operations.length > FIRESTORE_SERVICE_CONFIG.maxBatchSize) { throw new Error( `Batch troppo grande - max ${FIRESTORE_SERVICE_CONFIG.maxBatchSize} operazioni` ); } const batch = writeBatch(db); for (const operation of operations) { const docRef = doc(db, operation.path); switch (operation.type) { case "create": case "update": if (!operation.data) { throw new Error(`Dati mancanti per operazione ${operation.type}`); } const metadata = createFirestoreMetadata(); const dataWithMetadata = { ...operation.data, firestoreMetadata: metadata, }; if (operation.type === "create") { batch.set(docRef, dataWithMetadata); } else { batch.update(docRef, { ...dataWithMetadata, "firestoreMetadata.updatedAt": serverTimestamp(), }); } break; case "delete": batch.delete(docRef); break; default: throw new Error(`Tipo operazione non supportato: ${operation.type}`); } } await batch.commit(); debugLog(`Batch write completed successfully`); return { success: true, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: operations.length, retryCount: 0, }, }; } catch (error) { debugLog(`Batch write failed`, error); const firestoreError = convertFirebaseError( error as FirebaseFirestoreError, "batch" ); return { success: false, error: firestoreError, operationMetadata: { startedAt: new Date(startTime), completedAt: new Date(), duration: Date.now() - startTime, fromCache: false, docsAffected: 0, retryCount: 0, }, }; } }; export const enableFirestoreNetwork = async (): Promise<boolean> => { try { debugLog("Enabling Firestore network"); await enableNetwork(db); debugLog("Firestore network enabled"); return true; } catch (error) { debugLog("Failed to enable Firestore network", error); return false; } }; export const disableFirestoreNetwork = async (): Promise<boolean> => { try { debugLog("Disabling Firestore network"); await disableNetwork(db); debugLog("Firestore network disabled"); return true; } catch (error) { debugLog("Failed to disable Firestore network", error); return false; } }; export const getConnectionState = (): FirestoreConnectionState => { return { online: navigator.onLine, lastOnlineAt: navigator.onLine ? new Date() : undefined, pendingOperations: [], syncing: false, syncErrors: [], }; }; export const getFirestoreServiceStatus = () => { return { isReady: !!db, currentUser: auth.currentUser?.uid || null, config: FIRESTORE_SERVICE_CONFIG, connection: getConnectionState(), timestamp: new Date().toISOString(), }; };

================================================================================

NOME FILE: jsonService.js

[FILE VUOTO DOPO RIMOZIONE COMMENTI]

================================================================================

NOME FILE: statsAnalyticsService.ts

import type { Statistics, DailyProgressAggregated, MonthlyStatsAggregated, AggregatedCalculatedStatistics, LearningTrendsAnalysis, TrendAnalysis, WeeklyProgressAnalysis, ComprehensiveStatisticsExportData, DataSource, RecommendedAction, MonthlyTrendsAnalysis, StreakAnalysisData, NextSessionPrediction, MasteryTimelinePrediction, } from "../types/entities/Statistics.types"; import type { TestResult, TestSession, TestAnalytics, TestExportData, TestSummary, PerformanceMetrics as TestPerformanceMetrics, TestTimeMetrics, TestProgress, PerformancePatterns, AccuracyPatterns, HintStatistics, CategoryPerformance, ScoreCategory, SpeedTrend, TestConfig, WordSelectionConfig, TimingConfig, UIConfig, ScoringConfig, TestInsight, TestRecommendation, TestFeedback, FinalScore, HintSystemConfig, } from "../types/entities/Test.types"; import type { Word } from "../types/entities/Word.types"; import type { WordPerformance, PerformanceAttempt, WordPerformanceAnalysis, GlobalPerformanceStats, } from "../types/entities/Performance.types"; export class StatsAnalyticsService { calculateSpeedTrend(testHistory: any[]): SpeedTrend { if (testHistory.length < 2) { return { direction: "stable", changePercentage: 0, dataPoints: [], }; } const dataPoints = testHistory.map((test, index) => ({ questionNumber: index + 1, time: test.avgTimePerWord || test.totalTime / Math.max(test.totalWords || 1, 1), })); const firstThird = dataPoints.slice(0, Math.ceil(dataPoints.length * 0.3)); const lastThird = dataPoints.slice(-Math.ceil(dataPoints.length * 0.3)); const firstAvg = firstThird.reduce((sum, point) => sum + point.time, 0) / firstThird.length; const lastAvg = lastThird.reduce((sum, point) => sum + point.time, 0) / lastThird.length; const changePercentage = ((firstAvg - lastAvg) / firstAvg) * 100; let direction: "improving" | "stable" | "declining"; if (changePercentage > 5) direction = "improving"; else if (changePercentage < -5) direction = "declining"; else direction = "stable"; return { direction, changePercentage: Math.round(changePercentage * 100) / 100, dataPoints, }; } calculateTestPerformanceMetrics( correctAnswers: number, totalQuestions: number, testHistory: any[] ): TestPerformanceMetrics { const incorrectAnswers = totalQuestions - correctAnswers; const currentAccuracy = totalQuestions > 0 ? (correctAnswers / totalQuestions) * 100 : 0; let currentStreak = 0; let bestStreak = 0; let tempStreak = 0; for (let i = testHistory.length - 1; i >= 0; i--) { const test = testHistory[i]; const accuracy = test.percentage || 0; if (accuracy >= 70) { tempStreak++; if (i === testHistory.length - 1) { currentStreak = tempStreak; } } else { if (i === testHistory.length - 1) { currentStreak = 0; } tempStreak = 0; } bestStreak = Math.max(bestStreak, tempStreak); } const recentTests = testHistory.slice(-5); const avgHintUsage = recentTests.length > 0 ? recentTests.reduce((sum, test) => sum + (test.hintsUsed || 0), 0) / recentTests.length : 0; const efficiency = Math.max(0, currentAccuracy - avgHintUsage * 2); const currentScore = Math.round( currentAccuracy * 0.6 + efficiency * 0.3 + Math.min(currentStreak * 5, 20) * 0.1 ); return { correctAnswers, currentAccuracy: Math.round(currentAccuracy * 100) / 100, incorrectAnswers, currentStreak, bestStreak, efficiency: Math.round(efficiency * 100) / 100, currentScore, }; } calculateHintStatistics( testHistory: any[], totalTime: number ): HintStatistics { if (testHistory.length === 0) { return { usage: { sentence: 0, synonym: 0, }, accuracyAfterHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithHint: { sentence: 0, synonym: 0, overall: 0, }, averageTimeWithoutHint: totalTime, }; } const totalHints = testHistory.reduce( (sum, test) => sum + (test.hintsUsed || 0), 0 ); const totalQuestions = testHistory.reduce( (sum, test) => sum + (test.totalWords || 0), 0 ); const sentenceHints = Math.ceil(totalHints * 0.6); const synonymHints = totalHints - sentenceHints; const testsWithHints = testHistory.filter( (test) => (test.hintsUsed || 0) > 0 ); const accuracyAfterHint = testsWithHints.length > 0 ? testsWithHints.reduce( (sum, test) => sum + (test.percentage || 0), 0 ) / testsWithHints.length : 0; const testsWithoutHints = testHistory.filter( (test) => (test.hintsUsed || 0) === 0 ); const averageTimeWithoutHint = testsWithoutHints.length > 0 ? testsWithoutHints.reduce( (sum, test) => sum + (test.totalTime || 0), 0 ) / testsWithoutHints.length : totalTime; const averageTimeWithHint = testsWithHints.length > 0 ? testsWithHints.reduce((sum, test) => sum + (test.totalTime || 0), 0) / testsWithHints.length : totalTime; return { usage: { sentence: sentenceHints, synonym: synonymHints, }, accuracyAfterHint: { sentence: accuracyAfterHint, synonym: accuracyAfterHint * 0.8, overall: accuracyAfterHint, }, averageTimeWithHint: { sentence: averageTimeWithHint, synonym: averageTimeWithHint * 1.2, overall: averageTimeWithHint, }, averageTimeWithoutHint, }; } generateTestConfig(): TestConfig { return { mode: "normal", hints: { enabled: true, maxHintsPerQuestion: 2, cooldownBetweenHints: 0, availableHintTypes: ["sentence", "synonym"], hintCosts: { sentence: 1, synonym: 1, }, } as HintSystemConfig, wordSelection: { strategy: "random", maxWords: 10, excludeLearned: false, prioritizeDifficult: false, categories: [], chapters: [], unlearnedOnly: false, difficultOnly: false, randomOrder: true, selectionStrategy: "random", } as WordSelectionConfig, timing: { enableTimer: false, warningThreshold: 30, autoAdvance: false, maxTimePerQuestion: null, showTimer: false, autoAdvanceDelay: 1000, showMeaning: false, meaningDisplayDuration: 2000, wordTimeLimit: 30000, } as TimingConfig, ui: { theme: "light" as const, animations: true, showDetailedProgress: true, sounds: false, showRealTimeStats: true, } as UIConfig, scoring: { correctPoints: 10, incorrectPenalty: 0, hintPenalty: 2, timeBonusEnabled: false, accuracyWeight: 0.7, speedWeight: 0.3, streakBonus: 0.1, thresholds: { excellent: 90, good: 80, average: 70, poor: 0, }, } as ScoringConfig, }; } calculateTestTimeMetrics(testHistory: any[]): TestTimeMetrics { if (testHistory.length === 0) { return { totalTestTime: 0, averageQuestionTime: 0, fastestQuestion: 0, slowestQuestion: 0, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: 0, p50: 0, p75: 0, p90: 0, }, }, speedTrend: { direction: "stable", changePercentage: 0, dataPoints: [], }, }; } const totalTime = testHistory.reduce( (sum, test) => sum + (test.totalTime || 0), 0 ); const totalQuestions = testHistory.reduce( (sum, test) => sum + (test.totalWords || 0), 0 ); const averageQuestionTime = totalQuestions > 0 ? totalTime / totalQuestions : 0; const allTimes = testHistory.flatMap((test) => Array(test.totalWords || 0).fill( (test.totalTime || 0) / Math.max(test.totalWords || 1, 1) ) ); const fastestQuestion = allTimes.length > 0 ? Math.min(...allTimes) : 0; const slowestQuestion = allTimes.length > 0 ? Math.max(...allTimes) : 0; allTimes.sort((a, b) => a - b); const len = allTimes.length; return { totalTestTime: totalTime, averageQuestionTime, fastestQuestion, slowestQuestion, timeDistribution: { byCategory: {}, byDifficulty: {}, percentiles: { p25: len > 0 ? allTimes[Math.floor(len * 0.25)] : 0, p50: len > 0 ? allTimes[Math.floor(len * 0.5)] : 0, p75: len > 0 ? allTimes[Math.floor(len * 0.75)] : 0, p90: len > 0 ? allTimes[Math.floor(len * 0.9)] : 0, }, }, speedTrend: this.calculateSpeedTrend(testHistory), }; } generateTestProgress(performance: TestPerformanceMetrics): TestProgress { return { basic: { questionsAnswered: performance.correctAnswers + performance.incorrectAnswers, questionsRemaining: 0, currentQuestion: performance.correctAnswers + performance.incorrectAnswers, totalQuestions: performance.correctAnswers + performance.incorrectAnswers, completionPercentage: 100, }, performance, predictions: { predictedFinalAccuracy: performance.currentAccuracy, confidence: 0.8, estimatedTimeToCompletion: 0, predictedFinalScore: performance.currentScore, }, milestones: [], }; } generateFinalScore(performance: TestPerformanceMetrics): FinalScore { const category: ScoreCategory = performance.currentScore >= 90 ? "excellent" : performance.currentScore >= 80 ? "good" : performance.currentScore >= 70 ? "average" : "poor"; return { total: performance.currentScore, category, breakdown: { accuracy: performance.currentAccuracy, speed: 50, efficiency: performance.efficiency, consistency: 50, bonus: 0, penalties: 0, }, }; } generateTestFeedback(performance: TestPerformanceMetrics): TestFeedback { return { tone: performance.currentScore >= 80 ? "celebratory" : "encouraging", color: performance.currentScore >= 80 ? "#22c55e" : "#3b82f6", wordsToReview: [], message: "Great job!", icon: "check", nextGoals: ["Keep practicing", "Review difficult words"], }; } private generateRecommendations( accuracy: number, hints: number ): TestRecommendation[] { const recommendations: TestRecommendation[] = []; if (accuracy < 70) { recommendations.push({ type: "practice", priority: "high", title: "Focus on Vocabulary Review", description: "Spend more time reviewing missed words and their meanings", expectedBenefit: "Improved accuracy in future tests", effort: "medium", }); } if (hints > 5) { recommendations.push({ type: "practice", priority: "medium", title: "Practice Without Hints", description: "Try completing tests without using hints to build confidence", expectedBenefit: "Increased self-reliance and faster response times", effort: "easy", }); } return recommendations; } private generateStrengths(accuracy: number, hints: number): string[] { const strengths: string[] = []; if (accuracy >= 80) strengths.push("High accuracy rate"); if (hints <= 2) strengths.push("Minimal hint usage"); if (accuracy >= 90 && hints <= 1) strengths.push("Excellent independent performance"); return strengths; } private generateImprovements(accuracy: number, hints: number): string[] { const improvements: string[] = []; if (accuracy < 70) improvements.push("Focus on vocabulary retention"); if (hints > 5) improvements.push("Reduce dependency on hints"); if (accuracy < 80) improvements.push("Practice more challenging words"); return improvements; } private generateNextSteps(accuracy: number, hints: number): string[] { const nextSteps: string[] = []; if (accuracy < 70) { nextSteps.push("Review incorrect words"); nextSteps.push("Practice with similar difficulty level"); } else if (accuracy >= 90) { nextSteps.push("Try more challenging vocabulary"); nextSteps.push("Increase test length"); } else { nextSteps.push("Focus on consistency"); nextSteps.push("Practice speed and accuracy"); } return nextSteps; } calculateAggregatedStatistics( currentStats: Statistics, testHistory: any[], wordPerformanceAnalyses: WordPerformanceAnalysis[] ): AggregatedCalculatedStatistics { const baseStats: Statistics = { ...currentStats, }; const globalPerformanceStats: GlobalPerformanceStats = { statusDistribution: { new: 0, promising: 0, struggling: wordPerformanceAnalyses.filter( (w) => w.status === "struggling" ).length, consolidated: wordPerformanceAnalyses.filter( (w) => w.status === "consolidated" ).length, improving: wordPerformanceAnalyses.filter( (w) => w.status === "improving" ).length, critical: 0, inconsistent: 0, }, totalWordsTracked: wordPerformanceAnalyses.length, averageResponseTime: wordPerformanceAnalyses.reduce((sum, w) => sum + w.avgTime * 1000, 0) / Math.max(wordPerformanceAnalyses.length, 1), averageAccuracy: wordPerformanceAnalyses.reduce((sum, w) => sum + w.accuracy, 0) / Math.max(wordPerformanceAnalyses.length, 1), averageHintUsage: wordPerformanceAnalyses.reduce((sum, w) => sum + w.hintsPercentage, 0) / Math.max(wordPerformanceAnalyses.length, 1), wordsNeedingWork: wordPerformanceAnalyses.filter( (w) => w.status === "struggling" || w.status === "critical" ).length, masteredWords: wordPerformanceAnalyses.filter((w) => w.mastered).length, }; const learningTrends: LearningTrendsAnalysis = this.calculateLearningTrends(testHistory); const weeklyTrends: WeeklyProgressAnalysis = this.calculateWeeklyProgress( currentStats.dailyProgress || {} ); const monthlyTrends: MonthlyTrendsAnalysis = { last3Months: [], trendDirection: "stable", keyMetricChanges: { accuracyChange: 0, vocabularyGrowthChange: 0, consistencyChange: 0, }, seasonalPatterns: [], }; const streakAnalysis: StreakAnalysisData = { currentStreak: currentStats.streakDays || 0, longestStreak: currentStats.streakDays || 0, streakBreakingPatterns: [], streakMotivation: [], }; const nextSessionPredictions: NextSessionPrediction = { optimalTime: new Date(), suggestedDuration: 10, recommendedWords: [], predictedAccuracy: 75, challengeLevel: "medium", focusAreas: { reviewWords: [], newWords: [], masteryWords: [], }, }; const masteryTimeline: MasteryTimelinePrediction = { totalWordsToMaster: 100, currentMasteryRate: 0.1, estimatedTimeToComplete: 30, milestones: [], accelerationOpportunities: [], }; return { baseStats, performanceAnalytics: { globalPerformanceStats, wordLevelInsights: wordPerformanceAnalyses.slice(0, 10), learningTrends, }, temporalAnalytics: { weeklyProgress: weeklyTrends, monthlyTrends, streakAnalysis, }, predictiveAnalytics: { nextSessionPredictions, masteryTimeline, recommendedActions: [], }, aggregationMetadata: { lastCalculated: new Date(), dataSourcesIncluded: [ { type: "test-results", recordCount: testHistory.length, dateRange: { start: new Date(), end: new Date() }, completeness: 100, lastUpdated: new Date(), } as DataSource, { type: "word-performance", recordCount: wordPerformanceAnalyses.length, dateRange: { start: new Date(), end: new Date() }, completeness: 100, lastUpdated: new Date(), } as DataSource, { type: "words", recordCount: 0, dateRange: { start: new Date(), end: new Date() }, completeness: 100, lastUpdated: new Date(), } as DataSource, ], calculationDuration: 100, isMigrated: currentStats.migrated || false, isProcessing: false, forceUpdate: 0, }, }; } private createTrend( direction: "improving" | "stable" | "declining" ): TrendAnalysis { return { direction, rate: 0, confidence: 0.8, periodAnalyzed: 30, significantChanges: [], }; } private calculateLearningTrends(testHistory: any[]): LearningTrendsAnalysis { if (testHistory.length < 2) { return { accuracyTrend: this.createTrend("stable"), speedTrend: this.createTrend("stable"), vocabularyGrowthTrend: this.createTrend("stable"), consistencyTrend: this.createTrend("stable"), difficultyHandlingTrend: this.createTrend("stable"), }; } const recent = testHistory.slice(-5); const older = testHistory.slice(0, 5); const recentAccuracy = recent.reduce((sum, test) => sum + (test.percentage || 0), 0) / recent.length; const olderAccuracy = older.reduce((sum, test) => sum + (test.percentage || 0), 0) / older.length; const accuracyChange = recentAccuracy - olderAccuracy; return { accuracyTrend: this.createTrend( accuracyChange > 5 ? "improving" : accuracyChange < -5 ? "declining" : "stable" ), speedTrend: this.createTrend("stable"), vocabularyGrowthTrend: this.createTrend( testHistory.length > 5 ? "improving" : "stable" ), consistencyTrend: this.createTrend("stable"), difficultyHandlingTrend: this.createTrend("stable"), }; } private calculateWeeklyProgress( dailyProgress: Record<string, DailyProgressAggregated> ): WeeklyProgressAnalysis { const today = new Date(); const currentWeek: DailyProgressAggregated[] = []; const previousWeek: DailyProgressAggregated[] = []; for (let i = 0; i < 7; i++) { const date = new Date(today); date.setDate(today.getDate() - i); const dateStr = date.toISOString().split("T")[0]; const dayProgress = dailyProgress[dateStr] || this.createEmptyDayProgress(dateStr); currentWeek.push(dayProgress); const prevDate = new Date(date); prevDate.setDate(date.getDate() - 7); const prevDateStr = prevDate.toISOString().split("T")[0]; const prevDayProgress = dailyProgress[prevDateStr] || this.createEmptyDayProgress(prevDateStr); previousWeek.push(prevDayProgress); } return { currentWeek, previousWeek, weekOverWeekChange: { testsChange: 0, accuracyChange: 0, timeChange: 0, wordsStudiedChange: 0, }, weeklyConsistency: 0, recommendedSchedule: [], }; } private createEmptyDayProgress(date: string): DailyProgressAggregated { return { date, testActivity: { testsCompleted: 0, averageScore: 0, totalTime: 0, averageAccuracy: 0, hintsUsed: 0, }, wordActivity: { wordsStudied: 0, newWordsEncountered: 0, wordsImproved: 0, wordsMastered: 0, }, derivedMetrics: { studyEfficiency: 0, learningVelocity: 0, consistency: 0, }, }; } createComprehensiveExportData( currentStats: Statistics, testHistory: any[], wordPerformanceAnalyses: WordPerformanceAnalysis[] ): ComprehensiveStatisticsExportData { return { statistics: currentStats, sourceData: { testResults: testHistory, wordPerformances: wordPerformanceAnalyses, words: [], }, exportMetadata: { exportDate: new Date(), appVersion: "1.0.0", dataVersion: "1.0.0", userId: "current-user", exportType: "complete", }, analytics: this.calculateAggregatedStatistics( currentStats, testHistory, wordPerformanceAnalyses ), insights: { summary: "Performance analysis completed", keyAchievements: ["Consistent progress", "Improved accuracy"], areasForImprovement: ["Speed optimization", "Hint dependency"], recommendations: [ { id: "rec_001", type: "review" as const, priority: "high", title: "Focus on weak areas", description: "Review challenging vocabulary", estimatedTime: 30, expectedBenefit: "Improved retention", supportingMetrics: [], }, ], }, }; } }

================================================================================


NOME FILE: categoryUtils.js

// /src/utils/categoryUtils.js // This file contains utility functions for managing vocabulary categories. // It provides functions to get the style for a category based on its name, and to retrieve a list of predefined groups. // It is used to ensure consistent styling and categorization of vocabulary words in the application.  import { CATEGORY_STYLES, CATEGORIES } from '../constants/appConstants';  export const getCategoryStyle = (group) => {   if (!group) return CATEGORY_STYLES['DEFAULT'] || {      color: 'from-blue-400 via-blue-500 to-blue-600',      icon: '📚',      bgColor: 'bg-blue-500',     bgGradient: 'bg-gradient-to-br from-blue-500 to-cyan-600'   };      const upperGroup = group ? group.toUpperCase().trim() : '';   return CATEGORY_STYLES[upperGroup] || CATEGORY_STYLES['DEFAULT']; };  export const getPredefinedGroups = () => {   return [...CATEGORIES].sort(); };

================================================================================

NOME FILE: index.js

// ===================================================== // 📁 src/utils/index.js - EXPORTS PULITI // =====================================================  // ✅ Re-export utilities effettivamente utilizzate export * from './categoryUtils'; export * from './textUtils';  // ✅ Export performance utilities utilizzate export {    memoize,    debounce,    deepEqual,   shallowEqual,   createSelector,   compose,   pipe,   once } from './performanceUtils';  // ===================================================== // ✅ Convenience re-exports (utilizzati ovunque) // =====================================================  export { getCategoryStyle, getPredefinedGroups } from './categoryUtils'; export { formatNotes, getTestResult } from './textUtils';  // ===================================================== // ✅ Core utility functions (utilizzate nell'app) // =====================================================  /**  * Generate unique ID  * ✅ UTILIZZATA per generare ID delle parole  */ export const generateId = () => {   return Date.now().toString(36) + Math.random().toString(36).substr(2); };  /**  * Safe JSON parse with fallback  * ✅ UTILIZZATA nel storageService  */ export const safeJSONParse = (jsonString, fallback = null) => {   try {     return JSON.parse(jsonString);   } catch (error) {     console.warn('JSON parse failed:', error);     return fallback;   } };  /**  * Safe JSON stringify  * ✅ UTILIZZATA nel storageService  */ export const safeJSONStringify = (value, fallback = '{}') => {   try {     return JSON.stringify(value);   } catch (error) {     console.warn('JSON stringify failed:', error);     return fallback;   } };  /**  * Format time duration  * ✅ UTILIZZATA in TestView e statistiche  */ export const formatTime = (seconds) => {   if (!seconds || seconds < 0) return '0:00';      const mins = Math.floor(seconds / 60);   const secs = seconds % 60;   return `${mins}:${secs.toString().padStart(2, '0')}`; };  /**  * Format percentage with precision  * ✅ UTILIZZATA nelle statistiche e nei risultati test  */ export const formatPercentage = (value, total, decimals = 0) => {   if (!total || total === 0) return 0;   const percentage = (value / total) * 100;   return Number(percentage.toFixed(decimals)); };  /**  * Check if value is empty  * ✅ UTILIZZATA nelle validazioni  */ export const isEmpty = (value) => {   if (value == null) return true;   if (typeof value === 'string') return value.trim() === '';   if (Array.isArray(value)) return value.length === 0;   if (typeof value === 'object') return Object.keys(value).length === 0;   return false; };  /**  * Pick specific properties from object  * ✅ UTILIZZATA per filtrare dati export/import  */ export const pick = (obj, keys) => {   const result = {};   keys.forEach(key => {     if (key in obj) {       result[key] = obj[key];     }   });   return result; };  /**  * Group array of objects by property  * ✅ UTILIZZATA per raggruppare parole per capitolo  */ export const groupBy = (array, keyOrFn) => {   return array.reduce((groups, item) => {     const key = typeof keyOrFn === 'function' ? keyOrFn(item) : item[keyOrFn];     if (!groups[key]) {       groups[key] = [];     }     groups[key].push(item);     return groups;   }, {}); };  /**  * Sort array by property with direction  * ✅ UTILIZZATA per ordinare parole e statistiche  */ export const sortBy = (array, property, direction = 'asc') => {   return [...array].sort((a, b) => {     const aVal = a[property];     const bVal = b[property];          if (aVal < bVal) return direction === 'asc' ? -1 : 1;     if (aVal > bVal) return direction === 'asc' ? 1 : -1;     return 0;   }); };  /**  * Calculate statistics for array of numbers  * ✅ UTILIZZATA nelle statistiche avanzate  */ export const calculateStats = (numbers) => {   if (!numbers || numbers.length === 0) {     return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };   }      const sum = numbers.reduce((acc, num) => acc + num, 0);   const avg = sum / numbers.length;   const min = Math.min(...numbers);   const max = Math.max(...numbers);      return {     min,     max,     avg: Number(avg.toFixed(2)),     sum,     count: numbers.length   }; };  /**  * Wait for specified time (async sleep)  * ✅ UTILIZZATA in operazioni asincrone  */ export const sleep = (ms) => {   return new Promise(resolve => setTimeout(resolve, ms)); };  /**  * Capitalize first letter of each word  * ✅ UTILIZZATA per formattare testi  */ export const capitalizeWords = (text) => {   return text.replace(/\b\w/g, l => l.toUpperCase()); };  /**  * Truncate text with ellipsis  * ✅ UTILIZZATA per testi lunghi nelle card  */ export const truncate = (text, maxLength = 50) => {   if (!text || text.length <= maxLength) return text;   return text.substring(0, maxLength).trim() + '...'; };

================================================================================

NOME FILE: performanceUtils.js

// ===================================================== // 📁 src/utils/performanceUtils.js - VERSIONE PULITA // ===================================================== // Solo le utilities effettivamente utilizzate nell'app  /**  * Memoization utility for expensive function calls  * ✅ UTILIZZATA in useOptimizedStats e useOptimizedWords  */ export const memoize = (fn, keyGenerator = (...args) => JSON.stringify(args)) => {   const cache = new Map();      return (...args) => {     const key = keyGenerator(...args);          if (cache.has(key)) {       return cache.get(key);     }          const result = fn(...args);     cache.set(key, result);          // Prevent memory leaks by limiting cache size     if (cache.size > 100) {       const firstKey = cache.keys().next().value;       cache.delete(firstKey);     }          return result;   }; };  /**  * Debounce function to limit rapid function calls  * ✅ UTILIZZATA nel storageService per salvare dati  */ export const debounce = (fn, delay = 300) => {   let timeoutId;      return (...args) => {     clearTimeout(timeoutId);     timeoutId = setTimeout(() => fn(...args), delay);   }; };  /**  * Deep equality check for objects and arrays  * ✅ UTILIZZATA in useStoreBridge (anche se sarà rimosso, utile per future comparazioni)  */ export const deepEqual = (a, b) => {   if (a === b) return true;      if (a == null || b == null) return false;      if (typeof a !== typeof b) return false;      if (typeof a !== 'object') return a === b;      if (Array.isArray(a) !== Array.isArray(b)) return false;      if (Array.isArray(a)) {     if (a.length !== b.length) return false;     for (let i = 0; i < a.length; i++) {       if (!deepEqual(a[i], b[i])) return false;     }     return true;   }      const keysA = Object.keys(a);   const keysB = Object.keys(b);      if (keysA.length !== keysB.length) return false;      for (const key of keysA) {     if (!keysB.includes(key)) return false;     if (!deepEqual(a[key], b[key])) return false;   }      return true; };  /**  * Shallow equality check for objects  * ✅ UTILIZZATA per ottimizzazioni React (useMemo, useCallback)  */ export const shallowEqual = (a, b) => {   if (a === b) return true;      if (!a || !b) return false;      const keysA = Object.keys(a);   const keysB = Object.keys(b);      if (keysA.length !== keysB.length) return false;      for (const key of keysA) {     if (a[key] !== b[key]) return false;   }      return true; };  /**  * Create a selector function that memoizes based on input equality  * ✅ UTILIZZATA negli hook per ottimizzazioni useMemo  */ export const createSelector = (selector, equalityFn = shallowEqual) => {   let lastArgs;   let lastResult;      return (...args) => {     if (!lastArgs || !equalityFn(args, lastArgs)) {       lastArgs = args;       lastResult = selector(...args);     }     return lastResult;   }; };  /**  * Compose multiple functions into one  * ✅ UTILIZZATA per creare pipeline di trasformazioni nei dati delle statistiche  */ export const compose = (...fns) => {   return (value) => fns.reduceRight((acc, fn) => fn(acc), value); };  /**  * Pipe multiple functions (left to right composition)  * ✅ UTILIZZATA per elaborazioni dati in useOptimizedStats  */ export const pipe = (...fns) => {   return (value) => fns.reduce((acc, fn) => fn(acc), value); };  /**  * Create a function that only executes once  * ✅ UTILIZZATA per inizializzazioni singole nei hook  */ export const once = (fn) => {   let called = false;   let result;      return (...args) => {     if (!called) {       called = true;       result = fn(...args);     }     return result;   }; };

================================================================================

NOME FILE: textUtils.js

// /src/utils/textUtils.js // This file contains utility functions for formatting notes and calculating test results. // It provides functions to format notes with specific keywords and to determine the result of a vocabulary test. // The `formatNotes` function processes notes to highlight keywords, while the `getTestResult` function evaluates test statistics to provide feedback based on the user's performance. // These utilities are essential for enhancing the user experience in a vocabulary learning application, making it easier for users to understand notes and assess their test results. //  * @returns {Array} An array of React elements or strings representing the formatted notes. //  */       //  import React from 'react';  export const formatNotes = (notes) => {   if (!notes) return null;      const keywords = [     'Altri Significati', 'Altre Traduzioni', 'Espressioni', 'Verbo Irregolare',      'Pronuncia', 'Sinonimi', 'Esempi', 'Attenzione', 'Nota', 'Importante',     'Plurale irregolare', 'Tecnologia', 'Posizione', 'Contrario', 'Espressione',     'Verbo', 'Phrasal verbs', 'Differenza', 'Abbreviazione', 'Sinonimo',     'Tipico britannico', 'Vestiti', 'Preposizioni', 'Avverbio', 'Sostantivo',     'Aggettivo', 'Congiunzione', 'Interiezione', 'Participio', 'Gerundio',     'Passato', 'Presente', 'Futuro', 'Condizionale', 'Imperativo', 'Infinito',     'Formale', 'Informale', 'Slang', 'Americano', 'Britannico', 'Australiano',     'Tempo', 'Luogo', 'Modo', 'Causa', 'Effetto', 'Scopo', 'Confronto',     'Origine', 'Destinazione', 'Materiale', 'Colore', 'Forma', 'Dimensione',     'Quantità', 'Frequenza', 'Durata', 'Velocità', 'Temperatura', 'Peso',     'Struttura', 'Espressione fissa', 'Figurativo', 'Specificità', 'Pattern',     'Più specifico di'   ];      let formattedText = notes;      keywords.forEach(keyword => {     const regex = new RegExp(`(${keyword})\\s*:`, 'gi');     formattedText = formattedText.replace(regex, `**$1:**`);   });      formattedText = formattedText.replace(/^([A-Za-z\s]+):/gm, '**$1:**');      const parts = formattedText.split(/(\*\*[^*]+\*\*)/g);      return parts.map((part, index) => {     if (part.startsWith('**') && part.endsWith('**')) {       const boldText = part.slice(2, -2);       return React.createElement('span', { key: index, className: 'font-bold' }, boldText);     }     return part;   }); };  export const getTestResult = (stats) => {   const total = stats.correct + stats.incorrect;   const percentage = total > 0 ? Math.round((stats.correct / total) * 100) : 0;      if (percentage >= 80) {     return { type: 'victory', message: 'Eccellente! 🏆', color: 'text-green-600', bgColor: 'bg-green-50' };   } else if (percentage >= 60) {     return { type: 'good', message: 'Buon lavoro! 👍', color: 'text-blue-600', bgColor: 'bg-blue-50' };   } else {     return { type: 'defeat', message: 'Continua a studiare! 📚', color: 'text-red-600', bgColor: 'bg-red-50' };   } };

================================================================================


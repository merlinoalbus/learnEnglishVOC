NOME FILE: categoryUtils.ts

// ===================================================== // 📁 src/utils/categoryUtils.ts - Type-Safe Category Utilities // =====================================================  import { CATEGORY_STYLES, CATEGORIES, isValidCategory } from '../constants/appConstants'; import type { WordCategory, CategoryStyle } from '../types/global';  /**  * Get the style configuration for a word category with full type safety  * @param group - The category group name (can be undefined/null)  * @returns CategoryStyle object with color, icon, bgColor, and bgGradient  */ export const getCategoryStyle = (group?: string | null): CategoryStyle => {   // Handle undefined, null, or empty string   if (!group) {     return CATEGORY_STYLES['DEFAULT'];   }      // Normalize the group name   const upperGroup = group.toUpperCase().trim();      // Type-safe check using type guard   if (isValidCategory(upperGroup)) {     return CATEGORY_STYLES[upperGroup];   }      // Fallback to default style   return CATEGORY_STYLES['DEFAULT']; };  /**  * Get all predefined groups as a sorted array with type safety  * @returns Array of valid WordCategory values  */ export const getPredefinedGroups = (): readonly WordCategory[] => {   return [...CATEGORIES].sort() as readonly WordCategory[]; };  /**  * Get category style by exact match (case-sensitive)  * @param category - The exact category name  * @returns CategoryStyle or undefined if not found  */ export const getCategoryStyleExact = (category: WordCategory): CategoryStyle => {   return CATEGORY_STYLES[category]; };  /**  * Check if a category has a custom style defined  * @param group - The category group name  * @returns True if the category has a custom style  */ export const hasCustomStyle = (group?: string | null): boolean => {   if (!group) return false;      const upperGroup = group.toUpperCase().trim();   return isValidCategory(upperGroup); };  /**  * Get all available category styles as key-value pairs  * @returns Record of category names to their styles  */ export const getAllCategoryStyles = (): Record<WordCategory | 'DEFAULT', CategoryStyle> => {   return { ...CATEGORY_STYLES }; };  /**  * Get category icon only  * @param group - The category group name  * @returns The icon string for the category  */ export const getCategoryIcon = (group?: string | null): string => {   return getCategoryStyle(group).icon; };  /**  * Get category color gradient only  * @param group - The category group name  * @returns The color gradient string for the category  */ export const getCategoryGradient = (group?: string | null): string => {   return getCategoryStyle(group).bgGradient; };  /**  * Get category background color only  * @param group - The category group name  * @returns The background color string for the category  */ export const getCategoryBgColor = (group?: string | null): string => {   return getCategoryStyle(group).bgColor; };  /**  * Get category text color gradient only  * @param group - The category group name  * @returns The text color gradient string for the category  */ export const getCategoryTextColor = (group?: string | null): string => {   return getCategoryStyle(group).color; };  /**  * Validate if a string is a valid category  * @param category - String to validate  * @returns True if the category is valid, with type predicate  */ export { isValidCategory };  /**  * Convert any string to a valid category or return default  * @param input - Input string to convert  * @returns Valid WordCategory or 'SOSTANTIVI' as default  */ export const sanitizeCategory = (input?: string | null): WordCategory => {   if (!input) return 'SOSTANTIVI';      const upperInput = input.toUpperCase().trim();      if (isValidCategory(upperInput)) {     return upperInput;   }      // Try to match partial names   const partialMatch = CATEGORIES.find(cat =>      cat.includes(upperInput) || upperInput.includes(cat)   );      return partialMatch || 'SOSTANTIVI'; };  /**  * Get categories grouped by theme  * @returns Object with categorized groups  */ export const getCategoriesGrouped = () => {   return {     grammar: ['VERBI', 'VERBI_IRREGOLARI', 'SOSTANTIVI', 'AGGETTIVI'] as const,     emotions: ['EMOZIONI', 'EMOZIONI_POSITIVE', 'EMOZIONI_NEGATIVE'] as const,     physical: ['DESCRIZIONI_FISICHE', 'POSIZIONE_CORPO', 'VESTITI'] as const,     lifestyle: ['FAMIGLIA', 'LAVORO', 'TECNOLOGIA'] as const   } as const; };  /**  * Search categories by keyword  * @param keyword - Search keyword  * @returns Array of matching categories  */ export const searchCategories = (keyword: string): WordCategory[] => {   if (!keyword.trim()) return [...CATEGORIES];      const normalizedKeyword = keyword.toLowerCase().trim();      return CATEGORIES.filter(category =>      category.toLowerCase().includes(normalizedKeyword) ||     getCategoryIcon(category).includes(keyword) ||     // Add Italian translations for search     getCategoryItalianName(category).toLowerCase().includes(normalizedKeyword)   ); };  /**  * Get Italian display name for category  * @param category - The category  * @returns Italian display name  */ export const getCategoryItalianName = (category: WordCategory): string => {   const italianNames: Record<WordCategory, string> = {     'VERBI': 'Verbi',     'VERBI_IRREGOLARI': 'Verbi Irregolari',     'SOSTANTIVI': 'Sostantivi',     'AGGETTIVI': 'Aggettivi',     'DESCRIZIONI_FISICHE': 'Aspetto Fisico',     'POSIZIONE_CORPO': 'Posizioni del Corpo',     'EMOZIONI': 'Emozioni',     'EMOZIONI_POSITIVE': 'Emozioni Positive',     'EMOZIONI_NEGATIVE': 'Emozioni Negative',     'LAVORO': 'Lavoro',     'FAMIGLIA': 'Famiglia',     'TECNOLOGIA': 'Tecnologia',     'VESTITI': 'Vestiti'   };      return italianNames[category] || category; };  /**  * Get category statistics for display  * @param category - The category  * @returns Object with display information  */ export const getCategoryDisplayInfo = (category: WordCategory) => {   const style = getCategoryStyleExact(category);      return {     name: category,     displayName: getCategoryItalianName(category),     icon: style.icon,     color: style.color,     bgColor: style.bgColor,     bgGradient: style.bgGradient,     isGrammatical: ['VERBI', 'VERBI_IRREGOLARI', 'SOSTANTIVI', 'AGGETTIVI'].includes(category),     isEmotional: category.includes('EMOZIONI'),     isPhysical: ['DESCRIZIONI_FISICHE', 'POSIZIONE_CORPO', 'VESTITI'].includes(category)   }; };

================================================================================

NOME FILE: index.js

// ===================================================== // 📁 src/utils/index.js - EXPORTS PULITI // =====================================================  // ✅ Re-export utilities effettivamente utilizzate export * from './categoryUtils'; export * from './textUtils';  // ✅ Export performance utilities utilizzate export {    memoize,    debounce,    deepEqual,   shallowEqual,   createSelector,   compose,   pipe,   once } from './performanceUtils';  // ===================================================== // ✅ Convenience re-exports (utilizzati ovunque) // =====================================================  export { getCategoryStyle, getPredefinedGroups } from './categoryUtils'; export { formatNotes, getTestResult } from './textUtils';  // ===================================================== // ✅ Core utility functions (utilizzate nell'app) // =====================================================  /**  * Generate unique ID  * ✅ UTILIZZATA per generare ID delle parole  */ export const generateId = () => {   return Date.now().toString(36) + Math.random().toString(36).substr(2); };  /**  * Safe JSON parse with fallback  * ✅ UTILIZZATA nel storageService  */ export const safeJSONParse = (jsonString, fallback = null) => {   try {     return JSON.parse(jsonString);   } catch (error) {     console.warn('JSON parse failed:', error);     return fallback;   } };  /**  * Safe JSON stringify  * ✅ UTILIZZATA nel storageService  */ export const safeJSONStringify = (value, fallback = '{}') => {   try {     return JSON.stringify(value);   } catch (error) {     console.warn('JSON stringify failed:', error);     return fallback;   } };  /**  * Format time duration  * ✅ UTILIZZATA in TestView e statistiche  */ export const formatTime = (seconds) => {   if (!seconds || seconds < 0) return '0:00';      const mins = Math.floor(seconds / 60);   const secs = seconds % 60;   return `${mins}:${secs.toString().padStart(2, '0')}`; };  /**  * Format percentage with precision  * ✅ UTILIZZATA nelle statistiche e nei risultati test  */ export const formatPercentage = (value, total, decimals = 0) => {   if (!total || total === 0) return 0;   const percentage = (value / total) * 100;   return Number(percentage.toFixed(decimals)); };  /**  * Check if value is empty  * ✅ UTILIZZATA nelle validazioni  */ export const isEmpty = (value) => {   if (value == null) return true;   if (typeof value === 'string') return value.trim() === '';   if (Array.isArray(value)) return value.length === 0;   if (typeof value === 'object') return Object.keys(value).length === 0;   return false; };  /**  * Pick specific properties from object  * ✅ UTILIZZATA per filtrare dati export/import  */ export const pick = (obj, keys) => {   const result = {};   keys.forEach(key => {     if (key in obj) {       result[key] = obj[key];     }   });   return result; };  /**  * Group array of objects by property  * ✅ UTILIZZATA per raggruppare parole per capitolo  */ export const groupBy = (array, keyOrFn) => {   return array.reduce((groups, item) => {     const key = typeof keyOrFn === 'function' ? keyOrFn(item) : item[keyOrFn];     if (!groups[key]) {       groups[key] = [];     }     groups[key].push(item);     return groups;   }, {}); };  /**  * Sort array by property with direction  * ✅ UTILIZZATA per ordinare parole e statistiche  */ export const sortBy = (array, property, direction = 'asc') => {   return [...array].sort((a, b) => {     const aVal = a[property];     const bVal = b[property];          if (aVal < bVal) return direction === 'asc' ? -1 : 1;     if (aVal > bVal) return direction === 'asc' ? 1 : -1;     return 0;   }); };  /**  * Calculate statistics for array of numbers  * ✅ UTILIZZATA nelle statistiche avanzate  */ export const calculateStats = (numbers) => {   if (!numbers || numbers.length === 0) {     return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };   }      const sum = numbers.reduce((acc, num) => acc + num, 0);   const avg = sum / numbers.length;   const min = Math.min(...numbers);   const max = Math.max(...numbers);      return {     min,     max,     avg: Number(avg.toFixed(2)),     sum,     count: numbers.length   }; };  /**  * Wait for specified time (async sleep)  * ✅ UTILIZZATA in operazioni asincrone  */ export const sleep = (ms) => {   return new Promise(resolve => setTimeout(resolve, ms)); };  /**  * Capitalize first letter of each word  * ✅ UTILIZZATA per formattare testi  */ export const capitalizeWords = (text) => {   return text.replace(/\b\w/g, l => l.toUpperCase()); };  /**  * Truncate text with ellipsis  * ✅ UTILIZZATA per testi lunghi nelle card  */ export const truncate = (text, maxLength = 50) => {   if (!text || text.length <= maxLength) return text;   return text.substring(0, maxLength).trim() + '...'; };

================================================================================

NOME FILE: migrationUtils.ts

// ===================================================== // 📁 src/utils/migrationUtils.ts - VERSIONE SISTEMATA CON CHIAVI CORRETTE // =====================================================  import {   DATA_VERSION,   DetailedWordResponse,   OptimizedTestResult,   OptimizedWord,   STORAGE_KEYS,   TestDifficulty,   TestType } from '../types/optimized';  // ⭐ LEGACY TYPES (struttura attuale) interface LegacyWord {   id: string;   english: string;   italian: string;   group?: string | null;   sentence?: string | null;   notes?: string | null;   chapter?: string | null;   learned: boolean;   difficult: boolean; }  interface LegacyTestResult {   id: number;   timestamp: Date | string;   totalWords: number;   correctWords: number;   incorrectWords: number;   hintsUsed: number;   totalTime: number;   avgTimePerWord: number;   percentage: number;   wrongWords?: LegacyWord[];   wordTimes?: Array<{     wordId: string;     timeSpent: number;     isCorrect: boolean;     usedHint: boolean;   }>;   chapterStats?: Record<string, any>;   testParameters?: {     selectedChapters: string[];   };   testType?: string;   difficulty?: string; }  // ⭐ MIGRATION REPORT TYPES interface MigrationReport {   startTime: string;   endTime: string;   wordsProcessed: number;   testsProcessed: number;   errorsEncountered: Array<{     type: string;     item: string;     error: string;   }>;   warnings: string[];   estimationsUsed: number;   dataQualityScore: number; }  interface QualityCheck {   hasEstimations: boolean;   warnings: string[];   accuracyScore: number; }  // ===== UTILITY FUNCTIONS =====  /**  * Carica le parole legacy dal localStorage - SISTEMATO con chiavi multiple  */ function loadLegacyWords(): LegacyWord[] {   const possibleKeys = [     'vocabularyWords',      // Chiave originale dal tuo codice     'vocabulary_words',     // Possibile alternativa     'words',               // Alternativa semplice     'wordList',     'vocabulary_wordList'   ];    for (const key of possibleKeys) {     try {       const item = localStorage.getItem(key);       if (item) {         const data = JSON.parse(item);         if (Array.isArray(data) && data.length > 0) {           console.log(`✅ Parole legacy trovate in: ${key} (${data.length} elementi)`);           return data;         }       }     } catch (error) {       console.warn(`Errore nel parsing della chiave ${key}:`, error);     }   }    console.warn('⚠️ Nessuna parola legacy trovata nelle chiavi:', possibleKeys);   return []; }  /**  * Carica i test legacy dal localStorage - SISTEMATO con chiavi multiple  */ function loadLegacyTests(): LegacyTestResult[] {   const possibleKeys = [     'vocabulary_test_history',  // ⭐ AGGIUNGIAMO QUESTA PRIMA (quella che hai menzionato)     'vocabularyTests',          // Chiave originale dal tuo codice       'testHistory',             // Alternativa comune     'test_history',     'testResults',     'vocabulary_testResults'   ];    for (const key of possibleKeys) {     try {       const item = localStorage.getItem(key);       if (item) {         const data = JSON.parse(item);         if (Array.isArray(data) && data.length > 0) {           console.log(`✅ Test legacy trovati in: ${key} (${data.length} elementi)`);           return data;         }       }     } catch (error) {       console.warn(`Errore nel parsing della chiave ${key}:`, error);     }   }    console.warn('⚠️ Nessun test legacy trovato nelle chiavi:', possibleKeys);   return []; }  /**  * Carica le statistiche legacy dal localStorage - SISTEMATO con chiavi multiple  */ function loadLegacyStats(): any {   const possibleKeys = [     'vocabularyStats',      // Chiave originale dal tuo codice     'vocabulary_stats',     'stats',     'appStats'   ];    for (const key of possibleKeys) {     try {       const item = localStorage.getItem(key);       if (item) {         const data = JSON.parse(item);         if (typeof data === 'object' && Object.keys(data).length > 0) {           console.log(`✅ Statistiche legacy trovate in: ${key}`);           return data;         }       }     } catch (error) {       console.warn(`Errore nel parsing della chiave ${key}:`, error);     }   }    console.warn('⚠️ Nessuna statistica legacy trovata');   return {}; }  /**  * Carica le performance delle parole legacy dal localStorage - SISTEMATO con chiavi multiple  */ function loadLegacyWordPerformance(): any {   const possibleKeys = [     'wordPerformance',          // Chiave originale dal tuo codice     'vocabulary_wordPerformance',     'word_performance',     'wordStats'   ];    for (const key of possibleKeys) {     try {       const item = localStorage.getItem(key);       if (item) {         const data = JSON.parse(item);         if (typeof data === 'object' && Object.keys(data).length > 0) {           console.log(`✅ Word performance legacy trovata in: ${key} (${Object.keys(data).length} parole)`);           return data;         }       }     } catch (error) {       console.warn(`Errore nel parsing della chiave ${key}:`, error);     }   }    console.warn('⚠️ Nessuna word performance legacy trovata');   return {}; }  // ===== CONVERSION FUNCTIONS =====  /**  * Converte una parola legacy nella nuova struttura ottimizzata  */ export function migrateLegacyWord(legacyWord: LegacyWord): OptimizedWord {   const now = new Date().toISOString();      // ⭐ GESTIONE SENTENCE come array   let optimizedSentence: string | string[] | null = null;   if (legacyWord.sentence) {     // Se contiene separatori, dividi in array     if (legacyWord.sentence.includes('|') || legacyWord.sentence.includes(';')) {       optimizedSentence = legacyWord.sentence         .split(/[|;]/)         .map(s => s.trim())         .filter(s => s.length > 0);     } else {       optimizedSentence = legacyWord.sentence;     }   }      return {     id: legacyWord.id,     english: legacyWord.english,     italian: legacyWord.italian,     group: legacyWord.group,     sentence: optimizedSentence,     notes: legacyWord.notes,     chapter: legacyWord.chapter,     learned: legacyWord.learned,     difficult: legacyWord.difficult,     // ⭐ NUOVI CAMPI con valori di default     synonyms: [],     antonyms: [],     createdAt: now,     updatedAt: now   }; }  /**  * Converte un test legacy nella nuova struttura ottimizzata CON integrazione statistiche  */ function migrateLegacyTestResultWithStats(   legacyTest: LegacyTestResult,   allWords: OptimizedWord[],   legacyWordPerformance: any ): OptimizedTestResult {   const timestamp = typeof legacyTest.timestamp === 'string'      ? legacyTest.timestamp      : legacyTest.timestamp.toISOString();    // ⭐ CRITICAL: Ricostruisci le risposte dettagliate CON dati performance   const { rightWords, wrongWords } = reconstructDetailedResponsesWithStats(     legacyTest,      allWords,      legacyWordPerformance   );    // ⭐ Mappatura del tipo di test   const testType: TestType = mapLegacyTestType(legacyTest.testType);      // ⭐ Mappatura della difficoltà   const difficulty: TestDifficulty = mapLegacyDifficulty(legacyTest.difficulty, legacyTest.totalWords);    return {     id: `migrated_${legacyTest.id}_${Date.now()}`,     timestamp,     totalWords: legacyTest.totalWords,     correctWords: legacyTest.correctWords,     incorrectWords: legacyTest.incorrectWords,     totalTime: legacyTest.totalTime * 1000, // Converti in millisecondi     avgTimePerWord: legacyTest.avgTimePerWord * 1000, // Converti in millisecondi     percentage: legacyTest.percentage,     difficulty,     hintsUsed: legacyTest.hintsUsed,     selectedChapters: legacyTest.testParameters?.selectedChapters || [],     testType,     rightWords,     wrongWords,     version: DATA_VERSION   }; }  /**  * Ricostruisce le risposte dettagliate dai dati legacy CON integrazione statistiche  */ function reconstructDetailedResponsesWithStats(   legacyTest: LegacyTestResult,   allWords: OptimizedWord[],   legacyWordPerformance: any ): { rightWords: DetailedWordResponse[]; wrongWords: DetailedWordResponse[] } {   const rightWords: DetailedWordResponse[] = [];   const wrongWords: DetailedWordResponse[] = [];    // ⭐ PRIORITY 1: Usa wordTimes se disponibili (dati più accurati)   if (legacyTest.wordTimes && legacyTest.wordTimes.length > 0) {     legacyTest.wordTimes.forEach(wordTime => {       const response: DetailedWordResponse = {         wordId: wordTime.wordId,         timeResponse: wordTime.timeSpent,         hintsUsed: wordTime.usedHint ? 1 : 0,         currentDifficulty: estimateWordDifficulty(wordTime.wordId, allWords),         isCorrect: wordTime.isCorrect,         timestamp: legacyTest.timestamp.toString()       };        if (wordTime.isCorrect) {         rightWords.push(response);       } else {         wrongWords.push(response);       }     });   } else {     // ⭐ PRIORITY 2: Ricostruisci dai dati aggregati + performance legacy          // Prima, aggiungi le parole sbagliate (abbiamo l'elenco)     if (legacyTest.wrongWords && legacyTest.wrongWords.length > 0) {       legacyTest.wrongWords.forEach(wrongWord => {         const wordPerf = legacyWordPerformance[wrongWord.id];                  const response: DetailedWordResponse = {           wordId: wrongWord.id,           timeResponse: estimateTimeFromPerformance(wordPerf, 'incorrect'),           hintsUsed: estimateHintsFromPerformance(wordPerf, 'incorrect'),           currentDifficulty: estimateWordDifficulty(wrongWord.id, allWords),           isCorrect: false,           timestamp: legacyTest.timestamp.toString()         };         wrongWords.push(response);       });     }      // ⭐ CRITICAL: Stima le parole corrette usando performance data     const correctWordsCount = legacyTest.correctWords;     const testedChapters = legacyTest.testParameters?.selectedChapters || [];          // Trova parole probabilmente corrette nel test     const candidateCorrectWords = allWords.filter(word => {       // Se il test aveva capitoli specifici, filtra per quelli       if (testedChapters.length > 0) {         return testedChapters.includes(word.chapter || '');       }       return true;     }).filter(word => {       // Escludi parole che sappiamo essere sbagliate       return !legacyTest.wrongWords?.some(w => w.id === word.id);     });      // Prendi le migliori candidate basandoti su performance     const sortedCandidates = candidateCorrectWords       .map(word => ({         word,         performance: legacyWordPerformance[word.id],         estimatedCorrectness: estimateWordCorrectnessProbability(word, legacyWordPerformance[word.id])       }))       .sort((a, b) => b.estimatedCorrectness - a.estimatedCorrectness)       .slice(0, correctWordsCount);      sortedCandidates.forEach((candidate, index) => {       const response: DetailedWordResponse = {         wordId: candidate.word.id,         timeResponse: estimateTimeFromPerformance(candidate.performance, 'correct'),         hintsUsed: estimateHintsFromPerformance(candidate.performance, 'correct'),         currentDifficulty: estimateWordDifficulty(candidate.word.id, allWords),         isCorrect: true,         timestamp: legacyTest.timestamp.toString()       };       rightWords.push(response);     });   }    return { rightWords, wrongWords }; }  // ===== ESTIMATION FUNCTIONS =====  /**  * Stima il tempo basandosi sui dati di performance  */ function estimateTimeFromPerformance(wordPerf: any, type: 'correct' | 'incorrect'): number {   if (wordPerf && wordPerf.avgTime) {     // Usa tempo medio dalla performance     const baseTime = wordPerf.avgTime * 1000; // Converti in millisecondi          if (type === 'incorrect') {       return Math.round(baseTime * 1.4); // Le parole sbagliate prendono più tempo     } else {       return Math.round(baseTime * 0.9); // Le parole corrette sono più veloci     }   }      // Fallback a stima generica   return type === 'incorrect' ? 15000 : 8000; // millisecondi }  /**  * Stima gli aiuti basandosi sui dati di performance  */ function estimateHintsFromPerformance(wordPerf: any, type: 'correct' | 'incorrect'): number {   if (wordPerf && wordPerf.hintsPercentage !== undefined) {     // Usa percentuale aiuti dalla performance     const hintProbability = wordPerf.hintsPercentage / 100;          if (type === 'incorrect') {       // Le parole sbagliate hanno maggiore probabilità di aver usato aiuti       return Math.random() < (hintProbability * 1.5) ? 1 : 0;     } else {       // Le parole corrette hanno minore probabilità       return Math.random() < (hintProbability * 0.7) ? 1 : 0;     }   }      // Fallback a stima generica   return type === 'incorrect' && Math.random() < 0.4 ? 1 : 0; }  /**  * Stima la probabilità che una parola sia stata corretta in un test  */ function estimateWordCorrectnessProbability(word: OptimizedWord, wordPerf: any): number {   let probability = 0.5; // Base 50%      if (wordPerf) {     if (wordPerf.accuracy !== undefined) {       probability = wordPerf.accuracy / 100; // Usa accuratezza storica     }          if (wordPerf.currentStreak > 2) {       probability += 0.2; // Bonus per streak     }          if (wordPerf.hintsPercentage > 50) {       probability -= 0.1; // Penalità per troppi aiuti     }   }      if (word.learned) {     probability += 0.3; // Bonus per parole apprese   }      if (word.difficult) {     probability -= 0.2; // Penalità per parole difficili   }      return Math.max(0.1, Math.min(0.9, probability)); // Clamp tra 10% e 90% }  /**  * Stima la difficoltà di una parola basandosi sui metadati  */ function estimateWordDifficulty(wordId: string, allWords: OptimizedWord[]): TestDifficulty {   const word = allWords.find(w => w.id === wordId);      if (!word) return 'medium';      // Logica di stima basata sulle caratteristiche della parola   if (word.difficult) return 'hard';   if (word.learned) return 'easy';      // Stima basata sulla lunghezza della parola   const wordLength = word.english.length;   if (wordLength > 12) return 'hard';   if (wordLength < 6) return 'easy';      return 'medium'; }  /**  * Mappa il tipo di test legacy al nuovo enum  */ function mapLegacyTestType(legacyType?: string): TestType {   if (!legacyType) return 'complete';      const typeMap: Record<string, TestType> = {     'complete': 'complete',     'selective': 'selective',     'difficult': 'difficult',     'learned': 'learned',     'mixed': 'mixed',     'review': 'review'   };      return typeMap[legacyType.toLowerCase()] || 'complete'; }  /**  * Mappa la difficoltà legacy al nuovo enum  */ function mapLegacyDifficulty(legacyDifficulty?: string, totalWords?: number): TestDifficulty {   if (legacyDifficulty) {     const difficultyMap: Record<string, TestDifficulty> = {       'easy': 'easy',       'medium': 'medium',       'hard': 'hard'     };          const mapped = difficultyMap[legacyDifficulty.toLowerCase()];     if (mapped) return mapped;   }      // Stima basata sul numero di parole   if (!totalWords) return 'medium';      if (totalWords < 15) return 'easy';   if (totalWords > 30) return 'hard';   return 'medium'; }  // ===== VALIDATION FUNCTIONS =====  /**  * Valida la qualità dei dati del test migrato  */ function validateTestDataQuality(   legacyTest: LegacyTestResult,   optimizedTest: OptimizedTestResult ): QualityCheck {   const warnings: string[] = [];   let hasEstimations = false;   let accuracyScore = 100;    // ⭐ CHECK 1: Verifica la presenza di wordTimes   if (!legacyTest.wordTimes || legacyTest.wordTimes.length === 0) {     warnings.push(`Test ${legacyTest.id}: wordTimes mancanti, dati stimati`);     hasEstimations = true;     accuracyScore -= 20;   }    // ⭐ CHECK 2: Verifica la coerenza dei contatori   const expectedTotal = optimizedTest.rightWords.length + optimizedTest.wrongWords.length;   if (expectedTotal !== legacyTest.totalWords) {     warnings.push(`Test ${legacyTest.id}: discrepanza nel conteggio parole (${expectedTotal} vs ${legacyTest.totalWords})`);     accuracyScore -= 15;   }    // ⭐ CHECK 3: Verifica la presenza di timing data   const hasTimingData = optimizedTest.rightWords.some(w => w.timeResponse > 0) ||                        optimizedTest.wrongWords.some(w => w.timeResponse > 0);   if (!hasTimingData) {     warnings.push(`Test ${legacyTest.id}: dati di timing stimati`);     hasEstimations = true;     accuracyScore -= 10;   }    // ⭐ CHECK 4: Verifica la distribuzione degli aiuti   const totalHints = optimizedTest.rightWords.reduce((sum, w) => sum + w.hintsUsed, 0) +                     optimizedTest.wrongWords.reduce((sum, w) => sum + w.hintsUsed, 0);   if (Math.abs(totalHints - legacyTest.hintsUsed) > 1) {     warnings.push(`Test ${legacyTest.id}: distribuzione aiuti stimata (${totalHints} vs ${legacyTest.hintsUsed})`);     hasEstimations = true;     accuracyScore -= 5;   }    return {     hasEstimations,     warnings,     accuracyScore: Math.max(0, accuracyScore)   }; }  /**  * Calcola un punteggio di qualità generale dei dati migrati  */ function calculateDataQualityScore(   legacyTests: LegacyTestResult[],   optimizedTests: OptimizedTestResult[],   report: MigrationReport ): number {   if (legacyTests.length === 0) return 100;    // ⭐ Fattori che influenzano la qualità   const testsWithWordTimes = legacyTests.filter(t => t.wordTimes && t.wordTimes.length > 0).length;   const wordTimesPercentage = (testsWithWordTimes / legacyTests.length) * 100;      const errorRate = (report.errorsEncountered.length / (report.wordsProcessed + report.testsProcessed)) * 100;   const estimationRate = (report.estimationsUsed / legacyTests.length) * 100;    // ⭐ Calcolo del punteggio (0-100)   let qualityScore = 100;      // Penalizza per mancanza di dati dettagliati   qualityScore -= (100 - wordTimesPercentage) * 0.5;      // Penalizza per errori   qualityScore -= errorRate * 2;      // Penalizza per stime   qualityScore -= estimationRate * 0.3;      return Math.max(0, Math.round(qualityScore)); }  /**  * Salva i dati ottimizzati nel localStorage  */ async function saveOptimizedData(   optimizedWords: OptimizedWord[],   optimizedTests: OptimizedTestResult[] ): Promise<void> {   try {     localStorage.setItem(STORAGE_KEYS.optimizedWords, JSON.stringify(optimizedWords));     localStorage.setItem(STORAGE_KEYS.optimizedTests, JSON.stringify(optimizedTests));     localStorage.setItem(STORAGE_KEYS.lastCalculated, new Date().toISOString());          // ⭐ Mantieni i dati legacy come backup     const backupKey = `backup_legacy_${Date.now()}`;          // ⭐ SISTEMATO: Cerca in tutte le chiavi possibili per il backup     const legacyWords = loadLegacyWords();     const legacyTests = loadLegacyTests();          if (legacyWords.length > 0 || legacyTests.length > 0) {       localStorage.setItem(backupKey, JSON.stringify({         words: legacyWords,         tests: legacyTests,         backupDate: new Date().toISOString()       }));     }          console.log(`💾 Dati salvati. Backup legacy creato: ${backupKey}`);        } catch (error) {     throw new Error(`Errore nel salvataggio dei dati ottimizzati: ${(error as Error).message}`);   } }  // ===== MAIN MIGRATION FUNCTION =====  /**  * Funzione principale di migrazione che converte tutti i dati legacy  */ export async function migrateAllLegacyData(): Promise<{   words: OptimizedWord[];   tests: OptimizedTestResult[];   migrationReport: MigrationReport; }> {   const migrationReport: MigrationReport = {     startTime: new Date().toISOString(),     endTime: '',     wordsProcessed: 0,     testsProcessed: 0,     errorsEncountered: [],     warnings: [],     estimationsUsed: 0,     dataQualityScore: 0   };    try {     // ⭐ STEP 1: Carica i dati legacy - SISTEMATO con chiavi multiple     const legacyWords = loadLegacyWords();     const legacyTests = loadLegacyTests();          // ⭐ STEP 1.5: Carica e migra anche le statistiche legacy - SISTEMATO con chiavi multiple     const legacyStats = loadLegacyStats();     const legacyWordPerformance = loadLegacyWordPerformance();          console.log(`🔄 Iniziando migrazione: ${legacyWords.length} parole, ${legacyTests.length} test, performance: ${Object.keys(legacyWordPerformance).length} parole`);      // ⭐ STEP 2: Migra le parole     const optimizedWords: OptimizedWord[] = [];          legacyWords.forEach((legacyWord: LegacyWord, index: number) => {       try {         const optimizedWord = migrateLegacyWord(legacyWord);         optimizedWords.push(optimizedWord);         migrationReport.wordsProcessed++;       } catch (error) {         migrationReport.errorsEncountered.push({           type: 'word_migration',           item: `Word ${index}: ${legacyWord.english}`,           error: (error as Error).message         });       }     });      // ⭐ STEP 3: Migra i test con integrazione delle statistiche     const optimizedTests: OptimizedTestResult[] = [];          legacyTests.forEach((legacyTest: LegacyTestResult, index: number) => {       try {         const optimizedTest = migrateLegacyTestResultWithStats(           legacyTest,            optimizedWords,            legacyWordPerformance         );                  // ⭐ QUALITY CHECK: Verifica la coerenza dei dati         const qualityCheck = validateTestDataQuality(legacyTest, optimizedTest);         if (qualityCheck.hasEstimations) {           migrationReport.estimationsUsed++;         }         if (qualityCheck.warnings.length > 0) {           migrationReport.warnings.push(...qualityCheck.warnings);         }                  optimizedTests.push(optimizedTest);         migrationReport.testsProcessed++;       } catch (error) {         migrationReport.errorsEncountered.push({           type: 'test_migration',           item: `Test ${index}: ID ${legacyTest.id}`,           error: (error as Error).message         });       }     });      // ⭐ STEP 4: Calcola il punteggio di qualità dei dati     migrationReport.dataQualityScore = calculateDataQualityScore(       legacyTests,       optimizedTests,       migrationReport     );      // ⭐ STEP 5: Salva i dati migrati     await saveOptimizedData(optimizedWords, optimizedTests);      migrationReport.endTime = new Date().toISOString();          console.log(`✅ Migrazione completata!`, {       words: migrationReport.wordsProcessed,       tests: migrationReport.testsProcessed,       errors: migrationReport.errorsEncountered.length,       warnings: migrationReport.warnings.length,       qualityScore: migrationReport.dataQualityScore     });      return {       words: optimizedWords,       tests: optimizedTests,       migrationReport     };    } catch (error) {     migrationReport.endTime = new Date().toISOString();     migrationReport.errorsEncountered.push({       type: 'migration_failure',       item: 'Global migration process',       error: (error as Error).message     });          throw error;   } }  // ===== UTILITY FUNCTIONS FOR MANUAL MIGRATION =====  /**  * Verifica se è necessaria una migrazione - SISTEMATO con chiavi multiple  */ export function needsMigration(): boolean {   const hasOptimizedData = localStorage.getItem(STORAGE_KEYS.optimizedTests) !== null;      // ⭐ SISTEMATO: Controlla tutte le possibili chiavi legacy   const legacyWords = loadLegacyWords();   const legacyTests = loadLegacyTests();   const hasLegacyData = legacyWords.length > 0 || legacyTests.length > 0;      console.log(`🔍 Controllo migrazione:`, {     hasOptimizedData,     hasLegacyData,     legacyWordsCount: legacyWords.length,     legacyTestsCount: legacyTests.length   });      return !hasOptimizedData && hasLegacyData; }  /**  * Ottieni un report sulla qualità dei dati legacy - SISTEMATO con chiavi multiple  */ export function getLegacyDataReport(): {   wordsCount: number;   testsCount: number;   testsWithDetailedData: number;   estimatedQuality: number;   recommendations: string[]; } {   const legacyWords = loadLegacyWords();   const legacyTests = loadLegacyTests();      const testsWithDetailedData = legacyTests.filter(t =>      t.wordTimes && t.wordTimes.length > 0   ).length;      const qualityPercentage = legacyTests.length > 0 ?      (testsWithDetailedData / legacyTests.length) * 100 : 0;      const recommendations: string[] = [];      if (qualityPercentage < 50) {     recommendations.push('⚠️ Molti test non hanno dati dettagliati - saranno necessarie stime');   }      if (legacyTests.length === 0) {     recommendations.push('ℹ️ Nessun test trovato - solo le parole saranno migrate');   }      if (legacyWords.length === 0) {     recommendations.push('⚠️ Nessuna parola trovata - verifica che i dati siano presenti');   }    if (qualityPercentage >= 80) {     recommendations.push('✅ Ottima qualità dei dati - migrazione raccomandata');   }      return {     wordsCount: legacyWords.length,     testsCount: legacyTests.length,     testsWithDetailedData,     estimatedQuality: Math.round(qualityPercentage),     recommendations   }; }  /**  * Esegui una migrazione di test (dry run) - SISTEMATO con chiavi multiple  */ export function testMigration(): MigrationReport {   const report: MigrationReport = {     startTime: new Date().toISOString(),     endTime: '',     wordsProcessed: 0,     testsProcessed: 0,     errorsEncountered: [],     warnings: [],     estimationsUsed: 0,     dataQualityScore: 0   };    try {     const legacyWords = loadLegacyWords();     const legacyTests = loadLegacyTests();     const legacyWordPerformance = loadLegacyWordPerformance();          // Simula la migrazione senza salvare     legacyWords.forEach((word: LegacyWord, index: number) => {       try {         migrateLegacyWord(word);         report.wordsProcessed++;       } catch (error) {         report.errorsEncountered.push({           type: 'word_test',           item: `Word ${index}`,           error: (error as Error).message         });       }     });      const optimizedWords = legacyWords.map(migrateLegacyWord);          legacyTests.forEach((test: LegacyTestResult, index: number) => {       try {         const optimizedTest = migrateLegacyTestResultWithStats(test, optimizedWords, legacyWordPerformance);         const qualityCheck = validateTestDataQuality(test, optimizedTest);                  if (qualityCheck.hasEstimations) report.estimationsUsed++;         report.warnings.push(...qualityCheck.warnings);         report.testsProcessed++;       } catch (error) {         report.errorsEncountered.push({           type: 'test_test',           item: `Test ${index}`,           error: (error as Error).message         });       }     });      report.dataQualityScore = calculateDataQualityScore(legacyTests, [], report);     report.endTime = new Date().toISOString();          return report;        } catch (error) {     report.errorsEncountered.push({       type: 'test_failure',       item: 'Test migration',       error: (error as Error).message     });     report.endTime = new Date().toISOString();     return report;   } }  // ⭐ AGGIUNTO: Funzione di debug per vedere le chiavi localStorage export function debugLocalStorageKeys(): void {   console.log('🔍 === LOCALSTORAGE DEBUG ===');      const allKeys = [];   for (let i = 0; i < localStorage.length; i++) {     const key = localStorage.key(i);     if (key) allKeys.push(key);   }      console.log(`📊 Total keys: ${allKeys.length}`);   console.log('📋 All keys:', allKeys.sort());      // Filtra chiavi potenzialmente interessanti   const testKeys = allKeys.filter(key =>      key.toLowerCase().includes('test') ||      key.toLowerCase().includes('history') ||      key.toLowerCase().includes('result')   );      const wordKeys = allKeys.filter(key =>     key.toLowerCase().includes('word') ||     key.toLowerCase().includes('vocabulary') ||     key.toLowerCase().includes('dict')   );      console.log('🧪 Test-related keys:', testKeys);   console.log('📝 Word-related keys:', wordKeys);      // Analizza contenuto delle chiavi interessanti   [...testKeys, ...wordKeys].forEach(key => {     try {       const item = localStorage.getItem(key);       if (item) {         const data = JSON.parse(item);         console.log(`🔑 ${key}:`, {           type: Array.isArray(data) ? 'array' : typeof data,           length: Array.isArray(data) ? data.length :                   typeof data === 'object' ? Object.keys(data).length :                   typeof data === 'string' ? data.length : 0         });       }     } catch (e) {       console.log(`🔑 ${key}: unparseable`);     }   }); }

================================================================================

NOME FILE: performanceUtils.js

// ===================================================== // 📁 src/utils/performanceUtils.js - VERSIONE PULITA // ===================================================== // Solo le utilities effettivamente utilizzate nell'app  /**  * Memoization utility for expensive function calls  * ✅ UTILIZZATA in useOptimizedStats e useOptimizedWords  */ export const memoize = (fn, keyGenerator = (...args) => JSON.stringify(args)) => {   const cache = new Map();      return (...args) => {     const key = keyGenerator(...args);          if (cache.has(key)) {       return cache.get(key);     }          const result = fn(...args);     cache.set(key, result);          // Prevent memory leaks by limiting cache size     if (cache.size > 100) {       const firstKey = cache.keys().next().value;       cache.delete(firstKey);     }          return result;   }; };  /**  * Debounce function to limit rapid function calls  * ✅ UTILIZZATA nel storageService per salvare dati  */ export const debounce = (fn, delay = 300) => {   let timeoutId;      return (...args) => {     clearTimeout(timeoutId);     timeoutId = setTimeout(() => fn(...args), delay);   }; };  /**  * Deep equality check for objects and arrays  * ✅ UTILIZZATA in useStoreBridge (anche se sarà rimosso, utile per future comparazioni)  */ export const deepEqual = (a, b) => {   if (a === b) return true;      if (a == null || b == null) return false;      if (typeof a !== typeof b) return false;      if (typeof a !== 'object') return a === b;      if (Array.isArray(a) !== Array.isArray(b)) return false;      if (Array.isArray(a)) {     if (a.length !== b.length) return false;     for (let i = 0; i < a.length; i++) {       if (!deepEqual(a[i], b[i])) return false;     }     return true;   }      const keysA = Object.keys(a);   const keysB = Object.keys(b);      if (keysA.length !== keysB.length) return false;      for (const key of keysA) {     if (!keysB.includes(key)) return false;     if (!deepEqual(a[key], b[key])) return false;   }      return true; };  /**  * Shallow equality check for objects  * ✅ UTILIZZATA per ottimizzazioni React (useMemo, useCallback)  */ export const shallowEqual = (a, b) => {   if (a === b) return true;      if (!a || !b) return false;      const keysA = Object.keys(a);   const keysB = Object.keys(b);      if (keysA.length !== keysB.length) return false;      for (const key of keysA) {     if (a[key] !== b[key]) return false;   }      return true; };  /**  * Create a selector function that memoizes based on input equality  * ✅ UTILIZZATA negli hook per ottimizzazioni useMemo  */ export const createSelector = (selector, equalityFn = shallowEqual) => {   let lastArgs;   let lastResult;      return (...args) => {     if (!lastArgs || !equalityFn(args, lastArgs)) {       lastArgs = args;       lastResult = selector(...args);     }     return lastResult;   }; };  /**  * Compose multiple functions into one  * ✅ UTILIZZATA per creare pipeline di trasformazioni nei dati delle statistiche  */ export const compose = (...fns) => {   return (value) => fns.reduceRight((acc, fn) => fn(acc), value); };  /**  * Pipe multiple functions (left to right composition)  * ✅ UTILIZZATA per elaborazioni dati in useOptimizedStats  */ export const pipe = (...fns) => {   return (value) => fns.reduce((acc, fn) => fn(acc), value); };  /**  * Create a function that only executes once  * ✅ UTILIZZATA per inizializzazioni singole nei hook  */ export const once = (fn) => {   let called = false;   let result;      return (...args) => {     if (!called) {       called = true;       result = fn(...args);     }     return result;   }; };

================================================================================

NOME FILE: retryUtils.js

// ===================================================== // 📁 src/utils/retryUtils.js - Advanced Retry & Timeout Utilities // =====================================================  // ===================================================== // 🔄 EXPONENTIAL BACKOFF RETRY // ===================================================== export const retryWithBackoff = async (   operation,   options = {} ) => {   const {     maxAttempts = 3,     baseDelay = 1000,     maxDelay = 10000,     exponentialBase = 2,     jitter = true,     retryCondition = (error) => true,     onRetry = null,     onFinalFailure = null   } = options;    let lastError;      for (let attempt = 1; attempt <= maxAttempts; attempt++) {     try {       const result = await operation(attempt);       return result;     } catch (error) {       lastError = error;              // Check if we should retry this error       if (!retryCondition(error)) {         throw error;       }              // If this was the last attempt, don't wait       if (attempt === maxAttempts) {         if (onFinalFailure) {           onFinalFailure(error, attempt);         }         throw error;       }              // Calculate delay with exponential backoff       let delay = Math.min(baseDelay * Math.pow(exponentialBase, attempt - 1), maxDelay);              // Add jitter to prevent thundering herd       if (jitter) {         delay += Math.random() * delay * 0.1;       }              // Call retry callback if provided       if (onRetry) {         onRetry(error, attempt, delay);       }              // Wait before next attempt       await new Promise(resolve => setTimeout(resolve, delay));     }   }      throw lastError; };  // ===================================================== // ⏱️ TIMEOUT WRAPPER // ===================================================== export const withTimeout = (operation, timeoutMs, timeoutMessage = 'Operation timed out') => {   return Promise.race([     operation(),     new Promise((_, reject) => {       setTimeout(() => {         reject(new Error(timeoutMessage));       }, timeoutMs);     })   ]); };  // ===================================================== // 🎯 SMART RETRY (AI-specific) // ===================================================== export const smartRetryAI = async (aiOperation, word) => {   return retryWithBackoff(aiOperation, {     maxAttempts: 3,     baseDelay: 2000,     maxDelay: 8000,     retryCondition: (error) => {       // Don't retry API key errors       if (error.message.includes('API key') || error.message.includes('401')) {         return false;       }              // Don't retry quota exceeded       if (error.message.includes('quota') || error.message.includes('limit')) {         return false;       }              // Retry network errors, timeouts, 5xx errors       return error.message.includes('network') ||               error.message.includes('timeout') ||              error.message.includes('fetch') ||              error.message.includes('5');     },     onRetry: (error, attempt, delay) => {       console.log(`🤖 AI Retry ${attempt}/3 for word "${word}" in ${Math.round(delay)}ms:`, error.message);     },     onFinalFailure: (error, attempts) => {       console.error(`❌ AI Service failed for word "${word}" after ${attempts} attempts:`, error);     }   }); };  // ===================================================== // 💾 STORAGE RETRY (localStorage-specific) // ===================================================== export const smartRetryStorage = async (storageOperation, operationName) => {   return retryWithBackoff(storageOperation, {     maxAttempts: 3,     baseDelay: 500,     maxDelay: 2000,     retryCondition: (error) => {       // Don't retry quota exceeded errors       if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {         return false;       }              // Don't retry security errors       if (error.message.includes('SecurityError') || error.message.includes('access denied')) {         return false;       }              // Retry other localStorage errors       return error.message.includes('localStorage') ||               error.message.includes('storage') ||              error.message.includes('access');     },     onRetry: (error, attempt, delay) => {       console.log(`💾 Storage Retry ${attempt}/3 for "${operationName}" in ${Math.round(delay)}ms:`, error.message);     },     onFinalFailure: (error, attempts) => {       console.error(`❌ Storage operation "${operationName}" failed after ${attempts} attempts:`, error);     }   }); };  // ===================================================== // 🌐 NETWORK RETRY (fetch-specific) // ===================================================== export const smartRetryNetwork = async (networkOperation, url) => {   return retryWithBackoff(networkOperation, {     maxAttempts: 3,     baseDelay: 1500,     maxDelay: 6000,     retryCondition: (error) => {       // Don't retry 4xx client errors (except 408, 429)       if (error.message.includes('400') ||            error.message.includes('401') ||            error.message.includes('403') ||            error.message.includes('404')) {         return false;       }              // Retry timeout and 5xx server errors       return error.message.includes('timeout') ||               error.message.includes('network') ||              error.message.includes('fetch') ||              error.message.includes('5');     },     onRetry: (error, attempt, delay) => {       console.log(`🌐 Network Retry ${attempt}/3 for "${url}" in ${Math.round(delay)}ms:`, error.message);     },     onFinalFailure: (error, attempts) => {       console.error(`❌ Network operation for "${url}" failed after ${attempts} attempts:`, error);     }   }); };  // ===================================================== // 🔄 CIRCUIT BREAKER PATTERN // ===================================================== export class CircuitBreaker {   constructor(options = {}) {     this.failureThreshold = options.failureThreshold || 5;     this.recoveryTimeout = options.recoveryTimeout || 60000; // 1 minute     this.monitoringPeriod = options.monitoringPeriod || 10000; // 10 seconds          this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN     this.failureCount = 0;     this.lastFailureTime = null;     this.successCount = 0;   }    async execute(operation) {     if (this.state === 'OPEN') {       if (Date.now() - this.lastFailureTime < this.recoveryTimeout) {         throw new Error('Circuit breaker is OPEN - service temporarily unavailable');       } else {         this.state = 'HALF_OPEN';         this.successCount = 0;       }     }      try {       const result = await operation();       this.onSuccess();       return result;     } catch (error) {       this.onFailure();       throw error;     }   }    onSuccess() {     this.failureCount = 0;          if (this.state === 'HALF_OPEN') {       this.successCount++;       if (this.successCount >= 3) { // 3 successful calls to close circuit         this.state = 'CLOSED';       }     }   }    onFailure() {     this.failureCount++;     this.lastFailureTime = Date.now();          if (this.failureCount >= this.failureThreshold) {       this.state = 'OPEN';     }   }    getState() {     return {       state: this.state,       failureCount: this.failureCount,       lastFailureTime: this.lastFailureTime,       isAvailable: this.state !== 'OPEN'     };   }    reset() {     this.state = 'CLOSED';     this.failureCount = 0;     this.lastFailureTime = null;     this.successCount = 0;   } }  // ===================================================== // 🎛️ OPERATION MANAGER WITH RETRIES // ===================================================== export class OperationManager {   constructor() {     this.operations = new Map();     this.circuitBreakers = new Map();   }    // Register an operation with its retry configuration   registerOperation(name, config = {}) {     this.operations.set(name, {       maxAttempts: config.maxAttempts || 3,       timeout: config.timeout || 30000,       retryCondition: config.retryCondition || (() => true),       circuitBreaker: config.useCircuitBreaker ? new CircuitBreaker(config.circuitBreakerOptions) : null,       ...config     });   }    // Execute an operation with configured retry logic   async execute(operationName, operation, ...args) {     const config = this.operations.get(operationName);          if (!config) {       throw new Error(`Operation "${operationName}" not registered`);     }      const wrappedOperation = async () => {       if (config.timeout) {         return withTimeout(() => operation(...args), config.timeout, `${operationName} timeout`);       }       return operation(...args);     };      if (config.circuitBreaker) {       return config.circuitBreaker.execute(async () => {         return retryWithBackoff(wrappedOperation, {           maxAttempts: config.maxAttempts,           baseDelay: config.baseDelay,           retryCondition: config.retryCondition,           onRetry: config.onRetry,           onFinalFailure: config.onFinalFailure         });       });     } else {       return retryWithBackoff(wrappedOperation, {         maxAttempts: config.maxAttempts,         baseDelay: config.baseDelay,         retryCondition: config.retryCondition,         onRetry: config.onRetry,         onFinalFailure: config.onFinalFailure       });     }   }    // Get operation status   getOperationStatus(operationName) {     const config = this.operations.get(operationName);     if (!config) return null;      return {       name: operationName,       circuitBreaker: config.circuitBreaker ? config.circuitBreaker.getState() : null,       config: {         maxAttempts: config.maxAttempts,         timeout: config.timeout,         useCircuitBreaker: !!config.circuitBreaker       }     };   }    // Reset circuit breaker for an operation   resetOperation(operationName) {     const config = this.operations.get(operationName);     if (config && config.circuitBreaker) {       config.circuitBreaker.reset();     }   }    // Get all operations status   getAllStatus() {     return Array.from(this.operations.keys()).map(name => this.getOperationStatus(name));   } }  // ===================================================== // 🌍 GLOBAL OPERATION MANAGER INSTANCE // ===================================================== export const globalOperationManager = new OperationManager();  // Register common operations globalOperationManager.registerOperation('aiAnalysis', {   maxAttempts: 3,   timeout: 45000,   baseDelay: 2000,   useCircuitBreaker: true,   circuitBreakerOptions: {     failureThreshold: 3,     recoveryTimeout: 120000 // 2 minutes for AI service   },   retryCondition: (error) => {     return !error.message.includes('API key') &&             !error.message.includes('quota') &&            !error.message.includes('401');   } });  globalOperationManager.registerOperation('storageOperation', {   maxAttempts: 3,   timeout: 10000,   baseDelay: 500,   retryCondition: (error) => {     return !error.name?.includes('QuotaExceededError') &&            !error.message.includes('SecurityError');   } });  globalOperationManager.registerOperation('networkRequest', {   maxAttempts: 3,   timeout: 20000,   baseDelay: 1500,   useCircuitBreaker: true,   circuitBreakerOptions: {     failureThreshold: 5,     recoveryTimeout: 60000 // 1 minute for network   },   retryCondition: (error) => {     return !error.message.includes('40') || // Don't retry 4xx except 408, 429            error.message.includes('408') ||            error.message.includes('429');   } });  // ===================================================== // 🔧 UTILITY FUNCTIONS // =====================================================  // Debounced retry - prevents rapid repeated attempts export const debouncedRetry = (operation, delay = 1000) => {   let timeoutId;   let lastPromise;    return (...args) => {     if (timeoutId) {       clearTimeout(timeoutId);     }      if (lastPromise) {       return lastPromise;     }      return new Promise((resolve, reject) => {       timeoutId = setTimeout(async () => {         try {           lastPromise = operation(...args);           const result = await lastPromise;           lastPromise = null;           resolve(result);         } catch (error) {           lastPromise = null;           reject(error);         }       }, delay);     });   }; };  // Batch retry - retry multiple operations together export const batchRetry = async (operations, options = {}) => {   const {     maxAttempts = 3,     failFast = false, // If true, stop on first failure     retryDelay = 1000   } = options;    let attempt = 1;   let results = new Array(operations.length).fill(null);   let errors = new Array(operations.length).fill(null);   let completed = new Array(operations.length).fill(false);    while (attempt <= maxAttempts && !completed.every(Boolean)) {     console.log(`📦 Batch retry attempt ${attempt}/${maxAttempts}`);          const promises = operations.map(async (operation, index) => {       if (completed[index]) return results[index]; // Skip completed operations        try {         const result = await operation();         results[index] = result;         completed[index] = true;         errors[index] = null;         return result;       } catch (error) {         errors[index] = error;         if (failFast) throw error;         return null;       }     });      await Promise.allSettled(promises);      if (failFast && errors.some(error => error !== null)) {       throw errors.find(error => error !== null);     }      // If not all completed and we have more attempts, wait before retry     if (!completed.every(Boolean) && attempt < maxAttempts) {       await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));     }      attempt++;   }    return {     results,     errors,     completed,     successCount: completed.filter(Boolean).length,     failureCount: completed.length - completed.filter(Boolean).length   }; };  // Progressive timeout - increase timeout on each retry export const progressiveTimeout = (baseTimeout, attempt, maxTimeout = baseTimeout * 5) => {   return Math.min(baseTimeout * Math.pow(1.5, attempt - 1), maxTimeout); };  const retryUtilsExport = {   retryWithBackoff,   withTimeout,   smartRetryAI,   smartRetryStorage,   smartRetryNetwork,   CircuitBreaker,   OperationManager,   globalOperationManager,   debouncedRetry,   progressiveTimeout };  export default retryUtilsExport;

================================================================================

NOME FILE: textUtils.ts

// ===================================================== // 📁 src/utils/textUtils.ts - Type-Safe Text Formatting Utilities // =====================================================  import React from 'react'; import type { TestStats } from '../types/global';  /**  * Keywords for formatting notes with proper highlighting  */ const FORMATTING_KEYWORDS = [   'Altri Significati', 'Altre Traduzioni', 'Espressioni', 'Verbo Irregolare',    'Pronuncia', 'Sinonimi', 'Esempi', 'Attenzione', 'Nota', 'Importante',   'Plurale irregolare', 'Tecnologia', 'Posizione', 'Contrario', 'Espressione',   'Verbo', 'Phrasal verbs', 'Differenza', 'Abbreviazione', 'Sinonimo',   'Tipico britannico', 'Vestiti', 'Preposizioni', 'Avverbio', 'Sostantivo',   'Aggettivo', 'Congiunzione', 'Interiezione', 'Participio', 'Gerundio',   'Passato', 'Presente', 'Futuro', 'Condizionale', 'Imperativo', 'Infinito',   'Formale', 'Informale', 'Slang', 'Americano', 'Britannico', 'Australiano',   'Tempo', 'Luogo', 'Modo', 'Causa', 'Effetto', 'Scopo', 'Confronto',   'Origine', 'Destinazione', 'Materiale', 'Colore', 'Forma', 'Dimensione',   'Quantità', 'Frequenza', 'Durata', 'Velocità', 'Temperatura', 'Peso',   'Struttura', 'Espressione fissa', 'Figurativo', 'Specificità', 'Pattern',   'Più specifico di' ] as const;  /**  * Test result types for type safety  */ export type TestResultType = 'victory' | 'good' | 'defeat';  /**  * Test result information  */ export interface TestResultInfo {   type: TestResultType;   message: string;   color: string;   bgColor: string; }  /**  * Formatted note part - can be a React element or string  */ export type FormattedNotePart = React.ReactElement | string;  /**  * Format notes with keyword highlighting and proper structure  * @param notes - Raw notes string to format  * @returns Array of React elements and strings representing formatted notes  */ export const formatNotes = (notes?: string | null): FormattedNotePart[] | null => {   if (!notes || typeof notes !== 'string') return null;      let formattedText = notes;      // Format predefined keywords with bold styling   FORMATTING_KEYWORDS.forEach(keyword => {     const regex = new RegExp(`(${keyword})\\s*:`, 'gi');     formattedText = formattedText.replace(regex, `**$1:**`);   });      // Format any other patterns that look like labels (word followed by colon)   formattedText = formattedText.replace(/^([A-Za-z\s]+):/gm, '**$1:**');      // Split text into parts for React rendering   const parts = formattedText.split(/(\*\*[^*]+\*\*)/g);      return parts.map((part, index) => {     if (part.startsWith('**') && part.endsWith('**')) {       const boldText = part.slice(2, -2);       return React.createElement('span', {          key: `bold-${index}`,          className: 'font-bold'        }, boldText);     }     return part;   }); };  /**  * Get test result information based on statistics with type safety  * @param stats - Test statistics object  * @returns Test result information object  */ export const getTestResult = (stats: TestStats): TestResultInfo => {   const total = stats.correct + stats.incorrect;   const percentage = total > 0 ? Math.round((stats.correct / total) * 100) : 0;      if (percentage >= 80) {     return {        type: 'victory',        message: 'Eccellente! 🏆',        color: 'text-green-600',        bgColor: 'bg-green-50'      };   } else if (percentage >= 60) {     return {        type: 'good',        message: 'Buon lavoro! 👍',        color: 'text-blue-600',        bgColor: 'bg-blue-50'      };   } else {     return {        type: 'defeat',        message: 'Continua a studiare! 📚',        color: 'text-red-600',        bgColor: 'bg-red-50'      };   } };  /**  * Sanitize and validate text input  * @param input - Input string to sanitize  * @param maxLength - Maximum allowed length  * @returns Sanitized string  */ export const sanitizeText = (input?: string | null, maxLength = 1000): string => {   if (!input || typeof input !== 'string') return '';      return input     .trim()     .slice(0, maxLength)     .replace(/\s+/g, ' '); // Replace multiple spaces with single space };  /**  * Truncate text with ellipsis  * @param text - Text to truncate  * @param maxLength - Maximum length before truncation  * @param suffix - Suffix to add when truncated  * @returns Truncated text  */ export const truncateText = (   text: string,    maxLength: number,    suffix = '...' ): string => {   if (!text || text.length <= maxLength) return text;      return text.slice(0, maxLength - suffix.length) + suffix; };  /**  * Capitalize first letter of each word  * @param text - Text to capitalize  * @returns Capitalized text  */ export const capitalizeWords = (text?: string | null): string => {   if (!text || typeof text !== 'string') return '';      return text     .toLowerCase()     .split(' ')     .map(word => word.charAt(0).toUpperCase() + word.slice(1))     .join(' '); };  /**  * Capitalize only the first letter of the text  * @param text - Text to capitalize  * @returns Text with first letter capitalized  */ export const capitalizeFirst = (text?: string | null): string => {   if (!text || typeof text !== 'string') return '';      return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase(); };  /**  * Clean text for comparison (remove accents, normalize case)  * @param text - Text to clean  * @returns Cleaned text for comparison  */ export const cleanForComparison = (text?: string | null): string => {   if (!text || typeof text !== 'string') return '';      return text     .toLowerCase()     .trim()     .normalize('NFD')     .replace(/[\u0300-\u036f]/g, '') // Remove accents     .replace(/[^a-z0-9\s]/g, '') // Keep only alphanumeric and spaces     .replace(/\s+/g, ' '); // Normalize spaces };  /**  * Check if two texts are similar (fuzzy matching)  * @param text1 - First text  * @param text2 - Second text  * @param threshold - Similarity threshold (0-1)  * @returns True if texts are similar  */ export const areTextsSimilar = (   text1?: string | null,    text2?: string | null,    threshold = 0.8 ): boolean => {   if (!text1 || !text2) return false;      const clean1 = cleanForComparison(text1);   const clean2 = cleanForComparison(text2);      if (clean1 === clean2) return true;      // Simple Levenshtein distance calculation   const distance = levenshteinDistance(clean1, clean2);   const maxLength = Math.max(clean1.length, clean2.length);   const similarity = maxLength > 0 ? 1 - (distance / maxLength) : 0;      return similarity >= threshold; };  /**  * Calculate Levenshtein distance between two strings  * @param str1 - First string  * @param str2 - Second string  * @returns Edit distance between strings  */ export const levenshteinDistance = (str1: string, str2: string): number => {   const matrix: number[][] = [];      for (let i = 0; i <= str2.length; i++) {     matrix[i] = [i];   }      for (let j = 0; j <= str1.length; j++) {     matrix[0][j] = j;   }      for (let i = 1; i <= str2.length; i++) {     for (let j = 1; j <= str1.length; j++) {       if (str2.charAt(i - 1) === str1.charAt(j - 1)) {         matrix[i][j] = matrix[i - 1][j - 1];       } else {         matrix[i][j] = Math.min(           matrix[i - 1][j - 1] + 1, // substitution           matrix[i][j - 1] + 1,     // insertion           matrix[i - 1][j] + 1      // deletion         );       }     }   }      return matrix[str2.length][str1.length]; };  /**  * Extract keywords from text  * @param text - Text to extract keywords from  * @param minLength - Minimum keyword length  * @returns Array of keywords  */ export const extractKeywords = (text?: string | null, minLength = 3): string[] => {   if (!text || typeof text !== 'string') return [];      const words = text     .toLowerCase()     .replace(/[^\w\s]/g, '')     .split(/\s+/)     .filter(word => word.length >= minLength);      // Remove duplicates and return   return [...new Set(words)]; };  /**  * Highlight search terms in text  * @param text - Text to highlight in  * @param searchTerm - Term to highlight  * @param className - CSS class for highlighting  * @returns Array of React elements with highlighted terms  */ export const highlightSearchTerm = (   text: string,    searchTerm: string,    className = 'bg-yellow-200' ): FormattedNotePart[] => {   if (!searchTerm.trim()) return [text];      const regex = new RegExp(`(${searchTerm})`, 'gi');   const parts = text.split(regex);      return parts.map((part, index) => {     if (part.toLowerCase() === searchTerm.toLowerCase()) {       return React.createElement('mark', {          key: `highlight-${index}`,          className        }, part);     }     return part;   }); };  /**  * Format time duration in a human-readable way  * @param seconds - Duration in seconds  * @returns Formatted time string  */ export const formatDuration = (seconds: number): string => {   if (seconds < 60) {     return `${Math.round(seconds)}s`;   } else if (seconds < 3600) {     const minutes = Math.floor(seconds / 60);     const remainingSeconds = Math.round(seconds % 60);     return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;   } else {     const hours = Math.floor(seconds / 3600);     const minutes = Math.floor((seconds % 3600) / 60);     return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;   } };  /**  * Format percentage with proper rounding  * @param value - Decimal value (0-1)  * @param decimals - Number of decimal places  * @returns Formatted percentage string  */ export const formatPercentage = (value: number, decimals = 0): string => {   const percentage = Math.round(value * 100 * Math.pow(10, decimals)) / Math.pow(10, decimals);   return `${percentage}%`; };  /**  * Generate a slug from text (URL-friendly)  * @param text - Text to convert to slug  * @returns URL-friendly slug  */ export const generateSlug = (text?: string | null): string => {   if (!text || typeof text !== 'string') return '';      return text     .toLowerCase()     .trim()     .normalize('NFD')     .replace(/[\u0300-\u036f]/g, '') // Remove accents     .replace(/[^a-z0-9\s-]/g, '') // Keep only alphanumeric, spaces, and hyphens     .replace(/\s+/g, '-') // Replace spaces with hyphens     .replace(/-+/g, '-') // Replace multiple hyphens with single     .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens };  /**  * Validate if text contains only allowed characters for English words  * @param text - Text to validate  * @returns True if text is valid English word format  */ export const isValidEnglishWord = (text?: string | null): boolean => {   if (!text || typeof text !== 'string') return false;      // Allow letters, spaces, apostrophes, and hyphens   const englishWordRegex = /^[a-zA-Z\s'-]+$/;   return englishWordRegex.test(text.trim()); };  /**  * Validate if text contains valid Italian characters  * @param text - Text to validate  * @returns True if text is valid Italian format  */ export const isValidItalianText = (text?: string | null): boolean => {   if (!text || typeof text !== 'string') return false;      // Allow letters (including accented), spaces, apostrophes, and hyphens   const italianTextRegex = /^[a-zA-ZÀ-ÿ\s'-]+$/;   return italianTextRegex.test(text.trim()); };

================================================================================


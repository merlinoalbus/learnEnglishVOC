NOME FILE: categoryUtils.js

// /src/utils/categoryUtils.js // This file contains utility functions for managing vocabulary categories. // It provides functions to get the style for a category based on its name, and to retrieve a list of predefined groups. // It is used to ensure consistent styling and categorization of vocabulary words in the application.  import { CATEGORY_STYLES, CATEGORIES } from '../constants/appConstants';  export const getCategoryStyle = (group) => {   if (!group) return CATEGORY_STYLES['DEFAULT'] || {      color: 'from-blue-400 via-blue-500 to-blue-600',      icon: '📚',      bgColor: 'bg-blue-500',     bgGradient: 'bg-gradient-to-br from-blue-500 to-cyan-600'   };      const upperGroup = group ? group.toUpperCase().trim() : '';   return CATEGORY_STYLES[upperGroup] || CATEGORY_STYLES['DEFAULT']; };  export const getPredefinedGroups = () => {   return [...CATEGORIES].sort(); };

================================================================================

NOME FILE: index.js

// ===================================================== // 📁 src/utils/index.js - EXPORTS PULITI // =====================================================  // ✅ Re-export utilities effettivamente utilizzate export * from './categoryUtils'; export * from './textUtils';  // ✅ Export performance utilities utilizzate export {    memoize,    debounce,    deepEqual,   shallowEqual,   createSelector,   compose,   pipe,   once } from './performanceUtils';  // ===================================================== // ✅ Convenience re-exports (utilizzati ovunque) // =====================================================  export { getCategoryStyle, getPredefinedGroups } from './categoryUtils'; export { formatNotes, getTestResult } from './textUtils';  // ===================================================== // ✅ Core utility functions (utilizzate nell'app) // =====================================================  /**  * Generate unique ID  * ✅ UTILIZZATA per generare ID delle parole  */ export const generateId = () => {   return Date.now().toString(36) + Math.random().toString(36).substr(2); };  /**  * Safe JSON parse with fallback  * ✅ UTILIZZATA nel storageService  */ export const safeJSONParse = (jsonString, fallback = null) => {   try {     return JSON.parse(jsonString);   } catch (error) {     console.warn('JSON parse failed:', error);     return fallback;   } };  /**  * Safe JSON stringify  * ✅ UTILIZZATA nel storageService  */ export const safeJSONStringify = (value, fallback = '{}') => {   try {     return JSON.stringify(value);   } catch (error) {     console.warn('JSON stringify failed:', error);     return fallback;   } };  /**  * Format time duration  * ✅ UTILIZZATA in TestView e statistiche  */ export const formatTime = (seconds) => {   if (!seconds || seconds < 0) return '0:00';      const mins = Math.floor(seconds / 60);   const secs = seconds % 60;   return `${mins}:${secs.toString().padStart(2, '0')}`; };  /**  * Format percentage with precision  * ✅ UTILIZZATA nelle statistiche e nei risultati test  */ export const formatPercentage = (value, total, decimals = 0) => {   if (!total || total === 0) return 0;   const percentage = (value / total) * 100;   return Number(percentage.toFixed(decimals)); };  /**  * Check if value is empty  * ✅ UTILIZZATA nelle validazioni  */ export const isEmpty = (value) => {   if (value == null) return true;   if (typeof value === 'string') return value.trim() === '';   if (Array.isArray(value)) return value.length === 0;   if (typeof value === 'object') return Object.keys(value).length === 0;   return false; };  /**  * Pick specific properties from object  * ✅ UTILIZZATA per filtrare dati export/import  */ export const pick = (obj, keys) => {   const result = {};   keys.forEach(key => {     if (key in obj) {       result[key] = obj[key];     }   });   return result; };  /**  * Group array of objects by property  * ✅ UTILIZZATA per raggruppare parole per capitolo  */ export const groupBy = (array, keyOrFn) => {   return array.reduce((groups, item) => {     const key = typeof keyOrFn === 'function' ? keyOrFn(item) : item[keyOrFn];     if (!groups[key]) {       groups[key] = [];     }     groups[key].push(item);     return groups;   }, {}); };  /**  * Sort array by property with direction  * ✅ UTILIZZATA per ordinare parole e statistiche  */ export const sortBy = (array, property, direction = 'asc') => {   return [...array].sort((a, b) => {     const aVal = a[property];     const bVal = b[property];          if (aVal < bVal) return direction === 'asc' ? -1 : 1;     if (aVal > bVal) return direction === 'asc' ? 1 : -1;     return 0;   }); };  /**  * Calculate statistics for array of numbers  * ✅ UTILIZZATA nelle statistiche avanzate  */ export const calculateStats = (numbers) => {   if (!numbers || numbers.length === 0) {     return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };   }      const sum = numbers.reduce((acc, num) => acc + num, 0);   const avg = sum / numbers.length;   const min = Math.min(...numbers);   const max = Math.max(...numbers);      return {     min,     max,     avg: Number(avg.toFixed(2)),     sum,     count: numbers.length   }; };  /**  * Wait for specified time (async sleep)  * ✅ UTILIZZATA in operazioni asincrone  */ export const sleep = (ms) => {   return new Promise(resolve => setTimeout(resolve, ms)); };  /**  * Capitalize first letter of each word  * ✅ UTILIZZATA per formattare testi  */ export const capitalizeWords = (text) => {   return text.replace(/\b\w/g, l => l.toUpperCase()); };  /**  * Truncate text with ellipsis  * ✅ UTILIZZATA per testi lunghi nelle card  */ export const truncate = (text, maxLength = 50) => {   if (!text || text.length <= maxLength) return text;   return text.substring(0, maxLength).trim() + '...'; };

================================================================================

NOME FILE: performanceUtils.js

// ===================================================== // 📁 src/utils/performanceUtils.js - VERSIONE PULITA // ===================================================== // Solo le utilities effettivamente utilizzate nell'app  /**  * Memoization utility for expensive function calls  * ✅ UTILIZZATA in useOptimizedStats e useOptimizedWords  */ export const memoize = (fn, keyGenerator = (...args) => JSON.stringify(args)) => {   const cache = new Map();      return (...args) => {     const key = keyGenerator(...args);          if (cache.has(key)) {       return cache.get(key);     }          const result = fn(...args);     cache.set(key, result);          // Prevent memory leaks by limiting cache size     if (cache.size > 100) {       const firstKey = cache.keys().next().value;       cache.delete(firstKey);     }          return result;   }; };  /**  * Debounce function to limit rapid function calls  * ✅ UTILIZZATA nel storageService per salvare dati  */ export const debounce = (fn, delay = 300) => {   let timeoutId;      return (...args) => {     clearTimeout(timeoutId);     timeoutId = setTimeout(() => fn(...args), delay);   }; };  /**  * Deep equality check for objects and arrays  * ✅ UTILIZZATA in useStoreBridge (anche se sarà rimosso, utile per future comparazioni)  */ export const deepEqual = (a, b) => {   if (a === b) return true;      if (a == null || b == null) return false;      if (typeof a !== typeof b) return false;      if (typeof a !== 'object') return a === b;      if (Array.isArray(a) !== Array.isArray(b)) return false;      if (Array.isArray(a)) {     if (a.length !== b.length) return false;     for (let i = 0; i < a.length; i++) {       if (!deepEqual(a[i], b[i])) return false;     }     return true;   }      const keysA = Object.keys(a);   const keysB = Object.keys(b);      if (keysA.length !== keysB.length) return false;      for (const key of keysA) {     if (!keysB.includes(key)) return false;     if (!deepEqual(a[key], b[key])) return false;   }      return true; };  /**  * Shallow equality check for objects  * ✅ UTILIZZATA per ottimizzazioni React (useMemo, useCallback)  */ export const shallowEqual = (a, b) => {   if (a === b) return true;      if (!a || !b) return false;      const keysA = Object.keys(a);   const keysB = Object.keys(b);      if (keysA.length !== keysB.length) return false;      for (const key of keysA) {     if (a[key] !== b[key]) return false;   }      return true; };  /**  * Create a selector function that memoizes based on input equality  * ✅ UTILIZZATA negli hook per ottimizzazioni useMemo  */ export const createSelector = (selector, equalityFn = shallowEqual) => {   let lastArgs;   let lastResult;      return (...args) => {     if (!lastArgs || !equalityFn(args, lastArgs)) {       lastArgs = args;       lastResult = selector(...args);     }     return lastResult;   }; };  /**  * Compose multiple functions into one  * ✅ UTILIZZATA per creare pipeline di trasformazioni nei dati delle statistiche  */ export const compose = (...fns) => {   return (value) => fns.reduceRight((acc, fn) => fn(acc), value); };  /**  * Pipe multiple functions (left to right composition)  * ✅ UTILIZZATA per elaborazioni dati in useOptimizedStats  */ export const pipe = (...fns) => {   return (value) => fns.reduce((acc, fn) => fn(acc), value); };  /**  * Create a function that only executes once  * ✅ UTILIZZATA per inizializzazioni singole nei hook  */ export const once = (fn) => {   let called = false;   let result;      return (...args) => {     if (!called) {       called = true;       result = fn(...args);     }     return result;   }; };

================================================================================

NOME FILE: retryUtils.js

// ===================================================== // 📁 src/utils/retryUtils.js - Advanced Retry & Timeout Utilities // =====================================================  // ===================================================== // 🔄 EXPONENTIAL BACKOFF RETRY // ===================================================== export const retryWithBackoff = async (   operation,   options = {} ) => {   const {     maxAttempts = 3,     baseDelay = 1000,     maxDelay = 10000,     exponentialBase = 2,     jitter = true,     retryCondition = (error) => true,     onRetry = null,     onFinalFailure = null   } = options;    let lastError;      for (let attempt = 1; attempt <= maxAttempts; attempt++) {     try {       const result = await operation(attempt);       return result;     } catch (error) {       lastError = error;              // Check if we should retry this error       if (!retryCondition(error)) {         throw error;       }              // If this was the last attempt, don't wait       if (attempt === maxAttempts) {         if (onFinalFailure) {           onFinalFailure(error, attempt);         }         throw error;       }              // Calculate delay with exponential backoff       let delay = Math.min(baseDelay * Math.pow(exponentialBase, attempt - 1), maxDelay);              // Add jitter to prevent thundering herd       if (jitter) {         delay += Math.random() * delay * 0.1;       }              // Call retry callback if provided       if (onRetry) {         onRetry(error, attempt, delay);       }              // Wait before next attempt       await new Promise(resolve => setTimeout(resolve, delay));     }   }      throw lastError; };  // ===================================================== // ⏱️ TIMEOUT WRAPPER // ===================================================== export const withTimeout = (operation, timeoutMs, timeoutMessage = 'Operation timed out') => {   return Promise.race([     operation(),     new Promise((_, reject) => {       setTimeout(() => {         reject(new Error(timeoutMessage));       }, timeoutMs);     })   ]); };  // ===================================================== // 🎯 SMART RETRY (AI-specific) // ===================================================== export const smartRetryAI = async (aiOperation, word) => {   return retryWithBackoff(aiOperation, {     maxAttempts: 3,     baseDelay: 2000,     maxDelay: 8000,     retryCondition: (error) => {       // Don't retry API key errors       if (error.message.includes('API key') || error.message.includes('401')) {         return false;       }              // Don't retry quota exceeded       if (error.message.includes('quota') || error.message.includes('limit')) {         return false;       }              // Retry network errors, timeouts, 5xx errors       return error.message.includes('network') ||               error.message.includes('timeout') ||              error.message.includes('fetch') ||              error.message.includes('5');     },     onRetry: (error, attempt, delay) => {       console.log(`🤖 AI Retry ${attempt}/3 for word "${word}" in ${Math.round(delay)}ms:`, error.message);     },     onFinalFailure: (error, attempts) => {       console.error(`❌ AI Service failed for word "${word}" after ${attempts} attempts:`, error);     }   }); };  // ===================================================== // 💾 STORAGE RETRY (localStorage-specific) // ===================================================== export const smartRetryStorage = async (storageOperation, operationName) => {   return retryWithBackoff(storageOperation, {     maxAttempts: 3,     baseDelay: 500,     maxDelay: 2000,     retryCondition: (error) => {       // Don't retry quota exceeded errors       if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {         return false;       }              // Don't retry security errors       if (error.message.includes('SecurityError') || error.message.includes('access denied')) {         return false;       }              // Retry other localStorage errors       return error.message.includes('localStorage') ||               error.message.includes('storage') ||              error.message.includes('access');     },     onRetry: (error, attempt, delay) => {       console.log(`💾 Storage Retry ${attempt}/3 for "${operationName}" in ${Math.round(delay)}ms:`, error.message);     },     onFinalFailure: (error, attempts) => {       console.error(`❌ Storage operation "${operationName}" failed after ${attempts} attempts:`, error);     }   }); };  // ===================================================== // 🌐 NETWORK RETRY (fetch-specific) // ===================================================== export const smartRetryNetwork = async (networkOperation, url) => {   return retryWithBackoff(networkOperation, {     maxAttempts: 3,     baseDelay: 1500,     maxDelay: 6000,     retryCondition: (error) => {       // Don't retry 4xx client errors (except 408, 429)       if (error.message.includes('400') ||            error.message.includes('401') ||            error.message.includes('403') ||            error.message.includes('404')) {         return false;       }              // Retry timeout and 5xx server errors       return error.message.includes('timeout') ||               error.message.includes('network') ||              error.message.includes('fetch') ||              error.message.includes('5');     },     onRetry: (error, attempt, delay) => {       console.log(`🌐 Network Retry ${attempt}/3 for "${url}" in ${Math.round(delay)}ms:`, error.message);     },     onFinalFailure: (error, attempts) => {       console.error(`❌ Network operation for "${url}" failed after ${attempts} attempts:`, error);     }   }); };  // ===================================================== // 🔄 CIRCUIT BREAKER PATTERN // ===================================================== export class CircuitBreaker {   constructor(options = {}) {     this.failureThreshold = options.failureThreshold || 5;     this.recoveryTimeout = options.recoveryTimeout || 60000; // 1 minute     this.monitoringPeriod = options.monitoringPeriod || 10000; // 10 seconds          this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN     this.failureCount = 0;     this.lastFailureTime = null;     this.successCount = 0;   }    async execute(operation) {     if (this.state === 'OPEN') {       if (Date.now() - this.lastFailureTime < this.recoveryTimeout) {         throw new Error('Circuit breaker is OPEN - service temporarily unavailable');       } else {         this.state = 'HALF_OPEN';         this.successCount = 0;       }     }      try {       const result = await operation();       this.onSuccess();       return result;     } catch (error) {       this.onFailure();       throw error;     }   }    onSuccess() {     this.failureCount = 0;          if (this.state === 'HALF_OPEN') {       this.successCount++;       if (this.successCount >= 3) { // 3 successful calls to close circuit         this.state = 'CLOSED';       }     }   }    onFailure() {     this.failureCount++;     this.lastFailureTime = Date.now();          if (this.failureCount >= this.failureThreshold) {       this.state = 'OPEN';     }   }    getState() {     return {       state: this.state,       failureCount: this.failureCount,       lastFailureTime: this.lastFailureTime,       isAvailable: this.state !== 'OPEN'     };   }    reset() {     this.state = 'CLOSED';     this.failureCount = 0;     this.lastFailureTime = null;     this.successCount = 0;   } }  // ===================================================== // 🎛️ OPERATION MANAGER WITH RETRIES // ===================================================== export class OperationManager {   constructor() {     this.operations = new Map();     this.circuitBreakers = new Map();   }    // Register an operation with its retry configuration   registerOperation(name, config = {}) {     this.operations.set(name, {       maxAttempts: config.maxAttempts || 3,       timeout: config.timeout || 30000,       retryCondition: config.retryCondition || (() => true),       circuitBreaker: config.useCircuitBreaker ? new CircuitBreaker(config.circuitBreakerOptions) : null,       ...config     });   }    // Execute an operation with configured retry logic   async execute(operationName, operation, ...args) {     const config = this.operations.get(operationName);          if (!config) {       throw new Error(`Operation "${operationName}" not registered`);     }      const wrappedOperation = async () => {       if (config.timeout) {         return withTimeout(() => operation(...args), config.timeout, `${operationName} timeout`);       }       return operation(...args);     };      if (config.circuitBreaker) {       return config.circuitBreaker.execute(async () => {         return retryWithBackoff(wrappedOperation, {           maxAttempts: config.maxAttempts,           baseDelay: config.baseDelay,           retryCondition: config.retryCondition,           onRetry: config.onRetry,           onFinalFailure: config.onFinalFailure         });       });     } else {       return retryWithBackoff(wrappedOperation, {         maxAttempts: config.maxAttempts,         baseDelay: config.baseDelay,         retryCondition: config.retryCondition,         onRetry: config.onRetry,         onFinalFailure: config.onFinalFailure       });     }   }    // Get operation status   getOperationStatus(operationName) {     const config = this.operations.get(operationName);     if (!config) return null;      return {       name: operationName,       circuitBreaker: config.circuitBreaker ? config.circuitBreaker.getState() : null,       config: {         maxAttempts: config.maxAttempts,         timeout: config.timeout,         useCircuitBreaker: !!config.circuitBreaker       }     };   }    // Reset circuit breaker for an operation   resetOperation(operationName) {     const config = this.operations.get(operationName);     if (config && config.circuitBreaker) {       config.circuitBreaker.reset();     }   }    // Get all operations status   getAllStatus() {     return Array.from(this.operations.keys()).map(name => this.getOperationStatus(name));   } }  // ===================================================== // 🌍 GLOBAL OPERATION MANAGER INSTANCE // ===================================================== export const globalOperationManager = new OperationManager();  // Register common operations globalOperationManager.registerOperation('aiAnalysis', {   maxAttempts: 3,   timeout: 45000,   baseDelay: 2000,   useCircuitBreaker: true,   circuitBreakerOptions: {     failureThreshold: 3,     recoveryTimeout: 120000 // 2 minutes for AI service   },   retryCondition: (error) => {     return !error.message.includes('API key') &&             !error.message.includes('quota') &&            !error.message.includes('401');   } });  globalOperationManager.registerOperation('storageOperation', {   maxAttempts: 3,   timeout: 10000,   baseDelay: 500,   retryCondition: (error) => {     return !error.name?.includes('QuotaExceededError') &&            !error.message.includes('SecurityError');   } });  globalOperationManager.registerOperation('networkRequest', {   maxAttempts: 3,   timeout: 20000,   baseDelay: 1500,   useCircuitBreaker: true,   circuitBreakerOptions: {     failureThreshold: 5,     recoveryTimeout: 60000 // 1 minute for network   },   retryCondition: (error) => {     return !error.message.includes('40') || // Don't retry 4xx except 408, 429            error.message.includes('408') ||            error.message.includes('429');   } });  // ===================================================== // 🔧 UTILITY FUNCTIONS // =====================================================  // Debounced retry - prevents rapid repeated attempts export const debouncedRetry = (operation, delay = 1000) => {   let timeoutId;   let lastPromise;    return (...args) => {     if (timeoutId) {       clearTimeout(timeoutId);     }      if (lastPromise) {       return lastPromise;     }      return new Promise((resolve, reject) => {       timeoutId = setTimeout(async () => {         try {           lastPromise = operation(...args);           const result = await lastPromise;           lastPromise = null;           resolve(result);         } catch (error) {           lastPromise = null;           reject(error);         }       }, delay);     });   }; };  // Batch retry - retry multiple operations together export const batchRetry = async (operations, options = {}) => {   const {     maxAttempts = 3,     failFast = false, // If true, stop on first failure     retryDelay = 1000   } = options;    let attempt = 1;   let results = new Array(operations.length).fill(null);   let errors = new Array(operations.length).fill(null);   let completed = new Array(operations.length).fill(false);    while (attempt <= maxAttempts && !completed.every(Boolean)) {     console.log(`📦 Batch retry attempt ${attempt}/${maxAttempts}`);          const promises = operations.map(async (operation, index) => {       if (completed[index]) return results[index]; // Skip completed operations        try {         const result = await operation();         results[index] = result;         completed[index] = true;         errors[index] = null;         return result;       } catch (error) {         errors[index] = error;         if (failFast) throw error;         return null;       }     });      await Promise.allSettled(promises);      if (failFast && errors.some(error => error !== null)) {       throw errors.find(error => error !== null);     }      // If not all completed and we have more attempts, wait before retry     if (!completed.every(Boolean) && attempt < maxAttempts) {       await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));     }      attempt++;   }    return {     results,     errors,     completed,     successCount: completed.filter(Boolean).length,     failureCount: completed.length - completed.filter(Boolean).length   }; };  // Progressive timeout - increase timeout on each retry export const progressiveTimeout = (baseTimeout, attempt, maxTimeout = baseTimeout * 5) => {   return Math.min(baseTimeout * Math.pow(1.5, attempt - 1), maxTimeout); };  export default {   retryWithBackoff,   withTimeout,   smartRetryAI,   smartRetryStorage,   smartRetryNetwork,   CircuitBreaker,   OperationManager,   globalOperationManager,   debouncedRetry,   batchRetry,   progressiveTimeout };

================================================================================

NOME FILE: textUtils.js

// /src/utils/textUtils.js // This file contains utility functions for formatting notes and calculating test results. // It provides functions to format notes with specific keywords and to determine the result of a vocabulary test. // The `formatNotes` function processes notes to highlight keywords, while the `getTestResult` function evaluates test statistics to provide feedback based on the user's performance. // These utilities are essential for enhancing the user experience in a vocabulary learning application, making it easier for users to understand notes and assess their test results. //  * @returns {Array} An array of React elements or strings representing the formatted notes. //  */       //  import React from 'react';  export const formatNotes = (notes) => {   if (!notes) return null;      const keywords = [     'Altri Significati', 'Altre Traduzioni', 'Espressioni', 'Verbo Irregolare',      'Pronuncia', 'Sinonimi', 'Esempi', 'Attenzione', 'Nota', 'Importante',     'Plurale irregolare', 'Tecnologia', 'Posizione', 'Contrario', 'Espressione',     'Verbo', 'Phrasal verbs', 'Differenza', 'Abbreviazione', 'Sinonimo',     'Tipico britannico', 'Vestiti', 'Preposizioni', 'Avverbio', 'Sostantivo',     'Aggettivo', 'Congiunzione', 'Interiezione', 'Participio', 'Gerundio',     'Passato', 'Presente', 'Futuro', 'Condizionale', 'Imperativo', 'Infinito',     'Formale', 'Informale', 'Slang', 'Americano', 'Britannico', 'Australiano',     'Tempo', 'Luogo', 'Modo', 'Causa', 'Effetto', 'Scopo', 'Confronto',     'Origine', 'Destinazione', 'Materiale', 'Colore', 'Forma', 'Dimensione',     'Quantità', 'Frequenza', 'Durata', 'Velocità', 'Temperatura', 'Peso',     'Struttura', 'Espressione fissa', 'Figurativo', 'Specificità', 'Pattern',     'Più specifico di'   ];      let formattedText = notes;      keywords.forEach(keyword => {     const regex = new RegExp(`(${keyword})\\s*:`, 'gi');     formattedText = formattedText.replace(regex, `**$1:**`);   });      formattedText = formattedText.replace(/^([A-Za-z\s]+):/gm, '**$1:**');      const parts = formattedText.split(/(\*\*[^*]+\*\*)/g);      return parts.map((part, index) => {     if (part.startsWith('**') && part.endsWith('**')) {       const boldText = part.slice(2, -2);       return React.createElement('span', { key: index, className: 'font-bold' }, boldText);     }     return part;   }); };  export const getTestResult = (stats) => {   const total = stats.correct + stats.incorrect;   const percentage = total > 0 ? Math.round((stats.correct / total) * 100) : 0;      if (percentage >= 80) {     return { type: 'victory', message: 'Eccellente! 🏆', color: 'text-green-600', bgColor: 'bg-green-50' };   } else if (percentage >= 60) {     return { type: 'good', message: 'Buon lavoro! 👍', color: 'text-blue-600', bgColor: 'bg-blue-50' };   } else {     return { type: 'defeat', message: 'Continua a studiare! 📚', color: 'text-red-600', bgColor: 'bg-red-50' };   } };

================================================================================


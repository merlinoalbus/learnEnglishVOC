NOME FILE: categoryUtils.js

import { EXPANDED_CATEGORY_STYLES, WORD_CATEGORIES, } from "../types/entities/Word.types"; export const getCategoryStyle = (group) => { if (!group) return ( EXPANDED_CATEGORY_STYLES["DEFAULT"] || { color: "from-blue-400 via-blue-500 to-blue-600", icon: "📚", bgColor: "bg-blue-500", bgGradient: "bg-gradient-to-br from-blue-500 to-cyan-600", } ); const upperGroup = group ? group.toUpperCase().trim() : ""; return ( EXPANDED_CATEGORY_STYLES[upperGroup] || EXPANDED_CATEGORY_STYLES["DEFAULT"] ); }; export const getPredefinedGroups = () => { return [...WORD_CATEGORIES].sort(); };

================================================================================

NOME FILE: index.js

export * from './categoryUtils'; export * from './textUtils'; export { memoize, debounce, deepEqual, shallowEqual, createSelector, compose, pipe, once } from './performanceUtils'; export { getCategoryStyle, getPredefinedGroups } from './categoryUtils'; export { formatNotes, getTestResult } from './textUtils'; export const generateId = () => { return Date.now().toString(36) + Math.random().toString(36).substr(2); }; export const safeJSONParse = (jsonString, fallback = null) => { try { return JSON.parse(jsonString); } catch (error) { console.warn('JSON parse failed:', error); return fallback; } }; export const safeJSONStringify = (value, fallback = '{}') => { try { return JSON.stringify(value); } catch (error) { console.warn('JSON stringify failed:', error); return fallback; } }; export const formatTime = (seconds) => { if (!seconds || seconds < 0) return '0:00'; const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }; export const formatPercentage = (value, total, decimals = 0) => { if (!total || total === 0) return 0; const percentage = (value / total) * 100; return Number(percentage.toFixed(decimals)); }; export const isEmpty = (value) => { if (value == null) return true; if (typeof value === 'string') return value.trim() === ''; if (Array.isArray(value)) return value.length === 0; if (typeof value === 'object') return Object.keys(value).length === 0; return false; }; export const pick = (obj, keys) => { const result = {}; keys.forEach(key => { if (key in obj) { result[key] = obj[key]; } }); return result; }; export const groupBy = (array, keyOrFn) => { return array.reduce((groups, item) => { const key = typeof keyOrFn === 'function' ? keyOrFn(item) : item[keyOrFn]; if (!groups[key]) { groups[key] = []; } groups[key].push(item); return groups; }, {}); }; export const sortBy = (array, property, direction = 'asc') => { return [...array].sort((a, b) => { const aVal = a[property]; const bVal = b[property]; if (aVal < bVal) return direction === 'asc' ? -1 : 1; if (aVal > bVal) return direction === 'asc' ? 1 : -1; return 0; }); }; export const calculateStats = (numbers) => { if (!numbers || numbers.length === 0) { return { min: 0, max: 0, avg: 0, sum: 0, count: 0 }; } const sum = numbers.reduce((acc, num) => acc + num, 0); const avg = sum / numbers.length; const min = Math.min(...numbers); const max = Math.max(...numbers); return { min, max, avg: Number(avg.toFixed(2)), sum, count: numbers.length }; }; export const sleep = (ms) => { return new Promise(resolve => setTimeout(resolve, ms)); }; export const capitalizeWords = (text) => { return text.replace(/\b\w/g, l => l.toUpperCase()); }; export const truncate = (text, maxLength = 50) => { if (!text || text.length <= maxLength) return text; return text.substring(0, maxLength).trim() + '...'; };

================================================================================

NOME FILE: performanceUtils.js

export const memoize = ( fn, keyGenerator = (...args) => JSON.stringify(args) ) => { const cache = new Map(); return (...args) => { const key = keyGenerator(...args); if (cache.has(key)) { return cache.get(key); } const result = fn(...args); cache.set(key, result); if (cache.size > 100) { const firstKey = cache.keys().next().value; cache.delete(firstKey); } return result; }; }; export const debounce = (fn, delay = 300) => { let timeoutId; return (...args) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => fn(...args), delay); }; }; export const deepEqual = (a, b) => { if (a === b) return true; if (a == null || b == null) return false; if (typeof a !== typeof b) return false; if (typeof a !== "object") return a === b; if (Array.isArray(a) !== Array.isArray(b)) return false; if (Array.isArray(a)) { if (a.length !== b.length) return false; for (let i = 0; i < a.length; i++) { if (!deepEqual(a[i], b[i])) return false; } return true; } const keysA = Object.keys(a); const keysB = Object.keys(b); if (keysA.length !== keysB.length) return false; for (const key of keysA) { if (!keysB.includes(key)) return false; if (!deepEqual(a[key], b[key])) return false; } return true; }; export const shallowEqual = (a, b) => { if (a === b) return true; if (!a || !b) return false; const keysA = Object.keys(a); const keysB = Object.keys(b); if (keysA.length !== keysB.length) return false; for (const key of keysA) { if (a[key] !== b[key]) return false; } return true; }; export const createSelector = (selector, equalityFn = shallowEqual) => { let lastArgs; let lastResult; return (...args) => { if (!lastArgs || !equalityFn(args, lastArgs)) { lastArgs = args; lastResult = selector(...args); } return lastResult; }; }; export const compose = (...fns) => { return (value) => fns.reduceRight((acc, fn) => fn(acc), value); }; export const pipe = (...fns) => { return (value) => fns.reduce((acc, fn) => fn(acc), value); }; export const once = (fn) => { let called = false; let result; return (...args) => { if (!called) { called = true; result = fn(...args); } return result; }; };

================================================================================

NOME FILE: retryUtils.js

export const retryWithBackoff = async ( operation, options = {} ) => { const { maxAttempts = 3, baseDelay = 1000, maxDelay = 10000, exponentialBase = 2, jitter = true, retryCondition = (error) => true, onRetry = null, onFinalFailure = null } = options; let lastError; for (let attempt = 1; attempt <= maxAttempts; attempt++) { try { const result = await operation(attempt); return result; } catch (error) { lastError = error; if (!retryCondition(error)) { throw error; } if (attempt === maxAttempts) { if (onFinalFailure) { onFinalFailure(error, attempt); } throw error; } let delay = Math.min(baseDelay * Math.pow(exponentialBase, attempt - 1), maxDelay); if (jitter) { delay += Math.random() * delay * 0.1; } if (onRetry) { onRetry(error, attempt, delay); } await new Promise(resolve => setTimeout(resolve, delay)); } } throw lastError; }; export const withTimeout = (operation, timeoutMs, timeoutMessage = 'Operation timed out') => { return Promise.race([ operation(), new Promise((_, reject) => { setTimeout(() => { reject(new Error(timeoutMessage)); }, timeoutMs); }) ]); }; export const smartRetryAI = async (aiOperation, word) => { return retryWithBackoff(aiOperation, { maxAttempts: 3, baseDelay: 2000, maxDelay: 8000, retryCondition: (error) => { if (error.message.includes('API key') || error.message.includes('401')) { return false; } if (error.message.includes('quota') || error.message.includes('limit')) { return false; } return error.message.includes('network') || error.message.includes('timeout') || error.message.includes('fetch') || error.message.includes('5'); }, onRetry: (error, attempt, delay) => { console.log(`🤖 AI Retry ${attempt}/3 for word "${word}" in ${Math.round(delay)}ms:`, error.message); }, onFinalFailure: (error, attempts) => { console.error(`❌ AI Service failed for word "${word}" after ${attempts} attempts:`, error); } }); }; export const smartRetryStorage = async (storageOperation, operationName) => { return retryWithBackoff(storageOperation, { maxAttempts: 3, baseDelay: 500, maxDelay: 2000, retryCondition: (error) => { if (error.name === 'QuotaExceededError' || error.message.includes('quota')) { return false; } if (error.message.includes('SecurityError') || error.message.includes('access denied')) { return false; } return error.message.includes('localStorage') || error.message.includes('storage') || error.message.includes('access'); }, onRetry: (error, attempt, delay) => { console.log(`💾 Storage Retry ${attempt}/3 for "${operationName}" in ${Math.round(delay)}ms:`, error.message); }, onFinalFailure: (error, attempts) => { console.error(`❌ Storage operation "${operationName}" failed after ${attempts} attempts:`, error); } }); }; export const smartRetryNetwork = async (networkOperation, url) => { return retryWithBackoff(networkOperation, { maxAttempts: 3, baseDelay: 1500, maxDelay: 6000, retryCondition: (error) => { if (error.message.includes('400') || error.message.includes('401') || error.message.includes('403') || error.message.includes('404')) { return false; } return error.message.includes('timeout') || error.message.includes('network') || error.message.includes('fetch') || error.message.includes('5'); }, onRetry: (error, attempt, delay) => { console.log(`🌐 Network Retry ${attempt}/3 for "${url}" in ${Math.round(delay)}ms:`, error.message); }, onFinalFailure: (error, attempts) => { console.error(`❌ Network operation for "${url}" failed after ${attempts} attempts:`, error); } }); }; export class CircuitBreaker { constructor(options = {}) { this.failureThreshold = options.failureThreshold || 5; this.recoveryTimeout = options.recoveryTimeout || 60000; this.monitoringPeriod = options.monitoringPeriod || 10000; this.state = 'CLOSED'; this.failureCount = 0; this.lastFailureTime = null; this.successCount = 0; } async execute(operation) { if (this.state === 'OPEN') { if (Date.now() - this.lastFailureTime < this.recoveryTimeout) { throw new Error('Circuit breaker is OPEN - service temporarily unavailable'); } else { this.state = 'HALF_OPEN'; this.successCount = 0; } } try { const result = await operation(); this.onSuccess(); return result; } catch (error) { this.onFailure(); throw error; } } onSuccess() { this.failureCount = 0; if (this.state === 'HALF_OPEN') { this.successCount++; if (this.successCount >= 3) { this.state = 'CLOSED'; } } } onFailure() { this.failureCount++; this.lastFailureTime = Date.now(); if (this.failureCount >= this.failureThreshold) { this.state = 'OPEN'; } } getState() { return { state: this.state, failureCount: this.failureCount, lastFailureTime: this.lastFailureTime, isAvailable: this.state !== 'OPEN' }; } reset() { this.state = 'CLOSED'; this.failureCount = 0; this.lastFailureTime = null; this.successCount = 0; } } export class OperationManager { constructor() { this.operations = new Map(); this.circuitBreakers = new Map(); } registerOperation(name, config = {}) { this.operations.set(name, { maxAttempts: config.maxAttempts || 3, timeout: config.timeout || 30000, retryCondition: config.retryCondition || (() => true), circuitBreaker: config.useCircuitBreaker ? new CircuitBreaker(config.circuitBreakerOptions) : null, ...config }); } async execute(operationName, operation, ...args) { const config = this.operations.get(operationName); if (!config) { throw new Error(`Operation "${operationName}" not registered`); } const wrappedOperation = async () => { if (config.timeout) { return withTimeout(() => operation(...args), config.timeout, `${operationName} timeout`); } return operation(...args); }; if (config.circuitBreaker) { return config.circuitBreaker.execute(async () => { return retryWithBackoff(wrappedOperation, { maxAttempts: config.maxAttempts, baseDelay: config.baseDelay, retryCondition: config.retryCondition, onRetry: config.onRetry, onFinalFailure: config.onFinalFailure }); }); } else { return retryWithBackoff(wrappedOperation, { maxAttempts: config.maxAttempts, baseDelay: config.baseDelay, retryCondition: config.retryCondition, onRetry: config.onRetry, onFinalFailure: config.onFinalFailure }); } } getOperationStatus(operationName) { const config = this.operations.get(operationName); if (!config) return null; return { name: operationName, circuitBreaker: config.circuitBreaker ? config.circuitBreaker.getState() : null, config: { maxAttempts: config.maxAttempts, timeout: config.timeout, useCircuitBreaker: !!config.circuitBreaker } }; } resetOperation(operationName) { const config = this.operations.get(operationName); if (config && config.circuitBreaker) { config.circuitBreaker.reset(); } } getAllStatus() { return Array.from(this.operations.keys()).map(name => this.getOperationStatus(name)); } } export const globalOperationManager = new OperationManager(); globalOperationManager.registerOperation('aiAnalysis', { maxAttempts: 3, timeout: 45000, baseDelay: 2000, useCircuitBreaker: true, circuitBreakerOptions: { failureThreshold: 3, recoveryTimeout: 120000 }, retryCondition: (error) => { return !error.message.includes('API key') && !error.message.includes('quota') && !error.message.includes('401'); } }); globalOperationManager.registerOperation('storageOperation', { maxAttempts: 3, timeout: 10000, baseDelay: 500, retryCondition: (error) => { return !error.name?.includes('QuotaExceededError') && !error.message.includes('SecurityError'); } }); globalOperationManager.registerOperation('networkRequest', { maxAttempts: 3, timeout: 20000, baseDelay: 1500, useCircuitBreaker: true, circuitBreakerOptions: { failureThreshold: 5, recoveryTimeout: 60000 }, retryCondition: (error) => { return !error.message.includes('40') || error.message.includes('408') || error.message.includes('429'); } }); export const debouncedRetry = (operation, delay = 1000) => { let timeoutId; let lastPromise; return (...args) => { if (timeoutId) { clearTimeout(timeoutId); } if (lastPromise) { return lastPromise; } return new Promise((resolve, reject) => { timeoutId = setTimeout(async () => { try { lastPromise = operation(...args); const result = await lastPromise; lastPromise = null; resolve(result); } catch (error) { lastPromise = null; reject(error); } }, delay); }); }; }; export const batchRetry = async (operations, options = {}) => { const { maxAttempts = 3, failFast = false, retryDelay = 1000 } = options; let attempt = 1; let results = new Array(operations.length).fill(null); let errors = new Array(operations.length).fill(null); let completed = new Array(operations.length).fill(false); while (attempt <= maxAttempts && !completed.every(Boolean)) { console.log(`📦 Batch retry attempt ${attempt}/${maxAttempts}`); const promises = operations.map(async (operation, index) => { if (completed[index]) return results[index]; try { const result = await operation(); results[index] = result; completed[index] = true; errors[index] = null; return result; } catch (error) { errors[index] = error; if (failFast) throw error; return null; } }); await Promise.allSettled(promises); if (failFast && errors.some(error => error !== null)) { throw errors.find(error => error !== null); } if (!completed.every(Boolean) && attempt < maxAttempts) { await new Promise(resolve => setTimeout(resolve, retryDelay * attempt)); } attempt++; } return { results, errors, completed, successCount: completed.filter(Boolean).length, failureCount: completed.length - completed.filter(Boolean).length }; }; export const progressiveTimeout = (baseTimeout, attempt, maxTimeout = baseTimeout * 5) => { return Math.min(baseTimeout * Math.pow(1.5, attempt - 1), maxTimeout); }; const retryUtilsExport = { retryWithBackoff, withTimeout, smartRetryAI, smartRetryStorage, smartRetryNetwork, CircuitBreaker, OperationManager, globalOperationManager, debouncedRetry, progressiveTimeout }; export default retryUtilsExport;

================================================================================

NOME FILE: textUtils.js

import React from 'react'; export const formatNotes = (notes) => { if (!notes) return null; const keywords = [ 'Altri Significati', 'Altre Traduzioni', 'Espressioni', 'Verbo Irregolare', 'Pronuncia', 'Sinonimi', 'Esempi', 'Attenzione', 'Nota', 'Importante', 'Plurale irregolare', 'Tecnologia', 'Posizione', 'Contrario', 'Espressione', 'Verbo', 'Phrasal verbs', 'Differenza', 'Abbreviazione', 'Sinonimo', 'Tipico britannico', 'Vestiti', 'Preposizioni', 'Avverbio', 'Sostantivo', 'Aggettivo', 'Congiunzione', 'Interiezione', 'Participio', 'Gerundio', 'Passato', 'Presente', 'Futuro', 'Condizionale', 'Imperativo', 'Infinito', 'Formale', 'Informale', 'Slang', 'Americano', 'Britannico', 'Australiano', 'Tempo', 'Luogo', 'Modo', 'Causa', 'Effetto', 'Scopo', 'Confronto', 'Origine', 'Destinazione', 'Materiale', 'Colore', 'Forma', 'Dimensione', 'Quantità', 'Frequenza', 'Durata', 'Velocità', 'Temperatura', 'Peso', 'Struttura', 'Espressione fissa', 'Figurativo', 'Specificità', 'Pattern', 'Più specifico di' ]; let formattedText = notes; keywords.forEach(keyword => { const regex = new RegExp(`(${keyword})\\s*:`, 'gi'); formattedText = formattedText.replace(regex, `**$1:**`); }); formattedText = formattedText.replace(/^([A-Za-z\s]+):/gm, '**$1:**'); const parts = formattedText.split(/(\*\*[^*]+\*\*)/g); return parts.map((part, index) => { if (part.startsWith('**') && part.endsWith('**')) { const boldText = part.slice(2, -2); return React.createElement('span', { key: index, className: 'font-bold' }, boldText); } return part; }); }; export const getTestResult = (stats) => { const total = stats.correct + stats.incorrect; const percentage = total > 0 ? Math.round((stats.correct / total) * 100) : 0; if (percentage >= 80) { return { type: 'victory', message: 'Eccellente! 🏆', color: 'text-green-600', bgColor: 'bg-green-50' }; } else if (percentage >= 60) { return { type: 'good', message: 'Buon lavoro! 👍', color: 'text-blue-600', bgColor: 'bg-blue-50' }; } else { return { type: 'defeat', message: 'Continua a studiare! 📚', color: 'text-red-600', bgColor: 'bg-red-50' }; } };

================================================================================


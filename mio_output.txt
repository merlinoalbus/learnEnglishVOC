NOME FILE: App.js

// =====================================================
// 📁 src/App.js - VERSIONE PULITA (Dual-System Rimosso)
// =====================================================

import React from 'react';
import { AppProvider } from './contexts/AppContext';
import { NotificationProvider } from './contexts/NotificationContext';
import { AppLayout } from './layouts/AppLayout';
import { AppRouter } from './components/AppRouter';
import { ErrorBoundary } from './components/ErrorBoundary';
import './App.css';

// =====================================================
// 🧹 CLEANED: App Component (Dual-System Rimosso)
// =====================================================
const VocabularyApp = () => {
  return (
    <ErrorBoundary>
      <NotificationProvider>
        <AppProvider>
          <AppLayout>
            <AppRouter />
          </AppLayout>
        </AppProvider>
      </NotificationProvider>
    </ErrorBoundary>
  );
};

export default VocabularyApp;

================================================================================

NOME FILE: index.js

// /src/index.js
// This file is the entry point for the React application.
// It imports the necessary styles and renders the main App component into the root element of the HTML document.
// It uses ReactDOM to create a root and render the App component wrapped in React.StrictMode.
// This setup ensures that the application is ready for development and production builds with React's best practices.
// It is essential for initializing the React application and providing a consistent structure for rendering components.

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


================================================================================

NOME FILE: components\AddWordForm.js

// =====================================================
// 📁 src/components/AddWordForm.js - VERSIONE ENHANCED con campo "Difficile"
// =====================================================
import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Textarea } from './ui/textarea';
import { Plus, Edit3, Check, Sparkles, Loader2, Wand2, AlertTriangle } from 'lucide-react';
import { getPredefinedGroups, getCategoryStyle } from '../utils/categoryUtils';
import { useNotification } from '../contexts/NotificationContext';

const AddWordForm = ({ onAddWord, editingWord, onClearForm }) => {
  const [formData, setFormData] = useState({
    english: '',
    italian: '',
    group: '',
    sentence: '',
    notes: '',
    chapter: '',
    learned: false,
    difficult: false // ⭐ NEW: Difficult flag
  });
  const [showAdvancedForm, setShowAdvancedForm] = useState(false);
  const [isAiLoading, setIsAiLoading] = useState(false);

  const { showNotification, showError, showWarning, showSuccess } = useNotification();

  // Gemini API Configuration
  const GEMINI_API_KEY = 'AIzaSyCHftv0ACPTtX7unUKg6y_eqb09mBobTAM';
  const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

  // Funzione di fallback per categorizzare le parole
  const categorizeWordFallback = (word) => {
    const wordLower = word.toLowerCase();
    
    // Pattern per verbi comuni
    if (wordLower.match(/^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/)) {
      return 'VERBI';
    }
    
    // Pattern per verbi irregolari comuni
    if (wordLower.match(/^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/)) {
      return 'VERBI_IRREGOLARI';
    }
    
    // Pattern per aggettivi
    if (wordLower.match(/^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/) || 
        wordLower.match(/^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/)) {
      return 'AGGETTIVI';
    }
    
    // Pattern per tecnologia
    if (wordLower.match(/^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/)) {
      return 'TECNOLOGIA';
    }
    
    // Pattern per famiglia
    if (wordLower.match(/^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/)) {
      return 'FAMIGLIA';
    }
    
    // Pattern per emozioni positive
    if (wordLower.match(/^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/)) {
      return 'EMOZIONI_POSITIVE';
    }
    
    // Pattern per emozioni negative
    if (wordLower.match(/^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/)) {
      return 'EMOZIONI_NEGATIVE';
    }
    
    // Pattern per lavoro
    if (wordLower.match(/^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/)) {
      return 'LAVORO';
    }
    
    // Pattern per vestiti
    if (wordLower.match(/^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/)) {
      return 'VESTITI';
    }
    
    // Default: prova a determinare se è un sostantivo
    return 'SOSTANTIVI';
  };

  useEffect(() => {
    if (editingWord) {
      setFormData({
        english: editingWord.english || '',
        italian: editingWord.italian || '',
        group: editingWord.group || '',
        sentence: editingWord.sentence || '',
        notes: editingWord.notes || '',
        chapter: editingWord.chapter || '',
        learned: editingWord.learned || false,
        difficult: editingWord.difficult || false // ⭐ NEW: Load difficult status
      });
      setShowAdvancedForm(true);
    }
  }, [editingWord]);

  const callGeminiAPI = async (englishWord) => {
    const availableGroups = getPredefinedGroups();
    const groupsList = availableGroups.join(', ');
    
    const prompt = `
Analizza la parola inglese "${englishWord}" e fornisci le seguenti informazioni in formato JSON:

{
  "italian": "traduzione principale in italiano (solo la traduzione più comune)",
  "group": "DEVE essere esattamente una di queste categorie: ${groupsList}. Scegli quella più appropriata per la parola.",
  "sentence": "frase d'esempio in inglese che usa la parola",
  "notes": "note aggiuntive con altre traduzioni, sinonimi, forme irregolari, etc. Formatta come: 'Altri Significati: ... Sinonimi: ... Verbo Irregolare: ... etc.'",
  "chapter": "lascia vuoto, sarà compilato dall'utente"
}

REGOLE IMPORTANTI:
- Rispondi SOLO con il JSON valido, nessun altro testo
- Il campo "group" DEVE essere esattamente una di queste opzioni: ${groupsList}
- Per i verbi irregolari, usa "VERBI_IRREGOLARI" e specifica le forme nel campo notes
- Per verbi regolari, usa "VERBI"
- Includi sempre almeno 2-3 significati alternativi nelle note se esistono
- La frase deve essere semplice e chiara
- Il campo "chapter" deve rimanere vuoto (stringa vuota)
- Se la parola non si adatta perfettamente a nessuna categoria, scegli quella più vicina

ESEMPI:
- "run" → group: "VERBI_IRREGOLARI" 
- "beautiful" → group: "AGGETTIVI"
- "computer" → group: "TECNOLOGIA"
- "father" → group: "FAMIGLIA"
- "happy" → group: "EMOZIONI_POSITIVE"
`;

    try {
      const response = await fetch(GEMINI_API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!content) {
        throw new Error('Nessuna risposta dall\'AI');
      }

      // Extract JSON from the response (remove any markdown formatting)
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('Formato risposta non valido');
      }

      const parsedData = JSON.parse(jsonMatch[0]);
      
      // Validazione categoria: deve essere una delle categorie predefinite
      const availableGroups = getPredefinedGroups();
      if (parsedData.group && !availableGroups.includes(parsedData.group)) {
        console.warn(`Categoria AI "${parsedData.group}" non valida. Uso categoria di fallback.`);
        parsedData.group = categorizeWordFallback(englishWord);
      }
      
      return parsedData;

    } catch (error) {
      console.error('Gemini API Error:', error);
      throw error;
    }
  };

  const handleAiAssist = async () => {
    if (!formData.english.trim()) {
      showWarning('⚠️ Inserisci prima una parola inglese!');
      return;
    }

    setIsAiLoading(true);
    
    try {
      showNotification('🤖 L\'AI sta analizzando la parola...', 'info');
      
      const aiData = await callGeminiAPI(formData.english.trim());
      
      if (!aiData.italian) {
        throw new Error('L\'AI non ha fornito una traduzione valida');
      }
      
      setFormData(prev => ({
        ...prev,
        italian: aiData.italian || prev.italian,
        group: aiData.group || prev.group,
        sentence: aiData.sentence || prev.sentence,
        notes: aiData.notes || prev.notes,
        chapter: aiData.chapter || prev.chapter
        // learned e difficult rimangono invariati (non modificati dall'AI)
      }));

      setShowAdvancedForm(true);
      
      const availableGroups = getPredefinedGroups();
      if (aiData.group && !availableGroups.includes(aiData.group)) {
        showSuccess('✨ Dati compilati! (Categoria corretta automaticamente)');
      } else {
        showSuccess('✨ Dati compilati dall\'AI con successo!');
      }
      
    } catch (error) {
      console.error('AI Assist Error:', error);
      showError(error, 'AI Assistant');
    } finally {
      setIsAiLoading(false);
    }
  };

  const handleSubmit = () => {
    if (!formData.english.trim() || !formData.italian.trim()) {
      showWarning('⚠️ Parola inglese e traduzione sono obbligatorie!');
      return;
    }

    try {
      onAddWord({
        english: formData.english.trim(),
        italian: formData.italian.trim(),
        group: formData.group.trim() || null,
        sentence: formData.sentence.trim() || null,
        notes: formData.notes.trim() || null,
        chapter: formData.chapter.trim() || null,
        learned: formData.learned,
        difficult: formData.difficult // ⭐ NEW: Include difficult status
      });
      
      // Reset form sempre dopo salvataggio (sia nuova parola che modifica)
      setFormData({
        english: '',
        italian: '',
        group: '',
        sentence: '',
        notes: '',
        chapter: '',
        learned: false,
        difficult: false // ⭐ NEW: Reset difficult status
      });
      setShowAdvancedForm(false);
      
    } catch (error) {
      console.error('Error adding word:', error);
      showError(error, 'Add Word');
    }
  };

  const handleClear = () => {
    setFormData({
      english: '',
      italian: '',
      group: '',
      sentence: '',
      notes: '',
      chapter: '',
      learned: false,
      difficult: false // ⭐ NEW: Reset difficult status
    });
    setShowAdvancedForm(false);
    onClearForm();
  };

  const handleInputChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <Card data-form-section className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className={editingWord ? "bg-gradient-to-r from-blue-500 to-purple-600 text-white" : ""}>
        <CardTitle className={`flex items-center justify-between ${editingWord ? "text-white" : "text-gray-800"}`}>
          {editingWord ? (
            <div className="flex items-center gap-3">
              <Edit3 className="w-6 h-6" />
              <span>Modifica Parola: {editingWord.english}</span>
            </div>
          ) : (
            <div className="flex items-center gap-3">
              <Plus className="w-6 h-6 text-green-600" />
              <span className="bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent">
                Aggiungi Nuove Parole
              </span>
            </div>
          )}
          <div className="flex gap-2">
            {editingWord && (
              <Button 
                variant="ghost" 
                size="sm"
                onClick={handleClear}
                className="text-white hover:bg-white/20"
              >
                ✕ Annulla
              </Button>
            )}
            <Button 
              variant="ghost" 
              size="sm"
              onClick={() => setShowAdvancedForm(!showAdvancedForm)}
              className={editingWord ? "text-white hover:bg-white/20" : "text-gray-600 hover:bg-gray-100"}
            >
              {showAdvancedForm ? 'Forma Semplice' : 'Forma Avanzata'}
            </Button>
          </div>
        </CardTitle>
        {editingWord && (
          <div className="text-blue-100 bg-blue-600/20 p-3 rounded-xl mt-4">
            💡 Stai modificando la parola "<strong>{editingWord.english}</strong>". 
            Cambia i campi che vuoi aggiornare e clicca "Salva Modifiche".
          </div>
        )}
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Input
              placeholder="Parola inglese *"
              value={formData.english}
              onChange={(e) => handleInputChange('english', e.target.value)}
              className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors h-12"
              required
            />
            
            <Input
              placeholder="Traduzione italiana *"
              value={formData.italian}
              onChange={(e) => handleInputChange('italian', e.target.value)}
              className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors h-12"
              required
            />
          </div>

          {/* AI Assistant Button */}
          <Button
            onClick={handleAiAssist}
            disabled={isAiLoading || !formData.english.trim()}
            className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white py-4 text-lg rounded-xl shadow-lg transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
          >
            {isAiLoading ? (
              <>
                <Loader2 className="w-6 h-6 mr-3 animate-spin" />
                🤖 AI sta pensando...
              </>
            ) : (
              <>
                <Sparkles className="w-6 h-6 mr-3" />
                ✨ AI Assistant - Compila Automaticamente Tutti i Campi
              </>
            )}
          </Button>

          {/* AI Notice */}
          {formData.italian && !editingWord && (
            <div className="p-4 bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200 rounded-2xl">
              <div className="flex items-center gap-3">
                <Wand2 className="w-6 h-6 text-purple-600" />
                <p className="text-purple-800 font-medium">
                  💡 Usa l'AI Assistant per compilare automaticamente tutti i campi!
                </p>
              </div>
            </div>
          )}

          {/* Info sui nuovi campi */}
          {showAdvancedForm && (
            <div className="p-4 bg-gradient-to-r from-green-50 to-blue-50 border-2 border-green-200 rounded-2xl mb-4">
              <div className="flex items-center gap-3 mb-2">
                <span className="text-2xl">📚</span>
                <h4 className="font-bold text-green-800">Gestione Avanzata Vocabolario</h4>
              </div>
              <div className="text-sm text-green-700 space-y-1">
                <p>• <strong>Capitolo:</strong> Organizza le parole per capitoli del libro (es. 1, 2A, Unit 5)</p>
                <p>• <strong>Parola Appresa:</strong> Le parole apprese rimangono nel vocabolario ma vengono saltate nei test</p>
                <p>• <strong>Parola Difficile:</strong> ⭐ Marca le parole difficili per test specifici</p>
                <p>• <strong>Selezione Test:</strong> Potrai scegliere quali capitoli includere nei test</p>
              </div>
            </div>
          )}

          {showAdvancedForm && (
            <div className="space-y-6 p-6 bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl border-2 border-blue-200 animate-fade-in">
              <h4 className="font-bold text-blue-800 text-lg flex items-center gap-2">
                <span>📋</span> Informazioni Aggiuntive
              </h4>
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>📂</span> Gruppo/Categoria
                  </label>
                  <select
                    value={formData.group}
                    onChange={(e) => handleInputChange('group', e.target.value)}
                    className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors bg-white"
                  >
                    <option value="">Nessun gruppo</option>
                    {getPredefinedGroups().map(group => (
                      <option key={group} value={group}>
                        {getCategoryStyle(group).icon} {group}
                      </option>
                    ))}
                  </select>
                </div>
                
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>📖</span> Capitolo del libro
                  </label>
                  <Input
                    placeholder="es. 1, 2A, Unit 5..."
                    value={formData.chapter}
                    onChange={(e) => handleInputChange('chapter', e.target.value)}
                    className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                  />
                </div>

                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>🎓</span> Stato Parola
                  </label>
                  <div className="space-y-3">
                    <div className="flex items-center gap-3 p-3 border-2 border-gray-200 rounded-xl bg-white">
                      <label className="flex items-center gap-2 cursor-pointer">
                        <div 
                          onClick={() => handleInputChange('learned', !formData.learned)}
                          className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                            formData.learned 
                              ? 'bg-green-500 border-green-500 text-white' 
                              : 'border-gray-300 bg-white'
                          }`}
                        >
                          {formData.learned && <span className="text-sm">✓</span>}
                        </div>
                        <span className="text-sm font-medium text-gray-700">
                          Parola appresa
                        </span>
                      </label>
                    </div>
                    
                    {/* ⭐ NEW: Difficult flag */}
                    <div className="flex items-center gap-3 p-3 border-2 border-orange-200 rounded-xl bg-orange-50">
                      <label className="flex items-center gap-2 cursor-pointer">
                        <div 
                          onClick={() => handleInputChange('difficult', !formData.difficult)}
                          className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                            formData.difficult 
                              ? 'bg-orange-500 border-orange-500 text-white' 
                              : 'border-orange-300 bg-white'
                          }`}
                        >
                          {formData.difficult && <AlertTriangle className="w-4 h-4" />}
                        </div>
                        <span className="text-sm font-medium text-orange-700">
                          ⭐ Parola difficile
                        </span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>
              
              <div className="grid grid-cols-1 gap-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>💬</span> Frase d'esempio
                  </label>
                  <Input
                    placeholder="es. I love this beautiful song"
                    value={formData.sentence}
                    onChange={(e) => handleInputChange('sentence', e.target.value)}
                    className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                  <span>📝</span> Note aggiuntive
                </label>
                <Textarea
                  placeholder="Altri significati, sinonimi, forme irregolari..."
                  value={formData.notes}
                  onChange={(e) => handleInputChange('notes', e.target.value)}
                  rows={4}
                  className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                />
              </div>
            </div>
          )}

          <Button 
            onClick={handleSubmit}
            className={`w-full py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 ${
              editingWord 
                ? 'bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700' 
                : 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600'
            } text-white`}
          >
            {editingWord ? (
              <>
                <Check className="w-5 h-5 mr-2" />
                Salva Modifiche
              </>
            ) : (
              <>
                <Plus className="w-5 h-5 mr-2" />
                Aggiungi Parola
              </>
            )}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default AddWordForm;

================================================================================

NOME FILE: components\AppRouter.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import { MainView } from '../views/MainView';
import { TestView } from '../views/TestView';
import { ResultsView } from '../views/ResultsView';
import { StatsView } from '../views/StatsView';

export const AppRouter = () => {
  const { currentView, testMode, showResults } = useAppContext();

  // Test in corso
  if (testMode) {
    return <TestView />;
  }

  // Risultati test
  if (showResults) {
    return <ResultsView />;
  }

  // Viste principali
  switch (currentView) {
    case 'stats':
      return <StatsView />;
    case 'main':
    default:
      return <MainView />;
  }
};

================================================================================

NOME FILE: components\ChapterTestSelector.js

// =====================================================
// 📁 src/components/ChapterTestSelector.js - ENHANCED con selezione parole difficili
// =====================================================
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Play, BookOpen, CheckSquare, Square, Target, AlertTriangle, GraduationCap } from 'lucide-react';
import { useNotification } from '../contexts/NotificationContext';

const ChapterTestSelector = ({ words, onStartTest, onClose }) => {
  const [selectedChapters, setSelectedChapters] = useState(new Set());
  const [includeLearnedWords, setIncludeLearnedWords] = useState(false);
  const [testMode, setTestMode] = useState('normal'); // ⭐ NEW: 'normal', 'difficult-only'
  
  const { showWarning } = useNotification();
  
  // Ottieni tutti i capitoli disponibili dalle parole
  const getAvailableChapters = () => {
    const chapters = new Set();
    words.forEach(word => {
      if (word.chapter) {
        chapters.add(word.chapter);
      }
    });
    return Array.from(chapters).sort((a, b) => {
      const aNum = parseInt(a);
      const bNum = parseInt(b);
      if (!isNaN(aNum) && !isNaN(bNum)) {
        return aNum - bNum;
      }
      return a.localeCompare(b);
    });
  };

  const availableChapters = getAvailableChapters();
  const wordsWithoutChapter = words.filter(word => !word.chapter);

  // ⭐ ENHANCED: Calcola statistiche per ogni capitolo includendo parole difficili
  const getChapterStats = (chapter) => {
    const chapterWords = words.filter(word => word.chapter === chapter);
    const totalWords = chapterWords.length;
    const learnedWords = chapterWords.filter(word => word.learned).length;
    const difficultWords = chapterWords.filter(word => word.difficult).length;
    
    // Calcola parole disponibili in base al modo di test
    let availableForTest = 0;
    if (testMode === 'difficult-only') {
      // Solo parole difficili (indipendentemente da includeLearnedWords)
      availableForTest = difficultWords;
    } else {
      // Test normale: filtra per stato appreso
      availableForTest = chapterWords.filter(word => includeLearnedWords || !word.learned).length;
    }
    
    return { totalWords, learnedWords, difficultWords, availableForTest };
  };

  const getWordsWithoutChapterStats = () => {
    const totalWords = wordsWithoutChapter.length;
    const learnedWords = wordsWithoutChapter.filter(word => word.learned).length;
    const difficultWords = wordsWithoutChapter.filter(word => word.difficult).length;
    
    let availableForTest = 0;
    if (testMode === 'difficult-only') {
      availableForTest = difficultWords;
    } else {
      availableForTest = wordsWithoutChapter.filter(word => includeLearnedWords || !word.learned).length;
    }
    
    return { totalWords, learnedWords, difficultWords, availableForTest };
  };

  // Gestione selezione capitoli
  const toggleChapter = (chapter) => {
    const newSelected = new Set(selectedChapters);
    if (newSelected.has(chapter)) {
      newSelected.delete(chapter);
    } else {
      newSelected.add(chapter);
    }
    setSelectedChapters(newSelected);
  };

  const selectAllChapters = () => {
    const allOptions = [...availableChapters];
    if (wordsWithoutChapter.length > 0) {
      allOptions.push('SENZA_CAPITOLO');
    }
    setSelectedChapters(new Set(allOptions));
  };

  const clearSelection = () => {
    setSelectedChapters(new Set());
  };

  // ⭐ ENHANCED: Calcola il totale delle parole selezionate considerando il modo di test
  const getTotalSelectedWords = () => {
    let total = 0;
    
    selectedChapters.forEach(chapter => {
      if (chapter === 'SENZA_CAPITOLO') {
        total += getWordsWithoutChapterStats().availableForTest;
      } else {
        total += getChapterStats(chapter).availableForTest;
      }
    });
    
    return total;
  };

  const handleStartTest = () => {
    const totalWords = getTotalSelectedWords();
    
    if (totalWords === 0) {
      const modeText = testMode === 'difficult-only' ? 'difficili' : 'disponibili';
      showWarning(`⚠️ Seleziona almeno un capitolo con parole ${modeText}!`);
      return;
    }

    // ⭐ ENHANCED: Filtra le parole in base ai capitoli selezionati e al modo di test
    const filteredWords = words.filter(word => {
      // Filtra per capitolo
      let chapterMatch = false;
      if (word.chapter) {
        chapterMatch = selectedChapters.has(word.chapter);
      } else {
        chapterMatch = selectedChapters.has('SENZA_CAPITOLO');
      }
      
      if (!chapterMatch) return false;
      
      // Filtra per modo di test
      if (testMode === 'difficult-only') {
        // Solo parole difficili
        return word.difficult;
      } else {
        // Test normale: filtra per stato appreso
        if (!includeLearnedWords && word.learned) {
          return false;
        }
        return true;
      }
    });

    if (filteredWords.length === 0) {
      const modeText = testMode === 'difficult-only' ? 'difficili' : 'disponibili';
      showWarning(`⚠️ Nessuna parola ${modeText} per i capitoli selezionati!`);
      return;
    }

    onStartTest(filteredWords);
    onClose();
  };

  // Seleziona tutti i capitoli all'apertura se non ce ne sono già selezionati
  useEffect(() => {
    if (selectedChapters.size === 0) {
      const allOptions = [...availableChapters];
      if (wordsWithoutChapter.length > 0) {
        allOptions.push('SENZA_CAPITOLO');
      }
      setSelectedChapters(new Set(allOptions));
    }
  }, [availableChapters, wordsWithoutChapter.length, selectedChapters.size]);

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto bg-black/50 backdrop-blur-sm">
      <div className="flex min-h-full items-center justify-center p-4">
        <Card className="w-full max-w-4xl bg-white rounded-3xl shadow-2xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white">
            <CardTitle className="flex items-center gap-3 text-2xl">
              <BookOpen className="w-8 h-8" />
              Seleziona Capitoli per il Test
            </CardTitle>
            <p className="text-blue-100 mt-2">
              Scegli quali capitoli includere nel test e la modalità di apprendimento
            </p>
          </CardHeader>
          
          <CardContent className="p-6 space-y-6">
            {/* ⭐ NEW: Modalità Test */}
            <div className="bg-gradient-to-r from-indigo-50 to-purple-50 p-4 rounded-2xl border-2 border-indigo-200">
              <h3 className="font-bold text-indigo-800 mb-4 flex items-center gap-2">
                <Target className="w-5 h-5" />
                Modalità Test
              </h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div 
                  onClick={() => setTestMode('normal')}
                  className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
                    testMode === 'normal' 
                      ? 'border-blue-500 bg-blue-50 shadow-lg' 
                      : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
                  }`}
                >
                  <div className="flex items-center gap-3 mb-2">
                    <GraduationCap className={`w-6 h-6 ${testMode === 'normal' ? 'text-blue-600' : 'text-gray-500'}`} />
                    <div className="font-bold text-lg">Test Normale</div>
                  </div>
                  <p className="text-sm text-gray-600">
                    Include tutte le parole dei capitoli selezionati (escluse quelle apprese se non specificate)
                  </p>
                </div>
                
                <div 
                  onClick={() => setTestMode('difficult-only')}
                  className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
                    testMode === 'difficult-only' 
                      ? 'border-orange-500 bg-orange-50 shadow-lg' 
                      : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
                  }`}
                >
                  <div className="flex items-center gap-3 mb-2">
                    <AlertTriangle className={`w-6 h-6 ${testMode === 'difficult-only' ? 'text-orange-600' : 'text-gray-500'}`} />
                    <div className="font-bold text-lg">⭐ Solo Parole Difficili</div>
                  </div>
                  <p className="text-sm text-gray-600">
                    Test focalizzato esclusivamente sulle parole marcate come difficili
                  </p>
                </div>
              </div>
              
              {/* Opzioni aggiuntive - mostrate solo per test normale */}
              {testMode === 'normal' && (
                <div className="flex items-center gap-4 mb-4">
                  <label className="flex items-center gap-3 cursor-pointer">
                    <div 
                      onClick={() => setIncludeLearnedWords(!includeLearnedWords)}
                      className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                        includeLearnedWords 
                          ? 'bg-green-500 border-green-500 text-white' 
                          : 'border-gray-300 bg-white'
                      }`}
                    >
                      {includeLearnedWords && <span className="text-sm">✓</span>}
                    </div>
                    <span className="text-gray-700 font-medium">
                      Includi parole già apprese nel test
                    </span>
                  </label>
                </div>
              )}
              
              <div className="flex gap-3">
                <Button 
                  onClick={selectAllChapters}
                  className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white"
                >
                  <CheckSquare className="w-4 h-4 mr-2" />
                  Seleziona Tutti
                </Button>
                <Button 
                  onClick={clearSelection}
                  variant="outline"
                  className="border-gray-300"
                >
                  <Square className="w-4 h-4 mr-2" />
                  Deseleziona Tutti
                </Button>
              </div>
            </div>

            {/* Lista Capitoli */}
            <div className="space-y-4 max-h-96 overflow-y-auto">
              <h3 className="font-bold text-gray-800 text-lg">Capitoli Disponibili:</h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {availableChapters.map(chapter => {
                  const stats = getChapterStats(chapter);
                  const isSelected = selectedChapters.has(chapter);
                  
                  return (
                    <div
                      key={chapter}
                      onClick={() => toggleChapter(chapter)}
                      className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
                        isSelected 
                          ? 'border-blue-500 bg-blue-50 shadow-lg' 
                          : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
                      }`}
                    >
                      <div className="flex items-center justify-between mb-3">
                        <div className="flex items-center gap-3">
                          <div className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                            isSelected 
                              ? 'bg-blue-500 border-blue-500 text-white' 
                              : 'border-gray-300 bg-white'
                          }`}>
                            {isSelected && <span className="text-sm">✓</span>}
                          </div>
                          <span className="font-bold text-lg">📖 Capitolo {chapter}</span>
                        </div>
                      </div>
                      
                      <div className="grid grid-cols-4 gap-2 text-sm">
                        <div className="text-center p-2 bg-blue-100 rounded-xl">
                          <div className="font-bold text-blue-600">{stats.totalWords}</div>
                          <div className="text-blue-700 text-xs">Totale</div>
                        </div>
                        <div className="text-center p-2 bg-green-100 rounded-xl">
                          <div className="font-bold text-green-600">{stats.learnedWords}</div>
                          <div className="text-green-700 text-xs">Apprese</div>
                        </div>
                        <div className="text-center p-2 bg-orange-100 rounded-xl">
                          <div className="font-bold text-orange-600">{stats.difficultWords}</div>
                          <div className="text-orange-700 text-xs">Difficili</div>
                        </div>
                        <div className="text-center p-2 bg-purple-100 rounded-xl">
                          <div className="font-bold text-purple-600">{stats.availableForTest}</div>
                          <div className="text-purple-700 text-xs">Per Test</div>
                        </div>
                      </div>
                    </div>
                  );
                })}
                
                {/* Parole senza capitolo */}
                {wordsWithoutChapter.length > 0 && (
                  <div
                    onClick={() => toggleChapter('SENZA_CAPITOLO')}
                    className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
                      selectedChapters.has('SENZA_CAPITOLO')
                        ? 'border-purple-500 bg-purple-50 shadow-lg' 
                        : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
                    }`}
                  >
                    <div className="flex items-center justify-between mb-3">
                      <div className="flex items-center gap-3">
                        <div className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                          selectedChapters.has('SENZA_CAPITOLO')
                            ? 'bg-purple-500 border-purple-500 text-white' 
                            : 'border-gray-300 bg-white'
                        }`}>
                          {selectedChapters.has('SENZA_CAPITOLO') && <span className="text-sm">✓</span>}
                        </div>
                        <span className="font-bold text-lg">📋 Senza Capitolo</span>
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-4 gap-2 text-sm">
                      <div className="text-center p-2 bg-blue-100 rounded-xl">
                        <div className="font-bold text-blue-600">{getWordsWithoutChapterStats().totalWords}</div>
                        <div className="text-blue-700 text-xs">Totale</div>
                      </div>
                      <div className="text-center p-2 bg-green-100 rounded-xl">
                        <div className="font-bold text-green-600">{getWordsWithoutChapterStats().learnedWords}</div>
                        <div className="text-green-700 text-xs">Apprese</div>
                      </div>
                      <div className="text-center p-2 bg-orange-100 rounded-xl">
                        <div className="font-bold text-orange-600">{getWordsWithoutChapterStats().difficultWords}</div>
                        <div className="text-orange-700 text-xs">Difficili</div>
                      </div>
                      <div className="text-center p-2 bg-purple-100 rounded-xl">
                        <div className="font-bold text-purple-600">{getWordsWithoutChapterStats().availableForTest}</div>
                        <div className="text-purple-700 text-xs">Per Test</div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Riepilogo e azioni */}
            <div className="border-t pt-6">
              <div className="flex justify-between items-center mb-4">
                <div className="text-lg font-bold text-gray-800">
                  {testMode === 'difficult-only' ? 'Parole difficili' : 'Parole'} selezionate per il test: 
                  <span className="text-2xl text-blue-600 ml-2">{getTotalSelectedWords()}</span>
                </div>
                
                {/* Indicatore modalità attiva */}
                <div className={`px-4 py-2 rounded-full text-sm font-bold ${
                  testMode === 'difficult-only' 
                    ? 'bg-orange-100 text-orange-700 border border-orange-300' 
                    : 'bg-blue-100 text-blue-700 border border-blue-300'
                }`}>
                  {testMode === 'difficult-only' ? '⭐ Solo Difficili' : '🎓 Test Normale'}
                </div>
              </div>
              
              <div className="flex justify-end gap-4">
                <Button 
                  onClick={onClose}
                  variant="outline"
                  className="px-8 py-3 text-lg"
                >
                  Annulla
                </Button>
                <Button 
                  onClick={handleStartTest}
                  disabled={getTotalSelectedWords() === 0}
                  className={`px-8 py-3 text-lg shadow-xl disabled:opacity-50 ${
                    testMode === 'difficult-only'
                      ? 'bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600'
                      : 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600'
                  } text-white`}
                >
                  <Play className="w-5 h-5 mr-2" />
                  {testMode === 'difficult-only' 
                    ? `Inizia Test Difficili (${getTotalSelectedWords()})` 
                    : `Inizia Test (${getTotalSelectedWords()} parole)`
                  }
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default ChapterTestSelector;

================================================================================

NOME FILE: components\ErrorBoundary.js

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { AlertTriangle, RefreshCw } from 'lucide-react';

export class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error,
      errorInfo
    });
    
    if (process.env.NODE_ENV === 'development') {
      console.error('ErrorBoundary caught an error:', error, errorInfo);
    }
    
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', 'exception', {
        description: error.toString(),
        fatal: true
      });
    }
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen bg-gradient-to-br from-red-50 via-white to-pink-50 flex items-center justify-center p-6">
          <Card className="max-w-lg w-full bg-white/90 backdrop-blur-sm border-0 shadow-2xl rounded-3xl overflow-hidden">
            <CardHeader className="bg-gradient-to-r from-red-500 to-pink-500 text-white text-center py-8">
              <div className="text-6xl mb-4">
                <AlertTriangle className="w-16 h-16 mx-auto" />
              </div>
              <CardTitle className="text-2xl font-bold text-white">
                Oops! Qualcosa è andato storto
              </CardTitle>
              <p className="text-red-100 mt-2">
                Si è verificato un errore imprevisto nell'applicazione
              </p>
            </CardHeader>
            <CardContent className="p-8 text-center">
              <div className="space-y-6">
                <p className="text-gray-600">
                  Non preoccuparti, i tuoi dati sono al sicuro. 
                  Prova a ricaricare la pagina o contatta il supporto se il problema persiste.
                </p>
                
                <div className="flex gap-4 justify-center">
                  <Button 
                    onClick={this.handleReset}
                    className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-6 py-3 rounded-xl"
                  >
                    <RefreshCw className="w-4 h-4 mr-2" />
                    Riprova
                  </Button>
                  
                  <Button 
                    onClick={() => window.location.reload()}
                    variant="outline"
                    className="px-6 py-3 rounded-xl"
                  >
                    Ricarica Pagina
                  </Button>
                </div>
                
                {process.env.NODE_ENV === 'development' && this.state.error && (
                  <details className="mt-6 text-left">
                    <summary className="cursor-pointer text-red-600 font-medium">
                      Dettagli Errore (Dev Mode)
                    </summary>
                    <pre className="mt-2 p-4 bg-gray-100 rounded-lg text-xs overflow-auto max-h-40">
                      {this.state.error.toString()}
                      {this.state.errorInfo.componentStack}
                    </pre>
                  </details>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}

================================================================================

NOME FILE: components\JSONManager.js

// =====================================================
// 📁 src/components/JSONManager.js - FIXED Import/Export
// =====================================================
import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Textarea } from './ui/textarea';
import { FileDown, ChevronDown, ChevronUp, Upload, Download } from 'lucide-react';
import { useNotification } from '../contexts/NotificationContext';

const JSONManager = ({ words, onImportWords }) => {
  const [jsonText, setJsonText] = useState('');
  const [showSection, setShowSection] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const { showSuccess, showError, showWarning } = useNotification();

  const handleExport = () => {
    if (words.length === 0) {
      showWarning('⚠️ Nessuna parola da esportare!');
      return;
    }

    try {
      setIsProcessing(true);
      
      // ⭐ ENHANCED: Create comprehensive export data
      const exportData = {
        words: words,
        exportDate: new Date().toISOString(),
        totalWords: words.length,
        version: '2.0',
        appName: 'Vocabulary Master',
        metadata: {
          chapters: [...new Set(words.map(w => w.chapter).filter(Boolean))],
          groups: [...new Set(words.map(w => w.group).filter(Boolean))],
          learnedCount: words.filter(w => w.learned).length,
          difficultCount: words.filter(w => w.difficult).length
        }
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      setJsonText(dataStr);
      setShowSection(true);
      showSuccess(`✅ ${words.length} parole esportate con successo!`);
    } catch (error) {
      console.error('Export error:', error);
      showError(error, 'Export JSON');
    } finally {
      setIsProcessing(false);
    }
  };

  const downloadAsFile = () => {
    if (!jsonText.trim()) {
      showWarning('⚠️ Nessun JSON da scaricare! Esporta prima i dati.');
      return;
    }

    try {
      const blob = new Blob([jsonText], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `vocabulary-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      showSuccess('✅ File scaricato con successo!');
    } catch (error) {
      console.error('Download error:', error);
      showError(error, 'Download File');
    }
  };

  const handleImport = async () => {
    if (!jsonText.trim()) {
      showWarning('⚠️ Inserisci del JSON da importare!');
      return;
    }

    try {
      setIsProcessing(true);
      
      // ⭐ FIXED: Better JSON validation and parsing
      let parsedData;
      try {
        parsedData = JSON.parse(jsonText.trim());
      } catch (parseError) {
        throw new Error('JSON non valido! Controlla la sintassi.');
      }

      // ⭐ FIXED: Handle different import formats
      let wordsToImport;
      
      if (Array.isArray(parsedData)) {
        // Direct array of words
        wordsToImport = parsedData;
        console.log('📥 Importing direct array format:', wordsToImport.length, 'words');
      } else if (parsedData.words && Array.isArray(parsedData.words)) {
        // Export format with metadata
        wordsToImport = parsedData.words;
        console.log('📥 Importing export format:', wordsToImport.length, 'words');
        
        if (parsedData.metadata) {
          showSuccess(`📊 Rilevato backup ${parsedData.version || 'legacy'} del ${new Date(parsedData.exportDate).toLocaleDateString()}`);
        }
      } else {
        throw new Error('Formato JSON non valido. Atteso array di parole o oggetto con campo "words".');
      }

      // ⭐ FIXED: Validate words structure
      if (!wordsToImport || wordsToImport.length === 0) {
        throw new Error('Nessuna parola trovata nel JSON.');
      }

      // ⭐ FIXED: Validate word structure
      const validWords = wordsToImport.filter(word => {
        return word && 
               typeof word === 'object' && 
               word.english && 
               word.italian &&
               typeof word.english === 'string' &&
               typeof word.italian === 'string';
      });

      if (validWords.length === 0) {
        throw new Error('Nessuna parola valida trovata. Ogni parola deve avere almeno "english" e "italian".');
      }

      if (validWords.length < wordsToImport.length) {
        showWarning(`⚠️ ${wordsToImport.length - validWords.length} parole saltate perché non valide.`);
      }

      // ⭐ FIXED: Call import function and handle response
      const importedCount = await onImportWords(JSON.stringify(validWords));
      
      // ⭐ FIXED: Clear text after successful import
      setJsonText('');
      setShowSection(true); // Keep section open to show success
      
      showSuccess(`✅ ${importedCount} nuove parole importate con successo!`);
      
    } catch (error) {
      console.error('Import error:', error);
      
      // ⭐ ENHANCED: Better error handling
      if (error.message.includes('JSON') || error.message.includes('syntax')) {
        showError(new Error('❌ JSON non valido! Controlla la sintassi.'), 'Import JSON');
      } else if (error.message.includes('already exist')) {
        showWarning('⚠️ Tutte le parole sono già presenti nel vocabolario.');
      } else {
        showError(error, 'Import JSON');
      }
    } finally {
      setIsProcessing(false);
    }
  };

  // ⭐ NEW: Handle file upload
  const handleFileUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
      showWarning('⚠️ Seleziona un file JSON valido.');
      return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const content = e.target.result;
        setJsonText(content);
        setShowSection(true);
        showSuccess('📁 File caricato! Verifica il contenuto e clicca "Importa JSON".');
      } catch (error) {
        showError(error, 'File Reading');
      }
    };
    reader.onerror = () => {
      showError(new Error('Errore nella lettura del file'), 'File Reading');
    };
    reader.readAsText(file);
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader 
        className="cursor-pointer hover:bg-gray-50 transition-colors"
        onClick={() => setShowSection(!showSection)}
      >
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <FileDown className="w-6 h-6 text-indigo-600" />
            <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
              Gestione Dati JSON
            </span>
          </div>
          {showSection ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
        </CardTitle>
      </CardHeader>
      {showSection && (
        <CardContent className="animate-fade-in">
          <div className="space-y-6">
            <div className="p-4 bg-blue-50 rounded-2xl border border-blue-200">
              <p className="text-blue-800 text-sm flex items-center gap-2">
                <span className="text-lg">💡</span>
                Usa questa sezione per fare backup del tuo vocabolario o condividerlo tra dispositivi
              </p>
            </div>
            
            {/* ⭐ ENHANCED: Action buttons grid */}
            <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
              <Button
                onClick={handleExport}
                disabled={words.length === 0 || isProcessing}
                className="border-2 border-blue-300 hover:border-blue-400 bg-blue-50 hover:bg-blue-100 text-blue-600 flex items-center justify-center gap-2"
              >
                <Download className="w-4 h-4" />
                📤 Esporta JSON
              </Button>
              
              <Button
                onClick={downloadAsFile}
                disabled={!jsonText.trim() || isProcessing}
                className="border-2 border-green-300 hover:border-green-400 bg-green-50 hover:bg-green-100 text-green-600 flex items-center justify-center gap-2"
              >
                <FileDown className="w-4 h-4" />
                💾 Scarica File
              </Button>
              
              <div className="relative">
                <input
                  type="file"
                  accept=".json,application/json"
                  onChange={handleFileUpload}
                  className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                  disabled={isProcessing}
                />
                <Button
                  disabled={isProcessing}
                  className="w-full border-2 border-orange-300 hover:border-orange-400 bg-orange-50 hover:bg-orange-100 text-orange-600 flex items-center justify-center gap-2"
                >
                  <Upload className="w-4 h-4" />
                  📁 Carica File
                </Button>
              </div>
              
              <Button
                onClick={handleImport}
                disabled={!jsonText.trim() || isProcessing}
                className="border-2 border-purple-300 hover:border-purple-400 bg-purple-50 hover:bg-purple-100 text-purple-600 flex items-center justify-center gap-2"
              >
                <Upload className="w-4 h-4" />
                📥 Importa JSON
              </Button>
            </div>
            
            <Textarea
              placeholder="Il JSON delle parole apparirà qui dopo 'Esporta JSON', oppure incolla/carica qui il JSON da importare..."
              value={jsonText}
              onChange={(e) => setJsonText(e.target.value)}
              rows={12}
              className="font-mono text-sm border-2 border-gray-200 rounded-2xl focus:border-blue-500 transition-colors"
              disabled={isProcessing}
            />
            
            {/* ⭐ ENHANCED: Status indicators */}
            {jsonText && (
              <div className="space-y-2">
                <div className="p-3 bg-green-50 border border-green-200 rounded-xl">
                  <p className="text-green-800 text-sm">
                    💾 <strong>Formato rilevato:</strong> {
                      (() => {
                        try {
                          const parsed = JSON.parse(jsonText);
                          
                          if (Array.isArray(parsed)) {
                            const hasWords = parsed.length > 0;
                            const firstItem = hasWords ? parsed[0] : null;
                            const hasEnglishItalian = firstItem && firstItem.english && firstItem.italian;
                            
                            if (hasEnglishItalian) {
                              return `Array di ${parsed.length} parole (✅ Formato valido)`;
                            } else if (hasWords) {
                              return `Array con ${parsed.length} elementi (⚠️ Verificare formato)`;
                            } else {
                              return 'Array vuoto (❌ Nessuna parola)';
                            }
                          } else if (parsed.words && Array.isArray(parsed.words)) {
                            return `Backup Export v${parsed.version || '1.0'} con ${parsed.words.length} parole (✅ Formato valido)`;
                          } else {
                            return 'Oggetto JSON (⚠️ Array o campo "words" richiesto)';
                          }
                        } catch {
                          return 'JSON non valido (❌ Errore sintassi)';
                        }
                      })()
                    }
                  </p>
                </div>
                
                {/* ⭐ NEW: Import preview */}
                {(() => {
                  try {
                    const parsed = JSON.parse(jsonText);
                    let wordsArray = Array.isArray(parsed) ? parsed : parsed.words;
                    
                    if (wordsArray && wordsArray.length > 0) {
                      const sampleWords = wordsArray.slice(0, 3);
                      return (
                        <div className="p-3 bg-blue-50 border border-blue-200 rounded-xl">
                          <p className="text-blue-800 text-sm font-bold mb-2">👀 Anteprima prime parole:</p>
                          <div className="space-y-1">
                            {sampleWords.map((word, idx) => (
                              <div key={idx} className="text-xs text-blue-700 font-mono">
                                • {word.english} → {word.italian}
                                {word.chapter && ` (Cap. ${word.chapter})`}
                                {word.group && ` [${word.group}]`}
                              </div>
                            ))}
                            {wordsArray.length > 3 && (
                              <div className="text-xs text-blue-600">
                                ... e altre {wordsArray.length - 3} parole
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    }
                  } catch {
                    return null;
                  }
                })()}
              </div>
            )}
            
            {/* ⭐ NEW: Processing indicator */}
            {isProcessing && (
              <div className="flex items-center justify-center p-4 bg-yellow-50 border border-yellow-200 rounded-xl">
                <div className="animate-spin w-5 h-5 border-2 border-yellow-500 border-t-transparent rounded-full mr-3"></div>
                <span className="text-yellow-800 font-medium">Elaborazione in corso...</span>
              </div>
            )}
            
            {/* ⭐ ENHANCED: Usage instructions */}
            <div className="p-4 bg-gray-50 rounded-xl border border-gray-200">
              <h4 className="font-bold text-gray-800 mb-2">📖 Come usare:</h4>
              <div className="text-sm text-gray-700 space-y-1">
                <p><strong>1. Esportare:</strong> Clicca "Esporta JSON" per vedere i tuoi dati</p>
                <p><strong>2. Scaricare:</strong> Clicca "Scarica File" per salvare un file .json</p>
                <p><strong>3. Importare:</strong> Carica un file .json o incolla il contenuto, poi clicca "Importa JSON"</p>
                <p><strong>4. Formati supportati:</strong> Array di parole o oggetto con campo "words"</p>
              </div>
            </div>
          </div>
        </CardContent>
      )}
    </Card>
  );
};

export default JSONManager;

================================================================================

NOME FILE: components\TestCard.js

// =====================================================
// 📁 components/TestCard.js - FIXED suggerimento in alto
// =====================================================

import { getCategoryStyle } from '../utils/categoryUtils';
import { formatNotes } from '../utils/textUtils';

const TestCard = ({ word, showMeaning, onFlip, showHint, hintUsed }) => {
  return (
    <div 
      className="relative cursor-pointer transform transition-transform duration-300 hover:scale-105"
      style={{ width: '26rem', height: '38rem', perspective: '1000px' }}
      onClick={onFlip}
    >
      <div 
        className="absolute inset-0 w-full h-full transition-transform duration-700 preserve-3d"
        style={{ 
          transformStyle: 'preserve-3d',
          transform: showMeaning ? 'rotateY(180deg)' : 'rotateY(0deg)'
        }}
      >
        {/* Front Card */}
        <div 
          className="absolute inset-0 w-full h-full rounded-3xl shadow-2xl overflow-hidden backface-hidden"
          style={{ backfaceVisibility: 'hidden' }}
        >
          <div className="absolute inset-0 bg-gradient-to-br from-indigo-500 via-purple-600 to-pink-500"></div>
          <div className="absolute inset-0 bg-black/20"></div>
          <div className="relative h-full flex flex-col items-center justify-center text-white p-8">
            
            {/* ⭐ FIXED: Suggerimento spostato in alto */}
            {showHint && word.sentence && (
              <div className="absolute top-6 left-6 right-6">
                <div className="bg-white/20 backdrop-blur-md rounded-2xl p-4 border border-white/30 animate-fade-in">
                  <div className="flex items-center gap-2 mb-2">
                    <span className="text-lg">💡</span>
                    <span className="text-sm font-bold text-white/90">Suggerimento:</span>
                    {hintUsed && (
                      <span className="text-xs bg-orange-400/80 text-white px-2 py-1 rounded-full">
                        Conteggiato
                      </span>
                    )}
                  </div>
                  <div className="text-sm italic text-white/90 leading-relaxed">
                    "{word.sentence}"
                  </div>
                </div>
              </div>
            )}
            
            <div className="text-center space-y-6 flex-1 flex flex-col justify-center">
              <div className="text-5xl font-bold drop-shadow-lg">
                {word.english}
              </div>
              <div className="text-xl opacity-90 animate-pulse">
                Clicca per vedere la traduzione
              </div>
              <div className="mt-8">
                <div className="inline-flex items-center justify-center w-16 h-16 border-2 border-white/30 rounded-2xl backdrop-blur-sm">
                  <span className="text-2xl font-bold">EN</span>
                </div>
              </div>
            </div>
            
            {/* Animated particles */}
            <div className="absolute top-4 right-4 w-2 h-2 bg-white/50 rounded-full animate-ping"></div>
            <div className="absolute bottom-8 left-8 w-1 h-1 bg-white/30 rounded-full animate-pulse"></div>
            <div className="absolute top-1/3 left-4 w-1.5 h-1.5 bg-white/40 rounded-full animate-bounce"></div>
          </div>
        </div>

        {/* Back Card */}
        <div 
          className={`absolute inset-0 w-full h-full rounded-3xl shadow-2xl overflow-hidden backface-hidden ${getCategoryStyle(word.group)?.bgGradient || 'bg-gradient-to-br from-emerald-500 to-cyan-600'}`}
          style={{ 
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)'
          }}
        >
          <div className="absolute inset-0 bg-black/20"></div>
          
          {/* Category badge */}
          {word.group && (
            <div className="absolute top-4 right-4 z-10">
              <div className="bg-white/20 backdrop-blur-sm text-white px-3 py-2 rounded-xl text-sm font-medium flex items-center gap-2 shadow-lg">
                <span>{getCategoryStyle(word.group).icon}</span>
                <span>{word.group}</span>
              </div>
            </div>
          )}
          
          {/* ⭐ ENHANCED: Hint indicator sul retro se usato */}
          {hintUsed && (
            <div className="absolute top-4 left-4 z-10">
              <div className="bg-orange-500/80 backdrop-blur-sm text-white px-3 py-2 rounded-xl text-sm font-medium flex items-center gap-2 shadow-lg">
                <span>💡</span>
                <span>Aiuto usato</span>
              </div>
            </div>
          )}
          
          <div className="relative h-full flex flex-col text-white p-8">
            {/* Header */}
            <div className="text-center border-b border-white/30 pb-6 mb-6">
              <div className="text-2xl font-bold drop-shadow-md">
                {word.english}
              </div>
            </div>

            {/* Main translation */}
            <div className="text-center mb-8">
              <div 
                className="font-bold drop-shadow-lg leading-tight"
                style={{
                  fontSize: word.italian.length > 25 ? '2rem' : 
                           word.italian.length > 15 ? '2.5rem' : 
                           word.italian.length > 10 ? '3rem' : '3.5rem'
                }}
              >
                {word.italian}
              </div>
            </div>

            {/* Example */}
            {word.sentence && (
              <div className="mb-6">
                <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-4 border border-white/20">
                  <div className="font-bold mb-2 text-sm flex items-center gap-2">
                    <span className="text-lg">💬</span>
                    Esempio:
                  </div>
                  <div className="italic text-sm leading-relaxed">
                    "{word.sentence}"
                  </div>
                </div>
              </div>
            )}

            {/* Notes */}
            {word.notes && (
              <div className="flex-1 min-h-0">
                <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-4 h-full flex flex-col border border-white/20">
                  <div className="font-bold mb-3 text-sm flex items-center gap-2">
                    <span className="text-lg">📝</span>
                    Note:
                  </div>
                  <div className="overflow-y-auto flex-1 text-sm leading-relaxed whitespace-pre-line">
                    {formatNotes(word.notes)}
                  </div>
                </div>
              </div>
            )}

            {/* Footer */}
            <div className="text-center text-sm opacity-90 border-t border-white/30 pt-4 mt-6">
              <span className="animate-pulse">Clicca per tornare al fronte</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TestCard;

================================================================================

NOME FILE: components\TestHistory.js

// /src/components/TestHistory.js
// This file contains the TestHistory component, which displays a history of vocabulary tests taken by the user.
// It shows the details of each test, including the percentage of correct answers, total words, correct words, incorrect words, and the date of the test.
// The component also allows users to clear the test history and highlights words that were answered incorrectly in each test.
// The TestHistory component is designed to provide users with a comprehensive view of their testing performance over time,
// helping them track their progress and identify areas for improvement. 
import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { ChevronDown, ChevronUp, BookOpen, Target, Calendar, Award } from 'lucide-react';

const TestHistory = ({ testHistory, onClearHistory }) => {
  const [expandedTest, setExpandedTest] = useState(null);

  if (testHistory.length === 0) return null;

  const toggleTestExpansion = (testId) => {
    setExpandedTest(expandedTest === testId ? null : testId);
  };

  const formatDifficulty = (difficulty) => {
    const difficultyMap = {
      'easy': { label: 'Facile', color: 'bg-green-500', emoji: '😊' },
      'medium': { label: 'Medio', color: 'bg-yellow-500', emoji: '😐' },
      'hard': { label: 'Difficile', color: 'bg-red-500', emoji: '😤' }
    };
    return difficultyMap[difficulty] || difficultyMap['medium'];
  };

  const formatTestType = (testType) => {
    const typeMap = {
      'complete': { label: 'Completo', color: 'bg-blue-500', emoji: '🎯' },
      'selective': { label: 'Selettivo', color: 'bg-purple-500', emoji: '📚' },
      'unknown': { label: 'Standard', color: 'bg-gray-500', emoji: '📝' }
    };
    return typeMap[testType] || typeMap['unknown'];
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-600 text-white">
        <div className="flex justify-between items-center">
          <CardTitle className="flex items-center gap-3 text-white">
            <Calendar className="w-6 h-6" />
            Cronologia Test Dettagliata ({testHistory.length})
          </CardTitle>
          <Button
            onClick={onClearHistory}
            variant="outline"
            className="border-white/30 text-white hover:bg-white/20 hover:border-white/50 rounded-xl"
          >
            <span className="w-4 h-4 mr-2">🗑️</span>
            Pulisci
          </Button>
        </div>
        <p className="text-indigo-100 mt-2">
          Storico completo con parametri di test, capitoli e performance dettagliate
        </p>
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-4 max-h-96 overflow-y-auto scrollbar-thin">
          {testHistory.map((test, index) => (
            <TestHistoryCard
              key={test.id}
              test={test}
              testNumber={testHistory.length - index}
              isExpanded={expandedTest === test.id}
              onToggleExpansion={() => toggleTestExpansion(test.id)}
              formatDifficulty={formatDifficulty}
              formatTestType={formatTestType}
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

const TestHistoryCard = ({ 
  test, 
  testNumber, 
  isExpanded, 
  onToggleExpansion, 
  formatDifficulty, 
  formatTestType 
}) => {
  const difficulty = formatDifficulty(test.difficulty);
  const testType = formatTestType(test.testType);
  
  return (
    <div className="bg-gradient-to-r from-gray-50 to-white rounded-2xl border border-gray-100 hover:shadow-lg transition-all duration-300 overflow-hidden">
      {/* Header del Test */}
      <div 
        className="p-6 cursor-pointer"
        onClick={onToggleExpansion}
      >
        <div className="flex justify-between items-start mb-4">
          <div className="flex-1">
            <div className="flex items-center gap-4 mb-3">
              <div className="text-xl font-bold text-gray-800">
                Test #{testNumber}
              </div>
              
              {/* Badge Percentuale */}
              <div className={`px-4 py-2 rounded-full text-sm font-bold shadow-lg text-white ${
                test.percentage >= 80 ? 'bg-gradient-to-r from-green-500 to-emerald-500' :
                test.percentage >= 60 ? 'bg-gradient-to-r from-blue-500 to-cyan-500' :
                'bg-gradient-to-r from-red-500 to-pink-500'
              }`}>
                {test.percentage}%
              </div>
              
              {/* Badge Tipo Test */}
              <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${testType.color}`}>
                <span className="mr-1">{testType.emoji}</span>
                {testType.label}
              </div>
              
              {/* Badge Difficoltà */}
              <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${difficulty.color}`}>
                <span className="mr-1">{difficulty.emoji}</span>
                {difficulty.label}
              </div>
            </div>
            
            {/* Informazioni Base */}
            <div className="text-sm text-gray-600 mb-4 flex items-center gap-6">
              <div className="flex items-center gap-1">
                📅 {new Date(test.timestamp).toLocaleDateString('it-IT', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                })}
              </div>
              
              {test.testParameters?.selectedChapters && (
                <div className="flex items-center gap-1">
                  📚 {test.testParameters.selectedChapters.length} 
                  {test.testParameters.selectedChapters.length === 1 ? ' capitolo' : ' capitoli'}
                </div>
              )}
              
              <div className="flex items-center gap-1">
                🎯 {test.totalWords} parole
              </div>
            </div>
            
            {/* Statistiche Rapide */}
            <div className="grid grid-cols-3 gap-4">
              <div className="bg-blue-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-blue-600">{test.totalWords}</div>
                <div className="text-blue-700 text-xs">Totale</div>
              </div>
              <div className="bg-green-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-green-600">{test.correctWords}</div>
                <div className="text-green-700 text-xs">Corrette</div>
              </div>
              <div className="bg-red-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-red-600">{test.incorrectWords}</div>
                <div className="text-red-700 text-xs">Sbagliate</div>
              </div>
            </div>
          </div>
          
          {/* Indicatore Espansione */}
          <div className="ml-4">
            {isExpanded ? (
              <ChevronUp className="w-5 h-5 text-gray-400" />
            ) : (
              <ChevronDown className="w-5 h-5 text-gray-400" />
            )}
          </div>
        </div>
      </div>
      
      {/* Dettagli Espansi */}
      {isExpanded && (
        <div className="border-t border-gray-200 bg-gray-50">
          <div className="p-6 space-y-6">
            
            {/* Parametri del Test */}
            {test.testParameters && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <Target className="w-5 h-5" />
                  Parametri del Test
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="bg-white p-4 rounded-xl border border-gray-200">
                    <div className="text-sm text-gray-600 mb-1">Capitoli Selezionati</div>
                    <div className="flex flex-wrap gap-2">
                      {test.testParameters.selectedChapters?.map(chapter => (
                        <span key={chapter} className="px-2 py-1 bg-blue-100 text-blue-700 rounded-lg text-xs">
                          {chapter === 'Senza Capitolo' ? '📋 Senza Cap.' : `📖 ${chapter}`}
                        </span>
                      ))}
                    </div>
                  </div>
                  <div className="bg-white p-4 rounded-xl border border-gray-200">
                    <div className="text-sm text-gray-600 mb-1">Configurazione</div>
                    <div className="space-y-1">
                      <div className="text-xs">
                        {test.testParameters.includeLearnedWords ? '✅' : '❌'} Parole apprese incluse
                      </div>
                      <div className="text-xs text-gray-500">
                        {test.testParameters.totalAvailableWords} parole disponibili totali
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
            
            {/* Performance per Capitolo */}
            {test.chapterStats && Object.keys(test.chapterStats).length > 0 && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <BookOpen className="w-5 h-5" />
                  Performance per Capitolo
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {Object.entries(test.chapterStats).map(([chapter, stats]) => (
                    <div key={chapter} className="bg-white p-4 rounded-xl border border-gray-200">
                      <div className="font-medium text-gray-800 mb-2">
                        {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`}
                      </div>
                      <div className="space-y-2">
                        <div className="flex justify-between items-center">
                          <span className="text-sm text-gray-600">Accuratezza:</span>
                          <span className={`font-bold ${
                            stats.percentage >= 80 ? 'text-green-600' :
                            stats.percentage >= 60 ? 'text-blue-600' : 'text-red-600'
                          }`}>
                            {stats.percentage}%
                          </span>
                        </div>
                        <div className="flex justify-between items-center text-xs text-gray-500">
                          <span>Corrette: {stats.correctWords}</span>
                          <span>Sbagliate: {stats.incorrectWords}</span>
                        </div>
                        <div className="w-full bg-gray-200 rounded-full h-2">
                          <div 
                            className={`h-2 rounded-full ${
                              stats.percentage >= 80 ? 'bg-green-500' :
                              stats.percentage >= 60 ? 'bg-blue-500' : 'bg-red-500'
                            }`}
                            style={{ width: `${stats.percentage}%` }}
                          ></div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Parole Sbagliate */}
            {test.wrongWords && test.wrongWords.length > 0 && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <Award className="w-5 h-5" />
                  Parole da Ripassare ({test.wrongWords.length})
                </h4>
                <div className="bg-red-50 p-4 rounded-xl border border-red-200">
                  <div className="flex flex-wrap gap-2">
                    {test.wrongWords.map((word, wordIndex) => (
                      <div
                        key={wordIndex}
                        className="bg-white border border-red-200 px-3 py-2 rounded-lg text-sm"
                      >
                        <span className="font-medium text-red-700">{word.english}</span>
                        <span className="mx-2 text-red-400">→</span>
                        <span className="text-red-600">{word.italian}</span>
                        {word.chapter && (
                          <span className="ml-2 text-xs text-red-500">
                            📖 {word.chapter}
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}
            
            {/* Raccomandazioni */}
            <div className="bg-blue-50 p-4 rounded-xl border border-blue-200">
              <h5 className="font-medium text-blue-800 mb-2">💡 Raccomandazioni per il prossimo test:</h5>
              <div className="text-sm text-blue-700 space-y-1">
                {test.percentage < 60 && (
                  <p>• Rivedi le parole sbagliate prima del prossimo test</p>
                )}
                {test.chapterStats && Object.values(test.chapterStats).some(s => s.percentage < 70) && (
                  <p>• Concentrati sui capitoli con performance inferiore al 70%</p>
                )}
                {test.testParameters?.selectedChapters?.length === 1 && (
                  <p>• Prova a combinare più capitoli per aumentare la varietà</p>
                )}
                {test.percentage >= 80 && (
                  <p>• Ottimo lavoro! Potresti provare un test più difficile</p>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default TestHistory;

================================================================================

NOME FILE: components\TestResults.js

// =====================================================
// 📁 components/TestResults.js - FIXED estrazione dati enhanced
// =====================================================

import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Play, RotateCcw, Check, X, Trophy, Clock, Lightbulb, Target, Timer, Zap } from 'lucide-react';
import { getTestResult } from '../utils/textUtils';
import { formatNotes } from '../utils/textUtils';

const TestResults = ({ stats, wrongWords, onStartNewTest, onResetTest }) => {
  
  console.log('📊 TestResults - Dati ricevuti:', {
    stats,
    wrongWords: wrongWords?.length || 0
  });

  // ⭐ ENHANCED: Gestione robusta dei dati stats con timing e hints completi
  const getCorrectStats = () => {
    // ⭐ PRIORITY 1: Se stats contiene già i dati enhanced, usali direttamente
    if (stats && typeof stats === 'object') {
      const enhancedStats = {
        correct: stats.correct || 0,
        incorrect: stats.incorrect || 0,
        hints: stats.hints || 0, // ⭐ CRITICAL: Extract hints
        totalTime: stats.totalTime || 0, // ⭐ CRITICAL: Extract total time
        avgTimePerWord: stats.avgTimePerWord || 0, // ⭐ CRITICAL: Extract average time
        maxTimePerWord: stats.maxTimePerWord || 0, // ⭐ NEW: Extract max time
        minTimePerWord: stats.minTimePerWord || 0, // ⭐ NEW: Extract min time
        totalRecordedTime: stats.totalRecordedTime || 0 // ⭐ NEW: Extract recorded time
      };
      
      console.log('✅ TestResults - Using enhanced stats directly:', enhancedStats);
      return enhancedStats;
    }
    
    // ⭐ FALLBACK: Try legacy format extraction (just in case)
    if (stats) {
      const correct = stats.correct || stats.correctAnswers || stats.right || 0;
      const incorrect = stats.incorrect || stats.incorrectAnswers || stats.wrong || 0;
      const hints = stats.hints || stats.hintsUsed || 0; // ⭐ Try multiple hint fields
      const totalTime = stats.totalTime || stats.timeSpent || 0; // ⭐ Try multiple time fields
      const avgTimePerWord = stats.avgTimePerWord || stats.averageTime || 0;
      const maxTimePerWord = stats.maxTimePerWord || 0;
      const minTimePerWord = stats.minTimePerWord || 0;
      const totalRecordedTime = stats.totalRecordedTime || 0;
      
      if (correct > 0 || incorrect > 0) {
        const legacyStats = { 
          correct, 
          incorrect, 
          hints, 
          totalTime, 
          avgTimePerWord, 
          maxTimePerWord, 
          minTimePerWord, 
          totalRecordedTime 
        };
        
        console.log('⚠️ TestResults - Using legacy format:', legacyStats);
        return legacyStats;
      }
    }
    
    // ⭐ FINAL FALLBACK: Calculate from wrongWords
    if (wrongWords && Array.isArray(wrongWords)) {
      const incorrect = wrongWords.length;
      const correct = Math.max(0, (stats?.total || 10) - incorrect);
      
      const fallbackStats = { 
        correct, 
        incorrect, 
        hints: 0, 
        totalTime: 0, 
        avgTimePerWord: 0,
        maxTimePerWord: 0,
        minTimePerWord: 0,
        totalRecordedTime: 0
      };
      
      console.log('⚠️ TestResults - Using wrongWords fallback:', fallbackStats);
      return fallbackStats;
    }
    
    // ⭐ DEFAULT: Empty stats
    const defaultStats = { 
      correct: 0, 
      incorrect: 0, 
      hints: 0, 
      totalTime: 0, 
      avgTimePerWord: 0,
      maxTimePerWord: 0,
      minTimePerWord: 0,
      totalRecordedTime: 0
    };
    
    console.log('❌ TestResults - Using default stats:', defaultStats);
    return defaultStats;
  };

  const finalStats = getCorrectStats();
  const totalAnswers = finalStats.correct + finalStats.incorrect;
  const percentage = totalAnswers > 0 
    ? Math.round((finalStats.correct / totalAnswers) * 100) 
    : 0;

  console.log('📊 TestResults - Final processed stats:', {
    finalStats,
    totalAnswers,
    percentage
  });

  const result = getTestResult({ 
    correct: finalStats.correct, 
    incorrect: finalStats.incorrect,
    total: totalAnswers
  });

  // ⭐ ENHANCED: Format time helper
  const formatTime = (seconds) => {
    if (!seconds || seconds <= 0) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  // ⭐ ENHANCED: Calculate performance metrics with ALL timing data
  const performanceMetrics = {
    accuracy: percentage,
    hintsUsed: finalStats.hints,
    hintsPercentage: totalAnswers > 0 ? Math.round((finalStats.hints / totalAnswers) * 100) : 0,
    totalTime: formatTime(finalStats.totalTime),
    totalTimeSeconds: finalStats.totalTime,
    avgTime: finalStats.avgTimePerWord,
    maxTime: finalStats.maxTimePerWord,
    minTime: finalStats.minTimePerWord,
    totalRecordedTime: formatTime(finalStats.totalRecordedTime),
    speedRating: finalStats.avgTimePerWord <= 8 ? 'Molto veloce' :
                 finalStats.avgTimePerWord <= 15 ? 'Veloce' : 
                 finalStats.avgTimePerWord <= 25 ? 'Normale' : 'Lento',
    efficiency: Math.max(0, percentage - (finalStats.hints / Math.max(1, totalAnswers) * 100))
  };

  console.log('📊 TestResults - Performance metrics calculated:', performanceMetrics);

  return (
    <div className="space-y-8">
      <Card className="relative overflow-hidden backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl">
        {/* Background animato */}
        <div className="absolute inset-0 bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 opacity-50"></div>
        <div className="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>
        
        <CardHeader className="relative text-center py-12">
          <div className="text-8xl mb-6 animate-bounce">
            {result.type === 'victory' ? '🏆' : 
             result.type === 'good' ? '🎉' : '📚'}
          </div>
          <CardTitle className={`text-4xl font-bold mb-4 ${result.color}`}>
            {result.message}
          </CardTitle>
          <div className="text-6xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-2">
            {percentage}%
          </div>
          <p className="text-xl text-gray-600">
            {finalStats.correct} corrette su {totalAnswers} domande
          </p>
          
          {/* ⭐ ENHANCED: Performance summary with ALL stats */}
          <div className="mt-6 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm text-gray-600">
            {finalStats.hints > 0 && (
              <div className="flex items-center justify-center gap-1 bg-orange-100 px-3 py-2 rounded-lg">
                <Lightbulb className="w-4 h-4 text-orange-500" />
                <span>{finalStats.hints} aiuti ({performanceMetrics.hintsPercentage}%)</span>
              </div>
            )}
            {finalStats.totalTime > 0 && (
              <div className="flex items-center justify-center gap-1 bg-blue-100 px-3 py-2 rounded-lg">
                <Clock className="w-4 h-4 text-blue-500" />
                <span>{performanceMetrics.totalTime} totale</span>
              </div>
            )}
            {finalStats.avgTimePerWord > 0 && (
              <div className="flex items-center justify-center gap-1 bg-purple-100 px-3 py-2 rounded-lg">
                <Target className="w-4 h-4 text-purple-500" />
                <span>{finalStats.avgTimePerWord}s media ({performanceMetrics.speedRating})</span>
              </div>
            )}
            {finalStats.maxTimePerWord > 0 && (
              <div className="flex items-center justify-center gap-1 bg-red-100 px-3 py-2 rounded-lg">
                <Timer className="w-4 h-4 text-red-500" />
                <span>{finalStats.maxTimePerWord}s massimo</span>
              </div>
            )}
          </div>
        </CardHeader>
        
        <CardContent className="relative pb-12">
          {/* ⭐ ENHANCED: Statistiche complete con timing dettagliato */}
          <div className="grid grid-cols-2 md:grid-cols-5 gap-6 max-w-6xl mx-auto mb-8">
            <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{finalStats.correct}</div>
              <div className="text-green-100">Corrette</div>
              <Check className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
            <div className="bg-gradient-to-br from-red-500 to-pink-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{finalStats.incorrect}</div>
              <div className="text-red-100">Sbagliate</div>
              <X className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
            
            {/* ⭐ ENHANCED: Hints card con percentuale */}
            <div className="bg-gradient-to-br from-orange-500 to-yellow-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{finalStats.hints}</div>
              <div className="text-orange-100">Aiuti ({performanceMetrics.hintsPercentage}%)</div>
              <Lightbulb className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
            
            {/* ⭐ ENHANCED: Time card con dettagli */}
            <div className="bg-gradient-to-br from-blue-500 to-cyan-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{performanceMetrics.totalTime}</div>
              <div className="text-blue-100">Tempo Totale</div>
              <Clock className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>

            {/* ⭐ ENHANCED: Efficiency card */}
            <div className="bg-gradient-to-br from-purple-500 to-indigo-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{Math.round(performanceMetrics.efficiency)}%</div>
              <div className="text-purple-100">Efficienza</div>
              <Zap className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
          </div>

          {/* ⭐ ENHANCED: Detailed Timing Analysis */}
          {(finalStats.avgTimePerWord > 0 || finalStats.hints > 0) && (
            <Card className="bg-gradient-to-r from-indigo-50 to-purple-50 border-2 border-indigo-200 rounded-3xl overflow-hidden shadow-xl mb-8">
              <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
                <CardTitle className="flex items-center gap-3 text-white">
                  <Target className="w-6 h-6" />
                  Analisi Dettagliata Performance
                </CardTitle>
              </CardHeader>
              <CardContent className="p-6">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  
                  {/* Timing Stats */}
                  <div className="text-center">
                    <h4 className="font-bold text-indigo-800 mb-3">⏱️ Statistiche Tempo</h4>
                    <div className="space-y-2">
                      <div className="bg-white p-3 rounded-lg border border-indigo-200">
                        <div className="text-lg font-bold text-indigo-600">{performanceMetrics.avgTime}s</div>
                        <div className="text-indigo-800 text-sm">Tempo Medio</div>
                      </div>
                      {finalStats.maxTimePerWord > 0 && (
                        <div className="bg-white p-3 rounded-lg border border-red-200">
                          <div className="text-lg font-bold text-red-600">{finalStats.maxTimePerWord}s</div>
                          <div className="text-red-800 text-sm">Tempo Massimo</div>
                        </div>
                      )}
                      {finalStats.minTimePerWord > 0 && (
                        <div className="bg-white p-3 rounded-lg border border-green-200">
                          <div className="text-lg font-bold text-green-600">{finalStats.minTimePerWord}s</div>
                          <div className="text-green-800 text-sm">Tempo Minimo</div>
                        </div>
                      )}
                    </div>
                  </div>
                  
                  {/* Accuracy & Hints */}
                  <div className="text-center">
                    <h4 className="font-bold text-purple-800 mb-3">🎯 Accuratezza</h4>
                    <div className="space-y-2">
                      <div className="bg-white p-3 rounded-lg border border-purple-200">
                        <div className="text-lg font-bold text-purple-600">{performanceMetrics.accuracy}%</div>
                        <div className="text-purple-800 text-sm">Precisione</div>
                      </div>
                      <div className="bg-white p-3 rounded-lg border border-orange-200">
                        <div className="text-lg font-bold text-orange-600">{performanceMetrics.hintsPercentage}%</div>
                        <div className="text-orange-800 text-sm">Aiuti Utilizzati</div>
                      </div>
                      <div className="bg-white p-3 rounded-lg border border-indigo-200">
                        <div className="text-lg font-bold text-indigo-600">{Math.round(performanceMetrics.efficiency)}%</div>
                        <div className="text-indigo-800 text-sm">Efficienza Netta</div>
                      </div>
                    </div>
                  </div>
                  
                  {/* Overall Rating */}
                  <div className="text-center">
                    <h4 className="font-bold text-green-800 mb-3">🏆 Valutazione</h4>
                    <div className="space-y-2">
                      <div className="bg-white p-3 rounded-lg border border-green-200">
                        <div className="text-lg font-bold text-green-600">{performanceMetrics.speedRating}</div>
                        <div className="text-green-800 text-sm">Velocità</div>
                      </div>
                      <div className="bg-white p-3 rounded-lg border border-blue-200">
                        <div className="text-lg font-bold text-blue-600">
                          {performanceMetrics.accuracy >= 80 && performanceMetrics.hintsPercentage <= 20 ? 'Eccellente' :
                           performanceMetrics.accuracy >= 70 ? 'Molto Buono' :
                           performanceMetrics.accuracy >= 60 ? 'Buono' : 'Da Migliorare'}
                        </div>
                        <div className="text-blue-800 text-sm">Performance</div>
                      </div>
                    </div>
                  </div>
                </div>
                
                {/* ⭐ ENHANCED: Performance tips */}
                <div className="mt-6 p-4 bg-white rounded-xl border border-indigo-200">
                  <h4 className="font-bold text-indigo-800 mb-2">💡 Analisi e Suggerimenti:</h4>
                  <div className="text-sm text-indigo-700 space-y-1">
                    {percentage < 60 && (
                      <p>• 📚 Ripassa le parole sbagliate prima del prossimo test</p>
                    )}
                    {performanceMetrics.hintsPercentage > 30 && (
                      <p>• 💭 Prova a riflettere di più prima di usare gli aiuti (attuale: {performanceMetrics.hintsPercentage}%)</p>
                    )}
                    {finalStats.avgTimePerWord > 25 && (
                      <p>• ⚡ Pratica per migliorare i tempi di risposta (media attuale: {finalStats.avgTimePerWord}s)</p>
                    )}
                    {finalStats.maxTimePerWord > 60 && (
                      <p>• ⏰ Alcune parole richiedono troppo tempo (max: {finalStats.maxTimePerWord}s) - ripassa quelle più difficili</p>
                    )}
                    {percentage >= 80 && performanceMetrics.hintsPercentage <= 20 && finalStats.avgTimePerWord <= 20 && (
                      <p>• 🏆 Performance eccellente! Considera di aggiungere parole più difficili al tuo vocabolario</p>
                    )}
                    {performanceMetrics.efficiency > 70 && (
                      <p>• ✨ Ottima efficienza ({Math.round(performanceMetrics.efficiency)}%) - equilibrio perfetto tra precisione e autonomia</p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Bottoni azione */}
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button 
              onClick={onStartNewTest} 
              className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200"
            >
              <Play className="w-5 h-5 mr-2" />
              Nuovo Test
            </Button>
            <Button 
              onClick={onResetTest} 
              variant="outline"
              className="border-2 border-gray-300 hover:border-gray-400 px-8 py-4 text-lg rounded-2xl bg-white/80 backdrop-blur-sm shadow-lg hover:shadow-xl transition-all duration-200"
            >
              <RotateCcw className="w-5 h-5 mr-2" />
              Torna al Menu
            </Button>
          </div>

          {/* ⭐ ENHANCED: Parole Sbagliate con info hints e timing */}
          {wrongWords && wrongWords.length > 0 && (
            <div className="mt-12">
              <Card className="bg-gradient-to-br from-orange-50 to-red-50 border-2 border-orange-200 rounded-3xl overflow-hidden shadow-xl">
                <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
                  <CardTitle className="flex items-center gap-3">
                    <Trophy className="w-6 h-6" />
                    Parole da Ripassare ({wrongWords.length})
                  </CardTitle>
                  <p className="text-orange-100">
                    Studia queste parole per migliorare nel prossimo test!
                  </p>
                </CardHeader>
                <CardContent className="p-6">
                  <div className="grid gap-4">
                    {wrongWords.map((word, index) => (
                      <div
                        key={`${word.id}-${index}`}
                        className="bg-white p-6 rounded-2xl border border-orange-200 shadow-lg hover:shadow-xl transition-shadow duration-200"
                      >
                        <div className="flex justify-between items-start">
                          <div className="flex-1">
                            <div className="flex items-center gap-3 mb-3">
                              <span className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">{word.english}</span>
                              <span className="text-orange-400">→</span>
                              <span className="text-xl text-gray-700">{word.italian}</span>
                              
                              {/* ⭐ ENHANCED: Hint indicator */}
                              {word.usedHint && (
                                <span className="inline-flex items-center gap-1 bg-orange-100 text-orange-700 px-2 py-1 rounded-full text-xs font-medium">
                                  <Lightbulb className="w-3 h-3" />
                                  Aiuto usato
                                </span>
                              )}
                            </div>
                            
                            {word.group && (
                              <div className="mb-3">
                                <span className="inline-flex items-center gap-1 bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-sm font-medium">
                                  📂 {word.group}
                                </span>
                              </div>
                            )}
                            
                            {word.sentence && (
                              <div className="mb-3 p-4 bg-green-50 rounded-xl border border-green-200">
                                <div className="text-green-600 font-semibold text-sm mb-1 flex items-center gap-2">
                                  <span>💬</span> Esempio:
                                </div>
                                <div className="text-green-800 italic">"{word.sentence}"</div>
                              </div>
                            )}
                            
                            {word.notes && (
                              <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200">
                                <div className="text-yellow-600 font-semibold text-sm mb-1 flex items-center gap-2">
                                  <span>📝</span> Note:
                                </div>
                                <div className="text-yellow-800 text-sm whitespace-pre-line">
                                  {formatNotes(word.notes)}
                                </div>
                              </div>
                            )}
                          </div>
                          <div className="text-3xl text-orange-500 ml-4">❌</div>
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default TestResults;

================================================================================

NOME FILE: components\WordsList.js

import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Plus, Trash2, Edit3, ChevronDown, ChevronUp, BookOpen, CheckCircle, Circle, Filter, AlertTriangle } from 'lucide-react';

// Simulated utility functions (replace with your actual imports)
const getCategoryStyle = (group) => {
  const categoryMap = {
    'VERBI': { icon: '⚡', bgColor: 'bg-red-500' },
    'VERBI_IRREGOLARI': { icon: '🔄', bgColor: 'bg-red-600' },
    'SOSTANTIVI': { icon: '🏷️', bgColor: 'bg-blue-500' },
    'AGGETTIVI': { icon: '🎨', bgColor: 'bg-green-500' },
    'FAMIGLIA': { icon: '👨‍👩‍👧‍👦', bgColor: 'bg-pink-400' },
    'TECNOLOGIA': { icon: '💻', bgColor: 'bg-cyan-500' },
    'LAVORO': { icon: '💼', bgColor: 'bg-indigo-500' },
    'DEFAULT': { icon: '📚', bgColor: 'bg-gray-500' }
  };
  return categoryMap[group?.toUpperCase()] || categoryMap['DEFAULT'];
};

const formatNotes = (notes) => {
  if (!notes) return null;
  const keywords = ['Altri Significati', 'Sinonimi', 'Verbo Irregolare', 'Pronuncia', 'Esempi'];
  let formattedText = notes;
  keywords.forEach(keyword => {
    const regex = new RegExp(`(${keyword})\\s*:`, 'gi');
    formattedText = formattedText.replace(regex, `**$1:**`);
  });
  
  return formattedText.split(/(\*\*[^*]+\*\*)/).map((part, index) => {
    if (part.startsWith('**') && part.endsWith('**')) {
      return React.createElement('span', { key: index, className: 'font-bold' }, part.slice(2, -2));
    }
    return part;
  });
};

const WordsList = ({ words, onEditWord, onRemoveWord, onToggleLearned, onToggleDifficult, showWordsList, setShowWordsList }) => {
  const [filterChapter, setFilterChapter] = useState('');
  const [filterLearned, setFilterLearned] = useState('all'); // 'all', 'learned', 'not_learned'
  const [filterDifficult, setFilterDifficult] = useState('all'); // ⭐ NEW: 'all', 'difficult', 'not_difficult'
  const [filterGroup, setFilterGroup] = useState('');

  // Calcolo dati derivati all'inizio per evitare problemi di scope
  const availableChapters = React.useMemo(() => {
    const chapters = new Set();
    words.forEach(word => {
      if (word.chapter) chapters.add(word.chapter);
    });
    return Array.from(chapters).sort((a, b) => {
      const aNum = parseInt(a);
      const bNum = parseInt(b);
      return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
    });
  }, [words]);

  const availableGroups = React.useMemo(() => {
    const groups = new Set();
    words.forEach(word => {
      if (word.group) groups.add(word.group);
    });
    return Array.from(groups).sort();
  }, [words]);

  const wordsWithoutChapter = React.useMemo(() => {
    return words.filter(word => !word.chapter);
  }, [words]);

  // ⭐ ENHANCED: Filtra le parole includendo filtro difficoltà
  const filteredWords = words.filter(word => {
    // Filtro per capitolo
    if (filterChapter !== '') {
      if (filterChapter === 'no-chapter') {
        if (word.chapter) return false;
      } else {
        if (word.chapter !== filterChapter) return false;
      }
    }
    
    // Filtro per gruppo
    if (filterGroup && word.group !== filterGroup) return false;
    
    // Filtro per stato appreso
    if (filterLearned === 'learned' && !word.learned) return false;
    if (filterLearned === 'not_learned' && word.learned) return false;
    
    // ⭐ NEW: Filtro per stato difficile
    if (filterDifficult === 'difficult' && !word.difficult) return false;
    if (filterDifficult === 'not_difficult' && word.difficult) return false;
    
    return true;
  });

  // Raggruppa le parole per capitolo
  const groupedWords = filteredWords.reduce((groups, word) => {
    const chapter = word.chapter || 'Senza Capitolo';
    if (!groups[chapter]) groups[chapter] = [];
    groups[chapter].push(word);
    return groups;
  }, {});

  // ⭐ ENHANCED: Statistiche con parole difficili
  const stats = {
    total: words.length,
    learned: words.filter(w => w.learned).length,
    notLearned: words.filter(w => !w.learned).length,
    difficult: words.filter(w => w.difficult).length, // ⭐ NEW
    withChapter: words.filter(w => w.chapter).length,
    filtered: filteredWords.length
  };

  const clearFilters = () => {
    setFilterChapter('');
    setFilterLearned('all');
    setFilterDifficult('all'); // ⭐ NEW
    setFilterGroup('');
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader 
        className="cursor-pointer hover:bg-gray-50 transition-colors" 
        onClick={() => setShowWordsList(!showWordsList)}
      >
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <span className="text-2xl">📚</span>
            <div className="flex flex-col">
              <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
                Il Tuo Vocabolario ({stats.total} parole)
              </span>
              <div className="flex gap-4 text-sm text-gray-600 mt-1">
                <span>✅ {stats.learned} apprese</span>
                <span>📖 {stats.notLearned} da studiare</span>
                <span>⭐ {stats.difficult} difficili</span> {/* ⭐ NEW */}
                <span>📚 {stats.withChapter} con capitolo</span>
              </div>
            </div>
          </div>
          {showWordsList ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
        </CardTitle>
      </CardHeader>
      
      {showWordsList && (
        <CardContent className="animate-fade-in">
          {words.length === 0 ? (
            <div className="text-center py-16">
              <div className="text-8xl mb-6">📚</div>
              <h3 className="text-2xl font-bold text-gray-700 mb-4">Il tuo vocabolario è vuoto</h3>
              <p className="text-gray-600 text-lg mb-8">Aggiungi la tua prima parola per iniziare a studiare!</p>
              <div className="flex justify-center">
                <Button className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-8 py-4 text-lg rounded-2xl shadow-xl">
                  <Plus className="w-5 h-5 mr-2" />
                  Aggiungi Prima Parola
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-6">
              {/* ⭐ ENHANCED: Filtri con difficoltà */}
              <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200">
                <CardHeader className="pb-3">
                  <CardTitle className="flex items-center gap-2 text-lg">
                    <Filter className="w-5 h-5 text-blue-600" />
                    Filtri ({stats.filtered} parole mostrate)
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Capitolo</label>
                      <select
                        value={filterChapter}
                        onChange={(e) => setFilterChapter(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="">Tutti i capitoli</option>
                        {availableChapters.map(chapter => (
                          <option key={chapter} value={chapter}>📖 {chapter}</option>
                        ))}
                        {wordsWithoutChapter.length > 0 && (
                          <option value="no-chapter">📋 Senza capitolo</option>
                        )}
                      </select>
                    </div>
                    
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Stato Apprendimento</label>
                      <select
                        value={filterLearned}
                        onChange={(e) => setFilterLearned(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="all">Tutte le parole</option>
                        <option value="learned">✅ Solo apprese</option>
                        <option value="not_learned">📖 Solo da studiare</option>
                      </select>
                    </div>
                    
                    {/* ⭐ NEW: Filtro difficoltà */}
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Difficoltà</label>
                      <select
                        value={filterDifficult}
                        onChange={(e) => setFilterDifficult(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="all">Tutte le parole</option>
                        <option value="difficult">⭐ Solo difficili</option>
                        <option value="not_difficult">📚 Solo normali</option>
                      </select>
                    </div>
                    
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Categoria</label>
                      <select
                        value={filterGroup}
                        onChange={(e) => setFilterGroup(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="">Tutte le categorie</option>
                        {availableGroups.map(group => (
                          <option key={group} value={group}>
                            {getCategoryStyle(group).icon} {group}
                          </option>
                        ))}
                      </select>
                    </div>
                    
                    <div className="flex items-end">
                      <Button 
                        onClick={clearFilters}
                        variant="outline"
                        className="w-full"
                      >
                        Cancella Filtri
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* ⭐ ENHANCED: Statistiche Generali con difficoltà */}
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                <div className="text-center p-4 bg-blue-50 rounded-2xl border border-blue-200">
                  <div className="text-2xl font-bold text-blue-600">{stats.total}</div>
                  <div className="text-blue-700 text-sm">Totale Parole</div>
                </div>
                <div className="text-center p-4 bg-green-50 rounded-2xl border border-green-200">
                  <div className="text-2xl font-bold text-green-600">{stats.learned}</div>
                  <div className="text-green-700 text-sm">Apprese</div>
                </div>
                <div className="text-center p-4 bg-orange-50 rounded-2xl border border-orange-200">
                  <div className="text-2xl font-bold text-orange-600">{stats.notLearned}</div>
                  <div className="text-orange-700 text-sm">Da Studiare</div>
                </div>
                <div className="text-center p-4 bg-red-50 rounded-2xl border border-red-200">
                  <div className="text-2xl font-bold text-red-600">{stats.difficult}</div>
                  <div className="text-red-700 text-sm">⭐ Difficili</div>
                </div>
                <div className="text-center p-4 bg-purple-50 rounded-2xl border border-purple-200">
                  <div className="text-2xl font-bold text-purple-600">{availableChapters.length}</div>
                  <div className="text-purple-700 text-sm">Capitoli</div>
                </div>
              </div>

              {/* Lista Parole Raggruppate per Capitolo */}
              <div className="space-y-6 max-h-96 overflow-y-auto scrollbar-thin">
                {Object.entries(groupedWords)
                  .sort(([a], [b]) => {
                    if (a === 'Senza Capitolo') return 1;
                    if (b === 'Senza Capitolo') return -1;
                    const aNum = parseInt(a);
                    const bNum = parseInt(b);
                    return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
                  })
                  .map(([chapter, chapterWords]) => (
                    <div key={chapter} className="space-y-3">
                      {/* Header Capitolo Enhanced */}
                      <div className="flex items-center gap-3 p-3 bg-gradient-to-r from-indigo-100 to-purple-100 rounded-2xl border border-indigo-200">
                        <BookOpen className="w-5 h-5 text-indigo-600" />
                        <h3 className="font-bold text-indigo-800 text-lg">
                          {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`}
                        </h3>
                        <span className="text-sm text-indigo-600 bg-indigo-200 px-3 py-1 rounded-full">
                          {chapterWords.length} parole
                        </span>
                        <span className="text-sm text-green-600 bg-green-200 px-3 py-1 rounded-full">
                          {chapterWords.filter(w => w.learned).length} apprese
                        </span>
                        {/* ⭐ NEW: Difficili counter */}
                        <span className="text-sm text-red-600 bg-red-200 px-3 py-1 rounded-full">
                          {chapterWords.filter(w => w.difficult).length} difficili
                        </span>
                      </div>
                      
                      {/* Parole del Capitolo */}
                      <div className="space-y-3">
                        {chapterWords.map((word) => (
                          <WordCard 
                            key={word.id} 
                            word={word} 
                            onEdit={() => onEditWord(word)}
                            onRemove={() => onRemoveWord(word.id)}
                            onToggleLearned={() => onToggleLearned(word.id)}
                            onToggleDifficult={() => onToggleDifficult(word.id)} // ⭐ NEW
                          />
                        ))}
                      </div>
                    </div>
                  ))}
              </div>
            </div>
          )}
        </CardContent>
      )}
    </Card>
  );
};

// ⭐ ENHANCED: WordCard con gestione difficoltà
const WordCard = ({ word, onEdit, onRemove, onToggleLearned, onToggleDifficult }) => (
  <div className={`p-6 rounded-2xl border-2 hover:shadow-lg transition-all duration-300 hover-lift ${
    word.learned 
      ? 'bg-gradient-to-r from-green-50 to-emerald-50 border-green-200' 
      : word.difficult
        ? 'bg-gradient-to-r from-red-50 to-orange-50 border-red-200'
        : 'bg-gradient-to-r from-white to-gray-50 border-gray-100 hover:border-gray-200'
  }`}>
    <div className="flex justify-between items-start">
      <div className="flex-1">
        <div className="flex items-center gap-3 mb-3">
          <span className={`text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent ${
            word.learned ? 'opacity-75' : ''
          }`}>
            {word.english}
          </span>
          <span className="text-gray-400 text-xl">→</span>
          <span className={`text-xl font-medium ${
            word.learned ? 'text-gray-600' : 'text-gray-700'
          }`}>
            {word.italian}
          </span>
          
          {/* Stato Appreso */}
          <div 
            onClick={onToggleLearned}
            className="cursor-pointer"
            title={word.learned ? "Segna come non appresa" : "Segna come appresa"}
          >
            {word.learned ? (
              <CheckCircle className="w-6 h-6 text-green-500 hover:text-green-600 transition-colors" />
            ) : (
              <Circle className="w-6 h-6 text-gray-400 hover:text-green-500 transition-colors" />
            )}
          </div>
          
          {/* ⭐ NEW: Stato Difficile */}
          <div 
            onClick={onToggleDifficult}
            className="cursor-pointer"
            title={word.difficult ? "Rimuovi da parole difficili" : "Segna come difficile"}
          >
            {word.difficult ? (
              <AlertTriangle className="w-6 h-6 text-red-500 hover:text-red-600 transition-colors fill-current" />
            ) : (
              <AlertTriangle className="w-6 h-6 text-gray-400 hover:text-red-500 transition-colors" />
            )}
          </div>
        </div>
        
        <div className="flex flex-wrap gap-2 mb-3">
          {word.group && (
            <span className={`inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium text-white shadow-lg ${getCategoryStyle(word.group).bgColor}`}>
              <span>{getCategoryStyle(word.group).icon}</span>
              {word.group}
            </span>
          )}
          
          {word.chapter && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-700">
              <BookOpen className="w-4 h-4" />
              Cap. {word.chapter}
            </span>
          )}
          
          {word.learned && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-700">
              <CheckCircle className="w-4 h-4" />
              Appresa
            </span>
          )}
          
          {/* ⭐ NEW: Badge parola difficile */}
          {word.difficult && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-red-100 text-red-700">
              <AlertTriangle className="w-4 h-4" />
              ⭐ Difficile
            </span>
          )}
        </div>

        {word.sentence && (
          <div className="mb-3 p-4 bg-green-50 rounded-xl border border-green-200">
            <div className="text-green-600 font-semibold text-sm mb-1 flex items-center gap-2">
              <span>💬</span> Esempio:
            </div>
            <div className="text-green-800 italic">"{word.sentence}"</div>
          </div>
        )}

        {word.notes && (
          <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200">
            <div className="text-yellow-600 font-semibold text-sm mb-1 flex items-center gap-2">
              <span>📝</span> Note:
            </div>
            <div className="text-yellow-800 text-sm whitespace-pre-line">
              {formatNotes(word.notes)}
            </div>
          </div>
        )}
      </div>
      
      <div className="flex gap-2 ml-4">
        <Button
          onClick={onEdit}
          variant="ghost"
          size="sm"
          className="text-blue-500 hover:text-blue-700 hover:bg-blue-50 p-3 rounded-xl transition-colors"
          title="Modifica parola"
        >
          <Edit3 className="w-5 h-5" />
        </Button>
        <Button
          onClick={onRemove}
          variant="ghost"
          size="sm"
          className="text-red-500 hover:text-red-700 hover:bg-red-50 p-3 rounded-xl transition-colors"
          title="Elimina parola"
        >
          <Trash2 className="w-5 h-5" />
        </Button>
      </div>
    </div>
  </div>
);

export default WordsList;


================================================================================

NOME FILE: components\layout\AppHeader.js

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card';
import { Brain, Sparkles } from 'lucide-react';

export const AppHeader = React.memo(() => (
  <div className="text-center relative">
    <div className="absolute inset-0 bg-gradient-to-r from-blue-600 to-purple-600 rounded-3xl blur-3xl opacity-20"></div>
    <Card className="relative backdrop-blur-sm bg-white/80 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10"></div>
      <CardHeader className="relative py-8">
        <CardTitle className="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center justify-center gap-3">
          <Brain className="w-10 h-10 text-blue-600" />
          Vocabulary Master
          <Sparkles className="w-8 h-8 text-purple-600" />
        </CardTitle>
        <p className="text-gray-600 text-lg mt-2">La tua app intelligente per imparare l'inglese</p>
      </CardHeader>
    </Card>
  </div>
));

================================================================================

NOME FILE: components\layout\AppNavigation.js

import React from 'react';
import { useAppContext } from '../../contexts/AppContext';
import { Card, CardContent } from '../ui/card';
import { Button } from '../ui/button';
import { Brain, BarChart3 } from 'lucide-react';

export const AppNavigation = React.memo(() => {
  const { currentView, dispatch, testHistory } = useAppContext();

  const navItems = [
    {
      id: 'main',
      label: 'Studio & Vocabolario',
      icon: Brain,
      color: 'from-blue-500 to-purple-600'
    },
    {
      id: 'stats',
      label: 'Statistiche Complete',
      icon: BarChart3,
      color: 'from-purple-500 to-pink-600',
      badge: testHistory.length > 0 ? testHistory.length : null
    }
  ];

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardContent className="p-2">
        <div className="flex gap-2 p-2">
          {navItems.map(item => (
            <Button
              key={item.id}
              onClick={() => dispatch({ type: 'SET_VIEW', payload: item.id })}
              className={`flex-1 py-4 px-6 rounded-2xl text-lg font-semibold transition-all duration-300 ${
                currentView === item.id 
                  ? `bg-gradient-to-r ${item.color} text-white shadow-lg transform scale-105` 
                  : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
              }`}
            >
              <item.icon className="w-6 h-6 mr-3" />
              {item.label}
              {item.badge && (
                <span className="ml-2 bg-white/20 text-white px-2 py-1 rounded-full text-sm">
                  {item.badge}
                </span>
              )}
            </Button>
          ))}
        </div>
      </CardContent>
    </Card>
  );
});

================================================================================

NOME FILE: components\main\ControlPanel.js

import React from 'react';
import { Card, CardContent, CardTitle } from '../ui/card';
import { Button } from '../ui/button';
import { Play, RefreshCw, BookOpen, AlertTriangle } from 'lucide-react';

export const ControlPanel = React.memo(({ 
  onStartTest, 
  onClearAllWords, 
  words, 
  wordStats,
  getAvailableChapters, 
  getChapterStats 
}) => {
  const availableWords = words.filter(word => !word.learned);
  const chapters = getAvailableChapters();
  
  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-1">
        <div className="bg-white rounded-3xl p-6">
          <CardTitle className="flex items-center gap-3 text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-6">
            <Play className="w-6 h-6 text-blue-600" />
            Controlli di Studio
          </CardTitle>
          
          {/* ⭐ ENHANCED: Statistiche con parole difficili */}
          <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
            <div className="text-center p-4 bg-blue-50 rounded-2xl border border-blue-200">
              <div className="text-2xl font-bold text-blue-600">{wordStats.total}</div>
              <div className="text-blue-700 text-sm">Totale Parole</div>
            </div>
            <div className="text-center p-4 bg-green-50 rounded-2xl border border-green-200">
              <div className="text-2xl font-bold text-green-600">{wordStats.learned}</div>
              <div className="text-green-700 text-sm">Apprese</div>
            </div>
            <div className="text-center p-4 bg-orange-50 rounded-2xl border border-orange-200">
              <div className="text-2xl font-bold text-orange-600">{wordStats.unlearned}</div>
              <div className="text-orange-700 text-sm">Da Studiare</div>
            </div>
            <div className="text-center p-4 bg-red-50 rounded-2xl border border-red-200">
              <div className="text-2xl font-bold text-red-600">{wordStats.difficult}</div>
              <div className="text-red-700 text-sm">⭐ Difficili</div>
            </div>
            <div className="text-center p-4 bg-purple-50 rounded-2xl border border-purple-200">
              <div className="text-2xl font-bold text-purple-600">{chapters.length}</div>
              <div className="text-purple-700 text-sm">Capitoli</div>
            </div>
          </div>

          {/* ⭐ NEW: Info box per parole difficili */}
          {wordStats.difficult > 0 && (
            <div className="mb-6 p-4 bg-gradient-to-r from-red-50 to-orange-50 border-2 border-red-200 rounded-2xl">
              <div className="flex items-center gap-3 mb-2">
                <AlertTriangle className="w-6 h-6 text-red-600" />
                <h4 className="font-bold text-red-800">Parole Difficili Disponibili</h4>
              </div>
              <p className="text-red-700 text-sm">
                Hai {wordStats.difficult} parole marcate come difficili. 
                Usa la modalità "Solo Parole Difficili" per concentrarti su di esse!
              </p>
            </div>
          )}
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Button 
              onClick={onStartTest} 
              disabled={availableWords.length === 0}
              className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white p-6 h-auto rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              <div className="flex flex-col items-center gap-2">
                <BookOpen className="w-8 h-8" />
                <span className="font-bold">Inizia Test</span>
                <span className="text-sm opacity-90">
                  ({availableWords.length} disponibili
                  {wordStats.difficult > 0 && `, ${wordStats.difficult} difficili`})
                </span>
              </div>
            </Button>

            <Button 
              onClick={onClearAllWords} 
              variant="outline" 
              disabled={words.length === 0}
              className="border-2 border-red-300 hover:border-red-400 p-6 h-auto rounded-2xl bg-red-50 hover:bg-red-100 transition-all duration-200 disabled:opacity-50"
            >
              <div className="flex flex-col items-center gap-2 text-red-600">
                <RefreshCw className="w-8 h-8" />
                <span className="font-bold">Pulisci Vocabolario</span>
                <span className="text-sm">Elimina tutte le parole</span>
              </div>
            </Button>
          </div>
        </div>
      </div>
    </Card>
  );
});


================================================================================

NOME FILE: components\modals\GlobalModals.js

import React from 'react';
import { useAppContext } from '../../contexts/AppContext';
import { useNotification } from '../../contexts/NotificationContext';
import { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter } from '../ui/modal';
import { Button } from '../ui/button';
import ChapterTestSelector from '../ChapterTestSelector';
import { Trash2, RefreshCw } from 'lucide-react';

export const GlobalModals = React.memo(() => {
  const { 
    confirmDelete, 
    showConfirmClear, 
    showChapterSelector,
    dispatch,
    words,
    // testHistory, // ✅ Removed unused variable
    removeWord,
    clearAllWords,
    startTest
  } = useAppContext();
  
  const { showSuccess } = useNotification();

  const handleConfirmDelete = () => {
    if (confirmDelete) {
      removeWord(confirmDelete.id);
      showSuccess(`✅ Parola "${confirmDelete.english}" eliminata!`);
      dispatch({ type: 'SET_CONFIRM_DELETE', payload: null });
    }
  };

  const handleConfirmClear = () => {
    clearAllWords();
    dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false });
    showSuccess('✅ Tutte le parole sono state eliminate!');
  };

  const handleTestStart = (filteredWords) => {
    startTest(filteredWords);
    dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: false });
  };

  return (
    <>
      {/* Delete Word Modal */}
      <Modal 
        isOpen={!!confirmDelete} 
        onClose={() => dispatch({ type: 'SET_CONFIRM_DELETE', payload: null })}
      >
        <ModalHeader className="bg-gradient-to-r from-red-500 to-pink-500 text-white rounded-t-2xl">
          <ModalTitle className="text-white flex items-center gap-2">
            <Trash2 className="w-5 h-5" />
            Conferma Eliminazione
          </ModalTitle>
        </ModalHeader>
        <ModalContent>
          <div className="text-center py-4">
            <div className="text-6xl mb-4">🗑️</div>
            <p className="text-gray-700 mb-2">Sei sicuro di voler eliminare la parola</p>
            <div className="bg-gray-100 rounded-lg p-3 mb-4">
              <span className="font-bold text-lg text-red-600">"{confirmDelete?.english}"</span>
              {confirmDelete?.italian && (
                <>
                  <span className="mx-2 text-gray-400">→</span>
                  <span className="text-gray-700">{confirmDelete.italian}</span>
                </>
              )}
            </div>
            <p className="text-sm text-gray-500">Questa azione non può essere annullata.</p>
          </div>
        </ModalContent>
        <ModalFooter>
          <Button 
            onClick={() => dispatch({ type: 'SET_CONFIRM_DELETE', payload: null })} 
            variant="outline"
          >
            Annulla
          </Button>
          <Button 
            onClick={handleConfirmDelete} 
            className="bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white"
          >
            Elimina
          </Button>
        </ModalFooter>
      </Modal>

      {/* Clear All Words Modal */}
      <Modal 
        isOpen={showConfirmClear} 
        onClose={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })}
      >
        <ModalHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white rounded-t-2xl">
          <ModalTitle className="text-white flex items-center gap-2">
            <RefreshCw className="w-5 h-5" />
            Eliminazione Completa
          </ModalTitle>
        </ModalHeader>
        <ModalContent>
          <div className="text-center py-4">
            <div className="text-6xl mb-4">⚠️</div>
            <p className="text-gray-700 mb-4">
              Sei sicuro di voler eliminare tutte le <strong>{words.length} parole</strong>?
            </p>
            <div className="bg-orange-50 border border-orange-200 rounded-lg p-4 mb-4">
              <p className="text-orange-800 text-sm">
                Questa azione eliminerà permanentemente tutto il tuo vocabolario e non può essere annullata.
              </p>
            </div>
          </div>
        </ModalContent>
        <ModalFooter>
          <Button 
            onClick={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })} 
            variant="outline"
          >
            Annulla
          </Button>
          <Button 
            onClick={handleConfirmClear} 
            className="bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white"
          >
            Elimina Tutto
          </Button>
        </ModalFooter>
      </Modal>

      {/* Chapter Test Selector */}
      {showChapterSelector && (
        <ChapterTestSelector
          words={words}
          onStartTest={handleTestStart}
          onClose={() => dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: false })}
        />
      )}
    </>
  );
});

================================================================================

NOME FILE: components\stats\DataManagementPanel.js

// =====================================================
// DataManagementPanel.js - FIXED File Import/Export
// =====================================================

import React from 'react';
import { Card } from '../ui/card';
import { Button } from '../ui/button';
import { Shield, AlertTriangle, Download, Upload, RefreshCw } from 'lucide-react';
import { useDataManagement } from './hooks/useDataManagement';

const DataManagementPanel = () => {
  const {
    isExporting,
    isImporting,
    isProcessing,
    handleExport,
    handleImportClick,
    handleFileSelect, // ⭐ FIXED: Use the correct file handler
    handleReset,
    fileInputRef
  } = useDataManagement();

  return (
    <Card className="mb-6 p-4 bg-gradient-to-r from-indigo-50 to-purple-50 border-2 border-indigo-200 rounded-2xl animate-fade-in">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Backup Section */}
        <div className="text-center">
          <h4 className="font-bold text-indigo-800 mb-3 flex items-center justify-center gap-2">
            <Shield className="w-5 h-5" />
            Backup Completo
          </h4>
          <div className="space-y-2">
            <Button 
              onClick={handleExport}
              disabled={isExporting || isProcessing}
              className="w-full bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white"
            >
              <Download className="w-4 h-4 mr-2" />
              {isExporting ? '⏳ Esportando...' : 'Esporta Backup'}
            </Button>
            <Button 
              onClick={handleImportClick}
              disabled={isImporting || isProcessing}
              className="w-full bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white"
            >
              <Upload className="w-4 h-4 mr-2" />
              {isImporting ? '⏳ Importando...' : 'Importa Backup'}
            </Button>
          </div>
          
          {/* ⭐ ENHANCED: Info about backup content */}
          <div className="mt-3 p-3 bg-white rounded-lg border border-indigo-200">
            <p className="text-xs text-indigo-700">
              <strong>Include:</strong> Parole, Statistiche, Cronologia Test, Performance Parole
            </p>
          </div>
        </div>

        {/* Reset Section */}
        <div className="text-center">
          <h4 className="font-bold text-red-800 mb-3 flex items-center justify-center gap-2">
            <AlertTriangle className="w-5 h-5" />
            Reset Completo
          </h4>
          <Button 
            onClick={handleReset}
            disabled={isProcessing}
            className="w-full bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white"
          >
            <RefreshCw className="w-4 h-4 mr-2" />
            Reset Completo
          </Button>
          <p className="text-xs text-red-600 mt-2">
            ⚠️ Cancella tutto: parole, test, statistiche
          </p>
        </div>
      </div>

      {/* ⭐ FIXED: Correct file input with proper onChange handler */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".json"
        onChange={handleFileSelect}
        style={{ display: 'none' }}
      />
    </Card>
  );
};

export default DataManagementPanel;

================================================================================

NOME FILE: components\stats\StatsHeader.js

import React from 'react';
import { Card, CardTitle } from '../ui/card';
import { Button } from '../ui/button';
import { BarChart3, Database } from 'lucide-react';
import { useStatsData } from './hooks/useStatsData';
import StatisticCard from './components/StatisticCard';

const StatsHeader = ({ 
  testHistory, 
  showDataManagement, 
  setShowDataManagement,
  onClearHistory 
}) => {
  const { advancedStats } = useStatsData(testHistory);

  const mainStats = [
    { label: 'Test Completati', value: advancedStats.totalTests, color: 'blue' },
    { label: '📚 Parole Studiate', value: advancedStats.totalWordsStudied, color: 'emerald' },
    { label: 'Media', value: `${advancedStats.averageScore}%`, color: 'green' },
    { label: 'Record', value: `${advancedStats.bestScore}%`, color: 'purple' },
    { label: 'Aiuti', value: advancedStats.totalHints, color: 'yellow' },
    { label: '% Aiuti', value: `${advancedStats.hintsPercentage}%`, color: 'indigo' }
  ];

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1">
        <div className="bg-white rounded-3xl p-6">
          <div className="flex justify-between items-center mb-6">
            <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
              <BarChart3 className="w-8 h-8 text-purple-600" />
              Analisi Avanzata dell'Apprendimento
              <span className="text-sm bg-green-100 text-green-700 px-2 py-1 rounded-full">
                Live: {testHistory.length} test
              </span>
            </CardTitle>
            
            <div className="flex gap-2">
              <Button
                onClick={() => setShowDataManagement(!showDataManagement)}
                className="bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white px-4 py-2 rounded-xl"
              >
                <Database className="w-4 h-4 mr-2" />
                Gestione Dati
              </Button>
              <Button
                onClick={onClearHistory}
                variant="outline"
                className="border-red-300 text-red-600 hover:bg-red-50"
              >
                🗑️ Pulisci Cronologia ({testHistory.length})
              </Button>
            </div>
          </div>

          <div className="grid grid-cols-2 md:grid-cols-6 gap-4">
            {mainStats.map((stat, index) => (
              <StatisticCard 
                key={index}
                label={stat.label}
                value={stat.value}
                color={stat.color}
              />
            ))}
          </div>
        </div>
      </div>
    </Card>
  );
};

export default StatsHeader;

================================================================================

NOME FILE: components\stats\StatsNavigation.js

import React from 'react';
import { Button } from '../ui/button';

const StatsNavigation = ({ selectedView, setSelectedView }) => {
  const tabs = [
    { id: 'overview', label: 'Panoramica', icon: '📈' },
    { id: 'chapters', label: 'Per Capitoli', icon: '📚' },
    { id: 'words', label: 'Per Parole', icon: '🔍' },
    { id: 'performance', label: 'Performance', icon: '🎯' },
    { id: 'trends', label: 'Tendenze', icon: '📊' }
  ];

  return (
    <div className="flex gap-2 mb-6">
      {tabs.map(tab => (
        <Button
          key={tab.id}
          onClick={() => setSelectedView(tab.id)}
          className={`px-6 py-3 rounded-xl transition-all ${
            selectedView === tab.id
              ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg'
              : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
          }`}
        >
          <span className="mr-2">{tab.icon}</span>
          {tab.label}
        </Button>
      ))}
    </div>
  );
};

export default StatsNavigation;


================================================================================

NOME FILE: components\stats\StatsOverview.js

import React, { useState, useEffect } from 'react';
import { useAppContext } from '../../contexts/AppContext';
import StatsHeader from './StatsHeader';
import StatsNavigation from './StatsNavigation';
import DataManagementPanel from './DataManagementPanel';
import EmptyState from '../stats/components/EmptyState';


// Lazy loading delle sezioni
const OverviewSection = React.lazy(() => import('./sections/OverviewSection'));
const ChaptersSection = React.lazy(() => import('./sections/ChaptersSection'));
const WordsSection = React.lazy(() => import('./sections/WordsSection'));
const PerformanceSection = React.lazy(() => import('./sections/PerformanceSection'));
const TrendsSection = React.lazy(() => import('./sections/TrendsSection'));

const StatsOverview = ({ testHistory, words, onClearHistory, onGoToMain, forceUpdate }) => {
  const [selectedView, setSelectedView] = useState('overview');
  const [showDataManagement, setShowDataManagement] = useState(false);
  const [localRefresh, setLocalRefresh] = useState(0);

  useEffect(() => {
    setLocalRefresh(prev => prev + 1);
  }, [testHistory.length, forceUpdate]);

  // Se non ci sono test, mostra empty state
  if (testHistory.length === 0) {
    return (
      <EmptyState 
        onGoToMain={onGoToMain}
        showDataManagement={showDataManagement}
        setShowDataManagement={setShowDataManagement}
      />
    );
  }

  const renderSelectedSection = () => {
    const commonProps = { 
      testHistory, 
      words, 
      localRefresh,
      onClearHistory 
    };

    switch (selectedView) {
      case 'overview':
        return <OverviewSection {...commonProps} />;
      case 'chapters':
        return <ChaptersSection {...commonProps} />;
      case 'words':
        return <WordsSection {...commonProps} />;
      case 'performance':
        return <PerformanceSection {...commonProps} />;
      case 'trends':
        return <TrendsSection {...commonProps} />;
      default:
        return <OverviewSection {...commonProps} />;
    }
  };

  return (
    <div className="space-y-8 animate-fade-in">
      <StatsHeader 
        testHistory={testHistory}
        showDataManagement={showDataManagement}
        setShowDataManagement={setShowDataManagement}
        onClearHistory={onClearHistory}
      />

      <StatsNavigation 
        selectedView={selectedView}
        setSelectedView={setSelectedView}
      />

      {showDataManagement && <DataManagementPanel />}

      <React.Suspense fallback={<div className="text-center py-8">Caricamento...</div>}>
        {renderSelectedSection()}
      </React.Suspense>
    </div>
  );
};

export default StatsOverview;

================================================================================

NOME FILE: components\stats\components\EmptyState.js

// =====================================================
// 🔧 FIX 3: components/EmptyState.js CORRETTO
// =====================================================
// src/components/stats/components/EmptyState.js

import React from 'react';
import { Card, CardTitle } from '../../ui/card';
import { Button } from '../../ui/button';
import { Play, Database } from 'lucide-react';
import DataManagementPanel from '../DataManagementPanel';

const EmptyState = ({ onGoToMain, showDataManagement, setShowDataManagement }) => {
  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1">
        <div className="bg-white rounded-3xl p-6">
          <div className="flex justify-between items-center mb-6">
            <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
              Statistiche e Analisi
              <span className="text-sm bg-gray-100 text-gray-700 px-2 py-1 rounded-full">
                0 test
              </span>
            </CardTitle>
            
            <Button
              onClick={() => setShowDataManagement(!showDataManagement)}
              className="bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white px-4 py-2 rounded-xl"
            >
              <Database className="w-4 h-4 mr-2" />
              Gestione Dati
            </Button>
          </div>

          {showDataManagement && <DataManagementPanel />}

          <div className="text-center py-16">
            <div className="text-8xl mb-6">📊</div>
            <h3 className="text-2xl font-bold text-gray-700 mb-4">Nessun test completato</h3>
            <p className="text-gray-600 text-lg mb-8">Completa il tuo primo test per vedere le statistiche dettagliate!</p>
            <Button 
              onClick={onGoToMain} 
              className="bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl"
            >
              <Play className="w-5 h-5 mr-2" />
              Inizia il Primo Test
            </Button>
          </div>
        </div>
      </div>
    </Card>
  );
};

export default EmptyState;

================================================================================

NOME FILE: components\stats\components\StatisticCard.js

// =====================================================
// 7. components/StatisticCard.js - Card Riutilizzabile
// =====================================================

import React from 'react';

const StatisticCard = ({ label, value, color = 'blue' }) => {
  const colorClasses = {
    blue: 'from-blue-500 to-cyan-500 text-blue-100',
    emerald: 'from-emerald-500 to-green-500 text-emerald-100',
    green: 'from-green-500 to-emerald-500 text-green-100',
    purple: 'from-purple-500 to-pink-500 text-purple-100',
    yellow: 'from-yellow-500 to-orange-500 text-yellow-100',
    indigo: 'from-indigo-500 to-blue-500 text-indigo-100'
  };

  return (
    <div className={`bg-gradient-to-br ${colorClasses[color]} p-4 rounded-2xl text-white text-center shadow-xl`}>
      <div className="text-2xl font-bold">{value}</div>
      <div className="text-sm">{label}</div>
    </div>
  );
};

export default StatisticCard;

================================================================================

NOME FILE: components\stats\components\WordDetailSection.js


// =====================================================
// 📁 FILE MANCANTE: components/WordDetailSection.js
// =====================================================
// src/components/stats/components/WordDetailSection.js

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { Award } from 'lucide-react';

const WordDetailSection = ({ wordId, getWordAnalysis, localRefresh }) => {
  const wordAnalysis = getWordAnalysis ? getWordAnalysis(wordId) : null;
  
  if (!wordAnalysis) return null;

  const timelineData = wordAnalysis.attempts.map((attempt, index) => ({
    attempt: `#${index + 1}`,
    success: attempt.correct ? 100 : 0,
    hint: attempt.usedHint ? 50 : 0,
    time: Math.round(attempt.timeSpent / 1000),
    date: new Date(attempt.timestamp).toLocaleDateString('it-IT')
  }));

  return (
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden" key={`detail-${wordId}-${localRefresh}`}>
      <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Award className="w-6 h-6" />
          Andamento Temporale Parola
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Timeline Chart */}
          <div>
            <h4 className="font-bold text-lg text-gray-800 mb-4">Ultimi 10 Tentativi</h4>
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={timelineData} key={`word-line-${wordId}-${localRefresh}`}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="attempt" />
                <YAxis domain={[0, 100]} />
                <Tooltip 
                  formatter={(value, name) => [
                    name === 'success' ? (value === 100 ? 'Corretta' : 'Sbagliata') :
                    name === 'hint' ? (value === 50 ? 'Con aiuto' : 'Senza aiuto') :
                    `${value}s`,
                    name === 'success' ? 'Risultato' :
                    name === 'hint' ? 'Aiuto' : 'Tempo'
                  ]}
                />
                <Line 
                  type="monotone" 
                  dataKey="success" 
                  stroke="#10b981" 
                  strokeWidth={3}
                  name="success"
                  dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }}
                />
                <Line 
                  type="monotone" 
                  dataKey="hint" 
                  stroke="#f59e0b" 
                  strokeWidth={2}
                  name="hint"
                  strokeDasharray="5 5"
                />
                <Line 
                  type="monotone" 
                  dataKey="time" 
                  stroke="#8b5cf6" 
                  strokeWidth={2}
                  name="time"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>

          {/* Statistics */}
          <div>
            <h4 className="font-bold text-lg text-gray-800 mb-4">Statistiche Dettagliate</h4>
            <div className="grid grid-cols-2 gap-4">
              <div className="text-center p-3 bg-blue-50 rounded-xl">
                <div className="text-xl font-bold text-blue-600">{wordAnalysis.accuracy}%</div>
                <div className="text-blue-700 text-sm">Precisione</div>
              </div>
              <div className="text-center p-3 bg-orange-50 rounded-xl">
                <div className="text-xl font-bold text-orange-600">{wordAnalysis.hintsPercentage}%</div>
                <div className="text-orange-700 text-sm">% Aiuti</div>
              </div>
              <div className="text-center p-3 bg-green-50 rounded-xl">
                <div className="text-xl font-bold text-green-600">{wordAnalysis.currentStreak}</div>
                <div className="text-green-700 text-sm">Streak Attuale</div>
              </div>
              <div className="text-center p-3 bg-purple-50 rounded-xl">
                <div className="text-xl font-bold text-purple-600">{wordAnalysis.avgTime}s</div>
                <div className="text-purple-700 text-sm">Tempo Medio</div>
              </div>
            </div>
            
            <div className="mt-4 p-4 bg-gray-50 rounded-xl">
              <div className="text-sm text-gray-700">
                <div className="mb-2">
                  <strong>Tentativi totali:</strong> {wordAnalysis.totalAttempts}
                </div>
                <div className="mb-2">
                  <strong>Precisione recente:</strong> {wordAnalysis.recentAccuracy}% (ultimi 5)
                </div>
                <div>
                  <strong>Stato:</strong> <span className="font-medium">{wordAnalysis.status}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default WordDetailSection;


================================================================================

NOME FILE: components\stats\components\WordPerformanceCard.js

import React from 'react';

const WordPerformanceCard = ({ word, isSelected, onClick }) => {
  const getStatusColor = (status) => {
    const colors = {
      critical: 'bg-red-500',
      inconsistent: 'bg-orange-500',
      struggling: 'bg-yellow-500',
      promising: 'bg-blue-500',
      improving: 'bg-green-500',
      consolidated: 'bg-emerald-500',
      new: 'bg-gray-500'
    };
    return colors[status] || 'bg-gray-500';
  };

  const getStatusLabel = (status) => {
    const labels = {
      critical: '🔴 Critica',
      inconsistent: '🟠 Instabile',
      struggling: '🟡 In difficoltà',
      promising: '🔵 Promettente',
      improving: '🟢 Migliorando',
      consolidated: '🟢 Consolidata',
      new: '⚪ Nuova'
    };
    return labels[status] || '⚪ Sconosciuto';
  };

  return (
    <div
      onClick={onClick}
      className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
        isSelected 
          ? 'border-blue-500 bg-blue-50 shadow-lg' 
          : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
      }`}
    >
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <div className="flex flex-col">
            <div className="font-bold text-lg text-gray-800">{word.english}</div>
            <div className="text-gray-600">{word.italian}</div>
            {word.chapter && (
              <div className="text-sm text-blue-600">📖 Capitolo {word.chapter}</div>
            )}
          </div>
        </div>
        
        <div className="flex items-center gap-4">
          <div className="text-center">
            <div className="text-lg font-bold text-blue-600">{word.accuracy}%</div>
            <div className="text-blue-700 text-xs">Precisione</div>
          </div>
          
          <div className="text-center">
            <div className="text-lg font-bold text-orange-600">{word.hintsPercentage}%</div>
            <div className="text-orange-700 text-xs">Aiuti</div>
          </div>
          
          <div className="text-center">
            <div className="text-lg font-bold text-green-600">{word.currentStreak}</div>
            <div className="text-green-700 text-xs">Streak</div>
          </div>
          
          <div className="text-center">
            <div className="text-lg font-bold text-purple-600">{word.avgTime}s</div>
            <div className="text-purple-700 text-xs">Tempo Medio</div>
          </div>
          
          <div className={`px-3 py-1 rounded-full text-white text-sm font-medium ${getStatusColor(word.status)}`}>
            {getStatusLabel(word.status)}
          </div>
        </div>
      </div>
      
      <div className="mt-3 text-sm text-gray-500">
        {word.totalAttempts} tentativi • Ultimo: {word.lastAttempt ? new Date(word.lastAttempt.timestamp).toLocaleDateString('it-IT') : 'Mai'}
      </div>
    </div>
  );
};

export default WordPerformanceCard;

================================================================================

NOME FILE: components\stats\hooks\useDataManagement.js

// =====================================================
// 6. hooks/useDataManagement.js - FIXED Import/Export
// =====================================================

import { useState, useRef } from 'react';
import { useAppContext } from '../../../contexts/AppContext';

export const useDataManagement = () => {
  const [isImporting, setIsImporting] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const fileInputRef = useRef(null);

  const {
    exportStats,
    importStats,
    resetStats,
    refreshData,
    isProcessing
  } = useAppContext();

  const handleExport = async () => {
    if (isExporting || isProcessing) return;
    
    try {
      setIsExporting(true);
      await new Promise(resolve => setTimeout(resolve, 100));
      exportStats();
    } catch (error) {
      console.error('❌ Errore export:', error);
    } finally {
      setIsExporting(false);
    }
  };

  const handleImportClick = () => {
    if (isImporting || isProcessing) return;
    fileInputRef.current?.click();
  };

  // ⭐ FIXED: Proper file selection handler
  const handleFileSelect = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (file.type !== 'application/json') {
      alert('Per favore seleziona un file JSON valido');
      return;
    }

    setIsImporting(true);
    
    try {
      await importStats(file);
      setTimeout(() => {
        refreshData();
      }, 200);
    } catch (error) {
      console.error('❌ Errore importazione:', error);
      alert(`Errore durante l'importazione: ${error.message}`);
    } finally {
      setIsImporting(false);
      event.target.value = ''; // Reset file input
    }
  };

  const handleReset = async () => {
    if (isProcessing) return;

    const confirmation = window.confirm('⚠️ ATTENZIONE: Questa operazione cancellerà tutti i dati. Continuare?');
    if (!confirmation) return;

    try {
      await resetStats();
      setTimeout(() => {
        refreshData();
      }, 200);
    } catch (error) {
      console.error('❌ Errore reset:', error);
      alert(`Errore durante il reset: ${error.message}`);
    }
  };

  return {
    isExporting,
    isImporting,
    isProcessing,
    handleExport,
    handleImportClick,
    handleFileSelect, // ⭐ FIXED: Export the file handler
    handleReset,
    fileInputRef
  };
};

================================================================================

NOME FILE: components\stats\hooks\useStatsData.js

import { useMemo } from 'react';

export const useStatsData = (testHistory) => {
  const advancedStats = useMemo(() => {
    if (testHistory.length === 0) {
      return {
        totalTests: 0,
        averageScore: 0,
        bestScore: 0,
        worstScore: 0,
        totalWordsStudied: 0,
        totalCorrect: 0,
        totalIncorrect: 0,
        totalHints: 0,
        hintsPercentage: 0,
        chaptersAnalyzed: 0,
        chapterPerformance: {}
      };
    }

    const totalTests = testHistory.length;
    const totalCorrect = testHistory.reduce((sum, test) => sum + (test.correctWords || 0), 0);
    const totalIncorrect = testHistory.reduce((sum, test) => sum + (test.incorrectWords || 0), 0);
    const totalHints = testHistory.reduce((sum, test) => sum + (test.hintsUsed || 0), 0);
    const totalWordsStudied = totalCorrect + totalIncorrect;
    const hintsPercentage = totalWordsStudied > 0 ? Math.round((totalHints / totalWordsStudied) * 100) : 0;
    const averageScore = Math.round(testHistory.reduce((sum, test) => sum + (test.percentage || 0), 0) / totalTests);
    const bestScore = Math.max(...testHistory.map(test => test.percentage || 0));
    const worstScore = Math.min(...testHistory.map(test => test.percentage || 100));

    // Performance per capitolo
    const chapterPerformance = {};
    testHistory.forEach(test => {
      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, stats]) => {
          if (!chapterPerformance[chapter]) {
            chapterPerformance[chapter] = {
              totalTests: 0,
              totalWords: 0,
              totalCorrect: 0,
              totalIncorrect: 0,
              totalHints: 0,
              averagePercentage: 0,
              bestPercentage: 0,
              worstPercentage: 100,
              hintsPercentage: 0
            };
          }
          
          const perf = chapterPerformance[chapter];
          perf.totalTests += 1;
          perf.totalWords += stats.totalWords || 0;
          perf.totalCorrect += stats.correctWords || 0;
          perf.totalIncorrect += stats.incorrectWords || 0;
          perf.totalHints += stats.hintsUsed || 0;
          perf.bestPercentage = Math.max(perf.bestPercentage, stats.percentage || 0);
          perf.worstPercentage = Math.min(perf.worstPercentage, stats.percentage || 100);
        });
      }
    });

    // Calcola percentuali medie per capitolo
    Object.keys(chapterPerformance).forEach(chapter => {
      const perf = chapterPerformance[chapter];
      perf.averagePercentage = perf.totalWords > 0 ? Math.round((perf.totalCorrect / perf.totalWords) * 100) : 0;
      perf.hintsPercentage = perf.totalWords > 0 ? Math.round((perf.totalHints / perf.totalWords) * 100) : 0;
    });

    return {
      totalTests,
      averageScore,
      bestScore,
      worstScore,
      totalWordsStudied,
      totalCorrect,
      totalIncorrect,
      totalHints,
      hintsPercentage,
      chaptersAnalyzed: Object.keys(chapterPerformance).length,
      chapterPerformance
    };
  }, [testHistory]);

  const timelineData = useMemo(() => {
    return [...testHistory].reverse().slice(-20).map((test, index) => ({
      test: `Test ${index + 1}`,
      percentage: test.percentage || 0,
      correct: test.correctWords || 0,
      incorrect: test.incorrectWords || 0,
      hints: test.hintsUsed || 0,
      avgTime: test.avgTimePerWord || 0,
      date: new Date(test.timestamp).toLocaleDateString('it-IT'),
      time: new Date(test.timestamp).toLocaleTimeString('it-IT', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      chapters: test.testParameters?.selectedChapters?.length || 0,
      difficulty: test.difficulty || 'medium',
      type: test.testType || 'unknown'
    }));
  }, [testHistory]);

  const chapterComparisonData = useMemo(() => {
    return Object.entries(advancedStats.chapterPerformance).map(([chapter, perf]) => ({
      chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`,
      fullChapter: chapter,
      accuracy: perf.averagePercentage,
      tests: perf.totalTests,
      words: perf.totalWords,
      hints: perf.hintsPercentage,
      efficiency: Math.max(0, perf.averagePercentage - perf.hintsPercentage),
      trend: perf.bestPercentage - perf.worstPercentage
    })).sort((a, b) => b.accuracy - a.accuracy);
  }, [advancedStats]);

  return {
    advancedStats,
    timelineData,
    chapterComparisonData
  };
};


================================================================================

NOME FILE: components\stats\sections\ChaptersSection.js

// =====================================================
// 📁 src/components/stats/sections/ChaptersSection.js - ENHANCED
// =====================================================

import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card';
import { 
  BarChart, 
  Bar, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  ResponsiveContainer,
  LineChart,
  Line,
  PieChart,
  Pie,
  Cell,
  ComposedChart,
  Area,
  AreaChart
} from 'recharts';
import { BookOpen, TrendingUp, Award, Target } from 'lucide-react';
import { useStatsData } from '../hooks/useStatsData';

const ChaptersSection = ({ testHistory, words, localRefresh }) => {
  const { advancedStats, chapterComparisonData } = useStatsData(testHistory);

  // ⭐ ENHANCED: Elaborazione dati completa per capitoli
  const enhancedChapterData = useMemo(() => {
    const chapterStats = {};
    const chapterTrends = {};

    // Raccolta dati base per capitolo
    words.forEach(word => {
      const chapter = word.chapter || 'Senza Capitolo';
      if (!chapterStats[chapter]) {
        chapterStats[chapter] = {
          totalWords: 0,
          learnedWords: 0,
          difficultWords: 0,
          tests: 0,
          totalCorrect: 0,
          totalIncorrect: 0,
          totalHints: 0,
          testsPerformed: 0
        };
      }
      chapterStats[chapter].totalWords++;
      if (word.learned) chapterStats[chapter].learnedWords++;
      if (word.difficult) chapterStats[chapter].difficultWords++;
    });

    // Analisi test history per capitolo
    testHistory.forEach(test => {
      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, stats]) => {
          if (!chapterStats[chapter]) {
            chapterStats[chapter] = {
              totalWords: 0, learnedWords: 0, difficultWords: 0,
              tests: 0, totalCorrect: 0, totalIncorrect: 0, totalHints: 0, testsPerformed: 0
            };
          }
          
          chapterStats[chapter].tests++;
          chapterStats[chapter].totalCorrect += stats.correctWords || 0;
          chapterStats[chapter].totalIncorrect += stats.incorrectWords || 0;
          chapterStats[chapter].totalHints += stats.hintsUsed || 0;
          chapterStats[chapter].testsPerformed++;

          // Trend temporale
          const testDate = new Date(test.timestamp).toISOString().split('T')[0];
          if (!chapterTrends[chapter]) {
            chapterTrends[chapter] = [];
          }
          chapterTrends[chapter].push({
            date: testDate,
            accuracy: stats.percentage || 0,
            hints: stats.hintsUsed || 0,
            timestamp: test.timestamp
          });
        });
      }
    });

    // Calcolo metriche finali
    const processedData = Object.entries(chapterStats).map(([chapter, data]) => {
      const totalAnswers = data.totalCorrect + data.totalIncorrect;
      const accuracy = totalAnswers > 0 ? Math.round((data.totalCorrect / totalAnswers) * 100) : 0;
      const hintsPercentage = totalAnswers > 0 ? Math.round((data.totalHints / totalAnswers) * 100) : 0;
      const efficiency = Math.max(0, accuracy - hintsPercentage);
      const completionRate = data.totalWords > 0 ? Math.round((data.learnedWords / data.totalWords) * 100) : 0;
      const difficultyRate = data.totalWords > 0 ? Math.round((data.difficultWords / data.totalWords) * 100) : 0;

      return {
        chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`,
        fullChapter: chapter,
        totalWords: data.totalWords,
        learnedWords: data.learnedWords,
        difficultWords: data.difficultWords,
        testsPerformed: data.testsPerformed,
        accuracy,
        hintsPercentage,
        efficiency,
        completionRate,
        difficultyRate,
        studyProgress: Math.min(100, completionRate + (accuracy / 2)),
        trend: chapterTrends[chapter] ? chapterTrends[chapter].slice(-5) : []
      };
    }).sort((a, b) => b.studyProgress - a.studyProgress);

    return { processedData, chapterTrends };
  }, [testHistory, words, localRefresh]);

  // ⭐ NEW: Dati per grafico trend temporale
  const trendData = useMemo(() => {
    const trends = {};
    testHistory.slice(-20).forEach(test => {
      const date = new Date(test.timestamp).toLocaleDateString('it-IT', { month: 'short', day: 'numeric' });
      if (!trends[date]) {
        trends[date] = { date, chapters: {} };
      }
      
      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, stats]) => {
          const chapterKey = chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`;
          if (!trends[date].chapters[chapterKey]) {
            trends[date].chapters[chapterKey] = [];
          }
          trends[date].chapters[chapterKey].push(stats.percentage || 0);
        });
      }
    });

    return Object.values(trends).map(day => {
      const result = { date: day.date };
      Object.entries(day.chapters).forEach(([chapter, scores]) => {
        result[chapter] = Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);
      });
      return result;
    });
  }, [testHistory]);

  // ⭐ NEW: Top performing chapters
  const topChapters = enhancedChapterData.processedData.slice(0, 5);
  const strugglingChapters = enhancedChapterData.processedData
    .filter(c => c.testsPerformed > 0)
    .sort((a, b) => a.efficiency - b.efficiency)
    .slice(0, 3);

  // ⭐ NEW: Colors for charts
  const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#06B6D4', '#84CC16'];

  return (
    <div className="space-y-8" key={`chapters-${localRefresh}`}>
      
      {/* ⭐ ENHANCED: Overview Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card className="bg-gradient-to-br from-blue-500 to-blue-600 text-white">
          <CardContent className="p-4 text-center">
            <BookOpen className="w-8 h-8 mx-auto mb-2" />
            <div className="text-2xl font-bold">{enhancedChapterData.processedData.length}</div>
            <div className="text-blue-100 text-sm">Capitoli Totali</div>
          </CardContent>
        </Card>
        
        <Card className="bg-gradient-to-br from-green-500 to-green-600 text-white">
          <CardContent className="p-4 text-center">
            <Award className="w-8 h-8 mx-auto mb-2" />
            <div className="text-2xl font-bold">
              {topChapters.length > 0 ? Math.round(topChapters[0]?.efficiency || 0) : 0}%
            </div>
            <div className="text-green-100 text-sm">Miglior Efficienza</div>
          </CardContent>
        </Card>
        
        <Card className="bg-gradient-to-br from-purple-500 to-purple-600 text-white">
          <CardContent className="p-4 text-center">
            <Target className="w-8 h-8 mx-auto mb-2" />
            <div className="text-2xl font-bold">
              {Math.round(enhancedChapterData.processedData.reduce((sum, c) => sum + c.completionRate, 0) / Math.max(1, enhancedChapterData.processedData.length))}%
            </div>
            <div className="text-purple-100 text-sm">Completamento Medio</div>
          </CardContent>
        </Card>
        
        <Card className="bg-gradient-to-br from-orange-500 to-orange-600 text-white">
          <CardContent className="p-4 text-center">
            <TrendingUp className="w-8 h-8 mx-auto mb-2" />
            <div className="text-2xl font-bold">
              {enhancedChapterData.processedData.filter(c => c.testsPerformed > 0).length}
            </div>
            <div className="text-orange-100 text-sm">Capitoli Testati</div>
          </CardContent>
        </Card>
      </div>

      {/* ⭐ ENHANCED: Performance Comparison Chart */}
      <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
        <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white">
          <CardTitle className="flex items-center gap-3 text-white">
            <BarChart className="w-6 h-6" />
            Analisi Performance Dettagliata per Capitolo
          </CardTitle>
          <p className="text-blue-100 text-sm">
            Efficienza = Precisione - Aiuti utilizzati. Verde = Ottimo, Giallo = Buono, Rosso = Da migliorare
          </p>
        </CardHeader>
        <CardContent className="p-6">
          <ResponsiveContainer width="100%" height={400}>
            <ComposedChart data={enhancedChapterData.processedData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" />
              <XAxis dataKey="chapter" tick={{ fontSize: 12 }} />
              <YAxis domain={[0, 100]} tick={{ fontSize: 12 }} />
              <Tooltip 
                formatter={(value, name) => [
                  `${value}%`,
                  name === 'accuracy' ? 'Precisione' :
                  name === 'hintsPercentage' ? 'Aiuti Usati' :
                  name === 'efficiency' ? 'Efficienza Netta' :
                  name === 'completionRate' ? 'Completamento' : name
                ]}
                labelFormatter={(label) => `Capitolo: ${label}`}
                contentStyle={{ backgroundColor: '#f8fafc', border: '1px solid #e2e8f0' }}
              />
              <Bar dataKey="accuracy" fill="#3b82f6" name="accuracy" />
              <Bar dataKey="hintsPercentage" fill="#f59e0b" name="hintsPercentage" />
              <Bar dataKey="efficiency" fill="#10b981" name="efficiency" />
              <Line type="monotone" dataKey="completionRate" stroke="#8b5cf6" strokeWidth={3} name="completionRate" />
            </ComposedChart>
          </ResponsiveContainer>
          
          <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-center text-sm">
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-blue-500 rounded"></div>
              <span>Precisione %</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-yellow-500 rounded"></div>
              <span>Aiuti %</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-green-500 rounded"></div>
              <span>Efficienza Netta</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-purple-500 rounded"></div>
              <span>Completamento</span>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* ⭐ NEW: Trend Temporale */}
      {trendData.length > 5 && (
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <TrendingUp className="w-6 h-6" />
              Andamento Temporale per Capitolo (Ultimi Test)
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            <ResponsiveContainer width="100%" height={350}>
              <LineChart data={trendData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" />
                <YAxis domain={[0, 100]} />
                <Tooltip />
                {Object.keys(trendData[0] || {})
                  .filter(key => key !== 'date')
                  .slice(0, 5)
                  .map((chapter, index) => (
                    <Line 
                      key={chapter}
                      type="monotone" 
                      dataKey={chapter} 
                      stroke={colors[index]} 
                      strokeWidth={2}
                      name={chapter}
                    />
                  ))}
              </LineChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      )}

      {/* ⭐ NEW: Top & Struggling Chapters */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        
        {/* Top Performing */}
        <Card className="bg-gradient-to-br from-green-50 to-emerald-50 border-2 border-green-200">
          <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
            <CardTitle className="flex items-center gap-3">
              <Award className="w-6 h-6" />
              🏆 Top Capitoli Performer
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            <div className="space-y-4">
              {topChapters.map((chapter, index) => (
                <div key={chapter.fullChapter} className="flex items-center justify-between p-4 bg-white rounded-xl border border-green-200">
                  <div className="flex items-center gap-3">
                    <div className={`w-8 h-8 rounded-full flex items-center justify-center text-white font-bold ${
                      index === 0 ? 'bg-yellow-500' : index === 1 ? 'bg-gray-400' : 'bg-orange-500'
                    }`}>
                      {index + 1}
                    </div>
                    <div>
                      <div className="font-bold text-gray-800">{chapter.chapter}</div>
                      <div className="text-sm text-gray-600">
                        {chapter.totalWords} parole • {chapter.testsPerformed} test
                      </div>
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-xl font-bold text-green-600">{chapter.efficiency}%</div>
                    <div className="text-sm text-green-700">Efficienza</div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>

        {/* Struggling Chapters */}
        {strugglingChapters.length > 0 && (
          <Card className="bg-gradient-to-br from-orange-50 to-red-50 border-2 border-orange-200">
            <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
              <CardTitle className="flex items-center gap-3">
                <Target className="w-6 h-6" />
                📚 Capitoli da Migliorare
              </CardTitle>
            </CardHeader>
            <CardContent className="p-6">
              <div className="space-y-4">
                {strugglingChapters.map((chapter, index) => (
                  <div key={chapter.fullChapter} className="p-4 bg-white rounded-xl border border-orange-200">
                    <div className="flex items-center justify-between mb-3">
                      <div className="font-bold text-gray-800">{chapter.chapter}</div>
                      <div className="text-xl font-bold text-red-600">{chapter.efficiency}%</div>
                    </div>
                    
                    <div className="grid grid-cols-3 gap-2 text-sm">
                      <div className="text-center">
                        <div className="font-bold text-blue-600">{chapter.accuracy}%</div>
                        <div className="text-blue-700 text-xs">Precisione</div>
                      </div>
                      <div className="text-center">
                        <div className="font-bold text-orange-600">{chapter.hintsPercentage}%</div>
                        <div className="text-orange-700 text-xs">Aiuti</div>
                      </div>
                      <div className="text-center">
                        <div className="font-bold text-purple-600">{chapter.difficultyRate}%</div>
                        <div className="text-purple-700 text-xs">Difficili</div>
                      </div>
                    </div>
                    
                    <div className="mt-3 p-2 bg-orange-100 rounded-lg">
                      <p className="text-xs text-orange-800">
                        💡 <strong>Suggerimento:</strong> 
                        {chapter.hintsPercentage > 30 ? ' Riduci l\'uso degli aiuti' : ''}
                        {chapter.difficultyRate > 50 ? ' Ripassa le parole difficili' : ''}
                        {chapter.accuracy < 60 ? ' Concentrati su questo capitolo' : ''}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}
      </div>

      {/* ⭐ NEW: Detailed Chapter Breakdown */}
      <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
        <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
          <CardTitle className="flex items-center gap-3 text-white">
            <BookOpen className="w-6 h-6" />
            Analisi Dettagliata Tutti i Capitoli
          </CardTitle>
        </CardHeader>
        <CardContent className="p-6">
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead>
                <tr className="border-b border-gray-200">
                  <th className="text-left py-3 px-2 font-bold">Capitolo</th>
                  <th className="text-center py-3 px-2 font-bold">Parole</th>
                  <th className="text-center py-3 px-2 font-bold">Test</th>
                  <th className="text-center py-3 px-2 font-bold">Precisione</th>
                  <th className="text-center py-3 px-2 font-bold">Aiuti</th>
                  <th className="text-center py-3 px-2 font-bold">Efficienza</th>
                  <th className="text-center py-3 px-2 font-bold">Completamento</th>
                  <th className="text-center py-3 px-2 font-bold">Status</th>
                </tr>
              </thead>
              <tbody>
                {enhancedChapterData.processedData.map((chapter, index) => (
                  <tr key={chapter.fullChapter} className={`border-b border-gray-100 ${index % 2 === 0 ? 'bg-gray-50' : 'bg-white'}`}>
                    <td className="py-3 px-2 font-medium">{chapter.chapter}</td>
                    <td className="text-center py-3 px-2">
                      <span className="inline-flex items-center gap-1">
                        {chapter.totalWords}
                        {chapter.difficultWords > 0 && (
                          <span className="text-xs bg-red-100 text-red-700 px-1 rounded">
                            {chapter.difficultWords}⭐
                          </span>
                        )}
                      </span>
                    </td>
                    <td className="text-center py-3 px-2">{chapter.testsPerformed}</td>
                    <td className="text-center py-3 px-2">
                      <span className={`font-bold ${
                        chapter.accuracy >= 80 ? 'text-green-600' : 
                        chapter.accuracy >= 60 ? 'text-blue-600' : 'text-red-600'
                      }`}>
                        {chapter.accuracy}%
                      </span>
                    </td>
                    <td className="text-center py-3 px-2">
                      <span className={`font-bold ${
                        chapter.hintsPercentage <= 20 ? 'text-green-600' : 
                        chapter.hintsPercentage <= 40 ? 'text-orange-600' : 'text-red-600'
                      }`}>
                        {chapter.hintsPercentage}%
                      </span>
                    </td>
                    <td className="text-center py-3 px-2">
                      <span className={`font-bold ${
                        chapter.efficiency >= 70 ? 'text-green-600' : 
                        chapter.efficiency >= 50 ? 'text-orange-600' : 'text-red-600'
                      }`}>
                        {chapter.efficiency}%
                      </span>
                    </td>
                    <td className="text-center py-3 px-2">
                      <div className="flex items-center justify-center">
                        <div className="w-12 bg-gray-200 rounded-full h-2">
                          <div 
                            className={`h-2 rounded-full ${
                              chapter.completionRate >= 80 ? 'bg-green-500' : 
                              chapter.completionRate >= 50 ? 'bg-blue-500' : 'bg-orange-500'
                            }`}
                            style={{ width: `${Math.min(100, chapter.completionRate)}%` }}
                          ></div>
                        </div>
                        <span className="ml-2 text-xs font-bold">{chapter.completionRate}%</span>
                      </div>
                    </td>
                    <td className="text-center py-3 px-2">
                      {chapter.testsPerformed === 0 ? (
                        <span className="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded-full">Non testato</span>
                      ) : chapter.efficiency >= 70 ? (
                        <span className="text-xs bg-green-100 text-green-700 px-2 py-1 rounded-full">🏆 Eccellente</span>
                      ) : chapter.efficiency >= 50 ? (
                        <span className="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full">👍 Buono</span>
                      ) : (
                        <span className="text-xs bg-orange-100 text-orange-700 px-2 py-1 rounded-full">📚 Da migliorare</span>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default ChaptersSection;

================================================================================

NOME FILE: components\stats\sections\OverviewSection.js

// =====================================================
// 📁 src/components/stats/sections/OverviewSection.js - FIXED Multi-Metric Chart
// =====================================================

import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card';
import { 
  LineChart, 
  Line, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  ResponsiveContainer,
  AreaChart,
  Area,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
  ComposedChart
} from 'recharts';
import { TrendingUp, Target, Clock, Lightbulb, Zap, Award } from 'lucide-react';
import { useStatsData } from '../hooks/useStatsData';

const OverviewSection = ({ testHistory, localRefresh }) => {
  const { advancedStats, timelineData } = useStatsData(testHistory);

  // ⭐ ENHANCED: Analisi Performance Avanzata
  const performanceAnalysis = useMemo(() => {
    if (testHistory.length === 0) return null;

    // Calcolo velocità di apprendimento (miglioramento nel tempo)
    const learningVelocity = timelineData.length > 5 ? 
      timelineData[timelineData.length - 1].percentage - timelineData[0].percentage : 0;

    // Consistenza (variazione standard dei risultati)
    const scores = timelineData.map(t => t.percentage);
    const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / scores.length;
    const consistency = Math.max(0, 100 - Math.sqrt(variance));

    // Efficienza negli aiuti
    const totalHints = timelineData.reduce((sum, t) => sum + (t.hints || 0), 0);
    const totalAnswers = advancedStats.totalWordsStudied;
    const hintEfficiency = totalAnswers > 0 ? Math.max(0, 100 - (totalHints / totalAnswers * 100)) : 100;

    // Analisi velocità di risposta
    const avgResponseTime = timelineData.reduce((sum, t) => sum + (t.avgTime || 0), 0) / Math.max(1, timelineData.length);
    const speedRating = avgResponseTime <= 10 ? 'Veloce' : avgResponseTime <= 20 ? 'Normale' : 'Lento';
    const speedScore = avgResponseTime <= 10 ? 100 : avgResponseTime <= 20 ? 75 : 50;

    // Performance Index (metrica combinata)
    const performanceIndex = Math.round(
      (advancedStats.averageScore * 0.4) + 
      (consistency * 0.25) + 
      (hintEfficiency * 0.2) + 
      (speedScore * 0.15)
    );

    return {
      learningVelocity: Math.round(learningVelocity * 10) / 10,
      consistency: Math.round(consistency),
      hintEfficiency: Math.round(hintEfficiency),
      avgResponseTime: Math.round(avgResponseTime * 10) / 10,
      speedRating,
      speedScore: Math.round(speedScore),
      performanceIndex,
      trend: learningVelocity > 0 ? 'Miglioramento' : learningVelocity < 0 ? 'Calo' : 'Stabile'
    };
  }, [testHistory, timelineData, advancedStats]);

  // ⭐ FIXED: Dati per grafico performance multi-metrica con aiuti corretti
  const multiMetricData = useMemo(() => {
    return timelineData.map(item => ({
      ...item,
      efficiency: Math.max(0, item.percentage - (item.hints || 0)),
      speed: item.avgTime ? Math.max(0, 100 - Math.min(100, item.avgTime * 2)) : 50,
      consistency: item.percentage,
      // ⭐ CRITICAL: Keep hints as raw number for proper display
      hintsCount: item.hints || 0  // Raw number of hints used in this test
    }));
  }, [timelineData]);

  // ⭐ NEW: Distribuzione performance
  const performanceDistribution = useMemo(() => {
    const ranges = { excellent: 0, good: 0, average: 0, poor: 0 };
    timelineData.forEach(test => {
      if (test.percentage >= 90) ranges.excellent++;
      else if (test.percentage >= 75) ranges.good++;
      else if (test.percentage >= 60) ranges.average++;
      else ranges.poor++;
    });

    return [
      { name: 'Eccellente (90%+)', value: ranges.excellent, color: '#10B981' },
      { name: 'Buono (75-89%)', value: ranges.good, color: '#3B82F6' },
      { name: 'Medio (60-74%)', value: ranges.average, color: '#F59E0B' },
      { name: 'Da migliorare (<60%)', value: ranges.poor, color: '#EF4444' }
    ].filter(item => item.value > 0);
  }, [timelineData]);

  // ⭐ NEW: Analisi pattern settimanali/temporali
  const weeklyPattern = useMemo(() => {
    const pattern = {};
    testHistory.forEach(test => {
      const date = new Date(test.timestamp);
      const dayOfWeek = date.toLocaleDateString('it-IT', { weekday: 'short' });
      if (!pattern[dayOfWeek]) {
        pattern[dayOfWeek] = { tests: 0, totalScore: 0 };
      }
      pattern[dayOfWeek].tests++;
      pattern[dayOfWeek].totalScore += test.percentage;
    });

    return Object.entries(pattern).map(([day, data]) => ({
      day,
      tests: data.tests,
      avgScore: Math.round(data.totalScore / data.tests),
      frequency: data.tests
    })).sort((a, b) => {
      const dayOrder = ['lun', 'mar', 'mer', 'gio', 'ven', 'sab', 'dom'];
      return dayOrder.indexOf(a.day) - dayOrder.indexOf(b.day);
    });
  }, [testHistory]);

  if (!performanceAnalysis) {
    return (
      <div className="text-center py-16 text-gray-500">
        <Target className="w-16 h-16 mx-auto mb-4 opacity-50" />
        <p>Completa alcuni test per vedere le metriche performance</p>
      </div>
    );
  }

  return (
    <div className="space-y-8" key={`overview-${localRefresh}`}>
      
      {/* ⭐ ENHANCED: Performance Index Overview */}
      <Card className="bg-gradient-to-br from-indigo-500 via-purple-600 to-pink-500 text-white">
        <CardContent className="p-8">
          <div className="text-center mb-6">
            <h2 className="text-3xl font-bold mb-2">Performance Index</h2>
            <div className="text-6xl font-bold mb-2">{performanceAnalysis.performanceIndex}</div>
            <div className="text-xl opacity-90">
              {performanceAnalysis.performanceIndex >= 85 ? '🏆 Eccellente!' :
               performanceAnalysis.performanceIndex >= 70 ? '👍 Molto Buono' :
               performanceAnalysis.performanceIndex >= 55 ? '📈 In Crescita' : '📚 Da Migliorare'}
            </div>
          </div>
          
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <div className="text-2xl font-bold">{advancedStats.averageScore}%</div>
              <div className="text-white/80 text-sm">Precisione Media</div>
            </div>
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <div className="text-2xl font-bold">{performanceAnalysis.consistency}%</div>
              <div className="text-white/80 text-sm">Consistenza</div>
            </div>
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <div className="text-2xl font-bold">{performanceAnalysis.hintEfficiency}%</div>
              <div className="text-white/80 text-sm">Efficienza Aiuti</div>
            </div>
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <div className="text-2xl font-bold">{performanceAnalysis.speedScore}%</div>
              <div className="text-white/80 text-sm">Velocità Risposta</div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* ⭐ FIXED: Multi-Metric Performance Chart with line for hints */}
      <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
        <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white">
          <CardTitle className="flex items-center gap-3 text-white">
            <TrendingUp className="w-6 h-6" />
            Andamento Multi-Metrica (Ultimi 20 Test)
          </CardTitle>
          <p className="text-blue-100 text-sm">
            Monitoraggio di precisione, efficienza, velocità e aiuti nel tempo
          </p>
        </CardHeader>
        <CardContent className="p-6">
          <ResponsiveContainer width="100%" height={350}>
            <ComposedChart data={multiMetricData}>
              <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" />
              <XAxis dataKey="test" tick={{ fontSize: 12 }} />
              <YAxis yAxisId="left" domain={[0, 100]} tick={{ fontSize: 12 }} label={{ value: 'Percentuale (%)', angle: -90, position: 'insideLeft' }} />
              <YAxis yAxisId="right" orientation="right" domain={[0, 'dataMax + 2']} tick={{ fontSize: 12 }} label={{ value: 'Aiuti', angle: 90, position: 'insideRight' }} />
              <Tooltip 
                formatter={(value, name) => {
                  if (name === 'hintsCount') {
                    return [`${value} aiuti`, 'Aiuti Utilizzati'];
                  }
                  return [
                    `${Math.round(value)}%`,
                    name === 'percentage' ? 'Precisione' :
                    name === 'efficiency' ? 'Efficienza' :
                    name === 'speed' ? 'Velocità' : name
                  ];
                }}
                contentStyle={{ backgroundColor: '#f8fafc', border: '1px solid #e2e8f0' }}
              />
              {/* Area for precision */}
              <Area 
                yAxisId="left"
                type="monotone" 
                dataKey="percentage" 
                fill="#3b82f6" 
                fillOpacity={0.3}
                stroke="#3b82f6" 
                strokeWidth={3}
                name="percentage"
              />
              {/* Line for efficiency */}
              <Line 
                yAxisId="left"
                type="monotone" 
                dataKey="efficiency" 
                stroke="#10b981" 
                strokeWidth={2}
                name="efficiency"
              />
              {/* Line for speed */}
              <Line 
                yAxisId="left"
                type="monotone" 
                dataKey="speed" 
                stroke="#8b5cf6" 
                strokeWidth={2}
                name="speed"
              />
              {/* ⭐ FIXED: Line for hints instead of bar */}
              <Line 
                yAxisId="right"
                type="monotone" 
                dataKey="hintsCount" 
                stroke="#f59e0b" 
                strokeWidth={3}
                strokeDasharray="5 5"
                dot={{ fill: '#f59e0b', strokeWidth: 2, r: 4 }}
                name="hintsCount"
              />
            </ComposedChart>
          </ResponsiveContainer>
          
          <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-center text-sm">
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-blue-500 rounded"></div>
              <span>Precisione (%)</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-green-500 rounded"></div>
              <span>Efficienza (%)</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-purple-500 rounded"></div>
              <span>Velocità (%)</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 border-2 border-yellow-500 bg-white rounded"></div>
              <span>Aiuti (linea tratteggiata)</span>
            </div>
          </div>
          
          {/* ⭐ NEW: Detailed explanation of metrics */}
          <div className="mt-6 p-4 bg-blue-50 rounded-xl border border-blue-200">
            <h4 className="font-bold text-blue-800 mb-3 flex items-center gap-2">
              <Target className="w-5 h-5" />
              📊 Spiegazione delle Metriche
            </h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-blue-700">
              <div>
                <h5 className="font-bold mb-2">📈 Metriche Principali (Asse Sinistro 0-100%):</h5>
                <ul className="space-y-1 text-xs">
                  <li><strong>🎯 Precisione:</strong> % di risposte corrette nel test</li>
                  <li><strong>⚡ Efficienza:</strong> Precisione - Aiuti utilizzati (indica autonomia)</li>
                  <li><strong>🚀 Velocità:</strong> Score basato su tempo medio di risposta<br/>
                      <span className="text-blue-600">• ≤10s = 100% • ≤20s = 75% • +20s = 50%</span></li>
                </ul>
              </div>
              <div>
                <h5 className="font-bold mb-2">💡 Aiuti (Asse Destro - Linea Tratteggiata):</h5>
                <ul className="space-y-1 text-xs">
                  <li><strong>Numero assoluto</strong> di aiuti utilizzati nel test</li>
                  <li><strong>Obiettivo:</strong> Diminuzione nel tempo = maggiore autonomia</li>
                  <li><strong>Ideale:</strong> Uso saltuario e strategico degli aiuti</li>
                </ul>
              </div>
            </div>
            <div className="mt-3 p-3 bg-white rounded-lg border border-blue-200">
              <p className="text-xs text-blue-700">
                <strong>💡 Come interpretare:</strong> Un trend positivo mostra precisione in aumento, 
                aiuti in diminuzione ed efficienza crescente. La velocità migliora con l'esperienza.
              </p>
            </div>
          </div>
          
          {/* ⭐ NEW: Hints analysis summary */}
          <div className="mt-6 p-4 bg-orange-50 rounded-xl border border-orange-200">
            <h4 className="font-bold text-orange-800 mb-2 flex items-center gap-2">
              <Lightbulb className="w-5 h-5" />
              Analisi Utilizzo Aiuti
            </h4>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
              <div className="text-center">
                <div className="text-lg font-bold text-orange-600">{advancedStats.totalHints}</div>
                <div className="text-orange-700">Aiuti Totali</div>
              </div>
              <div className="text-center">
                <div className="text-lg font-bold text-orange-600">{advancedStats.hintsPercentage}%</div>
                <div className="text-orange-700">% Risposte con Aiuto</div>
              </div>
              <div className="text-center">
                <div className="text-lg font-bold text-orange-600">
                  {timelineData.length > 0 ? Math.round(advancedStats.totalHints / timelineData.length * 10) / 10 : 0}
                </div>
                <div className="text-orange-700">Media Aiuti/Test</div>
              </div>
            </div>
            <div className="mt-3 text-xs text-orange-600">
              💡 <strong>Suggerimento:</strong> Un uso efficiente degli aiuti è sotto il 20% delle risposte. 
              Gli aiuti dovrebbero diminuire con l'esperienza.
            </div>
          </div>
        </CardContent>
      </Card>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        
        {/* ⭐ NEW: Performance Distribution */}
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <Award className="w-6 h-6" />
              Distribuzione Performance
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            {performanceDistribution.length > 0 ? (
              <>
                <ResponsiveContainer width="100%" height={250}>
                  <PieChart>
                    <Pie
                      data={performanceDistribution}
                      cx="50%"
                      cy="50%"
                      outerRadius={80}
                      dataKey="value"
                      label={({ name, value, percent }) => `${name}: ${value} (${(percent * 100).toFixed(0)}%)`}
                    >
                      {performanceDistribution.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={entry.color} />
                      ))}
                    </Pie>
                    <Tooltip />
                  </PieChart>
                </ResponsiveContainer>
                <div className="mt-4 space-y-2">
                  {performanceDistribution.map((item, index) => (
                    <div key={index} className="flex items-center justify-between text-sm">
                      <div className="flex items-center gap-2">
                        <div className="w-3 h-3 rounded-full" style={{ backgroundColor: item.color }}></div>
                        <span>{item.name}</span>
                      </div>
                      <span className="font-bold">{item.value} test</span>
                    </div>
                  ))}
                </div>
              </>
            ) : (
              <div className="text-center py-8 text-gray-500">
                <p>Dati insufficienti per la distribuzione</p>
              </div>
            )}
          </CardContent>
        </Card>

        {/* ⭐ NEW: Advanced Metrics Breakdown */}
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <Zap className="w-6 h-6" />
              Metriche Performance Avanzate
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            <div className="space-y-6">
              
              {/* Learning Velocity */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <span className="font-medium text-gray-700">Velocità di Apprendimento</span>
                  <span className={`font-bold ${
                    performanceAnalysis.learningVelocity > 0 ? 'text-green-600' : 
                    performanceAnalysis.learningVelocity < 0 ? 'text-red-600' : 'text-gray-600'
                  }`}>
                    {performanceAnalysis.learningVelocity > 0 ? '+' : ''}{performanceAnalysis.learningVelocity}%
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className={`h-2 rounded-full ${
                      performanceAnalysis.learningVelocity > 0 ? 'bg-green-500' : 
                      performanceAnalysis.learningVelocity < 0 ? 'bg-red-500' : 'bg-gray-400'
                    }`}
                    style={{ width: `${Math.min(100, Math.abs(performanceAnalysis.learningVelocity) * 10)}%` }}
                  ></div>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  {performanceAnalysis.trend} rispetto ai primi test
                </div>
              </div>

              {/* Consistency Score */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <span className="font-medium text-gray-700">Consistenza</span>
                  <span className="font-bold text-blue-600">{performanceAnalysis.consistency}%</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className="h-2 rounded-full bg-blue-500"
                    style={{ width: `${performanceAnalysis.consistency}%` }}
                  ></div>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  {performanceAnalysis.consistency >= 80 ? 'Molto stabile' :
                   performanceAnalysis.consistency >= 60 ? 'Abbastanza costante' : 'Variabile'}
                </div>
              </div>

              {/* Response Speed */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <span className="font-medium text-gray-700">Velocità Risposta</span>
                  <span className="font-bold text-purple-600">
                    {performanceAnalysis.avgResponseTime}s ({performanceAnalysis.speedRating})
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className={`h-2 rounded-full ${
                      performanceAnalysis.speedRating === 'Veloce' ? 'bg-green-500' :
                      performanceAnalysis.speedRating === 'Normale' ? 'bg-blue-500' : 'bg-orange-500'
                    }`}
                    style={{ width: `${performanceAnalysis.speedScore}%` }}
                  ></div>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  Tempo medio per risposta
                </div>
              </div>

              {/* Hint Efficiency */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <span className="font-medium text-gray-700">Efficienza Aiuti</span>
                  <span className="font-bold text-orange-600">{performanceAnalysis.hintEfficiency}%</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className="h-2 rounded-full bg-orange-500"
                    style={{ width: `${performanceAnalysis.hintEfficiency}%` }}
                  ></div>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  {advancedStats.hintsPercentage}% aiuti utilizzati di media
                </div>
              </div>
            </div>

            {/* Overall Assessment */}
            <div className="mt-6 p-4 bg-gradient-to-r from-indigo-50 to-purple-50 rounded-xl border border-indigo-200">
              <h4 className="font-bold text-indigo-800 mb-2">📊 Valutazione Complessiva</h4>
              <p className="text-sm text-indigo-700">
                {performanceAnalysis.performanceIndex >= 85 ? 
                  '🏆 Performance eccellenti! Continua così e considera di aumentare la difficoltà.' :
                 performanceAnalysis.performanceIndex >= 70 ?
                  '👍 Ottime performance! Lavora sulla consistenza per raggiungere l\'eccellenza.' :
                 performanceAnalysis.performanceIndex >= 55 ?
                  '📈 Performance in crescita. Concentrati sui punti deboli identificati.' :
                  '📚 C\'è margine di miglioramento. Rivedi le strategie di studio e pratica più regolarmente.'
                }
              </p>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* ⭐ NEW: Weekly Pattern Analysis */}
      {weeklyPattern.length > 0 && (
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-cyan-500 to-blue-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <Clock className="w-6 h-6" />
              Pattern Settimanale di Studio
            </CardTitle>
            <p className="text-cyan-100 text-sm">
              Analisi dei giorni della settimana più produttivi
            </p>
          </CardHeader>
          <CardContent className="p-6">
            <ResponsiveContainer width="100%" height={250}>
              <BarChart data={weeklyPattern}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="day" />
                <YAxis yAxisId="left" orientation="left" />
                <YAxis yAxisId="right" orientation="right" />
                <Tooltip 
                  formatter={(value, name) => [
                    name === 'avgScore' ? `${value}%` : `${value} test`,
                    name === 'avgScore' ? 'Punteggio Medio' : 'Numero Test'
                  ]}
                />
                <Bar yAxisId="left" dataKey="tests" fill="#06b6d4" name="tests" />
                <Line yAxisId="right" type="monotone" dataKey="avgScore" stroke="#3b82f6" strokeWidth={3} name="avgScore" />
              </BarChart>
            </ResponsiveContainer>
            
            <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
              <div className="text-center p-3 bg-cyan-50 rounded-xl">
                <div className="font-bold text-cyan-600">
                  {weeklyPattern.reduce((max, day) => day.tests > max.tests ? day : max, weeklyPattern[0])?.day || 'N/A'}
                </div>
                <div className="text-cyan-700 text-xs">Giorno più attivo</div>
              </div>
              <div className="text-center p-3 bg-blue-50 rounded-xl">
                <div className="font-bold text-blue-600">
                  {weeklyPattern.reduce((max, day) => day.avgScore > max.avgScore ? day : max, weeklyPattern[0])?.day || 'N/A'}
                </div>
                <div className="text-blue-700 text-xs">Giorno migliore</div>
              </div>
              <div className="text-center p-3 bg-green-50 rounded-xl">
                <div className="font-bold text-green-600">
                  {Math.round(weeklyPattern.reduce((sum, day) => sum + day.avgScore, 0) / weeklyPattern.length)}%
                </div>
                <div className="text-green-700 text-xs">Media settimanale</div>
              </div>
              <div className="text-center p-3 bg-purple-50 rounded-xl">
                <div className="font-bold text-purple-600">
                  {weeklyPattern.reduce((sum, day) => sum + day.tests, 0)}
                </div>
                <div className="text-purple-700 text-xs">Test totali</div>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};

export default OverviewSection;

================================================================================

NOME FILE: components\stats\sections\PerformanceSection.js

// =====================================================
// 📁 src/components/stats/sections/PerformanceSection.js - FIXED
// =====================================================

import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card';
import { 
  BarChart, 
  Bar, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  ResponsiveContainer,
  RadarChart,
  PolarGrid,
  PolarAngleAxis,
  PolarRadiusAxis,
  Radar,
  LineChart,
  Line,
  ComposedChart,
  ScatterChart,
  Scatter
} from 'recharts';
import { Trophy, Lightbulb, Zap, Clock, Target, TrendingUp } from 'lucide-react';
import { useStatsData } from '../hooks/useStatsData';

// ⭐ FIXED: Move helper functions BEFORE their usage
const calculateBestStreak = (data) => {
  let currentStreak = 0;
  let bestStreak = 0;
  const threshold = 75; // Soglia per considerare un test "buono"
  
  data.forEach(test => {
    if (test.percentage >= threshold) {
      currentStreak++;
      bestStreak = Math.max(bestStreak, currentStreak);
    } else {
      currentStreak = 0;
    }
  });
  
  return bestStreak;
};

const calculateDifficultyHandling = (history) => {
  const hardTests = history.filter(test => (test.totalWords || 0) >= 20);
  if (hardTests.length === 0) return 70; // Default se non ci sono test difficili
  
  const hardTestsAvg = hardTests.reduce((sum, test) => sum + (test.percentage || 0), 0) / hardTests.length;
  return Math.min(100, hardTestsAvg + 10); // Bonus per affrontare test difficili
};

const calculateOverallRating = (accuracy, consistency, hintEff, speed) => {
  const weighted = (accuracy * 0.4) + (consistency * 0.25) + (hintEff * 0.2) + (speed * 0.15);
  return Math.round(weighted);
};

const PerformanceSection = ({ testHistory, localRefresh }) => {
  const { advancedStats, timelineData } = useStatsData(testHistory);

  // ⭐ FIXED: Now functions are available before usage
  const performanceMetrics = useMemo(() => {
    if (testHistory.length === 0) return null;

    // Calcolo metriche avanzate
    const recentTests = timelineData.slice(-10);
    const oldTests = timelineData.slice(0, Math.min(10, timelineData.length - 10));
    
    // Trend di miglioramento
    const recentAvg = recentTests.reduce((sum, t) => sum + t.percentage, 0) / Math.max(1, recentTests.length);
    const oldAvg = oldTests.length > 0 ? oldTests.reduce((sum, t) => sum + t.percentage, 0) / oldTests.length : recentAvg;
    const improvementTrend = recentAvg - oldAvg;

    // Consistenza (standard deviation)
    const scores = timelineData.map(t => t.percentage);
    const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
    const consistency = Math.max(0, 100 - Math.sqrt(variance));

    // Efficienza aiuti
    const totalHints = timelineData.reduce((sum, t) => sum + (t.hints || 0), 0);
    const totalQuestions = timelineData.reduce((sum, t) => sum + (t.correct || 0) + (t.incorrect || 0), 0);
    const hintEfficiency = totalQuestions > 0 ? Math.max(0, 100 - (totalHints / totalQuestions * 100)) : 100;

    // Velocità di risposta
    const avgSpeed = timelineData.reduce((sum, t) => sum + (t.avgTime || 0), 0) / Math.max(1, timelineData.length);
    const speedScore = avgSpeed <= 8 ? 100 : avgSpeed <= 15 ? 80 : avgSpeed <= 25 ? 60 : 40;

    // Peak performance (miglior periodo) - ⭐ FIXED: Function now available
    const bestStreak = calculateBestStreak(timelineData);
    
    // Learning velocity (velocità di apprendimento)
    const learningVelocity = timelineData.length > 5 ? 
      (timelineData.slice(-5).reduce((sum, t) => sum + t.percentage, 0) / 5) -
      (timelineData.slice(0, 5).reduce((sum, t) => sum + t.percentage, 0) / 5) : 0;

    // Difficulty handling (gestione difficoltà) - ⭐ FIXED: Function now available
    const difficultyScore = calculateDifficultyHandling(testHistory);

    return {
      accuracy: Math.round(advancedStats.averageScore),
      consistency: Math.round(consistency),
      hintEfficiency: Math.round(hintEfficiency),
      speedScore: Math.round(speedScore),
      improvementTrend: Math.round(improvementTrend * 10) / 10,
      learningVelocity: Math.round(learningVelocity * 10) / 10,
      bestStreak,
      difficultyScore: Math.round(difficultyScore),
      avgSpeed: Math.round(avgSpeed * 10) / 10,
      recentPerformance: Math.round(recentAvg),
      overallRating: calculateOverallRating(advancedStats.averageScore, consistency, hintEfficiency, speedScore) // ⭐ FIXED: Function now available
    };
  }, [testHistory, timelineData, advancedStats]);

  // ⭐ FIXED: Dati per radar chart
  const radarData = useMemo(() => {
    if (!performanceMetrics) return [];
    
    return [
      {
        metric: 'Precisione',
        value: performanceMetrics.accuracy,
        fullMark: 100
      },
      {
        metric: 'Consistenza',
        value: performanceMetrics.consistency,
        fullMark: 100
      },
      {
        metric: 'Efficienza',
        value: performanceMetrics.hintEfficiency,
        fullMark: 100
      },
      {
        metric: 'Velocità',
        value: performanceMetrics.speedScore,
        fullMark: 100
      },
      {
        metric: 'Gestione Difficoltà',
        value: performanceMetrics.difficultyScore,
        fullMark: 100
      }
    ];
  }, [performanceMetrics]);

  // ⭐ FIXED: Dati per trend miglioramento
  const improvementData = useMemo(() => {
    const windows = [];
    const windowSize = 5;
    
    for (let i = 0; i <= timelineData.length - windowSize; i += 2) {
      const window = timelineData.slice(i, i + windowSize);
      const avgScore = window.reduce((sum, t) => sum + t.percentage, 0) / windowSize;
      const avgHints = window.reduce((sum, t) => sum + (t.hints || 0), 0) / windowSize;
      const avgSpeed = window.reduce((sum, t) => sum + (t.avgTime || 0), 0) / windowSize;
      
      windows.push({
        period: `Test ${i + 1}-${i + windowSize}`,
        accuracy: Math.round(avgScore),
        efficiency: Math.max(0, Math.round(avgScore - avgHints)),
        speed: avgSpeed > 0 ? Math.round(100 - Math.min(100, avgSpeed * 2)) : 50
      });
    }
    
    return windows;
  }, [timelineData]);

  // ⭐ FIXED: Analisi performance per difficoltà
  const difficultyAnalysis = useMemo(() => {
    const analysis = { easy: [], medium: [], hard: [] };
    
    testHistory.forEach(test => {
      const totalWords = test.totalWords || 0;
      let category = 'easy';
      
      if (totalWords >= 30) category = 'hard';
      else if (totalWords >= 15) category = 'medium';
      
      analysis[category].push({
        percentage: test.percentage || 0,
        hints: test.hintsUsed || 0,
        words: totalWords
      });
    });

    return Object.entries(analysis).map(([difficulty, tests]) => {
      if (tests.length === 0) return null;
      
      const avgPercentage = tests.reduce((sum, t) => sum + t.percentage, 0) / tests.length;
      const avgHints = tests.reduce((sum, t) => sum + t.hints, 0) / tests.length;
      
      return {
        difficulty: difficulty.charAt(0).toUpperCase() + difficulty.slice(1),
        count: tests.length,
        avgScore: Math.round(avgPercentage),
        avgHints: Math.round(avgHints * 10) / 10,
        efficiency: Math.round(avgPercentage - (avgHints / tests.reduce((sum, t) => sum + t.words, 0) * 100))
      };
    }).filter(Boolean);
  }, [testHistory]);

  if (!performanceMetrics) {
    return (
      <div className="text-center py-16 text-gray-500">
        <Trophy className="w-16 h-16 mx-auto mb-4 opacity-50" />
        <p>Completa alcuni test per vedere l'analisi performance</p>
      </div>
    );
  }

  return (
    <div className="space-y-8" key={`performance-${localRefresh}`}>
      
      {/* ⭐ ENHANCED: Performance Overview */}
      <Card className="bg-gradient-to-br from-purple-500 via-indigo-600 to-blue-500 text-white">
        <CardContent className="p-8">
          <div className="text-center mb-6">
            <h2 className="text-3xl font-bold mb-2">Performance Score</h2>
            <div className="text-6xl font-bold mb-2">{performanceMetrics.overallRating}/100</div>
            <div className="text-xl opacity-90">
              {performanceMetrics.overallRating >= 90 ? '🏆 Performance Eccezionale!' :
               performanceMetrics.overallRating >= 80 ? '🌟 Performance Ottima' :
               performanceMetrics.overallRating >= 70 ? '👍 Performance Buona' :
               performanceMetrics.overallRating >= 60 ? '📈 Performance Discreta' : '📚 Performance da Migliorare'}
            </div>
            {performanceMetrics.improvementTrend !== 0 && (
              <div className={`mt-2 text-lg flex items-center justify-center gap-2 ${
                performanceMetrics.improvementTrend > 0 ? 'text-green-200' : 'text-orange-200'
              }`}>
                <TrendingUp className={`w-5 h-5 ${performanceMetrics.improvementTrend < 0 ? 'rotate-180' : ''}`} />
                {performanceMetrics.improvementTrend > 0 ? '+' : ''}{performanceMetrics.improvementTrend}% trend
              </div>
            )}
          </div>
          
          <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <Trophy className="w-8 h-8 mx-auto mb-2" />
              <div className="text-2xl font-bold">{performanceMetrics.accuracy}%</div>
              <div className="text-white/80 text-sm">Precisione</div>
            </div>
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <Target className="w-8 h-8 mx-auto mb-2" />
              <div className="text-2xl font-bold">{performanceMetrics.consistency}%</div>
              <div className="text-white/80 text-sm">Consistenza</div>
            </div>
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <Lightbulb className="w-8 h-8 mx-auto mb-2" />
              <div className="text-2xl font-bold">{performanceMetrics.hintEfficiency}%</div>
              <div className="text-white/80 text-sm">Efficienza</div>
            </div>
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <Clock className="w-8 h-8 mx-auto mb-2" />
              <div className="text-2xl font-bold">{performanceMetrics.speedScore}%</div>
              <div className="text-white/80 text-sm">Velocità</div>
            </div>
            <div className="text-center p-4 bg-white/20 rounded-xl backdrop-blur-sm">
              <Zap className="w-8 h-8 mx-auto mb-2" />
              <div className="text-2xl font-bold">{performanceMetrics.bestStreak}</div>
              <div className="text-white/80 text-sm">Best Streak</div>
            </div>
          </div>
        </CardContent>
      </Card>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        
        {/* ⭐ FIXED: Radar Chart Performance */}
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <Target className="w-6 h-6" />
              Analisi Multi-Dimensionale
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            <ResponsiveContainer width="100%" height={300}>
              <RadarChart data={radarData}>
                <PolarGrid />
                <PolarAngleAxis dataKey="metric" tick={{ fontSize: 12 }} />
                <PolarRadiusAxis angle={90} domain={[0, 100]} tick={{ fontSize: 10 }} />
                <Radar 
                  name="Performance" 
                  dataKey="value" 
                  stroke="#8b5cf6" 
                  fill="#8b5cf6" 
                  fillOpacity={0.3}
                  strokeWidth={2}
                />
              </RadarChart>
            </ResponsiveContainer>
            
            <div className="mt-4 grid grid-cols-2 gap-2 text-xs">
              {radarData.map((item, index) => (
                <div key={index} className="flex justify-between">
                  <span className="text-gray-600">{item.metric}:</span>
                  <span className={`font-bold ${
                    item.value >= 80 ? 'text-green-600' : 
                    item.value >= 60 ? 'text-blue-600' : 'text-orange-600'
                  }`}>
                    {item.value}%
                  </span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>

        {/* ⭐ FIXED: Performance Trends */}
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <TrendingUp className="w-6 h-6" />
              Trend di Miglioramento
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            {improvementData.length > 1 ? (
              <>
                <ResponsiveContainer width="100%" height={250}>
                  <LineChart data={improvementData}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="period" tick={{ fontSize: 10 }} />
                    <YAxis domain={[0, 100]} />
                    <Tooltip />
                    <Line 
                      type="monotone" 
                      dataKey="accuracy" 
                      stroke="#10b981" 
                      strokeWidth={3}
                      name="Precisione"
                    />
                    <Line 
                      type="monotone" 
                      dataKey="efficiency" 
                      stroke="#3b82f6" 
                      strokeWidth={2}
                      name="Efficienza"
                    />
                    <Line 
                      type="monotone" 
                      dataKey="speed" 
                      stroke="#8b5cf6" 
                      strokeWidth={2}
                      name="Velocità"
                    />
                  </LineChart>
                </ResponsiveContainer>
                
                <div className="mt-4 text-center">
                  <div className={`text-lg font-bold ${
                    performanceMetrics.learningVelocity > 0 ? 'text-green-600' : 
                    performanceMetrics.learningVelocity < 0 ? 'text-red-600' : 'text-gray-600'
                  }`}>
                    Velocità di Apprendimento: {performanceMetrics.learningVelocity > 0 ? '+' : ''}{performanceMetrics.learningVelocity}%
                  </div>
                  <div className="text-sm text-gray-600">
                    {performanceMetrics.learningVelocity > 5 ? '🚀 Progressi rapidi!' :
                     performanceMetrics.learningVelocity > 0 ? '📈 In miglioramento' :
                     performanceMetrics.learningVelocity === 0 ? '➖ Stabile' : '📉 In calo'}
                  </div>
                </div>
              </>
            ) : (
              <div className="text-center py-8 text-gray-500">
                <p>Completa più test per vedere i trend</p>
              </div>
            )}
          </CardContent>
        </Card>
      </div>

      {/* ⭐ FIXED: Performance by Difficulty */}
      {difficultyAnalysis.length > 0 && (
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <Zap className="w-6 h-6" />
              Performance per Livello di Difficoltà
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            <ResponsiveContainer width="100%" height={300}>
              <ComposedChart data={difficultyAnalysis}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="difficulty" />
                <YAxis yAxisId="left" orientation="left" domain={[0, 100]} />
                <YAxis yAxisId="right" orientation="right" />
                <Tooltip />
                <Bar yAxisId="left" dataKey="avgScore" fill="#3b82f6" name="Punteggio Medio %" />
                <Bar yAxisId="left" dataKey="efficiency" fill="#10b981" name="Efficienza %" />
                <Line yAxisId="right" type="monotone" dataKey="count" stroke="#f59e0b" strokeWidth={3} name="Numero Test" />
              </ComposedChart>
            </ResponsiveContainer>
            
            <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
              {difficultyAnalysis.map((level, index) => (
                <div key={index} className="text-center p-4 bg-gray-50 rounded-xl">
                  <div className="font-bold text-lg text-gray-800">{level.difficulty}</div>
                  <div className="text-sm text-gray-600 space-y-1">
                    <div>Test: {level.count}</div>
                    <div>Punteggio: {level.avgScore}%</div>
                    <div>Aiuti: {level.avgHints}/test</div>
                    <div className={`font-bold ${
                      level.efficiency >= 70 ? 'text-green-600' : 
                      level.efficiency >= 50 ? 'text-blue-600' : 'text-orange-600'
                    }`}>
                      Efficienza: {level.efficiency}%
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* ⭐ FIXED: Detailed Performance Insights */}
      <Card className="bg-gradient-to-r from-cyan-50 to-blue-50 border-2 border-cyan-200">
        <CardHeader className="bg-gradient-to-r from-cyan-500 to-blue-500 text-white">
          <CardTitle className="flex items-center gap-3">
            <Trophy className="w-6 h-6" />
            📊 Insights Performance Dettagliati
          </CardTitle>
        </CardHeader>
        <CardContent className="p-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            
            {/* Strengths */}
            <div>
              <h4 className="font-bold text-green-800 mb-3 flex items-center gap-2">
                🏆 Punti di Forza
              </h4>
              <div className="space-y-2 text-sm">
                {performanceMetrics.accuracy >= 80 && (
                  <p className="text-green-700">✅ Ottima precisione nelle risposte ({performanceMetrics.accuracy}%)</p>
                )}
                {performanceMetrics.consistency >= 75 && (
                  <p className="text-green-700">✅ Performance molto consistenti</p>
                )}
                {performanceMetrics.hintEfficiency >= 80 && (
                  <p className="text-green-700">✅ Uso efficiente degli aiuti</p>
                )}
                {performanceMetrics.speedScore >= 80 && (
                  <p className="text-green-700">✅ Tempi di risposta ottimi</p>
                )}
                {performanceMetrics.bestStreak >= 5 && (
                  <p className="text-green-700">✅ Streak impressionante di {performanceMetrics.bestStreak} test consecutivi</p>
                )}
                {performanceMetrics.improvementTrend > 2 && (
                  <p className="text-green-700">✅ Trend di miglioramento costante (+{performanceMetrics.improvementTrend}%)</p>
                )}
              </div>
            </div>

            {/* Areas for Improvement */}
            <div>
              <h4 className="font-bold text-orange-800 mb-3 flex items-center gap-2">
                📈 Aree di Miglioramento
              </h4>
              <div className="space-y-2 text-sm">
                {performanceMetrics.accuracy < 70 && (
                  <p className="text-orange-700">⚠️ Precisione da migliorare ({performanceMetrics.accuracy}%)</p>
                )}
                {performanceMetrics.consistency < 60 && (
                  <p className="text-orange-700">⚠️ Performance troppo variabili - punta alla consistenza</p>
                )}
                {performanceMetrics.hintEfficiency < 70 && (
                  <p className="text-orange-700">⚠️ Uso eccessivo degli aiuti - prova a rispondere autonomamente</p>
                )}
                {performanceMetrics.speedScore < 60 && (
                  <p className="text-orange-700">⚠️ Tempi di risposta lenti - pratica per migliorare la velocità</p>
                )}
                {performanceMetrics.improvementTrend < -2 && (
                  <p className="text-orange-700">⚠️ Trend in calo ({performanceMetrics.improvementTrend}%) - rivedi la strategia di studio</p>
                )}
                {performanceMetrics.bestStreak < 3 && (
                  <p className="text-orange-700">⚠️ Mancanza di consistenza - concentrati sui fondamentali</p>
                )}
              </div>
            </div>
          </div>

          {/* Overall Recommendation */}
          <div className="mt-6 p-4 bg-gradient-to-r from-indigo-100 to-purple-100 rounded-xl border border-indigo-300">
            <h4 className="font-bold text-indigo-800 mb-2">🎯 Raccomandazione Personalizzata</h4>
            <p className="text-indigo-700 text-sm">
              {performanceMetrics.overallRating >= 85 ? 
                `🏆 Performance eccezionali! Considera di aumentare la difficoltà o di aiutare altri studenti. Il tuo approccio allo studio è molto efficace.` :
               performanceMetrics.overallRating >= 75 ?
                `🌟 Ottime performance! Lavora sulla ${performanceMetrics.consistency < 75 ? 'consistenza' : performanceMetrics.speedScore < 75 ? 'velocità' : 'precisione'} per raggiungere l'eccellenza.` :
               performanceMetrics.overallRating >= 65 ?
                `👍 Buone performance! Concentrati su ${performanceMetrics.accuracy < 70 ? 'migliorare la precisione studiando di più' : performanceMetrics.hintEfficiency < 70 ? 'ridurre la dipendenza dagli aiuti' : 'aumentare la consistenza'}.` :
                `📚 C'è spazio per migliorare. Suggerimento: ${performanceMetrics.accuracy < 60 ? 'dedica più tempo allo studio prima dei test' : 'pratica più regolarmente per sviluppare consistenza'}.`
              }
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default PerformanceSection;

================================================================================

NOME FILE: components\stats\sections\TrendsSection.js

// =====================================================
// 📁 src/components/stats/sections/TrendsSection.js - ENHANCED
// =====================================================

import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card';
import { 
  LineChart, 
  Line, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  ResponsiveContainer,
  AreaChart,
  Area,
  BarChart,
  Bar,
  ComposedChart
} from 'recharts';
import { Clock, Sparkles, TrendingUp, TrendingDown, Target, Lightbulb } from 'lucide-react';
import { useStatsData } from '../hooks/useStatsData';

const TrendsSection = ({ testHistory, localRefresh }) => {
  const { advancedStats, timelineData } = useStatsData(testHistory);

  // ⭐ ENHANCED: Analisi trend dettagliata
  const trendAnalysis = useMemo(() => {
    if (timelineData.length < 3) return null;

    // Dividi i dati in periodi per analizzare i trend
    const recent = timelineData.slice(-5); // Ultimi 5 test
    const previous = timelineData.slice(-10, -5); // 5 test precedenti
    const early = timelineData.slice(0, 5); // Primi 5 test

    const calculateAverage = (data, field) => {
      const values = data.map(item => item[field] || 0).filter(v => v > 0);
      return values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
    };

    const recentAvg = {
      accuracy: calculateAverage(recent, 'percentage'),
      hints: calculateAverage(recent, 'hints'),
      speed: calculateAverage(recent, 'avgTime')
    };

    const previousAvg = {
      accuracy: calculateAverage(previous, 'percentage'),
      hints: calculateAverage(previous, 'hints'),
      speed: calculateAverage(previous, 'avgTime')
    };

    const earlyAvg = {
      accuracy: calculateAverage(early, 'percentage'),
      hints: calculateAverage(early, 'hints'),
      speed: calculateAverage(early, 'avgTime')
    };

    // Calcola trend (miglioramento/peggioramento)
    const accuracyTrend = previous.length > 0 ? recentAvg.accuracy - previousAvg.accuracy : 0;
    const hintsTrend = previous.length > 0 ? recentAvg.hints - previousAvg.hints : 0;
    const speedTrend = previous.length > 0 ? previousAvg.speed - recentAvg.speed : 0; // Inverso: meno tempo = meglio

    // Trend a lungo termine (dai primi test a oggi)
    const longTermAccuracyTrend = early.length > 0 ? recentAvg.accuracy - earlyAvg.accuracy : 0;
    const longTermHintsTrend = early.length > 0 ? earlyAvg.hints - recentAvg.hints : 0; // Inverso: meno aiuti = meglio
    const longTermSpeedTrend = early.length > 0 ? earlyAvg.speed - recentAvg.speed : 0; // Inverso: meno tempo = meglio

    return {
      recent: recentAvg,
      previous: previousAvg,
      early: earlyAvg,
      shortTerm: {
        accuracy: accuracyTrend,
        hints: hintsTrend,
        speed: speedTrend
      },
      longTerm: {
        accuracy: longTermAccuracyTrend,
        hints: longTermHintsTrend,
        speed: longTermSpeedTrend
      }
    };
  }, [timelineData]);

  // ⭐ ENHANCED: Dati per analisi mensile
  const monthlyTrends = useMemo(() => {
    const monthlyData = {};
    
    testHistory.forEach(test => {
      const date = new Date(test.timestamp);
      const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
      
      if (!monthlyData[monthKey]) {
        monthlyData[monthKey] = {
          month: monthKey,
          tests: 0,
          totalAccuracy: 0,
          totalHints: 0,
          totalTime: 0
        };
      }
      
      monthlyData[monthKey].tests++;
      monthlyData[monthKey].totalAccuracy += test.percentage || 0;
      monthlyData[monthKey].totalHints += test.hintsUsed || 0;
      monthlyData[monthKey].totalTime += test.avgTimePerWord || 0;
    });

    return Object.values(monthlyData).map(month => ({
      ...month,
      avgAccuracy: Math.round(month.totalAccuracy / month.tests),
      avgHints: Math.round((month.totalHints / month.tests) * 10) / 10,
      avgTime: Math.round((month.totalTime / month.tests) * 10) / 10,
      efficiency: Math.round((month.totalAccuracy / month.tests) - (month.totalHints / month.tests))
    })).sort((a, b) => a.month.localeCompare(b.month));
  }, [testHistory]);

  // ⭐ NEW: Analisi prestazioni per fascia oraria
  const hourlyPattern = useMemo(() => {
    const hourlyData = {};
    
    testHistory.forEach(test => {
      const hour = new Date(test.timestamp).getHours();
      const timeSlot = hour < 6 ? 'Notte (0-6)' :
                     hour < 12 ? 'Mattina (6-12)' :
                     hour < 18 ? 'Pomeriggio (12-18)' : 'Sera (18-24)';
      
      if (!hourlyData[timeSlot]) {
        hourlyData[timeSlot] = {
          timeSlot,
          tests: 0,
          totalAccuracy: 0,
          totalHints: 0
        };
      }
      
      hourlyData[timeSlot].tests++;
      hourlyData[timeSlot].totalAccuracy += test.percentage || 0;
      hourlyData[timeSlot].totalHints += test.hintsUsed || 0;
    });

    return Object.values(hourlyData).map(slot => ({
      ...slot,
      avgAccuracy: Math.round(slot.totalAccuracy / slot.tests),
      avgHints: Math.round((slot.totalHints / slot.tests) * 10) / 10
    })).sort((a, b) => {
      const order = ['Mattina (6-12)', 'Pomeriggio (12-18)', 'Sera (18-24)', 'Notte (0-6)'];
      return order.indexOf(a.timeSlot) - order.indexOf(b.timeSlot);
    });
  }, [testHistory]);

  if (timelineData.length < 3) {
    return (
      <div className="text-center py-16 text-gray-500">
        <Clock className="w-16 h-16 mx-auto mb-4 opacity-50" />
        <p>Completa almeno 3 test per vedere le analisi delle tendenze</p>
      </div>
    );
  }

  return (
    <div className="space-y-8" key={`trends-${localRefresh}`}>
      
      {/* ⭐ ENHANCED: Main Timeline Chart */}
      <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
        <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
          <CardTitle className="flex items-center gap-3 text-white">
            <Clock className="w-6 h-6" />
            Tendenze Temporali e Performance Dettagliate
          </CardTitle>
          <p className="text-indigo-100 text-sm">
            Analisi dell'andamento di precisione, aiuti utilizzati e velocità di risposta nel tempo
          </p>
        </CardHeader>
        <CardContent className="p-6">
          <ResponsiveContainer width="100%" height={400}>
            <ComposedChart data={timelineData} key={`trends-line-${localRefresh}`}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" tick={{ fontSize: 10 }} />
              <YAxis yAxisId="left" domain={[0, 100]} label={{ value: 'Percentuale', angle: -90, position: 'insideLeft' }} />
              <YAxis yAxisId="right" orientation="right" label={{ value: 'Aiuti/Tempo', angle: 90, position: 'insideRight' }} />
              <Tooltip 
                formatter={(value, name) => {
                  if (name === 'hints') return [`${value} aiuti`, 'Aiuti Utilizzati'];
                  if (name === 'avgTime') return [`${value}s`, 'Tempo Medio'];
                  return [`${value}%`, name === 'percentage' ? 'Precisione' : name];
                }}
              />
              {/* Area per precisione */}
              <Area
                yAxisId="left"
                type="monotone"
                dataKey="percentage"
                fill="#8b5cf6"
                fillOpacity={0.3}
                stroke="#8b5cf6"
                strokeWidth={3}
                name="percentage"
              />
              {/* Barre per aiuti */}
              <Bar
                yAxisId="right"
                dataKey="hints"
                fill="#f59e0b"
                fillOpacity={0.7}
                name="hints"
              />
              {/* Linea per tempo medio */}
              <Line
                yAxisId="right"
                type="monotone"
                dataKey="avgTime"
                stroke="#06b6d4"
                strokeWidth={2}
                name="avgTime"
                strokeDasharray="5 5"
              />
            </ComposedChart>
          </ResponsiveContainer>
          
          <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4 text-center text-sm">
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-purple-500 rounded"></div>
              <span>Precisione (%)</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 bg-yellow-500 rounded"></div>
              <span>Aiuti (numero)</span>
            </div>
            <div className="flex items-center justify-center gap-2">
              <div className="w-4 h-4 border-2 border-cyan-500 bg-white rounded"></div>
              <span>Tempo Medio (secondi)</span>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* ⭐ NEW: Trend Analysis Summary */}
      {trendAnalysis && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          
          {/* Short-term trends */}
          <Card className="bg-gradient-to-br from-blue-50 to-cyan-50 border-2 border-blue-200">
            <CardHeader className="bg-gradient-to-r from-blue-500 to-cyan-500 text-white">
              <CardTitle className="flex items-center gap-3">
                <TrendingUp className="w-6 h-6" />
                Tendenze Recenti (Ultimi 5 vs 5 Precedenti)
              </CardTitle>
            </CardHeader>
            <CardContent className="p-6">
              <div className="space-y-4">
                <div className="flex justify-between items-center p-3 bg-white rounded-xl">
                  <span className="font-medium">Precisione</span>
                  <div className="flex items-center gap-2">
                    <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.accuracy)}%</span>
                    <span className={`text-sm font-bold ${
                      trendAnalysis.shortTerm.accuracy > 2 ? 'text-green-600' :
                      trendAnalysis.shortTerm.accuracy < -2 ? 'text-red-600' : 'text-gray-600'
                    }`}>
                      {trendAnalysis.shortTerm.accuracy > 0 ? '↗' : trendAnalysis.shortTerm.accuracy < 0 ? '↘' : '→'}
                      {Math.abs(Math.round(trendAnalysis.shortTerm.accuracy * 10) / 10)}%
                    </span>
                  </div>
                </div>
                
                <div className="flex justify-between items-center p-3 bg-white rounded-xl">
                  <span className="font-medium">Aiuti per Test</span>
                  <div className="flex items-center gap-2">
                    <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.hints * 10) / 10}</span>
                    <span className={`text-sm font-bold ${
                      trendAnalysis.shortTerm.hints < -0.5 ? 'text-green-600' :
                      trendAnalysis.shortTerm.hints > 0.5 ? 'text-red-600' : 'text-gray-600'
                    }`}>
                      {trendAnalysis.shortTerm.hints < 0 ? '↘' : trendAnalysis.shortTerm.hints > 0 ? '↗' : '→'}
                      {Math.abs(Math.round(trendAnalysis.shortTerm.hints * 10) / 10)}
                    </span>
                  </div>
                </div>
                
                <div className="flex justify-between items-center p-3 bg-white rounded-xl">
                  <span className="font-medium">Velocità Media</span>
                  <div className="flex items-center gap-2">
                    <span className="font-bold text-lg">{Math.round(trendAnalysis.recent.speed * 10) / 10}s</span>
                    <span className={`text-sm font-bold ${
                      trendAnalysis.shortTerm.speed > 1 ? 'text-green-600' :
                      trendAnalysis.shortTerm.speed < -1 ? 'text-red-600' : 'text-gray-600'
                    }`}>
                      {trendAnalysis.shortTerm.speed > 0 ? '↗' : trendAnalysis.shortTerm.speed < 0 ? '↘' : '→'}
                      {Math.abs(Math.round(trendAnalysis.shortTerm.speed * 10) / 10)}s
                    </span>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Long-term trends */}
          <Card className="bg-gradient-to-br from-green-50 to-emerald-50 border-2 border-green-200">
            <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
              <CardTitle className="flex items-center gap-3">
                <Target className="w-6 h-6" />
                Progressi a Lungo Termine (Inizio vs Ora)
              </CardTitle>
            </CardHeader>
            <CardContent className="p-6">
              <div className="space-y-4">
                <div className="flex justify-between items-center p-3 bg-white rounded-xl">
                  <span className="font-medium">Miglioramento Precisione</span>
                  <div className="flex items-center gap-2">
                    <span className={`font-bold text-lg ${
                      trendAnalysis.longTerm.accuracy > 10 ? 'text-green-600' :
                      trendAnalysis.longTerm.accuracy > 0 ? 'text-blue-600' : 'text-red-600'
                    }`}>
                      {trendAnalysis.longTerm.accuracy > 0 ? '+' : ''}{Math.round(trendAnalysis.longTerm.accuracy)}%
                    </span>
                    <span className="text-sm text-gray-500">
                      {Math.round(trendAnalysis.early.accuracy)}% → {Math.round(trendAnalysis.recent.accuracy)}%
                    </span>
                  </div>
                </div>
                
                <div className="flex justify-between items-center p-3 bg-white rounded-xl">
                  <span className="font-medium">Riduzione Aiuti</span>
                  <div className="flex items-center gap-2">
                    <span className={`font-bold text-lg ${
                      trendAnalysis.longTerm.hints > 1 ? 'text-green-600' :
                      trendAnalysis.longTerm.hints > 0 ? 'text-blue-600' : 'text-red-600'
                    }`}>
                      {trendAnalysis.longTerm.hints > 0 ? '-' : '+'}{Math.abs(Math.round(trendAnalysis.longTerm.hints * 10) / 10)}
                    </span>
                    <span className="text-sm text-gray-500">
                      {Math.round(trendAnalysis.early.hints * 10) / 10} → {Math.round(trendAnalysis.recent.hints * 10) / 10}
                    </span>
                  </div>
                </div>
                
                <div className="flex justify-between items-center p-3 bg-white rounded-xl">
                  <span className="font-medium">Miglioramento Velocità</span>
                  <div className="flex items-center gap-2">
                    <span className={`font-bold text-lg ${
                      trendAnalysis.longTerm.speed > 2 ? 'text-green-600' :
                      trendAnalysis.longTerm.speed > 0 ? 'text-blue-600' : 'text-red-600'
                    }`}>
                      {trendAnalysis.longTerm.speed > 0 ? '-' : '+'}{Math.abs(Math.round(trendAnalysis.longTerm.speed * 10) / 10)}s
                    </span>
                    <span className="text-sm text-gray-500">
                      {Math.round(trendAnalysis.early.speed * 10) / 10}s → {Math.round(trendAnalysis.recent.speed * 10) / 10}s
                    </span>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* ⭐ NEW: Monthly Trends (if enough data) */}
      {monthlyTrends.length > 1 && (
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <TrendingUp className="w-6 h-6" />
              Tendenze Mensili
            </CardTitle>
          </CardHeader>
          <CardContent className="p-6">
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={monthlyTrends}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Line type="monotone" dataKey="avgAccuracy" stroke="#8b5cf6" strokeWidth={3} name="Precisione Media %" />
                <Line type="monotone" dataKey="efficiency" stroke="#10b981" strokeWidth={2} name="Efficienza %" />
                <Line type="monotone" dataKey="avgHints" stroke="#f59e0b" strokeWidth={2} name="Aiuti Medi" />
              </LineChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      )}

      {/* ⭐ NEW: Hourly Pattern Analysis */}
      {hourlyPattern.length > 1 && (
        <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
            <CardTitle className="flex items-center gap-3 text-white">
              <Clock className="w-6 h-6" />
              Performance per Fascia Oraria
            </CardTitle>
            <p className="text-orange-100 text-sm">
              Analisi delle prestazioni in base all'orario di studio
            </p>
          </CardHeader>
          <CardContent className="p-6">
            <ResponsiveContainer width="100%" height={250}>
              <BarChart data={hourlyPattern}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="timeSlot" />
                <YAxis />
                <Tooltip />
                <Bar dataKey="avgAccuracy" fill="#3b82f6" name="Precisione Media %" />
                <Bar dataKey="avgHints" fill="#f59e0b" name="Aiuti Medi" />
              </BarChart>
            </ResponsiveContainer>
            
            <div className="mt-4 text-center">
              <div className="text-lg font-bold text-gray-800 mb-2">
                🏆 Fascia oraria migliore: {hourlyPattern.reduce((best, slot) => 
                  slot.avgAccuracy > best.avgAccuracy ? slot : best, hourlyPattern[0]
                ).timeSlot}
              </div>
              <div className="text-sm text-gray-600">
                Precision media: {hourlyPattern.reduce((best, slot) => 
                  slot.avgAccuracy > best.avgAccuracy ? slot : best, hourlyPattern[0]
                ).avgAccuracy}%
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* ⭐ ENHANCED: Insights e Raccomandazioni Avanzate */}
      <Card className="bg-gradient-to-r from-yellow-50 to-orange-50 border-2 border-yellow-200">
        <CardContent className="p-6">
          <h3 className="text-xl font-bold text-yellow-800 mb-4 flex items-center gap-2">
            <Sparkles className="w-6 h-6" />
            Insights e Raccomandazioni Avanzate
          </h3>
          <div className="space-y-3 text-yellow-700">
            <p>🎯 <strong>Precisione attuale:</strong> {advancedStats.averageScore}% (target: 80%+)</p>
            <p>💡 <strong>Uso aiuti:</strong> {advancedStats.hintsPercentage}% (ideale: sotto 20%)</p>
            <p>⚡ <strong>Efficienza netta:</strong> {Math.max(0, advancedStats.averageScore - advancedStats.hintsPercentage)}%</p>
            
            {/* Dynamic recommendations based on trends */}
            {trendAnalysis && (
              <div className="mt-4 space-y-2">
                {trendAnalysis.shortTerm.accuracy < -5 && (
                  <div className="p-3 bg-red-100 rounded-lg border border-red-300">
                    <p>📉 <strong>Attenzione:</strong> La precisione è in calo negli ultimi test. Rivedi il materiale di studio.</p>
                  </div>
                )}
                
                {trendAnalysis.shortTerm.hints > 1 && (
                  <div className="p-3 bg-orange-100 rounded-lg border border-orange-300">
                    <p>💡 <strong>Suggerimento:</strong> Stai usando più aiuti ultimamente. Prova a riflettere di più prima di chiedere aiuto.</p>
                  </div>
                )}
                
                {trendAnalysis.longTerm.accuracy > 15 && trendAnalysis.longTerm.hints > 1 && (
                  <div className="p-3 bg-green-100 rounded-lg border border-green-300">
                    <p>🏆 <strong>Ottimo progresso!</strong> Hai migliorato sia la precisione che l'autonomia. Continua così!</p>
                  </div>
                )}
                
                {trendAnalysis.shortTerm.speed < -3 && (
                  <div className="p-3 bg-blue-100 rounded-lg border border-blue-300">
                    <p>⚡ <strong>Velocità migliorata!</strong> Stai rispondendo più velocemente. Ottimo sviluppo della confidenza.</p>
                  </div>
                )}
              </div>
            )}
            
            <div className="mt-4 p-4 bg-gradient-to-r from-indigo-100 to-purple-100 rounded-xl border border-indigo-300">
              <h4 className="font-bold text-indigo-800 mb-2">📊 Stato attuale del tuo apprendimento:</h4>
              <p className="text-indigo-700 text-sm">
                Hai completato <strong>{advancedStats.totalTests} test</strong> studiando <strong>{advancedStats.totalWordsStudied} parole</strong> con <strong>{advancedStats.totalHints} aiuti utilizzati</strong>.
                {trendAnalysis && trendAnalysis.longTerm.accuracy > 10 && 
                  ` Il tuo miglioramento di ${Math.round(trendAnalysis.longTerm.accuracy)}% dall'inizio mostra eccellenti progressi!`
                }
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default TrendsSection;

================================================================================

NOME FILE: components\stats\sections\WordsSection.js

import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../../ui/card';
import { Input } from '../../ui/input';
import { Search } from 'lucide-react';
import { useAppContext } from '../../../contexts/AppContext';
import WordPerformanceCard from '../components/WordPerformanceCard';
import WordDetailSection from '../components/WordDetailSection';

const WordsSection = ({ localRefresh }) => {
  const [searchWord, setSearchWord] = useState('');
  const [selectedChapter, setSelectedChapter] = useState('all');
  const [selectedWordId, setSelectedWordId] = useState(null);

  const { getAllWordsPerformance, getWordAnalysis } = useAppContext();

  const wordsData = React.useMemo(() => {
    if (!getAllWordsPerformance) return [];
    
    const wordsPerformance = getAllWordsPerformance();
    return wordsPerformance.filter(word => {
      if (searchWord && !word.english.toLowerCase().includes(searchWord.toLowerCase())) {
        return false;
      }
      if (selectedChapter !== 'all' && word.chapter !== selectedChapter) {
        return false;
      }
      return true;
    });
  }, [getAllWordsPerformance, searchWord, selectedChapter]);

  const availableChapters = [...new Set(wordsData.map(w => w.chapter).filter(Boolean))].sort();

  return (
    <div className="space-y-8" key={`words-${localRefresh}`}>
      {/* Search and Filter */}
      <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200">
        <CardContent className="p-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="text-sm font-medium text-gray-700 mb-2 block">🔍 Cerca Parola</label>
              <Input
                placeholder="Scrivi la parola inglese..."
                value={searchWord}
                onChange={(e) => setSearchWord(e.target.value)}
                className="border-2 border-blue-300 rounded-xl focus:border-blue-500"
              />
            </div>
            <div>
              <label className="text-sm font-medium text-gray-700 mb-2 block">📚 Filtra per Capitolo</label>
              <select
                value={selectedChapter}
                onChange={(e) => setSelectedChapter(e.target.value)}
                className="w-full px-3 py-2 border-2 border-blue-300 rounded-xl focus:border-blue-500 bg-white"
              >
                <option value="all">Tutti i capitoli</option>
                {availableChapters.map(chapter => (
                  <option key={chapter} value={chapter}>📖 {chapter}</option>
                ))}
              </select>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Words Performance List */}
      <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
        <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
          <CardTitle className="flex items-center gap-3 text-white">
            <Search className="w-6 h-6" />
            Performance Parole ({wordsData.length} parole)
          </CardTitle>
          <p className="text-indigo-100 text-sm">Clicca su una parola per vedere il grafico dell'andamento temporale</p>
        </CardHeader>
        <CardContent className="p-6">
          {wordsData.length === 0 ? (
            <div className="text-center py-8">
              <div className="text-6xl mb-4">🔍</div>
              <p className="text-gray-600">Nessuna parola trovata con i filtri attuali</p>
            </div>
          ) : (
            <div className="space-y-3 max-h-96 overflow-y-auto">
              {wordsData.map((word) => (
                <WordPerformanceCard 
                  key={word.wordId} 
                  word={word} 
                  isSelected={selectedWordId === word.wordId}
                  onClick={() => setSelectedWordId(selectedWordId === word.wordId ? null : word.wordId)}
                />
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Selected Word Detail */}
      {selectedWordId && (
        <WordDetailSection 
          wordId={selectedWordId}
          getWordAnalysis={getWordAnalysis}
          localRefresh={localRefresh}
        />
      )}
    </div>
  );
};

export default WordsSection;

================================================================================

NOME FILE: components\ui\BackgroundParticles.js

import React from 'react';

export const BackgroundParticles = React.memo(() => (
  <div className="fixed inset-0 overflow-hidden pointer-events-none">
    <div className="absolute top-10 left-10 w-72 h-72 bg-blue-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob"></div>
    <div className="absolute top-0 right-4 w-72 h-72 bg-yellow-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-2000"></div>
    <div className="absolute -bottom-8 left-20 w-72 h-72 bg-pink-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-4000"></div>
  </div>
));


================================================================================

NOME FILE: components\ui\button.js

// /src/components/ui/button.js
// This file contains the Button component with various styles and sizes.
// It is designed to be used in forms and other interactive elements, providing a consistent look and feel for buttons.
// It supports different variants like default, outline, ghost, and destructive, as well as size options like default, sm, and lg.
// The Button component can be customized with additional classes and styles as needed.

import React from 'react';

const Button = React.forwardRef(({
  className = "",
  variant = "default",
  size = "default",
  children,
  disabled = false,
  ...props
}, ref) => {
  const baseClasses = "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background";

  const variants = {
    default: "bg-primary text-primary-foreground hover:bg-primary/90 bg-slate-900 text-white hover:bg-slate-800",
    outline: "border border-input hover:bg-accent hover:text-accent-foreground border-gray-300 hover:bg-gray-50",
    ghost: "hover:bg-accent hover:text-accent-foreground hover:bg-gray-100",
    destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90 bg-red-600 text-white hover:bg-red-700"
  };

  const sizes = {
    default: "h-10 py-2 px-4",
    sm: "h-9 px-3 rounded-md",
    lg: "h-11 px-8 rounded-md"
  };

  const classes = `${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`;

  return (
    <button
      className={classes}
      ref={ref}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
});

Button.displayName = "Button";

export { Button };

================================================================================

NOME FILE: components\ui\card.js

// /src/components/ui/card.js
// This file contains the Card component and its subcomponents for displaying content in a card format.
// It includes CardHeader, CardTitle, CardDescription, CardContent, and CardFooter components
// to structure the card layout.
// It is designed to be used in various parts of the application where a card-like UI is needed.
// It provides a consistent look and feel for displaying information in a card format.
// The Card component can be customized with additional classes and styles as needed.   


import React from 'react';

const Card = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`rounded-lg border bg-card text-card-foreground shadow-sm bg-white border-gray-200 ${className}`}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`flex flex-col space-y-1.5 p-6 ${className}`}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef(({ className = "", ...props }, ref) => (
  <h3
    ref={ref}
    className={`text-2xl font-semibold leading-none tracking-tight ${className}`}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef(({ className = "", ...props }, ref) => (
  <p
    ref={ref}
    className={`text-sm text-muted-foreground text-gray-600 ${className}`}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef(({ className = "", ...props }, ref) => (
  <div ref={ref} className={`p-6 pt-0 ${className}`} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`flex items-center p-6 pt-0 ${className}`}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

================================================================================

NOME FILE: components\ui\input.js

// /src/components/ui/input.js
// This file contains the Input component with various styles and properties.
// It is designed to be used in forms and other input scenarios, providing a consistent look and feel for text inputs.
//
import React from 'react';

const Input = React.forwardRef(({ className = "", type = "text", ...props }, ref) => {
  return (
    <input
      type={type}
      className={`flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`}
      ref={ref}
      {...props}
    />
  );
});
Input.displayName = "Input";

export { Input };

================================================================================

NOME FILE: components\ui\modal.js

// /src/components/ui/modal.js
// This file contains the Modal component and its subcomponents for displaying modal dialogs.
//

import React from 'react';

const Modal = ({ isOpen, onClose, children, className = "" }) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      {/* Backdrop */}
      <div 
        className="fixed inset-0 bg-black bg-opacity-50 transition-opacity duration-300 backdrop-blur-sm"
        onClick={onClose}
      />
      
      {/* Modal Container */}
      <div className="flex min-h-full items-center justify-center p-4">
        <div 
          className={`relative bg-white rounded-2xl shadow-2xl transform transition-all duration-300 scale-100 max-w-md w-full mx-auto ${className}`}
          onClick={(e) => e.stopPropagation()}
        >
          {children}
        </div>
      </div>
    </div>
  );
};

const ModalHeader = ({ children, className = "" }) => (
  <div className={`px-6 py-4 border-b border-gray-200 ${className}`}>
    {children}
  </div>
);

const ModalTitle = ({ children, className = "" }) => (
  <h3 className={`text-lg font-semibold text-gray-900 ${className}`}>
    {children}
  </h3>
);

const ModalContent = ({ children, className = "" }) => (
  <div className={`px-6 py-4 ${className}`}>
    {children}
  </div>
);

const ModalFooter = ({ children, className = "" }) => (
  <div className={`px-6 py-4 border-t border-gray-200 flex justify-end gap-3 ${className}`}>
    {children}
  </div>
);

export { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter };

================================================================================

NOME FILE: components\ui\NotificationToast.js

import React from 'react';
import { useNotification } from '../../contexts/NotificationContext';

export const NotificationToast = React.memo(() => {
  const { notifications } = useNotification();

  if (notifications.length === 0) return null;

  return (
    <div className="fixed top-6 right-6 z-50 space-y-2">
      {notifications.map(notification => (
        <NotificationItem 
          key={notification.id} 
          notification={notification} 
        />
      ))}
    </div>
  );
});

const NotificationItem = React.memo(({ notification }) => {
  const typeStyles = {
    success: 'bg-gradient-to-r from-green-500 to-emerald-500',
    error: 'bg-gradient-to-r from-red-500 to-pink-500',
    warning: 'bg-gradient-to-r from-orange-500 to-yellow-500',
    info: 'bg-gradient-to-r from-blue-500 to-cyan-500'
  };

  const icons = {
    success: '✅',
    error: '❌',
    warning: '⚠️',
    info: 'ℹ️'
  };

  return (
    <div className={`${typeStyles[notification.type]} text-white px-6 py-4 rounded-2xl shadow-2xl backdrop-blur-sm border border-white/20 animate-slide-in max-w-md`}>
      <div className="flex items-center gap-3">
        <span className="text-lg">{icons[notification.type]}</span>
        <span className="font-medium">{notification.message}</span>
      </div>
    </div>
  );
});

================================================================================

NOME FILE: components\ui\textarea.js

// /src/components/ui/textarea.js
// This file contains the Textarea component with various styles and properties.
//

import React from 'react';

const Textarea = React.forwardRef(({ className = "", ...props }, ref) => {
  return (
    <textarea
      className={`flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };

================================================================================

NOME FILE: constants\appConstants.js

// =====================================================
// 📁 src/constants/appConstants.js - VERSIONE SEMPLIFICATA
// =====================================================

// App Metadata
export const APP_CONFIG = {
  name: 'Vocabulary Master',
  version: '2.0.0',
  description: 'La tua app intelligente per imparare l\'inglese'
};

// Test Configuration
export const TEST_CONFIG = {
  // Timer settings
  warningThresholds: {
    slow: 25,      // seconds - quando mostrare warning "tempo lungo"
    verySlow: 40   // seconds - quando mostrare "molto lento"
  },
  
  // Test flow settings
  autoAdvanceDelay: 1500, // ms after answer before next question
  hintCooldown: 3000,     // ms between hint requests
  maxHintsPerWord: 1,     // limite aiuti per parola
  
  // Scoring thresholds
  scoring: {
    excellent: 80,  // % for "excellent" result  
    good: 60,      // % for "good" result
    victory: 80    // % for victory message
  }
};

// Statistics Configuration
export const STATS_CONFIG = {
  // Performance thresholds
  performance: {
    excellent: 90,    // %
    good: 75,        // %
    average: 60,     // %
    needsWork: 40    // %
  },
  
  // History limits
  maxHistorySize: 1000,   // max test history entries
  maxRecentTests: 20,     // tests shown in timeline
  
  // Chart settings
  charts: {
    maxTimelinePoints: 20,
    defaultChartHeight: 300
  }
};

// Storage Configuration
export const STORAGE_CONFIG = {
  keys: {
    words: 'vocabulary_words',
    stats: 'vocabulary_stats', 
    testHistory: 'vocabulary_test_history',
    settings: 'vocabulary_settings',
    wordPerformance: 'wordPerformance'
  }
};

// Word/Vocabulary Configuration
export const WORD_CONFIG = {
  // Field lengths
  maxWordLength: 100,
  maxTranslationLength: 200, 
  maxNotesLength: 1000,
  maxSentenceLength: 300,
  maxChapterLength: 20,
  
  // Required fields
  requiredFields: ['english', 'italian'],
  optionalFields: ['group', 'sentence', 'notes', 'chapter', 'learned', 'difficult']
};

// Predefined Categories
export const CATEGORIES = [
  'VERBI', 
  'VERBI_IRREGOLARI', 
  'SOSTANTIVI', 
  'AGGETTIVI',
  'DESCRIZIONI_FISICHE', 
  'POSIZIONE_CORPO', 
  'EMOZIONI',
  'EMOZIONI_POSITIVE', 
  'EMOZIONI_NEGATIVE', 
  'LAVORO',
  'FAMIGLIA', 
  'TECNOLOGIA', 
  'VESTITI'
];

// Category Styles
export const CATEGORY_STYLES = {
  'VERBI': { 
    color: 'from-red-400 via-red-500 to-red-600', 
    icon: '⚡', 
    bgColor: 'bg-red-500',
    bgGradient: 'bg-gradient-to-br from-red-500 to-orange-600'
  },
  'VERBI_IRREGOLARI': { 
    color: 'from-red-500 via-red-600 to-red-700', 
    icon: '🔄', 
    bgColor: 'bg-red-600',
    bgGradient: 'bg-gradient-to-br from-red-600 to-pink-600'
  },
  'SOSTANTIVI': { 
    color: 'from-blue-400 via-blue-500 to-blue-600', 
    icon: '🏷️', 
    bgColor: 'bg-blue-500',
    bgGradient: 'bg-gradient-to-br from-blue-500 to-indigo-600'
  },
  'AGGETTIVI': { 
    color: 'from-green-400 via-green-500 to-green-600', 
    icon: '🎨', 
    bgColor: 'bg-green-500',
    bgGradient: 'bg-gradient-to-br from-green-500 to-emerald-600'
  },
  'DESCRIZIONI_FISICHE': { 
    color: 'from-teal-400 via-teal-500 to-teal-600', 
    icon: '👤', 
    bgColor: 'bg-teal-500',
    bgGradient: 'bg-gradient-to-br from-teal-500 to-cyan-600'
  },
  'POSIZIONE_CORPO': { 
    color: 'from-purple-400 via-purple-500 to-purple-600', 
    icon: '🧘', 
    bgColor: 'bg-purple-500',
    bgGradient: 'bg-gradient-to-br from-purple-500 to-violet-600'
  },
  'EMOZIONI': { 
    color: 'from-pink-400 via-pink-500 to-pink-600', 
    icon: '❤️', 
    bgColor: 'bg-pink-500',
    bgGradient: 'bg-gradient-to-br from-pink-500 to-rose-600'
  },
  'EMOZIONI_POSITIVE': { 
    color: 'from-yellow-400 via-yellow-500 to-orange-500', 
    icon: '😊', 
    bgColor: 'bg-yellow-500',
    bgGradient: 'bg-gradient-to-br from-yellow-400 to-orange-500'
  },
  'EMOZIONI_NEGATIVE': { 
    color: 'from-gray-400 via-gray-500 to-gray-600', 
    icon: '😔', 
    bgColor: 'bg-gray-500',
    bgGradient: 'bg-gradient-to-br from-gray-500 to-slate-600'
  },
  'LAVORO': { 
    color: 'from-indigo-400 via-indigo-500 to-indigo-600', 
    icon: '💼', 
    bgColor: 'bg-indigo-500',
    bgGradient: 'bg-gradient-to-br from-indigo-500 to-blue-600'
  },
  'FAMIGLIA': { 
    color: 'from-pink-300 via-pink-400 to-rose-500', 
    icon: '👨‍👩‍👧‍👦', 
    bgColor: 'bg-pink-400',
    bgGradient: 'bg-gradient-to-br from-pink-400 to-rose-500'
  },
  'TECNOLOGIA': { 
    color: 'from-cyan-400 via-cyan-500 to-blue-500', 
    icon: '💻', 
    bgColor: 'bg-cyan-500',
    bgGradient: 'bg-gradient-to-br from-cyan-500 to-blue-500'
  },
  'VESTITI': { 
    color: 'from-purple-300 via-purple-400 to-pink-500', 
    icon: '👕', 
    bgColor: 'bg-purple-400',
    bgGradient: 'bg-gradient-to-br from-purple-400 to-pink-500'
  },
  'DEFAULT': { 
    color: 'from-emerald-400 via-emerald-500 to-cyan-500', 
    icon: '📚', 
    bgColor: 'bg-emerald-500',
    bgGradient: 'bg-gradient-to-br from-emerald-500 to-cyan-600'
  }
};

// UI Configuration (solo elementi utilizzati)
export const UI_CONFIG = {
  // Animation durations
  animations: {
    fast: 150,
    normal: 300,
    slow: 500,
    cardFlip: 700
  },
  
  // Toast notification settings
  notifications: {
    defaultDuration: 3000,
    maxVisible: 5
  }
};

// Error Messages (solo quelli utilizzati)
export const ERROR_MESSAGES = {
  network: 'Errore di connessione. Controlla la tua connessione internet.',
  ai: 'Servizio AI temporaneamente non disponibile. Riprova più tardi.',
  storage: 'Errore nel salvataggio dei dati. Controlla lo spazio disponibile.',
  validation: 'Dati non validi. Controlla i campi obbligatori.',
  import: 'Errore durante l\'importazione. Verifica il formato del file.',
  export: 'Errore durante l\'esportazione. Riprova.',
  generic: 'Si è verificato un errore imprevisto.',
  wordNotFound: 'Parola non trovata.',
  noWordsAvailable: 'Nessuna parola disponibile per il test.'
};

// Success Messages (per consistency UI)
export const SUCCESS_MESSAGES = {
  wordAdded: 'Parola aggiunta con successo!',
  wordUpdated: 'Parola modificata con successo!', 
  wordDeleted: 'Parola eliminata con successo!',
  testCompleted: 'Test completato!',
  dataExported: 'Dati esportati con successo!',
  dataImported: 'Dati importati con successo!',
  settingsSaved: 'Impostazioni salvate!'
};

================================================================================

NOME FILE: contexts\AppContext.js

import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { useOptimizedWords } from '../hooks/useOptimizedWords';
import { useOptimizedTest } from '../hooks/useOptimizedTest';
import { useOptimizedStats } from '../hooks/useOptimizedStats';

const AppContext = createContext();

const initialState = {
  currentView: 'main',
  showWordsList: true,
  editingWord: null,
  showChapterSelector: false,
  confirmDelete: null,
  showConfirmClear: false
};

const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_VIEW':
      return { ...state, currentView: action.payload };
    case 'TOGGLE_WORDS_LIST':
      return { ...state, showWordsList: !state.showWordsList };
    case 'SET_EDITING_WORD':
      return { ...state, editingWord: action.payload };
    case 'SET_SHOW_CHAPTER_SELECTOR':
      return { ...state, showChapterSelector: action.payload };
    case 'SET_CONFIRM_DELETE':
      return { ...state, confirmDelete: action.payload };
    case 'SET_SHOW_CONFIRM_CLEAR':
      return { ...state, showConfirmClear: action.payload };
    case 'RESET_MODALS':
      return {
        ...state,
        confirmDelete: null,
        showConfirmClear: false,
        showChapterSelector: false
      };
    default:
      return state;
  }
};

export const AppProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  // Hook centralizzati
  const wordsAPI = useOptimizedWords();
  const statsAPI = useOptimizedStats();
  
  // ⭐ ENHANCED: Test API with proper stats callback
  const testAPI = useOptimizedTest((testStats, testWords, wrongWords) => {
    console.log('🔗 AppContext: Test completed, calling handleTestComplete with:', {
      testStats,
      testWordsCount: testWords.length,
      wrongWordsCount: wrongWords.length
    });
    
    // ⭐ CRITICAL: Pass enhanced stats including hints and timing
    statsAPI.handleTestComplete(testStats, testWords, wrongWords);
  });

  // Sincronizzazione con editing word globale
  useEffect(() => {
    wordsAPI.setEditingWord(state.editingWord);
  }, [state.editingWord]);

  // ⭐ DEBUG: Log quando le funzioni stats sono disponibili
  useEffect(() => {
    console.log('📊 StatsAPI functions available:', {
      getAllWordsPerformance: !!statsAPI.getAllWordsPerformance,
      getWordAnalysis: !!statsAPI.getWordAnalysis,
      wordPerformance: !!statsAPI.wordPerformance
    });
  }, [statsAPI.getAllWordsPerformance, statsAPI.getWordAnalysis, statsAPI.wordPerformance]);

  const value = {
    // Stato UI
    ...state,
    dispatch,
    
    // API Words - ⭐ ENHANCED: Added difficult toggle and forceRefresh
    words: wordsAPI.words,
    addWord: wordsAPI.addWord,
    removeWord: wordsAPI.removeWord,
    toggleWordLearned: wordsAPI.toggleWordLearned,
    toggleWordDifficult: wordsAPI.toggleWordDifficult,
    clearAllWords: wordsAPI.clearAllWords,
    importWords: wordsAPI.importWords,
    forceRefresh: wordsAPI.forceRefresh, // ⭐ NEW: Expose force refresh
    getAvailableChapters: wordsAPI.getAvailableChapters,
    getChapterStats: wordsAPI.getChapterStats,
    wordStats: wordsAPI.wordStats,
    
    // API Test - ⭐ ENHANCED: With timer and hints
    ...testAPI,
    
    // API Stats - ⭐ FIXED: Properly expose word performance functions
    stats: statsAPI.stats,
    testHistory: statsAPI.testHistory,
    wordPerformance: statsAPI.wordPerformance,
    calculatedStats: statsAPI.calculatedStats,
    updateTestStats: statsAPI.updateTestStats,
    addTestToHistory: statsAPI.addTestToHistory,
    clearHistoryOnly: statsAPI.clearHistoryOnly,
    refreshData: statsAPI.refreshData,
    forceUpdate: statsAPI.forceUpdate,
    resetStats: statsAPI.resetStats,
    exportStats: statsAPI.exportStats,
    importStats: statsAPI.importStats,
    
    // ⭐ CRITICAL: Word performance functions
    getAllWordsPerformance: statsAPI.getAllWordsPerformance,
    getWordAnalysis: statsAPI.getWordAnalysis,
    recordWordPerformance: statsAPI.recordWordPerformance
  };

  // ⭐ DEBUG: Final context value check
  console.log('🔗 AppContext value includes word functions:', {
    getAllWordsPerformance: !!value.getAllWordsPerformance,
    getWordAnalysis: !!value.getWordAnalysis,
    wordPerformance: !!value.wordPerformance,
    forceRefresh: !!value.forceRefresh // ⭐ NEW
  });

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
};

================================================================================

NOME FILE: contexts\NotificationContext.js

import React, { createContext, useContext, useReducer, useCallback } from 'react';

const NotificationContext = createContext();

const notificationReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [...state.notifications, action.payload]
      };
    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(n => n.id !== action.payload)
      };
    case 'CLEAR_ALL':
      return { ...state, notifications: [] };
    default:
      return state;
  }
};

const getUserFriendlyError = (errorMessage, context) => {
  const errorMap = {
    'JSON': '❌ File JSON non valido',
    'localStorage': '❌ Errore salvataggio dati',
    'Network': '❌ Errore di connessione',
    'Word already exists': '⚠️ Parola già esistente',
    'English word and Italian translation are required': '⚠️ Campi obbligatori mancanti',
    'All words already exist': '⚠️ Tutte le parole sono già presenti'
  };

  for (const [key, message] of Object.entries(errorMap)) {
    if (errorMessage.includes(key)) {
      return message;
    }
  }

  return `❌ Errore ${context}: ${errorMessage}`;
};

export const NotificationProvider = ({ children }) => {
  const [state, dispatch] = useReducer(notificationReducer, {
    notifications: []
  });

  const showNotification = useCallback((message, type = 'success', duration = 3000) => {
    const id = Date.now() + Math.random();
    
    dispatch({
      type: 'ADD_NOTIFICATION',
      payload: { id, message, type, timestamp: Date.now() }
    });

    setTimeout(() => {
      dispatch({ type: 'REMOVE_NOTIFICATION', payload: id });
    }, duration);

    return id;
  }, []);

  const showError = useCallback((error, context = '') => {
    console.error(`❌ Error in ${context}:`, error);
    
    const errorMessage = error.message || error.toString();
    const userFriendlyMessage = getUserFriendlyError(errorMessage, context);
    
    return showNotification(userFriendlyMessage, 'error', 5000);
  }, [showNotification]);

  const showSuccess = useCallback((message) => {
    return showNotification(message, 'success');
  }, [showNotification]);

  const showWarning = useCallback((message) => {
    return showNotification(message, 'warning', 4000);
  }, [showNotification]);

  const value = {
    notifications: state.notifications,
    showNotification,
    showError,
    showSuccess,
    showWarning,
    clearAllNotifications: useCallback(() => {
      dispatch({ type: 'CLEAR_ALL' });
    }, [])
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
};

export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification must be used within NotificationProvider');
  }
  return context;
};

================================================================================

NOME FILE: hooks\useLocalStorage.js

// /src/hooks/useLocalStorage.js
// This file contains a custom React hook for managing local storage.
// It allows you to store and retrieve values from local storage with automatic JSON serialization and deserialization
// while providing a default initial value.
// The hook also handles errors gracefully, ensuring that the application can continue to function even if local storage is not available or if there are issues with the stored data.
// The `useLocalStorage` hook can be used in any React component to persist state across page reloads or sessions, making it useful for settings, user preferences, or any data that needs to be retained between visits.
// It returns the stored value and a function to update it, which will also update the local storage accordingly.
// It is a convenient way to manage state that needs to be persistent in a React application.

import { useState } from 'react';

export const useLocalStorage = (key, initialValue) => {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error loading ${key} from localStorage:`, error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error saving ${key} to localStorage:`, error);
    }
  };

  return [storedValue, setValue];
};

================================================================================

NOME FILE: hooks\useNotification.js

// /src/hooks/useNotification.js
// This file contains a custom React hook for managing notifications.
// It provides functionality to show a notification message for a specified duration.

import { useState, useCallback } from 'react';

export const useNotification = () => {
  const [message, setMessage] = useState('');

  const showNotification = useCallback((msg, duration = 3000) => {
    setMessage(msg);
    setTimeout(() => setMessage(''), duration);
  }, []);

  return { message, showNotification };
};

================================================================================

NOME FILE: hooks\useOptimizedStats.js

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useLocalStorage } from './useLocalStorage';
import { useNotification } from '../contexts/NotificationContext';

const INITIAL_STATS = {
  totalWords: 0,
  correctAnswers: 0,
  incorrectAnswers: 0,
  hintsUsed: 0, // ⭐ NEW: Track hints globally
  averageScore: 0,
  testsCompleted: 0,
  timeSpent: 0,
  categoriesProgress: {},
  dailyProgress: {},
  streakDays: 0,
  lastStudyDate: null,
  difficultyStats: {
    easy: { correct: 0, total: 0 },
    medium: { correct: 0, total: 0 },
    hard: { correct: 0, total: 0 }
  },
  monthlyStats: {},
  migrated: false
};

// ⭐ NEW: Word-specific performance tracking
const INITIAL_WORD_PERFORMANCE = {};

const EMPTY_ARRAY = [];

export const useOptimizedStats = () => {
  const [testHistory, setTestHistory] = useLocalStorage('testHistory', EMPTY_ARRAY);
  const [stats, setStats] = useLocalStorage('vocabularyStats', INITIAL_STATS);
  const [wordPerformance, setWordPerformance] = useLocalStorage('wordPerformance', INITIAL_WORD_PERFORMANCE); // ⭐ NEW
  const { showSuccess, showError } = useNotification();
  
  const [optimizationState, setOptimizationState] = useState({
    isProcessing: false,
    lastUpdate: Date.now(),
    forceUpdate: 0
  });

  // ⭐ MEMOIZED SELECTORS with hints
  const selectors = useMemo(() => ({
    totalTests: testHistory.length,
    totalAnswers: stats.correctAnswers + stats.incorrectAnswers,
    totalHints: stats.hintsUsed, // ⭐ NEW
    accuracyRate: stats.correctAnswers + stats.incorrectAnswers > 0 
      ? Math.round((stats.correctAnswers / (stats.correctAnswers + stats.incorrectAnswers)) * 100)
      : 0,
    hintsRate: stats.correctAnswers + stats.incorrectAnswers > 0 
      ? Math.round((stats.hintsUsed / (stats.correctAnswers + stats.incorrectAnswers)) * 100)
      : 0, // ⭐ NEW: Percentage of answers with hints
    isActiveToday: (() => {
      const today = new Date().toISOString().split('T')[0];
      return Boolean(stats.dailyProgress[today]?.tests > 0);
    })(),
    avgTimePerTest: stats.testsCompleted > 0 
      ? Math.round(stats.timeSpent / stats.testsCompleted) 
      : 0
  }), [
    testHistory.length, 
    stats.correctAnswers, 
    stats.incorrectAnswers, 
    stats.hintsUsed, // ⭐ NEW
    stats.testsCompleted, 
    stats.timeSpent, 
    stats.dailyProgress
  ]);

  // ⭐ NEW: Word-specific analysis
  const getWordAnalysis = useCallback((wordId) => {
    const wordData = wordPerformance[wordId];
    if (!wordData) return null;

    const attempts = wordData.attempts || [];
    const totalAttempts = attempts.length;
    const correctAttempts = attempts.filter(a => a.correct).length;
    const hintsUsed = attempts.filter(a => a.usedHint).length;
    const lastAttempt = attempts[attempts.length - 1];
    
    // Calculate streak
    let currentStreak = 0;
    for (let i = attempts.length - 1; i >= 0; i--) {
      if (attempts[i].correct) {
        currentStreak++;
      } else {
        break;
      }
    }

    // Calculate improvement trend
    const recentAttempts = attempts.slice(-5);
    const recentCorrect = recentAttempts.filter(a => a.correct).length;
    const recentAccuracy = recentAttempts.length > 0 ? (recentCorrect / recentAttempts.length) * 100 : 0;

    // Word status classification
    let status = 'new';
    if (totalAttempts >= 3) {
      if (currentStreak >= 3) status = 'consolidated';
      else if (correctAttempts / totalAttempts >= 0.7) status = 'improving';
      else if (correctAttempts / totalAttempts <= 0.3) status = 'critical';
      else status = 'inconsistent';
    } else if (totalAttempts > 0) {
      status = currentStreak > 0 ? 'promising' : 'struggling';
    }

    return {
      totalAttempts,
      correctAttempts,
      accuracy: totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0,
      hintsUsed,
      hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0,
      currentStreak,
      lastAttempt,
      recentAccuracy: Math.round(recentAccuracy),
      status,
      avgTime: attempts.length > 0 ? Math.round(attempts.reduce((sum, a) => sum + (a.timeSpent || 0), 0) / attempts.length / 1000) : 0,
      attempts: attempts.slice(-10) // Last 10 attempts for trend
    };
  }, [wordPerformance]);

  // ⭐ NEW: Get all words with their performance
  const getAllWordsPerformance = useCallback(() => {
    return Object.keys(wordPerformance).map(wordId => {
      const analysis = getWordAnalysis(wordId);
      return {
        wordId,
        english: wordPerformance[wordId].english,
        italian: wordPerformance[wordId].italian,
        chapter: wordPerformance[wordId].chapter,
        ...analysis
      };
    }).sort((a, b) => {
      // Sort by status priority: critical -> inconsistent -> improving -> consolidated
      const statusPriority = {
        critical: 1,
        inconsistent: 2,
        struggling: 3,
        promising: 4,
        improving: 5,
        consolidated: 6,
        new: 7
      };
      return statusPriority[a.status] - statusPriority[b.status];
    });
  }, [wordPerformance, getWordAnalysis]);

  // ⭐ ENHANCED: Record word performance
  const recordWordPerformance = useCallback((word, isCorrect, usedHint, timeSpent) => {
    const wordId = word.id;
    const attempt = {
      timestamp: new Date().toISOString(),
      correct: isCorrect,
      usedHint: usedHint || false,
      timeSpent: timeSpent || 0
    };

    setWordPerformance(prev => ({
      ...prev,
      [wordId]: {
        english: word.english,
        italian: word.italian,
        chapter: word.chapter,
        attempts: [...(prev[wordId]?.attempts || []), attempt]
      }
    }));
  }, [setWordPerformance]);

  // ⭐ MEMOIZED WEEKLY PROGRESS
  const weeklyProgress = useMemo(() => {
    const last7Days = Array.from({ length: 7 }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - i);
      return date.toISOString().split('T')[0];
    });
    
    return last7Days.map(date => ({
      date,
      tests: stats.dailyProgress[date]?.tests || 0,
      correct: stats.dailyProgress[date]?.correct || 0,
      incorrect: stats.dailyProgress[date]?.incorrect || 0,
      hints: stats.dailyProgress[date]?.hints || 0 // ⭐ NEW
    }));
  }, [stats.dailyProgress]);

  // ⭐ OPTIMIZED STREAK CALCULATION
  const calculateStreak = useCallback((dailyProgress) => {
    const today = new Date();
    let streak = 0;
    
    for (let i = 0; i < 365; i++) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      
      if (dailyProgress[dateStr]?.tests > 0) {
        streak++;
      } else if (i === 0) {
        continue;
      } else {
        break;
      }
      
      if (i > 30 && streak === 0) break;
    }
    
    return streak;
  }, []);

  // ⭐ BATCH OPERATIONS
  const performBatchUpdate = useCallback((updates) => {
    setOptimizationState(prev => ({ ...prev, isProcessing: true }));
    
    try {
      if (updates.stats) {
        setStats(updates.stats);
      }
      if (updates.testHistory) {
        setTestHistory(updates.testHistory);
      }
      if (updates.wordPerformance) {
        setWordPerformance(updates.wordPerformance);
      }
      
      setOptimizationState(prev => ({
        ...prev,
        lastUpdate: Date.now(),
        forceUpdate: prev.forceUpdate + 1,
        isProcessing: false
      }));
      
    } catch (error) {
      console.error('❌ Batch update error:', error);
      showError(error, 'Batch Update');
      setOptimizationState(prev => ({ ...prev, isProcessing: false }));
    }
  }, [setStats, setTestHistory, setWordPerformance, showError]);

  // ⭐ OPTIMIZED MIGRATION
  const optimizedMigration = useCallback(() => {
    if (testHistory.length === 0) return;

    const migrationData = testHistory.reduce((acc, test) => {
      acc.correctAnswers += test.correctWords || 0;
      acc.incorrectAnswers += test.incorrectWords || 0;
      acc.hintsUsed += test.hintsUsed || 0; // ⭐ NEW
      acc.totalWords = Math.max(acc.totalWords, test.totalWords || 0);
      acc.timeSpent += test.timeSpent || Math.floor(Math.random() * 6) + 5;

      if (test.timestamp) {
        const testDate = new Date(test.timestamp).toISOString().split('T')[0];
        if (!acc.dailyProgress[testDate]) {
          acc.dailyProgress[testDate] = { tests: 0, correct: 0, incorrect: 0, hints: 0 };
        }
        acc.dailyProgress[testDate].tests += 1;
        acc.dailyProgress[testDate].correct += test.correctWords || 0;
        acc.dailyProgress[testDate].incorrect += test.incorrectWords || 0;
        acc.dailyProgress[testDate].hints += test.hintsUsed || 0; // ⭐ NEW
        
        if (!acc.lastStudyDate || testDate > acc.lastStudyDate) {
          acc.lastStudyDate = testDate;
        }
      }

      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, chapterData]) => {
          if (!acc.categoriesProgress[chapter]) {
            acc.categoriesProgress[chapter] = { correct: 0, total: 0, hints: 0 };
          }
          acc.categoriesProgress[chapter].correct += chapterData.correctWords || 0;
          acc.categoriesProgress[chapter].total += chapterData.totalWords || 0;
          acc.categoriesProgress[chapter].hints += chapterData.hintsUsed || 0; // ⭐ NEW
        });
      }

      return acc;
    }, {
      correctAnswers: 0,
      incorrectAnswers: 0,
      hintsUsed: 0, // ⭐ NEW
      totalWords: 0,
      timeSpent: 0,
      dailyProgress: {},
      categoriesProgress: {},
      lastStudyDate: null
    });

    const migratedStats = {
      ...INITIAL_STATS,
      ...migrationData,
      testsCompleted: testHistory.length,
      averageScore: migrationData.correctAnswers + migrationData.incorrectAnswers > 0 
        ? (migrationData.correctAnswers / (migrationData.correctAnswers + migrationData.incorrectAnswers)) * 100 
        : 0,
      streakDays: calculateStreak(migrationData.dailyProgress),
      migrated: true
    };

    performBatchUpdate({ stats: migratedStats });
    showSuccess(`✅ Migrati ${testHistory.length} test!`);
  }, [testHistory, calculateStreak, performBatchUpdate, showSuccess]);

  // ⭐ ENHANCED: Test completion with word tracking
  const handleTestComplete = useCallback((testStats, testWordsUsed, wrongWordsArray) => {
    console.log('📊 handleTestComplete called with:', { testStats, testWordsUsed: testWordsUsed.length, wrongWords: wrongWordsArray.length });

    const usedChapters = [...new Set(testWordsUsed.map(word => word.chapter || 'Senza Capitolo'))];
    
    const chapterStats = {};
    usedChapters.forEach(chapter => {
      const chapterWords = testWordsUsed.filter(word => 
        (word.chapter || 'Senza Capitolo') === chapter
      );
      const chapterWrongWords = wrongWordsArray.filter(word => 
        (word.chapter || 'Senza Capitolo') === chapter
      );
      
      // ⭐ NEW: Calculate hints for this chapter
      const chapterHints = testStats.wordTimes ? 
        testStats.wordTimes
          .filter(wt => chapterWords.some(cw => cw.id === wt.wordId))
          .filter(wt => wt.usedHint).length : 0;
      
      chapterStats[chapter] = {
        totalWords: chapterWords.length,
        correctWords: chapterWords.length - chapterWrongWords.length,
        incorrectWords: chapterWrongWords.length,
        hintsUsed: chapterHints, // ⭐ NEW
        percentage: chapterWords.length > 0 ? 
          Math.round(((chapterWords.length - chapterWrongWords.length) / chapterWords.length) * 100) : 0
      };
    });

    // ⭐ NEW: Record individual word performances
    if (testStats.wordTimes && Array.isArray(testStats.wordTimes)) {
      testStats.wordTimes.forEach(wordTime => {
        const word = testWordsUsed.find(w => w.id === wordTime.wordId);
        if (word) {
          recordWordPerformance(word, wordTime.isCorrect, wordTime.usedHint, wordTime.timeSpent);
        }
      });
    }

    const updates = {
      stats: { ...stats },
      testHistory: [
        {
          id: Date.now(),
          timestamp: new Date(),
          totalWords: testStats.correct + testStats.incorrect,
          correctWords: testStats.correct,
          incorrectWords: testStats.incorrect,
          hintsUsed: testStats.hints || 0, // ⭐ NEW
          totalTime: testStats.totalTime || 0, // ⭐ NEW
          avgTimePerWord: testStats.avgTimePerWord || 0, // ⭐ NEW
          percentage: Math.round((testStats.correct / (testStats.correct + testStats.incorrect)) * 100),
          wrongWords: [...wrongWordsArray],
          wordTimes: testStats.wordTimes || [], // ⭐ NEW: Store individual word times
          chapterStats,
          testParameters: {
            selectedChapters: usedChapters,
            includeLearnedWords: testWordsUsed.some(w => w.learned),
            totalAvailableWords: testWordsUsed.length
          },
          testType: usedChapters.length === 1 ? 'selective' : 'complete',
          difficulty: testWordsUsed.length < 10 ? 'easy' : testWordsUsed.length < 25 ? 'medium' : 'hard'
        },
        ...testHistory
      ]
    };

    // ⭐ ENHANCED: Update stats with hints
    updates.stats.testsCompleted += 1;
    updates.stats.correctAnswers += testStats.correct;
    updates.stats.incorrectAnswers += testStats.incorrect;
    updates.stats.hintsUsed += testStats.hints || 0; // ⭐ NEW
    updates.stats.timeSpent += testStats.totalTime || (Math.round(Math.random() * 10) + 5);
    
    const totalAnswers = updates.stats.correctAnswers + updates.stats.incorrectAnswers;
    updates.stats.averageScore = (updates.stats.correctAnswers / totalAnswers) * 100;

    const today = new Date().toISOString().split('T')[0];
    if (!updates.stats.dailyProgress[today]) {
      updates.stats.dailyProgress[today] = { tests: 0, correct: 0, incorrect: 0, hints: 0 };
    }
    updates.stats.dailyProgress[today].tests += 1;
    updates.stats.dailyProgress[today].correct += testStats.correct;
    updates.stats.dailyProgress[today].incorrect += testStats.incorrect;
    updates.stats.dailyProgress[today].hints += testStats.hints || 0; // ⭐ NEW
    
    updates.stats.lastStudyDate = today;
    updates.stats.streakDays = calculateStreak(updates.stats.dailyProgress);

    console.log('📊 Updating stats with:', updates.stats);
    performBatchUpdate(updates);
    showSuccess(`✅ Test completato! Risultato: ${updates.testHistory[0].percentage}%`);
  }, [stats, testHistory, calculateStreak, performBatchUpdate, showSuccess, recordWordPerformance]);

  // ⭐ FIXED: Export with WORDS included
  const exportStats = useCallback(() => {
    try {
      // ⭐ CRITICAL: Get words from localStorage - they're managed by useOptimizedWords
      const words = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');
      
      const exportData = {
        words, // ⭐ CRITICAL: Include actual words!
        stats,
        testHistory,
        wordPerformance, // ⭐ NEW: Include word performance
        exportDate: new Date().toISOString(),
        version: '2.2', // ⭐ Updated version
        dataTypes: ['words', 'stats', 'testHistory', 'wordPerformance'], // ⭐ Updated
        totalTests: testHistory.length,
        totalWords: words.length, // ⭐ FIXED: Count actual words, not performance
        totalWordPerformance: Object.keys(wordPerformance).length,
        description: 'Backup completo v2.2: parole + statistiche + cronologia test + performance parole'
      };
      
      const dataStr = JSON.stringify(exportData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `vocabulary-complete-backup-v2.2-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      showSuccess(`✅ Backup v2.2 esportato! (${words.length} parole + ${testHistory.length} test + ${Object.keys(wordPerformance).length} performance)`);
    } catch (error) {
      showError(error, 'Export');
    }
  }, [stats, testHistory, wordPerformance, showSuccess, showError]);

  // ⭐ FIXED: Import with WORDS support
  const importStats = useCallback((file) => {
    return new Promise((resolve, reject) => {
      if (optimizationState.isProcessing) {
        reject(new Error('Operazione già in corso'));
        return;
      }

      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          setOptimizationState(prev => ({ ...prev, isProcessing: true }));
          const importedData = JSON.parse(e.target.result);
          
          // ⭐ IMPROVED: Better validation
          const hasWords = importedData.words && Array.isArray(importedData.words);
          const hasStats = importedData.stats && typeof importedData.stats === 'object';
          const hasHistory = importedData.testHistory && Array.isArray(importedData.testHistory);
          const hasWordPerformance = importedData.wordPerformance && typeof importedData.wordPerformance === 'object';
          
          if (!hasWords && !hasStats && !hasHistory) {
            throw new Error('File non contiene dati validi (parole, statistiche o cronologia)');
          }
          
          const isNewFormat = importedData.version === '2.2' && hasWords;
          const isEnhancedBackup = importedData.version === '2.1' && hasWordPerformance;
          
          let confirmMessage = '';
          if (isNewFormat) {
            confirmMessage = `Backup Completo v2.2 rilevato (${importedData.words?.length || 0} parole + ${importedData.testHistory?.length || 0} test + ${Object.keys(importedData.wordPerformance || {}).length} performance).\nOK = Sostituisci tutto | Annulla = Combina`;
          } else if (isEnhancedBackup) {
            confirmMessage = `Backup Enhanced v2.1 rilevato (${importedData.testHistory?.length || 0} test + ${Object.keys(importedData.wordPerformance || {}).length} performance).\nOK = Sostituisci tutto | Annulla = Combina\n⚠️ ATTENZIONE: Non contiene parole!`;
          } else {
            confirmMessage = `Backup standard rilevato.\nOK = Sostituisci | Annulla = Combina`;
          }
          
          const shouldOverwrite = window.confirm(confirmMessage);
          
          // ⭐ IMPROVED: Better data handling
          let newStats = stats;
          let newHistory = testHistory;
          let newWordPerformance = wordPerformance;
          let importedWords = [];
          
          if (shouldOverwrite) {
            // Replace all data
            if (hasStats) {
              newStats = { ...importedData.stats, migrated: true };
            }
            if (hasHistory) {
              newHistory = [...importedData.testHistory];
            }
            if (hasWordPerformance) {
              newWordPerformance = { ...importedData.wordPerformance };
            }
            if (hasWords) {
              importedWords = [...importedData.words];
              // ⭐ CRITICAL: Save words to their storage
              localStorage.setItem('vocabularyWords', JSON.stringify(importedWords));
            }
            
            const components = [];
            if (hasWords) components.push(`${importedWords.length} parole`);
            if (hasHistory) components.push(`${newHistory.length} test`);
            if (hasWordPerformance) components.push(`${Object.keys(newWordPerformance).length} performance`);
            
            showSuccess(`✅ Backup ${isNewFormat ? 'v2.2' : isEnhancedBackup ? 'v2.1' : 'standard'} importato! ${components.join(' + ')}`);
          } else {
            // Merge data
            if (hasHistory) {
              const existingIds = new Set(testHistory.map(test => test.id));
              const newTests = importedData.testHistory.filter(test => !existingIds.has(test.id));
              newHistory = [...testHistory, ...newTests].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }
            
            if (hasWordPerformance) {
              newWordPerformance = { ...wordPerformance };
              Object.entries(importedData.wordPerformance).forEach(([wordId, data]) => {
                if (newWordPerformance[wordId]) {
                  // Merge attempts
                  const existingAttempts = newWordPerformance[wordId].attempts || [];
                  const newAttempts = data.attempts || [];
                  const allAttempts = [...existingAttempts, ...newAttempts]
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                  newWordPerformance[wordId] = { ...data, attempts: allAttempts };
                } else {
                  newWordPerformance[wordId] = data;
                }
              });
            }
            
            if (hasWords) {
              // ⭐ IMPROVED: Merge words intelligently
              const currentWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');
              const existingEnglish = new Set(currentWords.map(w => w.english.toLowerCase()));
              const newWords = importedData.words.filter(word => 
                !existingEnglish.has(word.english.toLowerCase())
              );
              
              if (newWords.length > 0) {
                importedWords = [...currentWords, ...newWords];
                localStorage.setItem('vocabularyWords', JSON.stringify(importedWords));
              } else {
                importedWords = currentWords;
              }
            }
            
            const components = [];
            if (hasWords) components.push(`+${importedWords.length - JSON.parse(localStorage.getItem('vocabularyWords') || '[]').length} nuove parole`);
            if (hasHistory) components.push(`+${newHistory.length - testHistory.length} test`);
            if (hasWordPerformance) components.push(`${Object.keys(importedData.wordPerformance).length} performance`);
            
            showSuccess(`✅ Dati combinati! ${components.join(', ')}`);
          }
          
          // ⭐ IMPROVED: Update all data
          performBatchUpdate({ 
            stats: newStats, 
            testHistory: newHistory,
            wordPerformance: newWordPerformance
          });
          
          // ⭐ IMPORTANT: Trigger words refresh if words were imported
          if (hasWords) {
            // Signal that words have changed by updating localStorage timestamp
            localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());
          }
          
          resolve({ 
            newStats, 
            newHistory, 
            newWordPerformance, 
            importedWords: hasWords ? importedWords : null 
          });
          
        } catch (error) {
          console.error('Import error:', error);
          showError(error, 'Import');
          reject(error);
        } finally {
          setOptimizationState(prev => ({ ...prev, isProcessing: false }));
        }
      };
      
      reader.onerror = () => {
        setOptimizationState(prev => ({ ...prev, isProcessing: false }));
        const error = new Error('Errore lettura file');
        showError(error, 'File Reading');
        reject(error);
      };
      
      reader.readAsText(file);
    });
  }, [stats, testHistory, wordPerformance, performBatchUpdate, showSuccess, showError, optimizationState.isProcessing]);

  // ⭐ COMPUTED VALUES
  const computedStats = useMemo(() => ({
    ...selectors,
    weeklyProgress,
    isMigrated: stats.migrated,
    isProcessing: optimizationState.isProcessing,
    forceUpdate: optimizationState.forceUpdate
  }), [selectors, weeklyProgress, stats.migrated, optimizationState]);

  // ⭐ AUTO-MIGRATION
  useEffect(() => {
    const shouldMigrate = !stats.migrated && testHistory.length > 0 && !optimizationState.isProcessing;
    
    if (shouldMigrate) {
      const timeoutId = setTimeout(optimizedMigration, 500);
      return () => clearTimeout(timeoutId);
    }
  }, [stats.migrated, testHistory.length, optimizationState.isProcessing, optimizedMigration]);

  return {
    stats,
    testHistory,
    wordPerformance, // ⭐ NEW
    calculatedStats: computedStats,
    
    handleTestComplete,
    addTestToHistory: useCallback((testResult) => {
      const updatedHistory = [testResult, ...testHistory];
      performBatchUpdate({ testHistory: updatedHistory });
    }, [testHistory, performBatchUpdate]),
    
    // ⭐ NEW: Word performance functions
    getWordAnalysis,
    getAllWordsPerformance,
    recordWordPerformance,
    
    refreshData: useCallback(() => {
      if (optimizationState.isProcessing) return;
      
      try {
        const freshHistory = JSON.parse(localStorage.getItem('testHistory') || '[]');
        const freshStats = JSON.parse(localStorage.getItem('vocabularyStats') || JSON.stringify(INITIAL_STATS));
        const freshWordPerformance = JSON.parse(localStorage.getItem('wordPerformance') || '{}');
        
        performBatchUpdate({
          stats: freshStats,
          testHistory: freshHistory,
          wordPerformance: freshWordPerformance
        });
      } catch (error) {
        showError(error, 'Refresh');
      }
    }, [optimizationState.isProcessing, performBatchUpdate, showError]),
    
    resetStats: useCallback(() => {
      if (window.confirm('⚠️ Cancellare tutto (parole, test, statistiche)?')) {
        // ⭐ ENHANCED: Also clear words
        localStorage.removeItem('vocabularyWords');
        localStorage.removeItem('vocabularyWords_lastUpdate');
        
        performBatchUpdate({
          stats: { ...INITIAL_STATS, migrated: true },
          testHistory: EMPTY_ARRAY,
          wordPerformance: INITIAL_WORD_PERFORMANCE
        });
        showSuccess('✅ Tutti i dati cancellati (parole, test, statistiche)!');
      }
    }, [performBatchUpdate, showSuccess]),
    
    clearHistoryOnly: useCallback(() => {
      if (window.confirm(`Cancellare ${testHistory.length} test?`)) {
        performBatchUpdate({ testHistory: EMPTY_ARRAY });
        showSuccess('✅ Cronologia cancellata!');
      }
    }, [testHistory.length, performBatchUpdate, showSuccess]),

    exportStats,
    importStats,
    
    ...computedStats
  };
};

export { useOptimizedStats as useStats };

================================================================================

NOME FILE: hooks\useOptimizedTest.js

// =====================================================
// 📁 hooks/useOptimizedTest.js - FIXED getTestSummary completo
// =====================================================

import { useState, useCallback, useMemo, useRef, useEffect } from 'react';

export const useOptimizedTest = (onTestComplete) => {
  const [currentWord, setCurrentWord] = useState(null);
  const [usedWordIds, setUsedWordIds] = useState(new Set());
  const [showMeaning, setShowMeaning] = useState(false);
  const [testMode, setTestMode] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [stats, setStats] = useState({ correct: 0, incorrect: 0, hints: 0 });
  const [wrongWords, setWrongWords] = useState([]);
  const [testWords, setTestWords] = useState([]);
  const [testSaved, setTestSaved] = useState(false);
  
  // ⭐ ENHANCED: Timer e transizioni
  const [wordTimes, setWordTimes] = useState([]);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const testStartTimeRef = useRef(null);
  const wordStartTimeRef = useRef(null);
  
  // ⭐ ENHANCED: Hint functionality
  const [showHint, setShowHint] = useState(false);
  const [hintUsedForCurrentWord, setHintUsedForCurrentWord] = useState(false);

  // ⭐ CRITICAL: Start timing when word appears (SOLO quando non in transizione)
  useEffect(() => {
    if (currentWord && testMode && !isTransitioning) {
      console.log('⏱️ New word appeared, starting timer:', currentWord.english);
      wordStartTimeRef.current = Date.now();
      setHintUsedForCurrentWord(false);
      setShowHint(false);
      setShowMeaning(false);
    }
  }, [currentWord, testMode, isTransitioning]);

  // ⭐ ENHANCED: Record word completion time
  const recordWordTime = useCallback((isCorrect, usedHint = false) => {
    if (wordStartTimeRef.current && currentWord) {
      const timeSpent = Date.now() - wordStartTimeRef.current;
      console.log(`⏱️ Recording time for ${currentWord.english}:`, {
        timeSpent: Math.round(timeSpent / 1000) + 's',
        isCorrect,
        usedHint
      });
      
      const wordRecord = {
        wordId: currentWord.id,
        english: currentWord.english,
        italian: currentWord.italian,
        chapter: currentWord.chapter,
        timeSpent,
        isCorrect,
        usedHint,
        timestamp: new Date().toISOString()
      };
      
      setWordTimes(prev => {
        const newTimes = [...prev, wordRecord];
        console.log('📊 Updated wordTimes:', newTimes.length, 'total records');
        return newTimes;
      });
      
      wordStartTimeRef.current = null;
    } else {
      console.warn('⚠️ Cannot record time - missing wordStartTimeRef or currentWord');
    }
  }, [currentWord]);

  // ⭐ PROGRESS: Enhanced with hints
  const progressData = useMemo(() => {
    if (testWords.length === 0) return { current: 0, total: 0, percentage: 0, hints: 0 };
    
    const answered = stats.correct + stats.incorrect;
    
    return {
      current: answered + 1,
      total: testWords.length,
      percentage: Math.round((answered / testWords.length) * 100),
      hints: stats.hints
    };
  }, [stats.correct, stats.incorrect, stats.hints, testWords.length]);

  // ⭐ ENHANCED: Summary con TUTTI i dati timing e hints per ResultsView
  const summaryData = useMemo(() => {
    const totalAnswered = stats.correct + stats.incorrect;
    const accuracy = totalAnswered > 0 ? Math.round((stats.correct / totalAnswered) * 100) : 0;
    const totalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0;
    
    // ⭐ ENHANCED: Calcoli timing più precisi da wordTimes
    const timingStats = wordTimes.length > 0 ? {
      avgTimePerWord: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000),
      maxTimePerWord: Math.round(Math.max(...wordTimes.map(r => r.timeSpent)) / 1000),
      minTimePerWord: Math.round(Math.min(...wordTimes.map(r => r.timeSpent)) / 1000),
      totalRecordedTime: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / 1000)
    } : {
      avgTimePerWord: 0,
      maxTimePerWord: 0,
      minTimePerWord: 0,
      totalRecordedTime: 0
    };
    
    // ⭐ CRITICAL: Return COMPLETE summary with ALL enhanced data
    const completeSummary = {
      current: totalAnswered + 1,
      total: testWords.length,
      percentage: Math.round((totalAnswered / testWords.length) * 100),
      answered: totalAnswered,
      remaining: testWords.length - totalAnswered,
      accuracy,
      correct: stats.correct,
      incorrect: stats.incorrect,
      hints: stats.hints, // ⭐ CRITICAL: Include hints count
      totalTime: Math.round(totalTestTime / 1000), // ⭐ CRITICAL: Include total time
      ...timingStats, // ⭐ CRITICAL: Include ALL timing stats
      // ⭐ NEW: Additional enhanced data for results
      wordTimes: [...wordTimes], // ⭐ Complete word timing data
      testStartTime: testStartTimeRef.current,
      hintsPercentage: totalAnswered > 0 ? Math.round((stats.hints / totalAnswered) * 100) : 0,
      efficiency: totalAnswered > 0 ? Math.max(0, accuracy - Math.round((stats.hints / totalAnswered) * 100)) : 0
    };
    
    console.log('📊 useOptimizedTest - Complete summary calculated:', completeSummary);
    return completeSummary;
  }, [stats.correct, stats.incorrect, stats.hints, testWords.length, wordTimes, testStartTimeRef.current]);

  // ⭐ OPTIMIZED RANDOM WORD SELECTION
  const getRandomUnusedWord = useCallback((wordList, usedIds) => {
    const unusedWords = wordList.filter(word => !usedIds.has(word.id));
    if (unusedWords.length === 0) return null;
    
    const randomIndex = Math.floor(Math.random() * unusedWords.length);
    return unusedWords[randomIndex];
  }, []);

  // ⭐ ENHANCED: Save test results with complete stats
  const saveTestResultsWithStats = useCallback((finalStats) => {
    if (!testSaved && (finalStats.correct > 0 || finalStats.incorrect > 0) && onTestComplete) {
      const finalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0;
      
      // ⭐ ENHANCED: Calcoli timing completi
      const timingStats = wordTimes.length > 0 ? {
        avgTimePerWord: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000),
        maxTimePerWord: Math.round(Math.max(...wordTimes.map(r => r.timeSpent)) / 1000),
        minTimePerWord: Math.round(Math.min(...wordTimes.map(r => r.timeSpent)) / 1000),
        totalRecordedTime: Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / 1000)
      } : {
        avgTimePerWord: 0,
        maxTimePerWord: 0,
        minTimePerWord: 0,
        totalRecordedTime: 0
      };
      
      console.log('💾 Saving test results with complete timing:', {
        finalStats,
        wordTimesCount: wordTimes.length,
        timingStats
      });
      
      const enhancedStats = {
        ...finalStats,
        totalTime: Math.round(finalTestTime / 1000),
        ...timingStats, // ⭐ CRITICAL: Include tutti i dati timing
        wordTimes: [...wordTimes] // ⭐ CRITICAL: Pass complete word times array
      };
      
      console.log('📤 Calling onTestComplete with enhancedStats:', enhancedStats);
      onTestComplete(enhancedStats, testWords, wrongWords);
      setTestSaved(true);
    }
  }, [testWords, wrongWords, testSaved, onTestComplete, wordTimes]);

  const startTest = useCallback((filteredWords = []) => {
    if (filteredWords.length === 0) return;
    
    console.log('🚀 Starting test with', filteredWords.length, 'words');
    
    setTestWords(filteredWords);
    setWrongWords([]);
    setTestSaved(false);
    setStats({ correct: 0, incorrect: 0, hints: 0 });
    setUsedWordIds(new Set());
    setWordTimes([]);
    setIsTransitioning(false);
    testStartTimeRef.current = Date.now();
    wordStartTimeRef.current = null;
    
    const firstWord = getRandomUnusedWord(filteredWords, new Set());
    setCurrentWord(firstWord);
    
    if (firstWord) {
      setUsedWordIds(new Set([firstWord.id]));
      console.log('📝 First word set:', firstWord.english);
    }
    
    setShowMeaning(false);
    setShowHint(false);
    setHintUsedForCurrentWord(false);
    setTestMode(true);
  }, [getRandomUnusedWord]);

  // ⭐ ENHANCED: Next word con transizione corretta
  const nextWord = useCallback(() => {
    const nextRandomWord = getRandomUnusedWord(testWords, usedWordIds);
    
    if (nextRandomWord) {
      console.log('➡️ Moving to next word:', nextRandomWord.english);
      
      setIsTransitioning(true);
      setShowMeaning(false);
      
      setTimeout(() => {
        setCurrentWord(nextRandomWord);
        setUsedWordIds(prev => new Set([...prev, nextRandomWord.id]));
        setShowHint(false);
        setHintUsedForCurrentWord(false);
        
        setTimeout(() => {
          setIsTransitioning(false);
        }, 100);
      }, 400);
    }
  }, [testWords, usedWordIds, getRandomUnusedWord]);

  // ⭐ ENHANCED: Hint functionality
  const toggleHint = useCallback(() => {
    if (!showHint && currentWord?.sentence) {
      console.log('💡 Showing hint for:', currentWord.english);
      setShowHint(true);
      setHintUsedForCurrentWord(true);
    } else {
      setShowHint(false);
    }
  }, [showHint, currentWord]);

  // ⭐ CRITICAL: Answer handling con timing corretto
  const handleAnswer = useCallback((isCorrect) => {
    console.log('📝 Handling answer:', { 
      isCorrect, 
      word: currentWord?.english, 
      hintUsed: hintUsedForCurrentWord,
      timeElapsed: wordStartTimeRef.current ? Math.round((Date.now() - wordStartTimeRef.current) / 1000) + 's' : 'no-timer'
    });
    
    // ⭐ CRITICAL: Record timing IMMEDIATAMENTE
    recordWordTime(isCorrect, hintUsedForCurrentWord);
    
    // ⭐ Update stats with hints properly tracked
    const newStats = {
      correct: stats.correct + (isCorrect ? 1 : 0),
      incorrect: stats.incorrect + (isCorrect ? 0 : 1),
      hints: stats.hints + (hintUsedForCurrentWord ? 1 : 0)
    };
    
    console.log('📊 Updated stats:', newStats);
    setStats(newStats);
    
    // ⭐ Track wrong words with hint info
    if (!isCorrect && currentWord) {
      const wrongWord = { ...currentWord, usedHint: hintUsedForCurrentWord };
      setWrongWords(prev => [...prev, wrongWord]);
      console.log('❌ Added wrong word:', wrongWord.english, 'with hint:', hintUsedForCurrentWord);
    }
    
    const totalAnswered = newStats.correct + newStats.incorrect;
    const isLastQuestion = totalAnswered >= testWords.length;
    
    console.log('🎯 Test progress:', {
      answered: totalAnswered,
      total: testWords.length,
      isLastQuestion
    });
    
    // ⭐ ENHANCED: Gestione sequenza risposta → fine test o prossima parola
    if (isLastQuestion) {
      console.log('🏁 Test completed, saving results...');
      saveTestResultsWithStats(newStats);
      setTestMode(false);
      setShowResults(true);
      setCurrentWord(null);
    } else {
      setTimeout(() => {
        nextWord();
      }, showMeaning ? 1000 : 600);
    }
  }, [currentWord, showMeaning, stats, testWords.length, hintUsedForCurrentWord, recordWordTime, saveTestResultsWithStats, nextWord]);

  const resetTest = useCallback(() => {
    if (!testSaved && (stats.correct > 0 || stats.incorrect > 0)) {
      console.log('💾 Auto-saving test before reset...');
      saveTestResultsWithStats(stats);
    }
    
    console.log('🔄 Resetting test...');
    setTestMode(false);
    setShowResults(false);
    setCurrentWord(null);
    setUsedWordIds(new Set());
    setWrongWords([]);
    setShowMeaning(false);
    setShowHint(false);
    setHintUsedForCurrentWord(false);
    setStats({ correct: 0, incorrect: 0, hints: 0 });
    setTestWords([]);
    setTestSaved(false);
    setWordTimes([]);
    setIsTransitioning(false);
    testStartTimeRef.current = null;
    wordStartTimeRef.current = null;
  }, [stats, testSaved, saveTestResultsWithStats]);

  const startNewTest = useCallback(() => {
    console.log('🔄 Starting new test...');
    setShowResults(false);
    setWrongWords([]);
    setTestSaved(false);
    setStats({ correct: 0, incorrect: 0, hints: 0 });
    setUsedWordIds(new Set());
    setCurrentWord(null);
    setWordTimes([]);
    setIsTransitioning(false);
    startTest(testWords);
  }, [startTest, testWords]);

  return {
    currentWord,
    usedWordIds,
    showMeaning,
    setShowMeaning,
    testMode,
    showResults,
    stats,
    wrongWords,
    testWords,
    isTransitioning,
    
    // ⭐ ENHANCED: Hint functionality
    showHint,
    toggleHint,
    hintUsed: hintUsedForCurrentWord,
    
    // ⭐ ENHANCED: Timer functionality
    wordTimes,
    
    startTest,
    handleAnswer,
    resetTest,
    startNewTest,
    getTestProgress: useCallback(() => progressData, [progressData]),
    // ⭐ CRITICAL: Return complete summary with ALL enhanced data
    getTestSummary: useCallback(() => summaryData, [summaryData])
  };
};

================================================================================

NOME FILE: hooks\useOptimizedWords.js

import { useState, useCallback, useMemo, useEffect } from 'react';
import { useLocalStorage } from './useLocalStorage';

const EMPTY_ARRAY = [];

export const useOptimizedWords = () => {
  const [words, setWords] = useLocalStorage('vocabularyWords', EMPTY_ARRAY);
  const [editingWord, setEditingWord] = useState(null);
  
  // ⭐ FIXED: Listen for external changes (like imports)
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // ⭐ FIXED: Better import change detection
  useEffect(() => {
    const handleStorageChange = (e) => {
      if (e.key === 'vocabularyWords' || e.key === 'vocabularyWords_lastUpdate') {
        console.log('📦 useOptimizedWords: Detected external words change, refreshing...');
        forceRefresh();
      }
    };

    // Listen for storage changes (from other tabs/imports)
    window.addEventListener('storage', handleStorageChange);
    
    // Also listen for custom event (from same tab imports)
    const handleCustomRefresh = () => {
      console.log('📦 useOptimizedWords: Custom refresh triggered');
      forceRefresh();
    };
    
    window.addEventListener('wordsImported', handleCustomRefresh);

    // ⭐ NEW: Enhanced timestamp checking for imports
    let lastCheck = localStorage.getItem('vocabularyWords_lastUpdate');
    const checkInterval = setInterval(() => {
      const currentCheck = localStorage.getItem('vocabularyWords_lastUpdate');
      if (currentCheck && currentCheck !== lastCheck) {
        lastCheck = currentCheck;
        handleCustomRefresh();
      }
    }, 1000);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('wordsImported', handleCustomRefresh);
      clearInterval(checkInterval);
    };
  }, []);

  // ⭐ NEW: Force refresh function
  const forceRefresh = useCallback(() => {
    try {
      const updatedWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');
      console.log('📦 Force refreshing with', updatedWords.length, 'words');
      setWords(updatedWords);
      setRefreshTrigger(prev => prev + 1);
    } catch (error) {
      console.error('Error in force refresh:', error);
    }
  }, [setWords]);

  // ⭐ MEMOIZED COMPUTATIONS - Enhanced with difficult words
  const wordStats = useMemo(() => ({
    total: words.length,
    learned: words.filter(w => w.learned).length,
    unlearned: words.filter(w => !w.learned).length,
    difficult: words.filter(w => w.difficult).length,
    normal: words.filter(w => !w.difficult && !w.learned).length,
    chapters: [...new Set(words.map(w => w.chapter).filter(Boolean))].sort(),
    groups: [...new Set(words.map(w => w.group).filter(Boolean))].sort()
  }), [words, refreshTrigger]);

  // ⭐ FIXED: Better word map generation with proper ID handling
  const wordMap = useMemo(() => {
    const map = {};
    words.forEach(word => {
      // Map by ID (primary key)
      if (word.id) {
        map[word.id] = word;
      }
      // Map by english word (for duplicate checking)
      if (word.english) {
        map[word.english.toLowerCase()] = word;
      }
    });
    console.log('📦 WordMap updated with', Object.keys(map).length / 2, 'words');
    return map;
  }, [words, refreshTrigger]);

  // ⭐ BATCH WORD OPERATIONS
  const batchUpdateWords = useCallback((updateFn) => {
    setWords(prevWords => {
      const newWords = updateFn(prevWords);
      const sortedWords = newWords.sort((a, b) => a.english.localeCompare(b.english));
      
      // ⭐ FIXED: Always update timestamp for import detection
      localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());
      
      console.log('📦 Batch updated to', sortedWords.length, 'words');
      return sortedWords;
    });
  }, [setWords]);

  // ⭐ FIXED: Enhanced add word with better ID and duplicate handling
  const addWord = useCallback((wordData) => {
    if (!wordData.english?.trim() || !wordData.italian?.trim()) {
      throw new Error('English word and Italian translation are required');
    }

    const englishWord = wordData.english.trim().toLowerCase();
    
    // ⭐ FIXED: Better duplicate checking - exclude current editing word
    if (!editingWord && wordMap[englishWord] && wordMap[englishWord].id !== editingWord?.id) {
      throw new Error('Word already exists');
    }
    
    batchUpdateWords(prevWords => {
      if (editingWord) {
        // ⭐ FIXED: Editing mode - preserve original ID and update
        console.log('📝 Editing word:', editingWord.english, '→', wordData.english);
        return prevWords.map(word =>
          word.id === editingWord.id
            ? { 
                ...word, 
                ...wordData, 
                id: editingWord.id, // ⭐ CRITICAL: Preserve original ID
                english: wordData.english.trim(),
                italian: wordData.italian.trim()
              }
            : word
        );
      } else {
        // ⭐ FIXED: Adding new word - generate consistent ID
        const newWord = {
          id: Date.now().toString() + Math.random().toString(36).substr(2, 9), // ⭐ Better ID generation
          english: wordData.english.trim(),
          italian: wordData.italian.trim(),
          group: wordData.group?.trim() || null,
          sentence: wordData.sentence?.trim() || null,
          notes: wordData.notes?.trim() || null,
          chapter: wordData.chapter?.trim() || null,
          learned: wordData.learned || false,
          difficult: wordData.difficult || false
        };
        console.log('➕ Adding new word:', newWord.english, 'with ID:', newWord.id);
        return [...prevWords, newWord];
      }
    });
    
    setEditingWord(null);
  }, [editingWord, wordMap, batchUpdateWords]);

  // ⭐ FIXED: Enhanced import with better ID and validation handling
  const importWords = useCallback((jsonText) => {
    try {
      const importedWords = JSON.parse(jsonText.trim());
      
      if (!Array.isArray(importedWords) || importedWords.length === 0) {
        throw new Error('Invalid JSON data - expected array of words');
      }

      // ⭐ FIXED: Better word validation and ID generation
      const validWords = importedWords
        .filter(word => word?.english && word?.italian)
        .map(word => ({
          id: word.id || (Date.now().toString() + Math.random().toString(36).substr(2, 9)), // ⭐ Ensure unique ID
          english: String(word.english).trim(),
          italian: String(word.italian).trim(),
          group: word.group ? String(word.group).trim() : null,
          sentence: word.sentence ? String(word.sentence).trim() : null,
          notes: word.notes ? String(word.notes).trim() : null,
          chapter: word.chapter ? String(word.chapter).trim() : null,
          learned: Boolean(word.learned),
          difficult: Boolean(word.difficult)
        }));

      if (validWords.length === 0) {
        throw new Error('No valid words found in JSON data');
      }

      // ⭐ FIXED: Better duplicate checking using current words state
      const currentWords = JSON.parse(localStorage.getItem('vocabularyWords') || '[]');
      const existingEnglish = new Set(currentWords.map(w => w.english.toLowerCase()));
      const newWords = validWords.filter(word =>
        !existingEnglish.has(word.english.toLowerCase())
      );

      if (newWords.length === 0) {
        throw new Error('All words already exist in your vocabulary');
      }

      // ⭐ FIXED: Direct localStorage update + state update for immediate sync
      const allWords = [...currentWords, ...newWords];
      localStorage.setItem('vocabularyWords', JSON.stringify(allWords));
      localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());
      
      // Update state immediately
      setWords(allWords);
      setRefreshTrigger(prev => prev + 1);
      
      // ⭐ FIXED: Trigger refresh event for other components
      window.dispatchEvent(new CustomEvent('wordsImported', { 
        detail: { count: newWords.length, total: allWords.length }
      }));
      
      console.log('📥 Imported', newWords.length, 'new words. Total:', allWords.length);
      return newWords.length;
    } catch (error) {
      console.error('Import error:', error);
      throw error;
    }
  }, [setWords]);

  // ⭐ FILTERED GETTERS - Enhanced with difficult words
  const getters = useMemo(() => ({
    getWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter),
    getDifficultWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter && word.difficult),
    getAvailableChapters: () => {
      const chapters = new Set();
      words.forEach(word => {
        if (word.chapter) chapters.add(word.chapter);
      });
      return Array.from(chapters).sort((a, b) => {
        const aNum = parseInt(a);
        const bNum = parseInt(b);
        return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
      });
    },
    getChapterStats: (chapter) => {
      const chapterWords = words.filter(word => word.chapter === chapter);
      return {
        total: chapterWords.length,
        learned: chapterWords.filter(w => w.learned).length,
        unlearned: chapterWords.filter(w => !w.learned).length,
        difficult: chapterWords.filter(w => w.difficult).length,
        normal: chapterWords.filter(w => !w.difficult && !w.learned).length
      };
    }
  }), [words, refreshTrigger]);

  return {
    words,
    editingWord,
    setEditingWord,
    wordStats,
    addWord,
    
    removeWord: useCallback((id) => {
      console.log('🗑️ Removing word with ID:', id);
      batchUpdateWords(prevWords => prevWords.filter(word => word.id !== id));
      if (editingWord?.id === id) setEditingWord(null);
    }, [editingWord?.id, batchUpdateWords]),

    toggleWordLearned: useCallback((id) => {
      console.log('📚 Toggling learned status for ID:', id);
      batchUpdateWords(prevWords =>
        prevWords.map(word =>
          word.id === id ? { ...word, learned: !word.learned } : word
        )
      );
    }, [batchUpdateWords]),

    // ⭐ NEW: Toggle difficult status
    toggleWordDifficult: useCallback((id) => {
      console.log('⭐ Toggling difficult status for ID:', id);
      batchUpdateWords(prevWords =>
        prevWords.map(word =>
          word.id === id ? { ...word, difficult: !word.difficult } : word
        )
      );
    }, [batchUpdateWords]),

    clearAllWords: useCallback(() => {
      console.log('🧹 Clearing all words');
      setWords(EMPTY_ARRAY);
      setEditingWord(null);
      localStorage.setItem('vocabularyWords_lastUpdate', Date.now().toString());
    }, [setWords]),

    importWords,
    forceRefresh, // ⭐ NEW: Expose force refresh function
    
    ...getters
  };
};

================================================================================

NOME FILE: layouts\AppLayout.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import { AppHeader } from '../components/layout/AppHeader';
import { AppNavigation } from '../components/layout/AppNavigation';
import { BackgroundParticles } from '../components/ui/BackgroundParticles';
import { NotificationToast } from '../components/ui/NotificationToast';
import { GlobalModals } from '../components/modals/GlobalModals';

export const AppLayout = ({ children }) => {
  const { testMode, showResults } = useAppContext();

  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-white to-cyan-50">
      <BackgroundParticles />
      <NotificationToast />
      <GlobalModals />
      
      <div className="relative z-10 max-w-6xl mx-auto p-6 space-y-8">
        {!testMode && !showResults && (
          <>
            <AppHeader />
            <AppNavigation />
          </>
        )}
        
        <main>
          {children}
        </main>
      </div>
    </div>
  );
};

================================================================================

NOME FILE: services\aiService.js

// =====================================================
// 📁 src/services/aiService.js - Gemini AI Integration Service
// =====================================================

import { AI_CONFIG, CATEGORIES, ERROR_MESSAGES } from '../constants/appConstants';

/**
 * AI Service for Gemini API integration
 * Estratto e ottimizzato da AddWordForm.js
 */
class AIService {
  constructor() {
    this.apiKey = AI_CONFIG.apiKey;
    this.baseUrl = AI_CONFIG.baseUrl;
    this.timeout = AI_CONFIG.timeout;
    this.maxRetries = AI_CONFIG.maxRetries;
    this.retryDelay = AI_CONFIG.retryDelay;
  }

  /**
   * Build the API URL with API key
   * @returns {string} Complete API URL
   */
  getApiUrl() {
    return `${this.baseUrl}?key=${this.apiKey}`;
  }

  /**
   * Word categorization fallback (from AddWordForm.js)
   * @param {string} word - English word to categorize
   * @returns {string} Category name
   */
  categorizeWordFallback(word) {
    const wordLower = word.toLowerCase();
    
    // Pattern per verbi comuni
    if (wordLower.match(/^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/)) {
      return 'VERBI';
    }
    
    // Pattern per verbi irregolari comuni
    if (wordLower.match(/^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/)) {
      return 'VERBI_IRREGOLARI';
    }
    
    // Pattern per aggettivi
    if (wordLower.match(/^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/) || 
        wordLower.match(/^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/)) {
      return 'AGGETTIVI';
    }
    
    // Pattern per tecnologia
    if (wordLower.match(/^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/)) {
      return 'TECNOLOGIA';
    }
    
    // Pattern per famiglia
    if (wordLower.match(/^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/)) {
      return 'FAMIGLIA';
    }
    
    // Pattern per emozioni positive
    if (wordLower.match(/^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/)) {
      return 'EMOZIONI_POSITIVE';
    }
    
    // Pattern per emozioni negative
    if (wordLower.match(/^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/)) {
      return 'EMOZIONI_NEGATIVE';
    }
    
    // Pattern per lavoro
    if (wordLower.match(/^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/)) {
      return 'LAVORO';
    }
    
    // Pattern per vestiti
    if (wordLower.match(/^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/)) {
      return 'VESTITI';
    }
    
    // Default: prova a determinare se è un sostantivo
    return 'SOSTANTIVI';
  }

  /**
   * Build Gemini API prompt for word analysis
   * @param {string} englishWord - English word to analyze
   * @returns {string} Complete prompt
   */
  buildPrompt(englishWord) {
    const groupsList = CATEGORIES.join(', ');
    
    return `
Analizza la parola inglese "${englishWord}" e fornisci le seguenti informazioni in formato JSON:

{
  "italian": "traduzione principale in italiano (solo la traduzione più comune)",
  "group": "DEVE essere esattamente una di queste categorie: ${groupsList}. Scegli quella più appropriata per la parola.",
  "sentence": "frase d'esempio in inglese che usa la parola",
  "notes": "note aggiuntive con altre traduzioni, sinonimi, forme irregolari, etc. Formatta come: 'Altri Significati: ... Sinonimi: ... Verbo Irregolare: ... etc.'",
  "chapter": "lascia vuoto, sarà compilato dall'utente"
}

REGOLE IMPORTANTI:
- Rispondi SOLO con il JSON valido, nessun altro testo
- Il campo "group" DEVE essere esattamente una di queste opzioni: ${groupsList}
- Per i verbi irregolari, usa "VERBI_IRREGOLARI" e specifica le forme nel campo notes
- Per verbi regolari, usa "VERBI"
- Includi sempre almeno 2-3 significati alternativi nelle note se esistono
- La frase deve essere semplice e chiara
- Il campo "chapter" deve rimanere vuoto (stringa vuota)
- Se la parola non si adatta perfettamente a nessuna categoria, scegli quella più vicina

ESEMPI:
- "run" → group: "VERBI_IRREGOLARI" 
- "beautiful" → group: "AGGETTIVI"
- "computer" → group: "TECNOLOGIA"
- "father" → group: "FAMIGLIA"
- "happy" → group: "EMOZIONI_POSITIVE"
`;
  }

  /**
   * Sleep utility for retry delays
   * @param {number} ms - Milliseconds to sleep
   * @returns {Promise}
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Make HTTP request to Gemini API with retries
   * @param {string} prompt - Prompt to send to AI
   * @param {number} attempt - Current attempt number
   * @returns {Promise<Object>} API response
   */
  async makeRequest(prompt, attempt = 1) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(this.getApiUrl(), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }]
        }),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API Error ${response.status}: ${errorText}`);
      }

      const data = await response.json();
      
      if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
        throw new Error('Invalid API response structure');
      }

      return data;

    } catch (error) {
      clearTimeout(timeoutId);
      
      // Handle timeout
      if (error.name === 'AbortError') {
        throw new Error('Request timeout');
      }
      
      // Handle network errors with retry
      if (attempt < this.maxRetries && (
        error.message.includes('fetch') || 
        error.message.includes('network') ||
        error.message.includes('timeout')
      )) {
        console.warn(`AI request attempt ${attempt} failed, retrying in ${this.retryDelay}ms...`);
        await this.sleep(this.retryDelay * attempt); // Exponential backoff
        return this.makeRequest(prompt, attempt + 1);
      }

      throw error;
    }
  }

  /**
   * Parse and validate AI response
   * @param {string} content - Raw AI response content
   * @param {string} fallbackWord - Original word for fallback categorization
   * @returns {Object} Parsed and validated word data
   */
  parseAIResponse(content, fallbackWord) {
    try {
      // Extract JSON from the response (remove any markdown formatting)
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('No JSON found in AI response');
      }

      const parsedData = JSON.parse(jsonMatch[0]);

      // Validate required fields
      if (!parsedData.italian) {
        throw new Error('Missing italian translation in AI response');
      }

      // Validate category: must be one of predefined categories
      if (parsedData.group && !CATEGORIES.includes(parsedData.group)) {
        console.warn(`Invalid AI category "${parsedData.group}", using fallback categorization`);
        parsedData.group = this.categorizeWordFallback(fallbackWord);
      }

      // Set default group if missing
      if (!parsedData.group) {
        parsedData.group = this.categorizeWordFallback(fallbackWord);
      }

      // Ensure chapter is empty string
      parsedData.chapter = parsedData.chapter || '';

      // Validate data integrity
      return {
        italian: parsedData.italian?.trim() || '',
        group: parsedData.group,
        sentence: parsedData.sentence?.trim() || '',
        notes: parsedData.notes?.trim() || '',
        chapter: ''
      };

    } catch (error) {
      console.error('Error parsing AI response:', error);
      
      // Fallback: return minimal data with categorization
      return {
        italian: '',
        group: this.categorizeWordFallback(fallbackWord),
        sentence: '',
        notes: 'AI parsing failed. Please fill manually.',
        chapter: ''
      };
    }
  }

  /**
   * Main method: Call Gemini API to analyze a word
   * @param {string} englishWord - English word to analyze
   * @returns {Promise<Object>} Word analysis data
   */
  async analyzeWord(englishWord) {
    if (!englishWord || typeof englishWord !== 'string') {
      throw new Error('Valid English word is required');
    }

    const trimmedWord = englishWord.trim();
    if (!trimmedWord) {
      throw new Error('English word cannot be empty');
    }

    try {
      // Build prompt
      const prompt = this.buildPrompt(trimmedWord);
      
      // Make API request
      const apiResponse = await this.makeRequest(prompt);
      
      // Extract content
      const content = apiResponse.candidates[0].content.parts[0].text;
      
      // Parse and validate response
      const wordData = this.parseAIResponse(content, trimmedWord);
      
      console.log('✅ AI analysis successful for:', trimmedWord);
      return wordData;

    } catch (error) {
      console.error('❌ AI analysis failed for:', trimmedWord, error);
      
      // Re-throw with user-friendly message
      if (error.message.includes('timeout')) {
        throw new Error(ERROR_MESSAGES.network);
      } else if (error.message.includes('API Error')) {
        throw new Error(ERROR_MESSAGES.ai);
      } else {
        throw new Error(`AI Error: ${error.message}`);
      }
    }
  }

  /**
   * Quick category prediction without full analysis
   * @param {string} englishWord - English word to categorize
   * @returns {string} Predicted category
   */
  quickCategorize(englishWord) {
    if (!englishWord || typeof englishWord !== 'string') {
      return 'SOSTANTIVI';
    }
    
    return this.categorizeWordFallback(englishWord.trim());
  }

  /**
   * Check if AI service is available
   * @returns {Promise<boolean>} Service availability
   */
  async isAvailable() {
    try {
      // Simple test request
      const testResponse = await fetch(this.getApiUrl(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: 'test' }] }]
        })
      });
      
      return testResponse.ok || testResponse.status === 400; // 400 is OK, means API is responsive
    } catch (error) {
      console.warn('AI service availability check failed:', error);
      return false;
    }
  }

  /**
   * Get service status information
   * @returns {Object} Service status
   */
  getStatus() {
    return {
      configured: !!this.apiKey,
      apiUrl: this.baseUrl,
      timeout: this.timeout,
      maxRetries: this.maxRetries,
      categories: CATEGORIES.length
    };
  }
}

// Create and export singleton instance
const aiService = new AIService();

export { aiService };
export default aiService;

================================================================================

NOME FILE: services\storageService.js

// =====================================================
// 📁 src/services/storageService.js - Optimized localStorage Wrapper
// =====================================================

import { STORAGE_CONFIG } from '../constants/appConstants';

/**
 * Enhanced localStorage service with error handling, compression, and backup functionality
 * Estratto e ottimizzato dalla logica esistente nel codebase
 */
class StorageService {
  constructor() {
    this.isAvailable = this.checkStorageAvailability();
    this.keys = STORAGE_CONFIG.keys;
  }

  /**
   * Check if localStorage is available
   * @returns {boolean}
   */
  checkStorageAvailability() {
    try {
      const test = '__storage_test__';
      localStorage.setItem(test, 'test');
      localStorage.removeItem(test);
      return true;
    } catch (error) {
      console.warn('localStorage not available:', error);
      return false;
    }
  }

  /**
   * Get item from localStorage with parsing
   * @param {string} key - Storage key
   * @param {*} defaultValue - Default value if key doesn't exist
   * @returns {*} Parsed value or default
   */
  get(key, defaultValue = null) {
    if (!this.isAvailable) {
      console.warn('Storage not available, returning default value');
      return defaultValue;
    }

    try {
      const item = localStorage.getItem(key);
      if (item === null) {
        return defaultValue;
      }
      
      // Try to parse JSON, fallback to string if it fails
      try {
        return JSON.parse(item);
      } catch (parseError) {
        console.warn(`Failed to parse JSON for key "${key}":`, parseError);
        return item; // Return as string if JSON parsing fails
      }
    } catch (error) {
      console.error(`Error getting item "${key}" from storage:`, error);
      return defaultValue;
    }
  }

  /**
   * Set item in localStorage with stringification
   * @param {string} key - Storage key
   * @param {*} value - Value to store
   * @returns {boolean} Success status
   */
  set(key, value) {
    if (!this.isAvailable) {
      console.warn('Storage not available, cannot save data');
      return false;
    }

    try {
      const serializedValue = JSON.stringify(value);
      localStorage.setItem(key, serializedValue);
      return true;
    } catch (error) {
      console.error(`Error setting item "${key}" in storage:`, error);
      
      // Handle quota exceeded error
      if (error.name === 'QuotaExceededError') {
        console.warn('Storage quota exceeded, attempting cleanup...');
        this.cleanup();
        
        // Try again after cleanup
        try {
          const serializedValue = JSON.stringify(value);
          localStorage.setItem(key, serializedValue);
          return true;
        } catch (retryError) {
          console.error('Failed to save even after cleanup:', retryError);
          return false;
        }
      }
      return false;
    }
  }

  /**
   * Remove item from localStorage
   * @param {string} key - Storage key
   * @returns {boolean} Success status
   */
  remove(key) {
    if (!this.isAvailable) {
      return false;
    }

    try {
      localStorage.removeItem(key);
      return true;
    } catch (error) {
      console.error(`Error removing item "${key}" from storage:`, error);
      return false;
    }
  }

  /**
   * Clear all localStorage data
   * @returns {boolean} Success status
   */
  clear() {
    if (!this.isAvailable) {
      return false;
    }

    try {
      localStorage.clear();
      return true;
    } catch (error) {
      console.error('Error clearing storage:', error);
      return false;
    }
  }

  /**
   * Get multiple items at once
   * @param {string[]} keys - Array of keys to retrieve
   * @returns {Object} Object with key-value pairs
   */
  getMultiple(keys) {
    const result = {};
    keys.forEach(key => {
      result[key] = this.get(key);
    });
    return result;
  }

  /**
   * Set multiple items at once
   * @param {Object} items - Object with key-value pairs to set
   * @returns {boolean} Success status
   */
  setMultiple(items) {
    try {
      Object.entries(items).forEach(([key, value]) => {
        if (!this.set(key, value)) {
          throw new Error(`Failed to set key: ${key}`);
        }
      });
      return true;
    } catch (error) {
      console.error('Error setting multiple items:', error);
      return false;
    }
  }

  /**
   * Check if key exists in storage
   * @param {string} key - Storage key
   * @returns {boolean}
   */
  exists(key) {
    if (!this.isAvailable) {
      return false;
    }
    return localStorage.getItem(key) !== null;
  }

  /**
   * Get all keys that match a pattern
   * @param {string} pattern - Pattern to match (regex string)
   * @returns {string[]} Array of matching keys
   */
  getKeysMatching(pattern) {
    if (!this.isAvailable) {
      return [];
    }

    try {
      const regex = new RegExp(pattern);
      const matchingKeys = [];
      
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && regex.test(key)) {
          matchingKeys.push(key);
        }
      }
      
      return matchingKeys;
    } catch (error) {
      console.error('Error getting keys matching pattern:', error);
      return [];
    }
  }

  /**
   * Get storage usage information
   * @returns {Object} Storage usage stats
   */
  getUsageStats() {
    if (!this.isAvailable) {
      return { used: 0, available: 0, total: 0 };
    }

    try {
      let used = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        used += (key?.length || 0) + (value?.length || 0);
      }

      // Estimate total available space (varies by browser)
      const total = 5 * 1024 * 1024; // 5MB typical limit
      const available = total - used;

      return {
        used,
        available,
        total,
        usedMB: (used / 1024 / 1024).toFixed(2),
        availableMB: (available / 1024 / 1024).toFixed(2),
        usagePercentage: ((used / total) * 100).toFixed(1)
      };
    } catch (error) {
      console.error('Error calculating usage stats:', error);
      return { used: 0, available: 0, total: 0 };
    }
  }

  /**
   * Cleanup old or large items to free space
   * @returns {boolean} Success status
   */
  cleanup() {
    if (!this.isAvailable) {
      return false;
    }

    try {
      console.log('Starting storage cleanup...');
      
      // Get all items with their sizes
      const items = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        const size = (key?.length || 0) + (value?.length || 0);
        
        items.push({ key, size, value });
      }

      // Sort by size (largest first)
      items.sort((a, b) => b.size - a.size);

      // Remove items that are not essential (avoid app critical keys)
      const criticalKeys = Object.values(this.keys);
      let cleaned = false;

      for (const item of items) {
        if (!criticalKeys.includes(item.key)) {
          // Check if it's an old backup or temporary data
          if (item.key.includes('backup_') || item.key.includes('temp_') || item.key.includes('cache_')) {
            localStorage.removeItem(item.key);
            console.log(`Removed non-essential item: ${item.key} (${item.size} bytes)`);
            cleaned = true;
          }
        }
      }

      if (!cleaned) {
        console.warn('No non-essential items found for cleanup');
      }

      return cleaned;
    } catch (error) {
      console.error('Error during cleanup:', error);
      return false;
    }
  }

  /**
   * Create a backup of critical data
   * @returns {Object|null} Backup data or null if failed
   */
  createBackup() {
    if (!this.isAvailable) {
      return null;
    }

    try {
      const backup = {};
      const criticalKeys = Object.values(this.keys);
      
      criticalKeys.forEach(key => {
        const data = this.get(key);
        if (data !== null) {
          backup[key] = data;
        }
      });

      backup._timestamp = Date.now();
      backup._version = '2.0.0';
      
      return backup;
    } catch (error) {
      console.error('Error creating backup:', error);
      return null;
    }
  }

  /**
   * Restore from backup data
   * @param {Object} backupData - Backup data to restore
   * @returns {boolean} Success status
   */
  restoreFromBackup(backupData) {
    if (!this.isAvailable || !backupData) {
      return false;
    }

    try {
      // Validate backup data
      if (!backupData._timestamp || !backupData._version) {
        throw new Error('Invalid backup data format');
      }

      // Restore each item
      Object.entries(backupData).forEach(([key, value]) => {
        if (!key.startsWith('_')) { // Skip metadata
          this.set(key, value);
        }
      });

      console.log('Successfully restored from backup');
      return true;
    } catch (error) {
      console.error('Error restoring from backup:', error);
      return false;
    }
  }

  // =====================================================
  // App-specific helper methods (extracted from existing code)
  // =====================================================

  /**
   * Get vocabulary words (replaces direct localStorage access in app)
   * @returns {Array} Array of word objects
   */
  getWords() {
    // Try new key first, then fallback to possible old keys
    let words = this.get(this.keys.words, null);
    
    if (!words || words.length === 0) {
      // Try common alternative keys that might be used by existing app
      const fallbackKeys = [
        'words', 
        'vocabularyWords', 
        'vocabulary_words_v1',
        'vocabulary-words',
        'app_words',
        'vocabWords'
      ];
      
      for (const key of fallbackKeys) {
        words = this.get(key, null);
        if (words && words.length > 0) {
          console.log(`📦 StorageService: Found words in fallback key "${key}" (${words.length} words)`);
          // Migrate to new key
          this.set(this.keys.words, words);
          break;
        }
      }
      
      // If still nothing, check raw localStorage for any key containing "word"
      if (!words || words.length === 0) {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.toLowerCase().includes('word')) {
            try {
              const data = JSON.parse(localStorage.getItem(key));
              if (Array.isArray(data) && data.length > 0 && data[0].english && data[0].italian) {
                console.log(`📦 StorageService: Found words in discovered key "${key}" (${data.length} words)`);
                words = data;
                // Migrate to new key
                this.set(this.keys.words, words);
                break;
              }
            } catch (e) {
              // Ignore parsing errors
            }
          }
        }
      }
    }
    
    return words || [];
  }

  /**
   * Save vocabulary words
   * @param {Array} words - Array of word objects
   * @returns {boolean} Success status
   */
  saveWords(words) {
    return this.set(this.keys.words, words);
  }

  /**
   * Get app statistics
   * @returns {Object} Stats object
   */
  getStats() {
    let stats = this.get(this.keys.stats, null);
    
    if (!stats || Object.keys(stats).length === 0) {
      // Try fallback keys for stats
      const fallbackKeys = ['stats', 'vocabulary_stats_v1', 'app_stats', 'vocabularyStats'];
      
      for (const key of fallbackKeys) {
        stats = this.get(key, null);
        if (stats && Object.keys(stats).length > 0) {
          console.log(`📦 StorageService: Found stats in fallback key "${key}"`);
          // Migrate to new key
          this.set(this.keys.stats, stats);
          break;
        }
      }
    }
    
    // Return with defaults merged
    return {
      testsCompleted: 0,
      correctAnswers: 0,
      incorrectAnswers: 0,
      totalWords: 0,
      streakDays: 0,
      lastStudyDate: null,
      timeSpent: 0,
      categoriesProgress: {},
      ...stats
    };
  }

  /**
   * Save app statistics
   * @param {Object} stats - Stats object
   * @returns {boolean} Success status
   */
  saveStats(stats) {
    return this.set(this.keys.stats, stats);
  }

  /**
   * Get test history
   * @returns {Array} Array of test history objects
   */
  getTestHistory() {
    let history = this.get(this.keys.testHistory, null);
    
    if (!history || history.length === 0) {
      // Try fallback keys for test history
      const fallbackKeys = ['testHistory', 'vocabulary_test_history_v1', 'test_history', 'vocabHistory'];
      
      for (const key of fallbackKeys) {
        history = this.get(key, null);
        if (history && history.length > 0) {
          console.log(`📦 StorageService: Found test history in fallback key "${key}" (${history.length} tests)`);
          // Migrate to new key
          this.set(this.keys.testHistory, history);
          break;
        }
      }
    }
    
    return history || [];
  }

  /**
   * Save test history
   * @param {Array} history - Array of test history objects
   * @returns {boolean} Success status
   */
  saveTestHistory(history) {
    return this.set(this.keys.testHistory, history);
  }

  /**
   * Get app settings
   * @returns {Object} Settings object
   */
  getSettings() {
    return this.get(this.keys.settings, {
      theme: 'light',
      notifications: true,
      autoAdvance: true,
      soundEnabled: true
    });
  }

  /**
   * Save app settings
   * @param {Object} settings - Settings object
   * @returns {boolean} Success status
   */
  saveSettings(settings) {
    return this.set(this.keys.settings, settings);
  }
}

// Create and export singleton instance
const storageService = new StorageService();

export { storageService };
export default storageService;

================================================================================

NOME FILE: utils\categoryUtils.js

// /src/utils/categoryUtils.js
// This file contains utility functions for managing vocabulary categories.
// It provides functions to get the style for a category based on its name, and to retrieve a list of predefined groups.
// It is used to ensure consistent styling and categorization of vocabulary words in the application.

export const getCategoryStyle = (group) => {
  if (!group) return { 
    color: 'from-blue-400 via-blue-500 to-blue-600', 
    icon: '📚', 
    bgColor: 'bg-blue-500',
    bgGradient: 'bg-gradient-to-br from-blue-500 to-cyan-600'
  };
  
  const categoryMap = {
    'VERBI': { 
      color: 'from-red-400 via-red-500 to-red-600', 
      icon: '⚡', 
      bgColor: 'bg-red-500',
      bgGradient: 'bg-gradient-to-br from-red-500 to-orange-600'
    },
    'VERBI_IRREGOLARI': { 
      color: 'from-red-500 via-red-600 to-red-700', 
      icon: '🔄', 
      bgColor: 'bg-red-600',
      bgGradient: 'bg-gradient-to-br from-red-600 to-pink-600'
    },
    'SOSTANTIVI': { 
      color: 'from-blue-400 via-blue-500 to-blue-600', 
      icon: '🏷️', 
      bgColor: 'bg-blue-500',
      bgGradient: 'bg-gradient-to-br from-blue-500 to-indigo-600'
    },
    'AGGETTIVI': { 
      color: 'from-green-400 via-green-500 to-green-600', 
      icon: '🎨', 
      bgColor: 'bg-green-500',
      bgGradient: 'bg-gradient-to-br from-green-500 to-emerald-600'
    },
    'DESCRIZIONI_FISICHE': { 
      color: 'from-teal-400 via-teal-500 to-teal-600', 
      icon: '👤', 
      bgColor: 'bg-teal-500',
      bgGradient: 'bg-gradient-to-br from-teal-500 to-cyan-600'
    },
    'POSIZIONE_CORPO': { 
      color: 'from-purple-400 via-purple-500 to-purple-600', 
      icon: '🧘', 
      bgColor: 'bg-purple-500',
      bgGradient: 'bg-gradient-to-br from-purple-500 to-violet-600'
    },
    'EMOZIONI': { 
      color: 'from-pink-400 via-pink-500 to-pink-600', 
      icon: '❤️', 
      bgColor: 'bg-pink-500',
      bgGradient: 'bg-gradient-to-br from-pink-500 to-rose-600'
    },
    'EMOZIONI_POSITIVE': { 
      color: 'from-yellow-400 via-yellow-500 to-orange-500', 
      icon: '😊', 
      bgColor: 'bg-yellow-500',
      bgGradient: 'bg-gradient-to-br from-yellow-400 to-orange-500'
    },
    'EMOZIONI_NEGATIVE': { 
      color: 'from-gray-400 via-gray-500 to-gray-600', 
      icon: '😔', 
      bgColor: 'bg-gray-500',
      bgGradient: 'bg-gradient-to-br from-gray-500 to-slate-600'
    },
    'LAVORO': { 
      color: 'from-indigo-400 via-indigo-500 to-indigo-600', 
      icon: '💼', 
      bgColor: 'bg-indigo-500',
      bgGradient: 'bg-gradient-to-br from-indigo-500 to-blue-600'
    },
    'FAMIGLIA': { 
      color: 'from-pink-300 via-pink-400 to-rose-500', 
      icon: '👨‍👩‍👧‍👦', 
      bgColor: 'bg-pink-400',
      bgGradient: 'bg-gradient-to-br from-pink-400 to-rose-500'
    },
    'TECNOLOGIA': { 
      color: 'from-cyan-400 via-cyan-500 to-blue-500', 
      icon: '💻', 
      bgColor: 'bg-cyan-500',
      bgGradient: 'bg-gradient-to-br from-cyan-500 to-blue-500'
    },
    'VESTITI': { 
      color: 'from-purple-300 via-purple-400 to-pink-500', 
      icon: '👕', 
      bgColor: 'bg-purple-400',
      bgGradient: 'bg-gradient-to-br from-purple-400 to-pink-500'
    },
    'DEFAULT': { 
      color: 'from-emerald-400 via-emerald-500 to-cyan-500', 
      icon: '📚', 
      bgColor: 'bg-emerald-500',
      bgGradient: 'bg-gradient-to-br from-emerald-500 to-cyan-600'
    }
  };
  
  const upperGroup = group ? group.toUpperCase().trim() : '';
  return categoryMap[upperGroup] || categoryMap['DEFAULT'];
};

export const getPredefinedGroups = () => {
  return [
    'VERBI', 'VERBI_IRREGOLARI', 'SOSTANTIVI', 'AGGETTIVI',
    'DESCRIZIONI_FISICHE', 'POSIZIONE_CORPO', 'EMOZIONI',
    'EMOZIONI_POSITIVE', 'EMOZIONI_NEGATIVE', 'LAVORO',
    'FAMIGLIA', 'TECNOLOGIA', 'VESTITI'
  ].sort();
};

================================================================================

NOME FILE: utils\index.js

// =====================================================
// 📁 src/utils/index.js - EXPORTS PULITI
// =====================================================

// ✅ Re-export utilities effettivamente utilizzate
export * from './categoryUtils';
export * from './textUtils';

// ✅ Export performance utilities utilizzate
export { 
  memoize, 
  debounce, 
  deepEqual,
  shallowEqual,
  createSelector,
  compose,
  pipe,
  once
} from './performanceUtils';

// =====================================================
// ✅ Convenience re-exports (utilizzati ovunque)
// =====================================================

export { getCategoryStyle, getPredefinedGroups } from './categoryUtils';
export { formatNotes, getTestResult } from './textUtils';

// =====================================================
// ✅ Core utility functions (utilizzate nell'app)
// =====================================================

/**
 * Generate unique ID
 * ✅ UTILIZZATA per generare ID delle parole
 */
export const generateId = () => {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
};

/**
 * Safe JSON parse with fallback
 * ✅ UTILIZZATA nel storageService
 */
export const safeJSONParse = (jsonString, fallback = null) => {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.warn('JSON parse failed:', error);
    return fallback;
  }
};

/**
 * Safe JSON stringify
 * ✅ UTILIZZATA nel storageService
 */
export const safeJSONStringify = (value, fallback = '{}') => {
  try {
    return JSON.stringify(value);
  } catch (error) {
    console.warn('JSON stringify failed:', error);
    return fallback;
  }
};

/**
 * Format time duration
 * ✅ UTILIZZATA in TestView e statistiche
 */
export const formatTime = (seconds) => {
  if (!seconds || seconds < 0) return '0:00';
  
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

/**
 * Format percentage with precision
 * ✅ UTILIZZATA nelle statistiche e nei risultati test
 */
export const formatPercentage = (value, total, decimals = 0) => {
  if (!total || total === 0) return 0;
  const percentage = (value / total) * 100;
  return Number(percentage.toFixed(decimals));
};

/**
 * Check if value is empty
 * ✅ UTILIZZATA nelle validazioni
 */
export const isEmpty = (value) => {
  if (value == null) return true;
  if (typeof value === 'string') return value.trim() === '';
  if (Array.isArray(value)) return value.length === 0;
  if (typeof value === 'object') return Object.keys(value).length === 0;
  return false;
};

/**
 * Pick specific properties from object
 * ✅ UTILIZZATA per filtrare dati export/import
 */
export const pick = (obj, keys) => {
  const result = {};
  keys.forEach(key => {
    if (key in obj) {
      result[key] = obj[key];
    }
  });
  return result;
};

/**
 * Group array of objects by property
 * ✅ UTILIZZATA per raggruppare parole per capitolo
 */
export const groupBy = (array, keyOrFn) => {
  return array.reduce((groups, item) => {
    const key = typeof keyOrFn === 'function' ? keyOrFn(item) : item[keyOrFn];
    if (!groups[key]) {
      groups[key] = [];
    }
    groups[key].push(item);
    return groups;
  }, {});
};

/**
 * Sort array by property with direction
 * ✅ UTILIZZATA per ordinare parole e statistiche
 */
export const sortBy = (array, property, direction = 'asc') => {
  return [...array].sort((a, b) => {
    const aVal = a[property];
    const bVal = b[property];
    
    if (aVal < bVal) return direction === 'asc' ? -1 : 1;
    if (aVal > bVal) return direction === 'asc' ? 1 : -1;
    return 0;
  });
};

/**
 * Calculate statistics for array of numbers
 * ✅ UTILIZZATA nelle statistiche avanzate
 */
export const calculateStats = (numbers) => {
  if (!numbers || numbers.length === 0) {
    return { min: 0, max: 0, avg: 0, sum: 0, count: 0 };
  }
  
  const sum = numbers.reduce((acc, num) => acc + num, 0);
  const avg = sum / numbers.length;
  const min = Math.min(...numbers);
  const max = Math.max(...numbers);
  
  return {
    min,
    max,
    avg: Number(avg.toFixed(2)),
    sum,
    count: numbers.length
  };
};

/**
 * Wait for specified time (async sleep)
 * ✅ UTILIZZATA in operazioni asincrone
 */
export const sleep = (ms) => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

/**
 * Capitalize first letter of each word
 * ✅ UTILIZZATA per formattare testi
 */
export const capitalizeWords = (text) => {
  return text.replace(/\b\w/g, l => l.toUpperCase());
};

/**
 * Truncate text with ellipsis
 * ✅ UTILIZZATA per testi lunghi nelle card
 */
export const truncate = (text, maxLength = 50) => {
  if (!text || text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
};

================================================================================

NOME FILE: utils\performanceUtils.js

// =====================================================
// 📁 src/utils/performanceUtils.js - VERSIONE PULITA
// =====================================================
// Solo le utilities effettivamente utilizzate nell'app

/**
 * Memoization utility for expensive function calls
 * ✅ UTILIZZATA in useOptimizedStats e useOptimizedWords
 */
export const memoize = (fn, keyGenerator = (...args) => JSON.stringify(args)) => {
  const cache = new Map();
  
  return (...args) => {
    const key = keyGenerator(...args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn(...args);
    cache.set(key, result);
    
    // Prevent memory leaks by limiting cache size
    if (cache.size > 100) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    return result;
  };
};

/**
 * Debounce function to limit rapid function calls
 * ✅ UTILIZZATA nel storageService per salvare dati
 */
export const debounce = (fn, delay = 300) => {
  let timeoutId;
  
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
};

/**
 * Deep equality check for objects and arrays
 * ✅ UTILIZZATA in useStoreBridge (anche se sarà rimosso, utile per future comparazioni)
 */
export const deepEqual = (a, b) => {
  if (a === b) return true;
  
  if (a == null || b == null) return false;
  
  if (typeof a !== typeof b) return false;
  
  if (typeof a !== 'object') return a === b;
  
  if (Array.isArray(a) !== Array.isArray(b)) return false;
  
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }
    return true;
  }
  
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (!keysB.includes(key)) return false;
    if (!deepEqual(a[key], b[key])) return false;
  }
  
  return true;
};

/**
 * Shallow equality check for objects
 * ✅ UTILIZZATA per ottimizzazioni React (useMemo, useCallback)
 */
export const shallowEqual = (a, b) => {
  if (a === b) return true;
  
  if (!a || !b) return false;
  
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (a[key] !== b[key]) return false;
  }
  
  return true;
};

/**
 * Create a selector function that memoizes based on input equality
 * ✅ UTILIZZATA negli hook per ottimizzazioni useMemo
 */
export const createSelector = (selector, equalityFn = shallowEqual) => {
  let lastArgs;
  let lastResult;
  
  return (...args) => {
    if (!lastArgs || !equalityFn(args, lastArgs)) {
      lastArgs = args;
      lastResult = selector(...args);
    }
    return lastResult;
  };
};

/**
 * Compose multiple functions into one
 * ✅ UTILIZZATA per creare pipeline di trasformazioni nei dati delle statistiche
 */
export const compose = (...fns) => {
  return (value) => fns.reduceRight((acc, fn) => fn(acc), value);
};

/**
 * Pipe multiple functions (left to right composition)
 * ✅ UTILIZZATA per elaborazioni dati in useOptimizedStats
 */
export const pipe = (...fns) => {
  return (value) => fns.reduce((acc, fn) => fn(acc), value);
};

/**
 * Create a function that only executes once
 * ✅ UTILIZZATA per inizializzazioni singole nei hook
 */
export const once = (fn) => {
  let called = false;
  let result;
  
  return (...args) => {
    if (!called) {
      called = true;
      result = fn(...args);
    }
    return result;
  };
};

================================================================================

NOME FILE: utils\textUtils.js

// /src/utils/textUtils.js
// This file contains utility functions for formatting notes and calculating test results.
// It provides functions to format notes with specific keywords and to determine the result of a vocabulary test.
// The `formatNotes` function processes notes to highlight keywords, while the `getTestResult` function evaluates test statistics to provide feedback based on the user's performance.
// These utilities are essential for enhancing the user experience in a vocabulary learning application, making it easier for users to understand notes and assess their test results.
//  * @returns {Array} An array of React elements or strings representing the formatted notes.
//  */      
//

import React from 'react';

export const formatNotes = (notes) => {
  if (!notes) return null;
  
  const keywords = [
    'Altri Significati', 'Altre Traduzioni', 'Espressioni', 'Verbo Irregolare', 
    'Pronuncia', 'Sinonimi', 'Esempi', 'Attenzione', 'Nota', 'Importante',
    'Plurale irregolare', 'Tecnologia', 'Posizione', 'Contrario', 'Espressione',
    'Verbo', 'Phrasal verbs', 'Differenza', 'Abbreviazione', 'Sinonimo',
    'Tipico britannico', 'Vestiti', 'Preposizioni', 'Avverbio', 'Sostantivo',
    'Aggettivo', 'Congiunzione', 'Interiezione', 'Participio', 'Gerundio',
    'Passato', 'Presente', 'Futuro', 'Condizionale', 'Imperativo', 'Infinito',
    'Formale', 'Informale', 'Slang', 'Americano', 'Britannico', 'Australiano',
    'Tempo', 'Luogo', 'Modo', 'Causa', 'Effetto', 'Scopo', 'Confronto',
    'Origine', 'Destinazione', 'Materiale', 'Colore', 'Forma', 'Dimensione',
    'Quantità', 'Frequenza', 'Durata', 'Velocità', 'Temperatura', 'Peso',
    'Struttura', 'Espressione fissa', 'Figurativo', 'Specificità', 'Pattern',
    'Più specifico di'
  ];
  
  let formattedText = notes;
  
  keywords.forEach(keyword => {
    const regex = new RegExp(`(${keyword})\\s*:`, 'gi');
    formattedText = formattedText.replace(regex, `**$1:**`);
  });
  
  formattedText = formattedText.replace(/^([A-Za-z\s]+):/gm, '**$1:**');
  
  const parts = formattedText.split(/(\*\*[^*]+\*\*)/g);
  
  return parts.map((part, index) => {
    if (part.startsWith('**') && part.endsWith('**')) {
      const boldText = part.slice(2, -2);
      return React.createElement('span', { key: index, className: 'font-bold' }, boldText);
    }
    return part;
  });
};

export const getTestResult = (stats) => {
  const total = stats.correct + stats.incorrect;
  const percentage = total > 0 ? Math.round((stats.correct / total) * 100) : 0;
  
  if (percentage >= 80) {
    return { type: 'victory', message: 'Eccellente! 🏆', color: 'text-green-600', bgColor: 'bg-green-50' };
  } else if (percentage >= 60) {
    return { type: 'good', message: 'Buon lavoro! 👍', color: 'text-blue-600', bgColor: 'bg-blue-50' };
  } else {
    return { type: 'defeat', message: 'Continua a studiare! 📚', color: 'text-red-600', bgColor: 'bg-red-50' };
  }
};

================================================================================

NOME FILE: views\MainView.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import { useNotification } from '../contexts/NotificationContext';
import { ControlPanel } from '../components/main/ControlPanel';
import JSONManager from '../components/JSONManager';
import AddWordForm from '../components/AddWordForm';
import WordsList from '../components/WordsList';

export const MainView = React.memo(() => {
  const {
    words,
    editingWord,
    showWordsList,
    dispatch,
    addWord,
    toggleWordLearned,
    toggleWordDifficult,
    importWords,
    forceRefresh, // ⭐ NEW: Force refresh function
    getAvailableChapters,
    getChapterStats,
    wordStats
  } = useAppContext();

  const { showSuccess, showError, showWarning } = useNotification();

  const handleStartTest = React.useCallback(() => {
    const availableWords = words.filter(word => !word.learned);
    if (availableWords.length === 0) {
      showWarning('⚠️ Nessuna parola disponibile per il test!');
      return;
    }
    dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: true });
  }, [words, dispatch, showWarning]);

  // ⭐ ENHANCED: Better word addition with validation
  const handleAddWord = React.useCallback((wordData) => {
    try {
      console.log('MainView: Adding/editing word:', wordData);
      addWord(wordData);
      dispatch({ type: 'SET_EDITING_WORD', payload: null });
      showSuccess(
        editingWord 
          ? `✅ Parola "${wordData.english}" modificata!`
          : `✅ Parola "${wordData.english}" aggiunta!`
      );
    } catch (error) {
      console.error('MainView: Error adding word:', error);
      showError(error, 'Add Word');
    }
  }, [addWord, editingWord, dispatch, showSuccess, showError]);

  const handleRemoveWord = React.useCallback((id) => {
    const wordToDelete = words.find(word => word.id === id);
    if (wordToDelete) {
      dispatch({ type: 'SET_CONFIRM_DELETE', payload: wordToDelete });
    }
  }, [words, dispatch]);

  const handleToggleWordLearned = React.useCallback((id) => {
    const word = words.find(w => w.id === id);
    if (word) {
      toggleWordLearned(id);
      showSuccess(
        word.learned 
          ? `📖 "${word.english}" segnata come da studiare`
          : `✅ "${word.english}" segnata come appresa!`
      );
    }
  }, [words, toggleWordLearned, showSuccess]);

  const handleToggleWordDifficult = React.useCallback((id) => {
    const word = words.find(w => w.id === id);
    if (word) {
      toggleWordDifficult(id);
      showSuccess(
        word.difficult 
          ? `📚 "${word.english}" rimossa dalle parole difficili`
          : `⭐ "${word.english}" segnata come difficile!`
      );
    }
  }, [words, toggleWordDifficult, showSuccess]);

  // ⭐ FIXED: Enhanced import with better error handling and force refresh
  const handleImportWords = React.useCallback(async (jsonText) => {
    try {
      console.log('MainView: Starting import process...');
      
      // Call the import function
      const count = await importWords(jsonText);
      
      // ⭐ CRITICAL: Force refresh to ensure UI synchronization
      if (forceRefresh) {
        console.log('MainView: Forcing refresh after import');
        setTimeout(forceRefresh, 100);
      }
      
      showSuccess(`✅ ${count} parole importate con successo!`);
      return count;
    } catch (error) {
      console.error('MainView: Import error:', error);
      
      // ⭐ ENHANCED: Better error messages
      if (error.message.includes('already exist')) {
        showWarning('⚠️ Tutte le parole nel JSON sono già presenti nel vocabolario.');
      } else if (error.message.includes('JSON')) {
        showError(new Error('❌ File JSON non valido. Controlla la sintassi.'), 'Import Words');
      } else {
        showError(error, 'Import Words');
      }
      throw error;
    }
  }, [importWords, forceRefresh, showSuccess, showError, showWarning]);

  // ⭐ NEW: Handle edit word with better ID validation
  const handleEditWord = React.useCallback((word) => {
    console.log('MainView: Editing word:', word);
    
    if (!word || !word.id) {
      showError(new Error('Impossibile modificare: parola non valida'), 'Edit Word');
      return;
    }
    
    // ⭐ ENHANCED: Validate word exists in current words list
    const existingWord = words.find(w => w.id === word.id);
    if (!existingWord) {
      showError(new Error('Parola non trovata nel vocabolario'), 'Edit Word');
      console.error('Word not found in words list:', word.id, 'Available IDs:', words.map(w => w.id));
      
      // ⭐ RECOVERY: Force refresh and retry
      if (forceRefresh) {
        forceRefresh();
        setTimeout(() => {
          const refreshedWord = words.find(w => w.english === word.english);
          if (refreshedWord) {
            dispatch({ type: 'SET_EDITING_WORD', payload: refreshedWord });
          }
        }, 500);
      }
      return;
    }
    
    dispatch({ type: 'SET_EDITING_WORD', payload: existingWord });
  }, [words, dispatch, showError, forceRefresh]);

  return (
    <div className="space-y-8 animate-fade-in">
      <ControlPanel 
        onStartTest={handleStartTest}
        onClearAllWords={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: true })}
        words={words}
        wordStats={wordStats}
        getAvailableChapters={getAvailableChapters}
        getChapterStats={getChapterStats}
      />

      <JSONManager 
        words={words}
        onImportWords={handleImportWords}
      />

      <AddWordForm
        onAddWord={handleAddWord}
        editingWord={editingWord}
        onClearForm={() => dispatch({ type: 'SET_EDITING_WORD', payload: null })}
      />

      <WordsList
        words={words}
        onEditWord={handleEditWord} // ⭐ FIXED: Use enhanced edit handler
        onRemoveWord={handleRemoveWord}
        onToggleLearned={handleToggleWordLearned}
        onToggleDifficult={handleToggleWordDifficult}
        showWordsList={showWordsList}
        setShowWordsList={() => dispatch({ type: 'TOGGLE_WORDS_LIST' })}
      />
    </div>
  );
});

================================================================================

NOME FILE: views\ResultsView.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import TestResults from '../components/TestResults';

export const ResultsView = React.memo(() => {
  const {
    wrongWords,
    startNewTest,
    resetTest,
    getTestSummary // ⭐ CRITICAL: Use this function that contains all enhanced data
  } = useAppContext();

  // ⭐ FIXED: Get test results directly from getTestSummary which contains enhanced data
  const getTestResultData = () => {
    // Get the enhanced summary with all timing and hints data
    const summary = getTestSummary && getTestSummary();
    
    console.log('🎯 ResultsView - Using getTestSummary data:', summary);
    
    if (summary && (summary.correct >= 0 || summary.incorrect >= 0)) {
      // ⭐ ENHANCED: Extract all available data from summary
      const enhancedData = {
        correct: summary.correct || 0,
        incorrect: summary.incorrect || 0,
        hints: summary.hints || 0, // ⭐ CRITICAL: Include hints count
        totalTime: summary.totalTime || 0, // ⭐ CRITICAL: Include total time
        avgTimePerWord: summary.avgTimePerWord || 0, // ⭐ CRITICAL: Include average time
        maxTimePerWord: summary.maxTimePerWord || 0, // ⭐ NEW: Include max time
        minTimePerWord: summary.minTimePerWord || 0, // ⭐ NEW: Include min time
        totalRecordedTime: summary.totalRecordedTime || 0, // ⭐ NEW: Include recorded time
        // Additional summary data
        total: summary.total || (summary.correct + summary.incorrect),
        answered: summary.answered || (summary.correct + summary.incorrect),
        accuracy: summary.accuracy || 0,
        percentage: summary.percentage || 0
      };
      
      console.log('✅ ResultsView - Enhanced data prepared:', enhancedData);
      return enhancedData;
    }
    
    // ⭐ FALLBACK: Calculate from wrongWords if summary not available
    if (wrongWords && Array.isArray(wrongWords)) {
      const incorrect = wrongWords.length;
      const fallbackData = { 
        correct: 0, 
        incorrect, 
        hints: 0, 
        totalTime: 0, 
        avgTimePerWord: 0,
        maxTimePerWord: 0,
        minTimePerWord: 0,
        totalRecordedTime: 0
      };
      
      console.log('⚠️ ResultsView - Using fallback from wrongWords:', fallbackData);
      return fallbackData;
    }
    
    // ⭐ FINAL FALLBACK
    const defaultData = { 
      correct: 0, 
      incorrect: 0, 
      hints: 0, 
      totalTime: 0, 
      avgTimePerWord: 0,
      maxTimePerWord: 0,
      minTimePerWord: 0,
      totalRecordedTime: 0
    };
    
    console.log('❌ ResultsView - Using default data:', defaultData);
    return defaultData;
  };

  const finalTestData = getTestResultData();

  console.log('🎯 ResultsView - Final data being passed to TestResults:', finalTestData);

  return (
    <TestResults
      stats={finalTestData}
      wrongWords={wrongWords}
      onStartNewTest={startNewTest}
      onResetTest={resetTest}
    />
  );
});

================================================================================

NOME FILE: views\StatsView.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext'; // ✅ Fixed: named export
import StatsOverview from '../components/stats/StatsOverview'; // ✅ Fixed: default import

export const StatsView = React.memo(() => {
  const {
    testHistory,
    words,
    clearHistoryOnly,
    dispatch,
    forceUpdate
  } = useAppContext();

  return (
    <StatsOverview
      testHistory={testHistory}
      words={words}
      onClearHistory={clearHistoryOnly}
      onGoToMain={() => dispatch({ type: 'SET_VIEW', payload: 'main' })}
      forceUpdate={forceUpdate}
    />
  );
});

================================================================================

NOME FILE: views\TestView.js

// =====================================================
// 📁 views/TestView.js - FIXED timer continuo e interfaccia
// =====================================================

import React, { useState, useEffect, useRef } from 'react';
import { useAppContext } from '../contexts/AppContext';
import { Card } from '../components/ui/card';
import { Button } from '../components/ui/button';
import TestCard from '../components/TestCard';
import { RotateCcw, Check, X, HelpCircle, Clock, Lightbulb } from 'lucide-react';

export const TestView = React.memo(() => {
  const {
    currentWord,
    showMeaning,
    setShowMeaning,
    handleAnswer,
    resetTest,
    getTestProgress,
    getTestSummary,
    showHint,
    toggleHint,
    hintUsed,
    isTransitioning // ⭐ NEW: Stato transizione
  } = useAppContext();

  // ⭐ FIXED: Timer continuo che NON si ferma al flip
  const [currentWordTime, setCurrentWordTime] = useState(0);
  const [isAnswering, setIsAnswering] = useState(false); // ⭐ NEW: Stato risposta
  const timerRef = useRef(null);
  const wordStartTimeRef = useRef(null);

  const progress = getTestProgress();
  const summary = getTestSummary();

  // ⭐ CRITICAL: Timer che continua SEMPRE fino alla risposta
  useEffect(() => {
    // Clear any existing timer
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }

    // Start timer when word appears, continues until answer is given
    if (currentWord && !isTransitioning && !isAnswering) {
      console.log('🕐 Starting UI timer for word:', currentWord.english);
      setCurrentWordTime(0);
      wordStartTimeRef.current = Date.now();
      
      timerRef.current = setInterval(() => {
        if (wordStartTimeRef.current && !isAnswering) {
          const elapsed = Math.floor((Date.now() - wordStartTimeRef.current) / 1000);
          setCurrentWordTime(elapsed);
        }
      }, 1000);
    } else if (!currentWord) {
      // Reset timer when no word
      setCurrentWordTime(0);
      wordStartTimeRef.current = null;
    }

    // Cleanup function
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [currentWord, isTransitioning, isAnswering]); // ⭐ REMOVED showMeaning dependency

  // ⭐ FIXED: Stop timer when component unmounts or test ends
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  // ⭐ ENHANCED: Handle answer with proper timer management
  const handleAnswerWithTimer = (isCorrect) => {
    console.log('📝 Answer given, stopping timer at:', currentWordTime, 'seconds');
    
    // ⭐ CRITICAL: Set answering state and stop timer
    setIsAnswering(true);
    
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
    
    // Call the original handler
    handleAnswer(isCorrect);
    
    // Reset answering state after delay
    setTimeout(() => {
      setIsAnswering(false);
    }, 1000);
  };

  // ⭐ NEW: Format time helper
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <>
      {/* ⭐ ENHANCED: Test Header */}
      <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-2xl overflow-hidden">
        <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-1">
          <div className="bg-white rounded-2xl p-6">
            <div className="flex justify-between items-center mb-4">
              <div>
                <h2 className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                  Test in Corso {isTransitioning && '🔄'}
                </h2>
                <p className="text-gray-600">Parola {progress.current} di {progress.total}</p>
                <div className="flex items-center gap-4 text-sm text-gray-500 mt-1">
                  <span>Accuratezza: {summary.accuracy}%</span>
                  <span>Rimanenti: {summary.remaining}</span>
                  {progress.hints > 0 && (
                    <span className="flex items-center gap-1 text-orange-600">
                      <Lightbulb className="w-4 h-4" />
                      Aiuti: {progress.hints}
                    </span>
                  )}
                  {summary.totalTime > 0 && (
                    <span className="flex items-center gap-1 text-purple-600">
                      <Clock className="w-4 h-4" />
                      Totale: {formatTime(summary.totalTime)}
                    </span>
                  )}
                  {/* ⭐ NEW: Show avg and max time if available */}
                  {summary.avgTimePerWord > 0 && (
                    <span className="flex items-center gap-1 text-blue-600">
                      📊 Media: {summary.avgTimePerWord}s
                    </span>
                  )}
                  {summary.maxTimePerWord > 0 && (
                    <span className="flex items-center gap-1 text-red-600">
                      ⏱️ Max: {summary.maxTimePerWord}s
                    </span>
                  )}
                </div>
              </div>
              <div className="text-right">
                <div className="flex gap-4">
                  <div className="text-center">
                    <div className="text-2xl font-bold text-green-600">{summary.correct}</div>
                    <div className="text-sm text-green-700">Corrette</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-red-600">{summary.incorrect}</div>
                    <div className="text-sm text-red-700">Sbagliate</div>
                  </div>
                  {/* ⭐ FIXED: Current word timer (continua sempre) */}
                  <div className="text-center">
                    <div className={`text-2xl font-bold flex items-center gap-1 transition-colors ${
                      currentWordTime > 30 ? 'text-red-600' : 
                      currentWordTime > 15 ? 'text-orange-600' : 'text-blue-600'
                    }`}>
                      <Clock className={`w-6 h-6 ${isAnswering ? 'animate-pulse' : ''}`} />
                      {formatTime(currentWordTime)}
                    </div>
                    <div className="text-sm text-blue-700">
                      {isAnswering ? 'Elaborando...' : 'Tempo Parola'}
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Enhanced Progress bar */}
            <div className="relative">
              <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-blue-500 to-purple-600 rounded-full transition-all duration-500 ease-out relative"
                  style={{ width: `${progress.percentage}%` }}
                >
                  <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer"></div>
                </div>
              </div>
              <div className="text-center mt-2 text-sm font-medium text-gray-600">
                {progress.percentage}% completato
                {summary.avgTimePerWord > 0 && (
                  <span className="ml-4 text-purple-600">
                    Media: {summary.avgTimePerWord}s/parola
                  </span>
                )}
              </div>
            </div>
          </div>
        </div>
      </Card>

      {/* ⭐ REMOVED: External hint display - now integrated in card */}

      {/* Test Card Area */}
      {currentWord && !isTransitioning && (
        <div className="relative min-h-[80vh] flex items-center justify-center">
          <TestCard 
            word={currentWord}
            showMeaning={showMeaning}
            onFlip={() => setShowMeaning(!showMeaning)}
            showHint={showHint} // ⭐ NEW: Pass hint state to card
            hintUsed={hintUsed} // ⭐ NEW: Pass hint used state
          />

          {/* ⭐ ENHANCED: Answer Buttons con nuovo stato */}
          <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 w-full max-w-2xl">
            <div className="flex justify-center space-x-6 mb-6">
              {showMeaning ? (
                <>
                  <Button
                    onClick={() => handleAnswerWithTimer(true)}
                    disabled={isAnswering}
                    className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-8 py-4 text-lg rounded-2xl shadow-2xl transform transition-all duration-200 hover:scale-105 border-0 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
                  >
                    <Check className="w-6 h-6 mr-3" />
                    {isAnswering ? 'Registrando...' : 'Sapevo la risposta!'}
                  </Button>
                  <Button
                    onClick={() => handleAnswerWithTimer(false)}
                    disabled={isAnswering}
                    className="bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white px-8 py-4 text-lg rounded-2xl shadow-2xl transform transition-all duration-200 hover:scale-105 border-0 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
                  >
                    <X className="w-6 h-6 mr-3" />
                    {isAnswering ? 'Registrando...' : 'Non la sapevo'}
                  </Button>
                </>
              ) : (
                <div className="text-center space-y-4">
                  <p className="text-xl text-gray-700 font-medium">🎯 Clicca la carta per vedere la traduzione</p>
                  <p className="text-sm text-gray-500">
                    {showHint ? '💡 Suggerimento visibile nella carta' : 'Cerca di ricordare il significato prima di girare'}
                  </p>
                  
                  {/* ⭐ ENHANCED: Hint Button */}
                  {currentWord?.sentence && (
                    <div className="flex justify-center">
                      <Button
                        onClick={toggleHint}
                        disabled={hintUsed}
                        className={`${
                          showHint 
                            ? 'bg-gradient-to-r from-orange-500 to-yellow-500 hover:from-orange-600 hover:to-yellow-600' 
                            : hintUsed
                              ? 'bg-gray-400 cursor-not-allowed'
                              : 'bg-gradient-to-r from-orange-400 to-yellow-400 hover:from-orange-500 hover:to-yellow-500'
                        } text-white px-6 py-3 text-base rounded-xl shadow-lg transform transition-all duration-200 hover:scale-105 border-0 disabled:transform-none disabled:hover:scale-100`}
                        title={hintUsed ? "Aiuto già utilizzato per questa parola" : "Mostra frase di contesto nella carta"}
                      >
                        <HelpCircle className="w-5 h-5 mr-2" />
                        {showHint ? '🔍 Nascondi Suggerimento' : hintUsed ? '✅ Aiuto Usato' : '💡 Mostra Suggerimento'}
                      </Button>
                    </div>
                  )}
                  
                  {/* ⭐ ENHANCED: Timer indicator for user */}
                  <div className="mt-4 text-center">
                    <div className={`inline-flex items-center gap-2 px-4 py-2 rounded-full transition-colors ${
                      currentWordTime > 30 ? 'bg-red-100 text-red-700' : 
                      currentWordTime > 15 ? 'bg-orange-100 text-orange-700' : 'bg-blue-100 text-blue-700'
                    }`}>
                      <Clock className={`w-4 h-4 ${isAnswering ? 'animate-pulse' : ''}`} />
                      <span className="font-mono font-bold">{formatTime(currentWordTime)}</span>
                      <span className="text-sm">
                        {isAnswering ? 'Elaborando...' :
                         currentWordTime > 30 ? 'Tempo lungo!' : 
                         currentWordTime > 15 ? 'Continua a riflettere...' : 'Tempo di riflessione'}
                      </span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* ⭐ NEW: Transition indicator */}
      {isTransitioning && (
        <div className="min-h-[80vh] flex items-center justify-center">
          <div className="text-center">
            <div className="text-6xl mb-4 animate-spin">🔄</div>
            <p className="text-xl text-gray-700 font-medium">Preparando la prossima parola...</p>
            <p className="text-sm text-gray-500">La carta sta ruotando</p>
          </div>
        </div>
      )}
      
      {/* End Test Button */}
      <div className="flex justify-center">
        <Button 
          onClick={resetTest} 
          variant="outline"
          disabled={isAnswering}
          className="bg-white/80 backdrop-blur-sm border border-gray-200 hover:bg-white/90 rounded-xl px-6 py-3 shadow-lg disabled:opacity-50"
        >
          <RotateCcw className="w-4 h-4 mr-2" />
          {isAnswering ? 'Attendere...' : 'Termina Test'}
        </Button>
      </div>
    </>
  );
});

================================================================================


NOME FILE: App.css

/* App.css - Stili aggiornati per la nuova versione */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  color: #333;
}

.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ===== HEADER MIGLIORATO ===== */
.app-header {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  color: white;
  padding: 1.5rem 2rem;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

.header-content {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 2rem;
}

.header-main h1 {
  font-size: 2.2rem;
  margin-bottom: 0.5rem;
  font-weight: 700;
}

.header-main p {
  opacity: 0.9;
  font-size: 1.1rem;
}

.header-stats {
  display: flex;
  gap: 1.5rem;
  align-items: center;
}

.header-stat {
  text-align: center;
  min-width: 60px;
}

.header-stat span {
  display: block;
  font-size: 1.4rem;
  font-weight: bold;
  line-height: 1;
}

.header-stat small {
  font-size: 0.8rem;
  opacity: 0.8;
  margin-top: 0.2rem;
  display: block;
}

.header-stat.streak span {
  font-size: 1.2rem;
}

/* ===== NAVIGATION MIGLIORATA ===== */
.app-nav {
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  padding: 0.5rem 0;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-container {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  gap: 0.5rem;
  padding: 0 1rem;
  justify-content: center;
  overflow-x: auto;
}

.nav-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.3rem;
  padding: 0.8rem 1rem;
  border: none;
  background: transparent;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 80px;
  position: relative;
  text-decoration: none;
  color: #555;
}

.nav-btn:hover {
  background: rgba(52, 152, 219, 0.1);
  transform: translateY(-1px);
}

.nav-btn.active {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
  transform: translateY(-1px);
}

.nav-icon {
  font-size: 1.3rem;
  line-height: 1;
}

.nav-text {
  font-size: 0.8rem;
  font-weight: 500;
  white-space: nowrap;
}

.nav-badge {
  position: absolute;
  top: 0.2rem;
  right: 0.2rem;
  background: #e74c3c;
  color: white;
  font-size: 0.7rem;
  padding: 0.1rem 0.4rem;
  border-radius: 10px;
  min-width: 18px;
  text-align: center;
  line-height: 1.2;
  font-weight: bold;
}

/* ===== INDICATORE SEZIONE ===== */
.section-indicator {
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(10px);
  padding: 0.8rem 2rem;
  display: flex;
  align-items: center;
  gap: 0.8rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.indicator-icon {
  font-size: 1.2rem;
}

.indicator-text {
  font-weight: 600;
  color: #2c3e50;
  font-size: 1rem;
}

/* ===== MAIN CONTENT ===== */
.app-main {
  flex: 1;
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  width: 100%;
}

/* ===== SCHERMATA INIZIALE TEST ===== */
.start-test {
  text-align: center;
  padding: 3rem 2rem;
}

.start-test-content {
  max-width: 600px;
  margin: 0 auto;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  padding: 3rem 2rem;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
}

.start-test h2 {
  color: #2c3e50;
  margin-bottom: 2rem;
  font-size: 2rem;
}

.test-info {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 1rem;
  margin: 2rem 0;
}

.info-card {
  background: linear-gradient(145deg, #f8f9fa, #ffffff);
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 1.2rem 0.8rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  transition: transform 0.2s ease;
}

.info-card:hover {
  transform: translateY(-2px);
}

.info-icon {
  font-size: 1.8rem;
  line-height: 1;
}

.info-card strong {
  font-size: 1.5rem;
  color: #2c3e50;
  font-weight: bold;
}

.info-card p {
  font-size: 0.8rem;
  color: #7f8c8d;
  text-align: center;
  margin: 0;
}

.btn-large {
  font-size: 1.1rem;
  padding: 1rem 2rem;
  margin: 2rem 0 1rem 0;
}

.help-text {
  color: #7f8c8d;
  font-style: italic;
  margin-top: 1rem;
}

/* ===== PULSANTI GENERALI ===== */
.btn {
  padding: 0.8rem 1.5rem;
  border: none;
  border-radius: 10px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  text-decoration: none;
  justify-content: center;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none !important;
}

.btn-primary {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
}

.btn-primary:hover:not(:disabled) {
  background: linear-gradient(145deg, #2980b9, #21618c);
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.btn-secondary {
  background: linear-gradient(145deg, #95a5a6, #7f8c8d);
  color: white;
  box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
}

.btn-secondary:hover:not(:disabled) {
  background: linear-gradient(145deg, #7f8c8d, #6c7b7d);
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
}

/* ===== ERROR VIEW ===== */
.error-view {
  text-align: center;
  padding: 3rem 2rem;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  max-width: 500px;
  margin: 2rem auto;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
}

.error-view h2 {
  color: #e74c3c;
  margin-bottom: 1rem;
}

.error-view p {
  color: #7f8c8d;
  margin-bottom: 2rem;
}

/* ===== FOOTER MIGLIORATO ===== */
.app-footer {
  background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
  color: white;
  padding: 1.5rem 2rem;
  margin-top: auto;
}

.footer-content {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
}

.footer-info p {
  margin: 0;
  font-size: 0.95rem;
}

.footer-stats {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  font-size: 0.9rem;
  opacity: 0.9;
}

.footer-stats span {
  white-space: nowrap;
}

/* ===== RESPONSIVE DESIGN ===== */
@media (max-width: 768px) {
  .app-header {
    padding: 1rem;
  }
  
  .header-content {
    flex-direction: column;
    gap: 1rem;
    text-align: center;
  }
  
  .header-main h1 {
    font-size: 1.8rem;
  }
  
  .header-main p {
    font-size: 1rem;
  }
  
  .header-stats {
    gap: 1rem;
  }
  
  .nav-container {
    padding: 0 0.5rem;
    gap: 0.2rem;
  }
  
  .nav-btn {
    min-width: 60px;
    padding: 0.6rem 0.5rem;
  }
  
  .nav-text {
    font-size: 0.7rem;
  }
  
  .section-indicator {
    padding: 0.6rem 1rem;
  }
  
  .app-main {
    padding: 1rem;
  }
  
  .start-test-content {
    padding: 2rem 1rem;
  }
  
  .test-info {
    grid-template-columns: repeat(2, 1fr);
    gap: 0.8rem;
  }
  
  .info-card {
    padding: 1rem 0.5rem;
  }
  
  .footer-content {
    flex-direction: column;
    gap: 0.8rem;
    text-align: center;
  }
  
  .footer-stats {
    flex-wrap: wrap;
    justify-content: center;
  }
}

@media (max-width: 480px) {
  .header-main h1 {
    font-size: 1.5rem;
  }
  
  .test-info {
    grid-template-columns: 1fr;
  }
  
  .nav-text {
    display: none;
  }
  
  .nav-btn {
    min-width: 50px;
    padding: 0.8rem 0.3rem;
  }
  
  .indicator-text {
    font-size: 0.9rem;
  }
}

/* ===== ANIMAZIONI ===== */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.app-main > * {
  animation: slideIn 0.3s ease-out;
}

.nav-btn {
  animation: fadeIn 0.2s ease-out;
}

/* ===== FOCUS E ACCESSIBILITÀ ===== */
.nav-btn:focus,
.btn:focus {
  outline: 2px solid #3498db;
  outline-offset: 2px;
}

.nav-btn.active:focus {
  outline-color: rgba(255, 255, 255, 0.8);
}

@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

================================================================================

NOME FILE: App.js

import React from 'react';
import { AppProvider } from './contexts/AppContext';
import { NotificationProvider } from './contexts/NotificationContext';
import { AppLayout } from './layouts/AppLayout';
import { AppRouter } from './components/AppRouter';
import { ErrorBoundary } from './components/ErrorBoundary';
import './App.css';

const VocabularyApp = () => {
  return (
    <ErrorBoundary>
      <NotificationProvider>
        <AppProvider>
          <AppLayout>
            <AppRouter />
          </AppLayout>
        </AppProvider>
      </NotificationProvider>
    </ErrorBoundary>
  );
};

export default VocabularyApp;

================================================================================

NOME FILE: index.css

/*
/src/index.css
This file contains the main CSS styles for the application, including Tailwind CSS imports and custom styles.
*/
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Stili di base */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* Utilità personalizzate */
@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

================================================================================

NOME FILE: index.js

// /src/index.js
// This file is the entry point for the React application.
// It imports the necessary styles and renders the main App component into the root element of the HTML document.
// It uses ReactDOM to create a root and render the App component wrapped in React.StrictMode.
// This setup ensures that the application is ready for development and production builds with React's best practices.
// It is essential for initializing the React application and providing a consistent structure for rendering components.

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


================================================================================

NOME FILE: components\AddWordForm.js

// =====================================================
// 📁 src/components/AddWordForm.js - VERSIONE ENHANCED con campo "Difficile"
// =====================================================
import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Textarea } from './ui/textarea';
import { Plus, Edit3, Check, Sparkles, Loader2, Wand2, AlertTriangle } from 'lucide-react';
import { getPredefinedGroups, getCategoryStyle } from '../utils/categoryUtils';
import { useNotification } from '../contexts/NotificationContext';

const AddWordForm = ({ onAddWord, editingWord, onClearForm }) => {
  const [formData, setFormData] = useState({
    english: '',
    italian: '',
    group: '',
    sentence: '',
    notes: '',
    chapter: '',
    learned: false,
    difficult: false // ⭐ NEW: Difficult flag
  });
  const [showAdvancedForm, setShowAdvancedForm] = useState(false);
  const [isAiLoading, setIsAiLoading] = useState(false);

  const { showNotification, showError, showWarning, showSuccess } = useNotification();

  // Gemini API Configuration
  const GEMINI_API_KEY = 'AIzaSyCHftv0ACPTtX7unUKg6y_eqb09mBobTAM';
  const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

  // Funzione di fallback per categorizzare le parole
  const categorizeWordFallback = (word) => {
    const wordLower = word.toLowerCase();
    
    // Pattern per verbi comuni
    if (wordLower.match(/^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/)) {
      return 'VERBI';
    }
    
    // Pattern per verbi irregolari comuni
    if (wordLower.match(/^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/)) {
      return 'VERBI_IRREGOLARI';
    }
    
    // Pattern per aggettivi
    if (wordLower.match(/^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/) || 
        wordLower.match(/^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/)) {
      return 'AGGETTIVI';
    }
    
    // Pattern per tecnologia
    if (wordLower.match(/^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/)) {
      return 'TECNOLOGIA';
    }
    
    // Pattern per famiglia
    if (wordLower.match(/^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/)) {
      return 'FAMIGLIA';
    }
    
    // Pattern per emozioni positive
    if (wordLower.match(/^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/)) {
      return 'EMOZIONI_POSITIVE';
    }
    
    // Pattern per emozioni negative
    if (wordLower.match(/^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/)) {
      return 'EMOZIONI_NEGATIVE';
    }
    
    // Pattern per lavoro
    if (wordLower.match(/^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/)) {
      return 'LAVORO';
    }
    
    // Pattern per vestiti
    if (wordLower.match(/^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/)) {
      return 'VESTITI';
    }
    
    // Default: prova a determinare se è un sostantivo
    return 'SOSTANTIVI';
  };

  useEffect(() => {
    if (editingWord) {
      setFormData({
        english: editingWord.english || '',
        italian: editingWord.italian || '',
        group: editingWord.group || '',
        sentence: editingWord.sentence || '',
        notes: editingWord.notes || '',
        chapter: editingWord.chapter || '',
        learned: editingWord.learned || false,
        difficult: editingWord.difficult || false // ⭐ NEW: Load difficult status
      });
      setShowAdvancedForm(true);
    }
  }, [editingWord]);

  const callGeminiAPI = async (englishWord) => {
    const availableGroups = getPredefinedGroups();
    const groupsList = availableGroups.join(', ');
    
    const prompt = `
Analizza la parola inglese "${englishWord}" e fornisci le seguenti informazioni in formato JSON:

{
  "italian": "traduzione principale in italiano (solo la traduzione più comune)",
  "group": "DEVE essere esattamente una di queste categorie: ${groupsList}. Scegli quella più appropriata per la parola.",
  "sentence": "frase d'esempio in inglese che usa la parola",
  "notes": "note aggiuntive con altre traduzioni, sinonimi, forme irregolari, etc. Formatta come: 'Altri Significati: ... Sinonimi: ... Verbo Irregolare: ... etc.'",
  "chapter": "lascia vuoto, sarà compilato dall'utente"
}

REGOLE IMPORTANTI:
- Rispondi SOLO con il JSON valido, nessun altro testo
- Il campo "group" DEVE essere esattamente una di queste opzioni: ${groupsList}
- Per i verbi irregolari, usa "VERBI_IRREGOLARI" e specifica le forme nel campo notes
- Per verbi regolari, usa "VERBI"
- Includi sempre almeno 2-3 significati alternativi nelle note se esistono
- La frase deve essere semplice e chiara
- Il campo "chapter" deve rimanere vuoto (stringa vuota)
- Se la parola non si adatta perfettamente a nessuna categoria, scegli quella più vicina

ESEMPI:
- "run" → group: "VERBI_IRREGOLARI" 
- "beautiful" → group: "AGGETTIVI"
- "computer" → group: "TECNOLOGIA"
- "father" → group: "FAMIGLIA"
- "happy" → group: "EMOZIONI_POSITIVE"
`;

    try {
      const response = await fetch(GEMINI_API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!content) {
        throw new Error('Nessuna risposta dall\'AI');
      }

      // Extract JSON from the response (remove any markdown formatting)
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('Formato risposta non valido');
      }

      const parsedData = JSON.parse(jsonMatch[0]);
      
      // Validazione categoria: deve essere una delle categorie predefinite
      const availableGroups = getPredefinedGroups();
      if (parsedData.group && !availableGroups.includes(parsedData.group)) {
        console.warn(`Categoria AI "${parsedData.group}" non valida. Uso categoria di fallback.`);
        parsedData.group = categorizeWordFallback(englishWord);
      }
      
      return parsedData;

    } catch (error) {
      console.error('Gemini API Error:', error);
      throw error;
    }
  };

  const handleAiAssist = async () => {
    if (!formData.english.trim()) {
      showWarning('⚠️ Inserisci prima una parola inglese!');
      return;
    }

    setIsAiLoading(true);
    
    try {
      showNotification('🤖 L\'AI sta analizzando la parola...', 'info');
      
      const aiData = await callGeminiAPI(formData.english.trim());
      
      if (!aiData.italian) {
        throw new Error('L\'AI non ha fornito una traduzione valida');
      }
      
      setFormData(prev => ({
        ...prev,
        italian: aiData.italian || prev.italian,
        group: aiData.group || prev.group,
        sentence: aiData.sentence || prev.sentence,
        notes: aiData.notes || prev.notes,
        chapter: aiData.chapter || prev.chapter
        // learned e difficult rimangono invariati (non modificati dall'AI)
      }));

      setShowAdvancedForm(true);
      
      const availableGroups = getPredefinedGroups();
      if (aiData.group && !availableGroups.includes(aiData.group)) {
        showSuccess('✨ Dati compilati! (Categoria corretta automaticamente)');
      } else {
        showSuccess('✨ Dati compilati dall\'AI con successo!');
      }
      
    } catch (error) {
      console.error('AI Assist Error:', error);
      showError(error, 'AI Assistant');
    } finally {
      setIsAiLoading(false);
    }
  };

  const handleSubmit = () => {
    if (!formData.english.trim() || !formData.italian.trim()) {
      showWarning('⚠️ Parola inglese e traduzione sono obbligatorie!');
      return;
    }

    try {
      onAddWord({
        english: formData.english.trim(),
        italian: formData.italian.trim(),
        group: formData.group.trim() || null,
        sentence: formData.sentence.trim() || null,
        notes: formData.notes.trim() || null,
        chapter: formData.chapter.trim() || null,
        learned: formData.learned,
        difficult: formData.difficult // ⭐ NEW: Include difficult status
      });
      
      // Reset form sempre dopo salvataggio (sia nuova parola che modifica)
      setFormData({
        english: '',
        italian: '',
        group: '',
        sentence: '',
        notes: '',
        chapter: '',
        learned: false,
        difficult: false // ⭐ NEW: Reset difficult status
      });
      setShowAdvancedForm(false);
      
    } catch (error) {
      console.error('Error adding word:', error);
      showError(error, 'Add Word');
    }
  };

  const handleClear = () => {
    setFormData({
      english: '',
      italian: '',
      group: '',
      sentence: '',
      notes: '',
      chapter: '',
      learned: false,
      difficult: false // ⭐ NEW: Reset difficult status
    });
    setShowAdvancedForm(false);
    onClearForm();
  };

  const handleInputChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <Card data-form-section className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className={editingWord ? "bg-gradient-to-r from-blue-500 to-purple-600 text-white" : ""}>
        <CardTitle className={`flex items-center justify-between ${editingWord ? "text-white" : "text-gray-800"}`}>
          {editingWord ? (
            <div className="flex items-center gap-3">
              <Edit3 className="w-6 h-6" />
              <span>Modifica Parola: {editingWord.english}</span>
            </div>
          ) : (
            <div className="flex items-center gap-3">
              <Plus className="w-6 h-6 text-green-600" />
              <span className="bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent">
                Aggiungi Nuove Parole
              </span>
            </div>
          )}
          <div className="flex gap-2">
            {editingWord && (
              <Button 
                variant="ghost" 
                size="sm"
                onClick={handleClear}
                className="text-white hover:bg-white/20"
              >
                ✕ Annulla
              </Button>
            )}
            <Button 
              variant="ghost" 
              size="sm"
              onClick={() => setShowAdvancedForm(!showAdvancedForm)}
              className={editingWord ? "text-white hover:bg-white/20" : "text-gray-600 hover:bg-gray-100"}
            >
              {showAdvancedForm ? 'Forma Semplice' : 'Forma Avanzata'}
            </Button>
          </div>
        </CardTitle>
        {editingWord && (
          <div className="text-blue-100 bg-blue-600/20 p-3 rounded-xl mt-4">
            💡 Stai modificando la parola "<strong>{editingWord.english}</strong>". 
            Cambia i campi che vuoi aggiornare e clicca "Salva Modifiche".
          </div>
        )}
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Input
              placeholder="Parola inglese *"
              value={formData.english}
              onChange={(e) => handleInputChange('english', e.target.value)}
              className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors h-12"
              required
            />
            
            <Input
              placeholder="Traduzione italiana *"
              value={formData.italian}
              onChange={(e) => handleInputChange('italian', e.target.value)}
              className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors h-12"
              required
            />
          </div>

          {/* AI Assistant Button */}
          <Button
            onClick={handleAiAssist}
            disabled={isAiLoading || !formData.english.trim()}
            className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white py-4 text-lg rounded-xl shadow-lg transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
          >
            {isAiLoading ? (
              <>
                <Loader2 className="w-6 h-6 mr-3 animate-spin" />
                🤖 AI sta pensando...
              </>
            ) : (
              <>
                <Sparkles className="w-6 h-6 mr-3" />
                ✨ AI Assistant - Compila Automaticamente Tutti i Campi
              </>
            )}
          </Button>

          {/* AI Notice */}
          {formData.italian && !editingWord && (
            <div className="p-4 bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200 rounded-2xl">
              <div className="flex items-center gap-3">
                <Wand2 className="w-6 h-6 text-purple-600" />
                <p className="text-purple-800 font-medium">
                  💡 Usa l'AI Assistant per compilare automaticamente tutti i campi!
                </p>
              </div>
            </div>
          )}

          {/* Info sui nuovi campi */}
          {showAdvancedForm && (
            <div className="p-4 bg-gradient-to-r from-green-50 to-blue-50 border-2 border-green-200 rounded-2xl mb-4">
              <div className="flex items-center gap-3 mb-2">
                <span className="text-2xl">📚</span>
                <h4 className="font-bold text-green-800">Gestione Avanzata Vocabolario</h4>
              </div>
              <div className="text-sm text-green-700 space-y-1">
                <p>• <strong>Capitolo:</strong> Organizza le parole per capitoli del libro (es. 1, 2A, Unit 5)</p>
                <p>• <strong>Parola Appresa:</strong> Le parole apprese rimangono nel vocabolario ma vengono saltate nei test</p>
                <p>• <strong>Parola Difficile:</strong> ⭐ Marca le parole difficili per test specifici</p>
                <p>• <strong>Selezione Test:</strong> Potrai scegliere quali capitoli includere nei test</p>
              </div>
            </div>
          )}

          {showAdvancedForm && (
            <div className="space-y-6 p-6 bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl border-2 border-blue-200 animate-fade-in">
              <h4 className="font-bold text-blue-800 text-lg flex items-center gap-2">
                <span>📋</span> Informazioni Aggiuntive
              </h4>
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>📂</span> Gruppo/Categoria
                  </label>
                  <select
                    value={formData.group}
                    onChange={(e) => handleInputChange('group', e.target.value)}
                    className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors bg-white"
                  >
                    <option value="">Nessun gruppo</option>
                    {getPredefinedGroups().map(group => (
                      <option key={group} value={group}>
                        {getCategoryStyle(group).icon} {group}
                      </option>
                    ))}
                  </select>
                </div>
                
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>📖</span> Capitolo del libro
                  </label>
                  <Input
                    placeholder="es. 1, 2A, Unit 5..."
                    value={formData.chapter}
                    onChange={(e) => handleInputChange('chapter', e.target.value)}
                    className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                  />
                </div>

                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>🎓</span> Stato Parola
                  </label>
                  <div className="space-y-3">
                    <div className="flex items-center gap-3 p-3 border-2 border-gray-200 rounded-xl bg-white">
                      <label className="flex items-center gap-2 cursor-pointer">
                        <div 
                          onClick={() => handleInputChange('learned', !formData.learned)}
                          className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                            formData.learned 
                              ? 'bg-green-500 border-green-500 text-white' 
                              : 'border-gray-300 bg-white'
                          }`}
                        >
                          {formData.learned && <span className="text-sm">✓</span>}
                        </div>
                        <span className="text-sm font-medium text-gray-700">
                          Parola appresa
                        </span>
                      </label>
                    </div>
                    
                    {/* ⭐ NEW: Difficult flag */}
                    <div className="flex items-center gap-3 p-3 border-2 border-orange-200 rounded-xl bg-orange-50">
                      <label className="flex items-center gap-2 cursor-pointer">
                        <div 
                          onClick={() => handleInputChange('difficult', !formData.difficult)}
                          className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                            formData.difficult 
                              ? 'bg-orange-500 border-orange-500 text-white' 
                              : 'border-orange-300 bg-white'
                          }`}
                        >
                          {formData.difficult && <AlertTriangle className="w-4 h-4" />}
                        </div>
                        <span className="text-sm font-medium text-orange-700">
                          ⭐ Parola difficile
                        </span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>
              
              <div className="grid grid-cols-1 gap-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>💬</span> Frase d'esempio
                  </label>
                  <Input
                    placeholder="es. I love this beautiful song"
                    value={formData.sentence}
                    onChange={(e) => handleInputChange('sentence', e.target.value)}
                    className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                  <span>📝</span> Note aggiuntive
                </label>
                <Textarea
                  placeholder="Altri significati, sinonimi, forme irregolari..."
                  value={formData.notes}
                  onChange={(e) => handleInputChange('notes', e.target.value)}
                  rows={4}
                  className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                />
              </div>
            </div>
          )}

          <Button 
            onClick={handleSubmit}
            className={`w-full py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 ${
              editingWord 
                ? 'bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700' 
                : 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600'
            } text-white`}
          >
            {editingWord ? (
              <>
                <Check className="w-5 h-5 mr-2" />
                Salva Modifiche
              </>
            ) : (
              <>
                <Plus className="w-5 h-5 mr-2" />
                Aggiungi Parola
              </>
            )}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default AddWordForm;

================================================================================

NOME FILE: components\AppRouter.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import { MainView } from '../views/MainView';
import { TestView } from '../views/TestView';
import { ResultsView } from '../views/ResultsView';
import { StatsView } from '../views/StatsView';
import { StatsManagerView } from '../views/StatsManagerView';

export const AppRouter = () => {
  const { currentView, testMode, showResults } = useAppContext();

  // Test in corso
  if (testMode) {
    return <TestView />;
  }

  // Risultati test
  if (showResults) {
    return <ResultsView />;
  }

  // Viste principali
  switch (currentView) {
    case 'stats':
      return <StatsView />;
    case 'stats-manager':
      return <StatsManagerView />;
    case 'main':
    default:
      return <MainView />;
  }
};


================================================================================

NOME FILE: components\ErrorBoundary.js

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { AlertTriangle, RefreshCw } from 'lucide-react';

export class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error,
      errorInfo
    });
    
    if (process.env.NODE_ENV === 'development') {
      console.error('ErrorBoundary caught an error:', error, errorInfo);
    }
    
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', 'exception', {
        description: error.toString(),
        fatal: true
      });
    }
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen bg-gradient-to-br from-red-50 via-white to-pink-50 flex items-center justify-center p-6">
          <Card className="max-w-lg w-full bg-white/90 backdrop-blur-sm border-0 shadow-2xl rounded-3xl overflow-hidden">
            <CardHeader className="bg-gradient-to-r from-red-500 to-pink-500 text-white text-center py-8">
              <div className="text-6xl mb-4">
                <AlertTriangle className="w-16 h-16 mx-auto" />
              </div>
              <CardTitle className="text-2xl font-bold text-white">
                Oops! Qualcosa è andato storto
              </CardTitle>
              <p className="text-red-100 mt-2">
                Si è verificato un errore imprevisto nell'applicazione
              </p>
            </CardHeader>
            <CardContent className="p-8 text-center">
              <div className="space-y-6">
                <p className="text-gray-600">
                  Non preoccuparti, i tuoi dati sono al sicuro. 
                  Prova a ricaricare la pagina o contatta il supporto se il problema persiste.
                </p>
                
                <div className="flex gap-4 justify-center">
                  <Button 
                    onClick={this.handleReset}
                    className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-6 py-3 rounded-xl"
                  >
                    <RefreshCw className="w-4 h-4 mr-2" />
                    Riprova
                  </Button>
                  
                  <Button 
                    onClick={() => window.location.reload()}
                    variant="outline"
                    className="px-6 py-3 rounded-xl"
                  >
                    Ricarica Pagina
                  </Button>
                </div>
                
                {process.env.NODE_ENV === 'development' && this.state.error && (
                  <details className="mt-6 text-left">
                    <summary className="cursor-pointer text-red-600 font-medium">
                      Dettagli Errore (Dev Mode)
                    </summary>
                    <pre className="mt-2 p-4 bg-gray-100 rounded-lg text-xs overflow-auto max-h-40">
                      {this.state.error.toString()}
                      {this.state.errorInfo.componentStack}
                    </pre>
                  </details>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}

================================================================================

NOME FILE: components\JSONManager.js

// =====================================================
// 📁 src/components/JSONManager.js - SOSTITUISCE il file esistente
// =====================================================
import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Textarea } from './ui/textarea';
import { FileDown, ChevronDown, ChevronUp } from 'lucide-react';
import { useNotification } from '../contexts/NotificationContext';

const JSONManager = ({ words, onImportWords }) => {
  const [jsonText, setJsonText] = useState('');
  const [showSection, setShowSection] = useState(false);

  // ⭐ AGGIORNATO: Usa il context invece della prop
  const { showSuccess, showError, showWarning } = useNotification();

  const handleExport = () => {
    if (words.length === 0) {
      // ⭐ AGGIORNATO: Usa showWarning dal context
      showWarning('⚠️ Nessuna parola da esportare!');
      return;
    }

    try {
      const dataStr = JSON.stringify(words, null, 2);
      setJsonText(dataStr);
      setShowSection(true);
      // ⭐ AGGIORNATO: Usa showSuccess dal context
      showSuccess('✅ Parole esportate con successo!');
    } catch (error) {
      console.error('Error exporting words:', error);
      // ⭐ AGGIORNATO: Usa showError dal context per gestione centralizzata
      showError(error, 'Export JSON');
    }
  };

  const handleImport = () => {
    if (!jsonText.trim()) {
      // ⭐ AGGIORNATO: Usa showWarning dal context
      showWarning('⚠️ Inserisci del JSON da importare!');
      return;
    }

    try {
      const newWordsCount = onImportWords(jsonText.trim());
      setJsonText('');
      // ⭐ AGGIORNATO: Usa showSuccess dal context
      showSuccess(`✅ ${newWordsCount} parole importate con successo!`);
    } catch (error) {
      console.error('Error importing words:', error);
      
      // ⭐ AGGIORNATO: Gestione errori migliorata con context
      const errorMessage = error.message.includes('JSON') ? 
        '❌ JSON non valido! Controlla la sintassi.' : 
        `❌ ${error.message}`;
      
      // Usa showError per errori gravi, showWarning per problemi di formato
      if (error.message.includes('JSON') || error.message.includes('Invalid')) {
        showWarning(errorMessage);
      } else {
        showError(error, 'Import JSON');
      }
    }
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader 
        className="cursor-pointer hover:bg-gray-50 transition-colors" 
        onClick={() => setShowSection(!showSection)}
      >
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <FileDown className="w-6 h-6 text-indigo-600" />
            <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
              Gestione Dati JSON
            </span>
          </div>
          {showSection ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
        </CardTitle>
      </CardHeader>
      {showSection && (
        <CardContent className="animate-fade-in">
          <div className="space-y-4">
            <div className="p-4 bg-blue-50 rounded-2xl border border-blue-200">
              <p className="text-blue-800 text-sm flex items-center gap-2">
                <span className="text-lg">💡</span>
                Usa questa sezione per fare backup del tuo vocabolario o condividerlo tra dispositivi
              </p>
            </div>
            
            <div className="flex gap-2">
              <Button 
                onClick={handleExport} 
                variant="outline" 
                disabled={words.length === 0}
                className="border-2 border-blue-300 hover:border-blue-400 bg-blue-50 hover:bg-blue-100 text-blue-600"
              >
                📤 Esporta JSON
              </Button>
              <Button 
                onClick={handleImport} 
                variant="outline"
                className="border-2 border-purple-300 hover:border-purple-400 bg-purple-50 hover:bg-purple-100 text-purple-600"
              >
                📥 Importa JSON
              </Button>
            </div>
            
            <Textarea
              placeholder="Il JSON delle parole apparirà qui dopo 'Esporta JSON', oppure incolla qui il JSON da importare..."
              value={jsonText}
              onChange={(e) => setJsonText(e.target.value)}
              rows={12}
              className="font-mono text-sm border-2 border-gray-200 rounded-2xl focus:border-blue-500 transition-colors"
            />
            
            {/* ⭐ AGGIUNTO: Info sui formati supportati */}
            {jsonText && (
              <div className="p-3 bg-green-50 border border-green-200 rounded-xl">
                <p className="text-green-800 text-sm">
                  💾 <strong>Formato rilevato:</strong> {
                    (() => {
                      try {
                        const parsed = JSON.parse(jsonText);
                        const isArray = Array.isArray(parsed);
                        const hasWords = isArray && parsed.length > 0;
                        const firstItem = hasWords ? parsed[0] : null;
                        const hasEnglishItalian = firstItem && firstItem.english && firstItem.italian;
                        
                        if (hasEnglishItalian) {
                          return `Array di ${parsed.length} parole (✅ Formato valido)`;
                        } else if (isArray) {
                          return `Array con ${parsed.length} elementi (⚠️ Verificare formato)`;
                        } else {
                          return 'Oggetto JSON (⚠️ Array richiesto)';
                        }
                      } catch {
                        return 'JSON non valido (❌ Errore sintassi)';
                      }
                    })()
                  }
                </p>
              </div>
            )}
          </div>
        </CardContent>
      )}
    </Card>
  );
};

export default JSONManager;

================================================================================

NOME FILE: components\StatsManager.css

/* components/StatsManager.css */

.stats-manager {
  max-width: 1000px;
  margin: 0 auto;
  padding: 2rem;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.stats-manager__header {
  text-align: center;
  margin-bottom: 2rem;
}

.stats-manager__header h2 {
  color: #2c3e50;
  margin-bottom: 0.5rem;
  font-size: 2.2rem;
}

.stats-manager__header p {
  color: #7f8c8d;
  font-size: 1.1rem;
}

/* Riepilogo Statistiche */
.stats-summary {
  margin-bottom: 2rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.stat-card {
  background: linear-gradient(145deg, #ffffff, #f8f9fa);
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 1.5rem;
  display: flex;
  align-items: center;
  gap: 1rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.stat-icon {
  font-size: 2rem;
  line-height: 1;
}

.stat-content h3 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: bold;
  color: #2c3e50;
}

.stat-content p {
  margin: 0;
  color: #7f8c8d;
  font-size: 0.9rem;
  font-weight: 500;
}

/* Dettagli Statistiche */
.stats-details {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
  margin-bottom: 3rem;
}

.detail-section {
  background: #f8f9fa;
  border-radius: 8px;
  padding: 1.5rem;
  border-left: 4px solid #3498db;
}

.detail-section h4 {
  margin: 0 0 1rem 0;
  color: #2c3e50;
  font-size: 1.2rem;
}

.detail-section p {
  margin: 0.5rem 0;
  color: #5a6c7d;
}

.detail-section strong {
  color: #2c3e50;
  font-weight: 600;
}

/* Progresso Categorie */
.category-progress {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 0.8rem;
}

.category-name {
  min-width: 100px;
  font-weight: 500;
  color: #2c3e50;
  font-size: 0.9rem;
}

.progress-bar {
  flex: 1;
  height: 8px;
  background: #e9ecef;
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #3498db, #2ecc71);
  border-radius: 4px;
  transition: width 0.3s ease;
}

.progress-text {
  font-size: 0.8rem;
  color: #7f8c8d;
  font-weight: 500;
  min-width: 80px;
  text-align: right;
}

/* Azioni di Gestione */
.stats-actions {
  display: grid;
  gap: 2rem;
}

.action-section {
  background: #ffffff;
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.action-section h3 {
  margin: 0 0 0.5rem 0;
  color: #2c3e50;
  font-size: 1.3rem;
}

.action-section p {
  margin: 0 0 1.5rem 0;
  color: #7f8c8d;
}

.action-buttons {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

/* Pulsanti */
.btn {
  padding: 0.8rem 1.5rem;
  border: none;
  border-radius: 8px;
  font-size: 0.95rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  text-decoration: none;
  min-width: 150px;
  justify-content: center;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-primary {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);
}

.btn-primary:hover:not(:disabled) {
  background: linear-gradient(145deg, #2980b9, #21618c);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
}

.btn-secondary {
  background: linear-gradient(145deg, #95a5a6, #7f8c8d);
  color: white;
  box-shadow: 0 2px 10px rgba(149, 165, 166, 0.3);
}

.btn-secondary:hover:not(:disabled) {
  background: linear-gradient(145deg, #7f8c8d, #6c7b7d);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(149, 165, 166, 0.4);
}

.btn-danger {
  background: linear-gradient(145deg, #e74c3c, #c0392b);
  color: white;
  box-shadow: 0 2px 10px rgba(231, 76, 60, 0.3);
}

.btn-danger:hover:not(:disabled) {
  background: linear-gradient(145deg, #c0392b, #a93226);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
}

/* Zona Pericolosa */
.danger-zone {
  border-color: #e74c3c !important;
  border-left: 4px solid #e74c3c !important;
  background: linear-gradient(145deg, #fff5f5, #ffffff) !important;
}

.danger-zone h3 {
  color: #e74c3c !important;
}

/* Informazioni sul Formato */
.format-info {
  margin-top: 2rem;
  background: #f8f9fa;
  border-radius: 8px;
  overflow: hidden;
}

.format-info details {
  cursor: pointer;
}

.format-info summary {
  padding: 1rem 1.5rem;
  background: #e9ecef;
  font-weight: 500;
  color: #2c3e50;
  border: none;
  outline: none;
  user-select: none;
  transition: background 0.2s ease;
}

.format-info summary:hover {
  background: #dee2e6;
}

.format-info summary::-webkit-details-marker {
  display: none;
}

.format-info summary::before {
  content: '▶';
  margin-right: 0.5rem;
  transition: transform 0.2s ease;
}

.format-info[open] summary::before {
  transform: rotate(90deg);
}

.format-content {
  padding: 1.5rem;
}

.format-content ul {
  margin: 1rem 0;
  padding-left: 1.5rem;
}

.format-content li {
  margin: 0.5rem 0;
  color: #5a6c7d;
}

/* Responsive Design */
@media (max-width: 768px) {
  .stats-manager {
    padding: 1rem;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .stats-details {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .action-buttons {
    flex-direction: column;
  }
  
  .btn {
    width: 100%;
    min-width: auto;
  }
  
  .category-progress {
    flex-direction: column;
    align-items: stretch;
    gap: 0.5rem;
  }
  
  .category-name {
    min-width: auto;
    text-align: center;
  }
  
  .progress-text {
    text-align: center;
    min-width: auto;
  }
}

@media (max-width: 480px) {
  .stats-manager__header h2 {
    font-size: 1.8rem;
  }
  
  .stats-manager__header p {
    font-size: 1rem;
  }
  
  .stat-card {
    padding: 1rem;
  }
  
  .stat-content h3 {
    font-size: 1.5rem;
  }
  
  .detail-section {
    padding: 1rem;
  }
  
  .action-section {
    padding: 1.5rem;
  }
}

/* Animazioni */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.stats-manager > * {
  animation: slideIn 0.3s ease-out;
}

.stats-manager > *:nth-child(2) {
  animation-delay: 0.1s;
}

.stats-manager > *:nth-child(3) {
  animation-delay: 0.2s;
}

.stats-manager > *:nth-child(4) {
  animation-delay: 0.3s;
}

================================================================================

NOME FILE: components\StatsManager.js

// components/StatsManager.js - Versione Sincronizzata - HOOK CORRETTO
import React, { useState, useRef, useEffect } from 'react';
import { useOptimizedStats } from '../hooks/useOptimizedStats'; // ✅ Fixed: correct hook name
import './StatsManager.css';

/**
 * ⭐ VERSIONE MIGLIORATA: Gestione completa con sincronizzazione automatica
 * - Import/Export unificato di statistiche + cronologia
 * - Cancellazione sincronizzata
 * - Aggiornamento UI automatico
 * - Gestione errori robusta
 */
const StatsManager = ({ onDataUpdated, forceUpdate }) => {
  const { 
    stats, 
    testHistory,
    calculatedStats, 
    exportStats, 
    importStats, 
    resetStats, 
    clearHistoryOnly,
    forceMigration, 
    isMigrated,
    refreshData,
    isProcessing
  } = useOptimizedStats(); // ✅ Fixed: using correct hook name

  const [isImporting, setIsImporting] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const fileInputRef = useRef(null);

  // ⭐ NUOVO: Effetto per aggiornare l'UI quando cambiano i dati
  useEffect(() => {
    if (onDataUpdated) {
      onDataUpdated();
    }
  }, [stats.testsCompleted, testHistory.length, forceUpdate, onDataUpdated]);

  // ⭐ MIGLIORATO: Export con feedback visivo
  const handleExport = async () => {
    if (isExporting || isProcessing) return;
    
    try {
      setIsExporting(true);
      await new Promise(resolve => setTimeout(resolve, 100)); // Small delay per UI feedback
      exportStats();
    } catch (error) {
      console.error('❌ Errore export:', error);
    } finally {
      setIsExporting(false);
    }
  };

  const handleImportClick = () => {
    if (isImporting || isProcessing) return;
    fileInputRef.current?.click();
  };

  // ⭐ MIGLIORATO: Import con sincronizzazione automatica
  const handleFileSelect = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (file.type !== 'application/json') {
      alert('Per favore seleziona un file JSON valido');
      return;
    }

    if (isImporting || isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    setIsImporting(true);
    
    try {
      console.log('🔄 Inizio importazione file:', file.name);
      
      // Importa i dati
      const result = await importStats(file);
      
      console.log('✅ Importazione completata:', result);
      
      // ⭐ SINCRONIZZAZIONE AUTOMATICA: Refresh multipli per garantire aggiornamento UI
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
        
        // Secondo refresh per sicurezza
        setTimeout(() => {
          refreshData();
          if (onDataUpdated) onDataUpdated();
        }, 300);
      }, 200);
      
    } catch (error) {
      console.error('❌ Errore importazione:', error);
      alert(`Errore durante l'importazione: ${error.message}`);
    } finally {
      setIsImporting(false);
      // Reset input per permettere di selezionare lo stesso file
      event.target.value = '';
    }
  };

  // ⭐ MIGLIORATO: Migrazione forzata con refresh
  const handleForceMigration = async () => {
    if (isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    try {
      console.log('🔄 Inizio migrazione forzata...');
      await forceMigration();
      
      // ⭐ REFRESH AUTOMATICO
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
      }, 300);
      
    } catch (error) {
      console.error('❌ Errore migrazione:', error);
      alert(`Errore durante la migrazione: ${error.message}`);
    }
  };

  // ⭐ MIGLIORATO: Reset completo con conferma avanzata
  const handleReset = async () => {
    if (isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    const confirmation = window.confirm(
      `⚠️ ATTENZIONE: Conferma cancellazione completa\n\n` +
      `Verranno cancellati:\n` +
      `• ${stats.testsCompleted} test dalle statistiche\n` +
      `• ${testHistory.length} test dalla cronologia\n` +
      `• Tutti i progressi e dati di apprendimento\n\n` +
      `Questa operazione è IRREVERSIBILE.\n\n` +
      `Sei assolutamente sicuro di voler procedere?`
    );

    if (!confirmation) return;

    // Doppia conferma per sicurezza
    const doubleConfirmation = window.confirm(
      '🚨 ULTIMA CONFERMA\n\n' +
      'Stai per ELIMINARE DEFINITIVAMENTE tutti i tuoi dati.\n' +
      'Non sarà possibile recuperarli.\n\n' +
      'Procedi con la cancellazione completa?'
    );

    if (!doubleConfirmation) return;

    try {
      console.log('🗑️ Inizio reset completo...');
      await resetStats();
      
      // ⭐ REFRESH AUTOMATICO
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
      }, 200);
      
    } catch (error) {
      console.error('❌ Errore reset:', error);
      alert(`Errore durante il reset: ${error.message}`);
    }
  };

  // ⭐ NUOVO: Cancella solo cronologia
  const handleClearHistoryOnly = async () => {
    if (isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    const confirmation = window.confirm(
      `Vuoi cancellare solo la cronologia dei test?\n\n` +
      `Verranno cancellati ${testHistory.length} test dalla cronologia.\n` +
      `Le statistiche rimarranno invariate.\n\n` +
      `Continuare?`
    );

    if (!confirmation) return;

    try {
      console.log('🗑️ Cancellazione cronologia...');
      await clearHistoryOnly();
      
      // ⭐ REFRESH AUTOMATICO
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
      }, 200);
      
    } catch (error) {
      console.error('❌ Errore cancellazione cronologia:', error);
      alert(`Errore durante la cancellazione: ${error.message}`);
    }
  };

  const formatTime = (minutes) => {
    if (minutes < 60) return `${minutes}m`;
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return `${hours}h ${remainingMinutes}m`;
  };

  const formatDate = (dateString) => {
    if (!dateString) return 'Mai';
    return new Date(dateString).toLocaleDateString('it-IT');
  };

  return (
    <div className="stats-manager">
      <div className="stats-manager__header">
        <h2>📊 Gestione Statistiche Centralizzata</h2>
        <p>Esporta, importa o gestisci le tue statistiche e cronologia in modo sincronizzato</p>
        {isProcessing && (
          <div className="processing-indicator" style={{
            background: '#e3f2fd',
            border: '1px solid #2196f3',
            borderRadius: '8px',
            padding: '1rem',
            marginTop: '1rem',
            color: '#1976d2'
          }}>
            ⏳ <strong>Operazione in corso...</strong> Attendere il completamento.
          </div>
        )}
      </div>

      {/* ⭐ AGGIORNATO: Riepilogo con dati real-time */}
      <div className="stats-summary">
        <div className="stats-grid">
          <div className="stat-card">
            <div className="stat-icon">🎯</div>
            <div className="stat-content">
              <h3>{stats.testsCompleted}</h3>
              <p>Test Statistiche</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">📅</div>
            <div className="stat-content">
              <h3>{testHistory.length}</h3>
              <p>Test Cronologia</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">📈</div>
            <div className="stat-content">
              <h3>{calculatedStats.accuracyRate}%</h3>
              <p>Precisione Media</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">🔥</div>
            <div className="stat-content">
              <h3>{stats.streakDays}</h3>
              <p>Giorni Streak</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">⏱️</div>
            <div className="stat-content">
              <h3>{formatTime(stats.timeSpent)}</h3>
              <p>Tempo Totale</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">✅</div>
            <div className="stat-content">
              <h3>{isMigrated ? 'Sync' : 'No'}</h3>
              <p>Stato Sincr.</p>
            </div>
          </div>
        </div>
      </div>

      {/* ⭐ AGGIORNATO: Dettagli con stato sincronizzazione */}
      <div className="stats-details">
        <div className="detail-section">
          <h4>📚 Vocabolario</h4>
          <p>Parole totali: <strong>{stats.totalWords}</strong></p>
          <p>Risposte corrette: <strong>{stats.correctAnswers}</strong></p>
          <p>Risposte sbagliate: <strong>{stats.incorrectAnswers}</strong></p>
        </div>

        <div className="detail-section">
          <h4>📅 Attività</h4>
          <p>Ultimo studio: <strong>{formatDate(stats.lastStudyDate)}</strong></p>
          <p>Tempo medio per test: <strong>{calculatedStats.avgTimePerTest}m</strong></p>
          <p>Attivo oggi: <strong>{calculatedStats.isActiveToday ? '✅ Sì' : '❌ No'}</strong></p>
        </div>

        <div className="detail-section">
          <h4>🔄 Sincronizzazione</h4>
          <p>Statistiche: <strong>{stats.testsCompleted} test</strong></p>
          <p>Cronologia: <strong>{testHistory.length} test</strong></p>
          <p>Stato: <strong>{isMigrated ? '✅ Sincronizzato' : '⏳ In attesa'}</strong></p>
          <p>Processing: <strong>{isProcessing ? '🔄 Attivo' : '✅ Pronto'}</strong></p>
        </div>

        {Object.keys(stats.categoriesProgress).length > 0 && (
          <div className="detail-section">
            <h4>🏷️ Progresso per Categoria</h4>
            {Object.entries(stats.categoriesProgress).map(([category, progress]) => (
              <div key={category} className="category-progress">
                <span className="category-name">{category}</span>
                <div className="progress-bar">
                  <div 
                    className="progress-fill"
                    style={{ 
                      width: `${progress.total > 0 ? (progress.correct / progress.total) * 100 : 0}%` 
                    }}
                  ></div>
                </div>
                <span className="progress-text">
                  {progress.correct}/{progress.total} ({progress.total > 0 ? Math.round((progress.correct / progress.total) * 100) : 0}%)
                </span>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* ⭐ MIGLIORATO: Azioni con stato sincronizzazione */}
      <div className="stats-actions">
        <div className="action-section">
          <h3>💾 Backup Completo Sincronizzato</h3>
          <p>Esporta o importa TUTTO in modo sincronizzato: statistiche + cronologia completa</p>
          
          <div className="action-buttons">
            <button 
              className={`btn btn-primary ${isExporting || isProcessing ? 'loading' : ''}`}
              onClick={handleExport}
              disabled={isExporting || isProcessing}
              title="Scarica backup completo: statistiche + cronologia"
            >
              {isExporting ? '⏳ Esportando...' : '📥 Esporta Backup Completo'}
            </button>
            
            <button 
              className={`btn btn-secondary ${isImporting || isProcessing ? 'loading' : ''}`}
              onClick={handleImportClick}
              disabled={isImporting || isProcessing}
              title="Carica backup completo con sincronizzazione automatica"
            >
              {isImporting ? '⏳ Importando...' : '📤 Importa Backup'}
            </button>
            
            <input
              ref={fileInputRef}
              type="file"
              accept=".json"
              onChange={handleFileSelect}
              style={{ display: 'none' }}
            />
          </div>
          
          <div className="format-content" style={{ 
            marginTop: '1rem', 
            padding: '1rem', 
            background: '#e8f5e8', 
            borderRadius: '8px' 
          }}>
            <p style={{ margin: 0, fontSize: '0.9rem', color: '#2d5d2d' }}>
              💡 <strong>Backup v2.0 Sincronizzato:</strong> Include {stats.testsCompleted} statistiche + {testHistory.length} cronologia
              {!isMigrated && <span style={{ color: '#d32f2f' }}> (⚠️ Non sincronizzato)</span>}
            </p>
          </div>
        </div>

        {/* ⭐ NUOVO: Sezione Sincronizzazione Avanzata */}
        <div className="action-section">
          <h3>🔄 Sincronizzazione Dati</h3>
          <p>Gestisci la sincronizzazione tra statistiche e cronologia test</p>
          
          <div className="action-buttons">
            <button 
              className={`btn btn-secondary ${isProcessing ? 'loading' : ''}`}
              onClick={handleForceMigration}
              disabled={isProcessing}
              title="Ri-sincronizza i dati dalla cronologia test esistente"
            >
              {isProcessing ? '⏳ Migrando...' : '🔄 Forza Sincronizzazione'}
            </button>
            
            <button 
              className={`btn btn-secondary ${isProcessing ? 'loading' : ''}`}
              onClick={() => {
                refreshData();
                if (onDataUpdated) onDataUpdated();
              }}
              disabled={isProcessing}
              title="Aggiorna manualmente l'interfaccia"
            >
              🔃 Refresh Interface
            </button>
          </div>
          
          <div className="format-content" style={{ 
            marginTop: '1rem', 
            padding: '1rem', 
            background: isMigrated ? '#e8f5e8' : '#fff3e0', 
            borderRadius: '8px' 
          }}>
            <p style={{ margin: 0, fontSize: '0.9rem', color: isMigrated ? '#2d5d2d' : '#e65100' }}>
              {isMigrated 
                ? '✅ Dati sincronizzati correttamente' 
                : '⚠️ Sincronizzazione richiesta - usa "Forza Sincronizzazione"'
              }
            </p>
          </div>
        </div>

        {/* ⭐ MIGLIORATO: Cancellazioni con opzioni separate */}
        <div className="action-section danger-zone">
          <h3>⚠️ Zona Pericolosa</h3>
          <p>Attenzione: queste azioni sono irreversibili</p>
          
          <div className="action-buttons">
            <button 
              className={`btn btn-danger ${isProcessing ? 'loading' : ''}`}
              onClick={handleClearHistoryOnly}
              disabled={isProcessing}
              title="Cancella solo la cronologia (mantiene statistiche)"
            >
              {isProcessing ? '⏳ Cancellando...' : '🗑️ Cancella Solo Cronologia'}
            </button>
            
            <button 
              className={`btn btn-danger ${isProcessing ? 'loading' : ''}`}
              onClick={handleReset}
              disabled={isProcessing}
              title="Cancella tutto: statistiche + cronologia (irreversibile)"
            >
              {isProcessing ? '⏳ Resettando...' : '🗑️ Reset Completo'}
            </button>
          </div>
          
          <div className="format-content" style={{ 
            marginTop: '1rem', 
            padding: '1rem', 
            background: '#ffebee', 
            borderRadius: '8px',
            border: '1px solid #f44336'
          }}>
            <p style={{ margin: 0, fontSize: '0.9rem', color: '#c62828' }}>
              ⚠️ <strong>Attenzione:</strong> Le operazioni di cancellazione sono permanenti e non possono essere annullate.
              Assicurati di aver fatto un backup prima di procedere.
            </p>
          </div>
        </div>
      </div>

      {/* ⭐ AGGIORNATO: Informazioni sul formato con stato sincronizzazione */}
      <div className="format-info">
        <details>
          <summary>ℹ️ Informazioni sul Sistema Sincronizzato</summary>
          <div className="format-content">
            <p><strong>🎯 Sistema Unificato v2.0 - Sincronizzazione Automatica</strong></p>
            <p>Il sistema gestisce automaticamente:</p>
            <ul>
              <li>📊 <strong>Statistiche Avanzate:</strong> Precisione, streak, tempo, categorie ({stats.testsCompleted} test)</li>
              <li>📅 <strong>Cronologia Completa:</strong> Tutti i test con dettagli ({testHistory.length} test)</li>
              <li>🔄 <strong>Sincronizzazione:</strong> Aggiornamento automatico dell'interfaccia</li>
              <li>⚡ <strong>Performance:</strong> Operazioni ottimizzate e feedback in tempo reale</li>
              <li>🛡️ <strong>Sicurezza:</strong> Validazione dati e conferme multiple</li>
            </ul>
            
            <div style={{ background: '#f0f8ff', padding: '1rem', borderRadius: '8px', marginTop: '1rem' }}>
              <p style={{ margin: 0, fontSize: '0.9rem' }}>
                <strong>🔄 Stato Sincronizzazione Attuale:</strong><br/>
                ✅ Statistiche: {stats.testsCompleted} test<br/>
                ✅ Cronologia: {testHistory.length} test<br/>
                {isMigrated ? '✅ Sincronizzato' : '⚠️ Richiede sincronizzazione'}<br/>
                {isProcessing ? '🔄 Operazione in corso...' : '✅ Sistema pronto'}
              </p>
            </div>
            
            <div style={{ background: '#e8f5e8', padding: '1rem', borderRadius: '8px', marginTop: '1rem' }}>
              <p style={{ margin: 0, fontSize: '0.9rem' }}>
                <strong>🛡️ Sicurezza e Backup:</strong><br/>
                • Tutti i dati vengono validati durante import/export<br/>
                • Conferme multiple per operazioni distruttive<br/>
                • Backup automatico prima di operazioni critiche<br/>
                • Possibilità di combinare o sostituire dati esistenti
              </p>
            </div>
          </div>
        </details>
      </div>
    </div>
  );
};

export default StatsManager;

================================================================================

NOME FILE: components\StatsOverview.js

// /src/components/StatsOverview.js - Enhanced con word performance tracking
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, BarChart, Bar, ScatterPlot, Scatter, ReferenceLine } from 'recharts';
import { BarChart3, TrendingUp, Trophy, Sparkles, Play, BookOpen, Target, Award, Calendar, Filter, Search, AlertTriangle, CheckCircle, Clock, Lightbulb } from 'lucide-react';
import { useAppContext } from '../contexts/AppContext';

const StatsOverview = ({ testHistory, words, onClearHistory, onGoToMain, forceUpdate }) => {
  const [selectedView, setSelectedView] = useState('overview');
  const [selectedChapter, setSelectedChapter] = useState('all');
  const [searchWord, setSearchWord] = useState('');
  const [selectedWordId, setSelectedWordId] = useState(null);
  
  // ⭐ NEW: Get word performance from context
  const { getAllWordsPerformance, getWordAnalysis } = useAppContext();
  
  const [localRefresh, setLocalRefresh] = useState(0);

  useEffect(() => {
    setLocalRefresh(prev => prev + 1);
  }, [testHistory.length, forceUpdate]);

  // ⭐ ENHANCED: Advanced stats with hints
  const getAdvancedStats = React.useMemo(() => {
    if (testHistory.length === 0) {
      return {
        totalTests: 0,
        averageScore: 0,
        bestScore: 0,
        worstScore: 0,
        totalWordsStudied: 0,
        totalCorrect: 0,
        totalIncorrect: 0,
        totalHints: 0, // ⭐ NEW
        hintsPercentage: 0, // ⭐ NEW
        chaptersAnalyzed: 0,
        testTypeDistribution: {},
        difficultyDistribution: {},
        improvementTrend: 0,
        lastWeekTests: 0,
        chapterPerformance: {}
      };
    }

    const totalTests = testHistory.length;
    const totalCorrect = testHistory.reduce((sum, test) => sum + (test.correctWords || 0), 0);
    const totalIncorrect = testHistory.reduce((sum, test) => sum + (test.incorrectWords || 0), 0);
    const totalHints = testHistory.reduce((sum, test) => sum + (test.hintsUsed || 0), 0); // ⭐ NEW
    const totalWordsStudied = totalCorrect + totalIncorrect;
    const hintsPercentage = totalWordsStudied > 0 ? Math.round((totalHints / totalWordsStudied) * 100) : 0; // ⭐ NEW
    const averageScore = Math.round(testHistory.reduce((sum, test) => sum + (test.percentage || 0), 0) / totalTests);
    const bestScore = Math.max(...testHistory.map(test => test.percentage || 0));
    const worstScore = Math.min(...testHistory.map(test => test.percentage || 100));

    // Performance per capitolo con hints
    const chapterPerformance = {};
    testHistory.forEach(test => {
      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, stats]) => {
          if (!chapterPerformance[chapter]) {
            chapterPerformance[chapter] = {
              totalTests: 0,
              totalWords: 0,
              totalCorrect: 0,
              totalIncorrect: 0,
              totalHints: 0, // ⭐ NEW
              averagePercentage: 0,
              bestPercentage: 0,
              worstPercentage: 100,
              hintsPercentage: 0 // ⭐ NEW
            };
          }
          
          const perf = chapterPerformance[chapter];
          perf.totalTests += 1;
          perf.totalWords += stats.totalWords || 0;
          perf.totalCorrect += stats.correctWords || 0;
          perf.totalIncorrect += stats.incorrectWords || 0;
          perf.totalHints += stats.hintsUsed || 0; // ⭐ NEW
          perf.bestPercentage = Math.max(perf.bestPercentage, stats.percentage || 0);
          perf.worstPercentage = Math.min(perf.worstPercentage, stats.percentage || 100);
        });
      }
    });

    // Calcola percentuali medie per capitolo
    Object.keys(chapterPerformance).forEach(chapter => {
      const perf = chapterPerformance[chapter];
      perf.averagePercentage = perf.totalWords > 0 ? Math.round((perf.totalCorrect / perf.totalWords) * 100) : 0;
      perf.hintsPercentage = perf.totalWords > 0 ? Math.round((perf.totalHints / perf.totalWords) * 100) : 0; // ⭐ NEW
    });

    return {
      totalTests,
      averageScore,
      bestScore,
      worstScore,
      totalWordsStudied,
      totalCorrect,
      totalIncorrect,
      totalHints, // ⭐ NEW
      hintsPercentage, // ⭐ NEW
      chaptersAnalyzed: Object.keys(chapterPerformance).length,
      testTypeDistribution: {},
      difficultyDistribution: {},
      improvementTrend: 0,
      lastWeekTests: 0,
      chapterPerformance
    };
  }, [testHistory]);

  // ⭐ ENHANCED: Timeline with hints and timing
  const getTimelineData = React.useMemo(() => {
    const data = [...testHistory].reverse().slice(-20).map((test, index) => ({
      test: `Test ${index + 1}`,
      percentage: test.percentage || 0,
      correct: test.correctWords || 0,
      incorrect: test.incorrectWords || 0,
      hints: test.hintsUsed || 0, // ⭐ NEW
      avgTime: test.avgTimePerWord || 0, // ⭐ NEW
      date: new Date(test.timestamp).toLocaleDateString('it-IT'),
      time: new Date(test.timestamp).toLocaleTimeString('it-IT', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      chapters: test.testParameters?.selectedChapters?.length || 0,
      difficulty: test.difficulty || 'medium',
      type: test.testType || 'unknown'
    }));
    
    return data;
  }, [testHistory]);

  // ⭐ NEW: Chapter performance with better visualization
  const getChapterComparisonData = React.useMemo(() => {
    return Object.entries(getAdvancedStats.chapterPerformance).map(([chapter, perf]) => ({
      chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`,
      fullChapter: chapter,
      accuracy: perf.averagePercentage,
      tests: perf.totalTests,
      words: perf.totalWords,
      hints: perf.hintsPercentage, // ⭐ NEW: Hints percentage
      efficiency: Math.max(0, perf.averagePercentage - perf.hintsPercentage), // ⭐ NEW: Performance without hints
      trend: perf.bestPercentage - perf.worstPercentage // ⭐ NEW: Improvement range
    })).sort((a, b) => b.accuracy - a.accuracy);
  }, [getAdvancedStats]);

  // ⭐ NEW: Word performance data
  const getWordPerformanceData = React.useMemo(() => {
    if (!getAllWordsPerformance) return [];
    
    const wordsPerformance = getAllWordsPerformance();
    return wordsPerformance.filter(word => {
      if (searchWord && !word.english.toLowerCase().includes(searchWord.toLowerCase())) {
        return false;
      }
      if (selectedChapter !== 'all' && word.chapter !== selectedChapter) {
        return false;
      }
      return true;
    });
  }, [getAllWordsPerformance, searchWord, selectedChapter]);

  const handleClearHistory = React.useCallback(() => {
    if (window.confirm(`Vuoi cancellare la cronologia di ${testHistory.length} test? Questa azione non può essere annullata.`)) {
      onClearHistory();
      setTimeout(() => {
        setLocalRefresh(prev => prev + 1);
      }, 100);
    }
  }, [testHistory.length, onClearHistory]);

  if (testHistory.length === 0) {
    return (
      <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
        <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1">
          <div className="bg-white rounded-3xl p-8">
            <div className="text-center py-16">
              <div className="text-8xl mb-6">📊</div>
              <h3 className="text-2xl font-bold text-gray-700 mb-4">Nessun test completato</h3>
              <p className="text-gray-600 text-lg mb-8">Completa il tuo primo test per vedere le statistiche dettagliate!</p>
              <Button 
                onClick={onGoToMain} 
                className="bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl"
              >
                <Play className="w-5 h-5 mr-2" />
                Inizia il Primo Test
              </Button>
            </div>
          </div>
        </div>
      </Card>
    );
  }

  return (
    <div className="space-y-8 animate-fade-in">
      {/* Header with enhanced indicators */}
      <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
        <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1">
          <div className="bg-white rounded-3xl p-6">
            <div className="flex justify-between items-center mb-6">
              <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
                <BarChart3 className="w-8 h-8 text-purple-600" />
                Analisi Avanzata dell'Apprendimento
                <span className="text-sm bg-green-100 text-green-700 px-2 py-1 rounded-full">
                  Live: {testHistory.length} test
                </span>
              </CardTitle>
              <Button
                onClick={handleClearHistory}
                variant="outline"
                className="border-red-300 text-red-600 hover:bg-red-50"
                disabled={testHistory.length === 0}
              >
                🗑️ Pulisci Cronologia ({testHistory.length})
              </Button>
            </div>

            {/* Navigation Tabs */}
            <div className="flex gap-2 mb-6">
              {[
                { id: 'overview', label: 'Panoramica', icon: '📈' },
                { id: 'chapters', label: 'Per Capitoli', icon: '📚' },
                { id: 'words', label: 'Per Parole', icon: '🔍' }, // ⭐ NEW
                { id: 'performance', label: 'Performance', icon: '🎯' },
                { id: 'trends', label: 'Tendenze', icon: '📊' }
              ].map(tab => (
                <Button
                  key={tab.id}
                  onClick={() => setSelectedView(tab.id)}
                  className={`px-6 py-3 rounded-xl transition-all ${
                    selectedView === tab.id
                      ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg'
                      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`}
                >
                  <span className="mr-2">{tab.icon}</span>
                  {tab.label}
                </Button>
              ))}
            </div>

            {/* ⭐ ENHANCED: Statistiche Generali con hints */}
            <div className="grid grid-cols-2 md:grid-cols-6 gap-4">
              <div className="bg-gradient-to-br from-blue-500 to-cyan-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.totalTests}</div>
                <div className="text-blue-100 text-sm">Test Totali</div>
              </div>
              <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.averageScore}%</div>
                <div className="text-green-100 text-sm">Media</div>
              </div>
              <div className="bg-gradient-to-br from-purple-500 to-pink-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.bestScore}%</div>
                <div className="text-purple-100 text-sm">Record</div>
              </div>
              <div className="bg-gradient-to-br from-orange-500 to-red-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.totalWordsStudied}</div>
                <div className="text-orange-100 text-sm">Parole</div>
              </div>
              <div className="bg-gradient-to-br from-yellow-500 to-orange-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.totalHints}</div>
                <div className="text-yellow-100 text-sm">Aiuti</div>
              </div>
              <div className="bg-gradient-to-br from-indigo-500 to-blue-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.hintsPercentage}%</div>
                <div className="text-indigo-100 text-sm">% Aiuti</div>
              </div>
            </div>
          </div>
        </div>
      </Card>

      {/* Dynamic Content Based on Selected View */}
      {selectedView === 'overview' && (
        <OverviewSection 
          stats={getAdvancedStats} 
          timelineData={getTimelineData} 
          localRefresh={localRefresh}
        />
      )}

      {selectedView === 'chapters' && (
        <ChaptersSection 
          chapterData={getChapterComparisonData}
          selectedChapter={selectedChapter}
          setSelectedChapter={setSelectedChapter}
          testHistory={testHistory}
          localRefresh={localRefresh}
        />
      )}

      {/* ⭐ NEW: Words performance section */}
      {selectedView === 'words' && (
        <WordsSection 
          wordsData={getWordPerformanceData}
          searchWord={searchWord}
          setSearchWord={setSearchWord}
          selectedChapter={selectedChapter}
          setSelectedChapter={setSelectedChapter}
          selectedWordId={selectedWordId}
          setSelectedWordId={setSelectedWordId}
          getWordAnalysis={getWordAnalysis}
          localRefresh={localRefresh}
        />
      )}

      {selectedView === 'performance' && (
        <PerformanceSection 
          stats={getAdvancedStats}
          timelineData={getTimelineData}
          localRefresh={localRefresh}
        />
      )}

      {selectedView === 'trends' && (
        <TrendsSection 
          timelineData={getTimelineData}
          stats={getAdvancedStats}
          localRefresh={localRefresh}
        />
      )}
    </div>
  );
};

// ⭐ ENHANCED: Overview Section with hints visualization
const OverviewSection = ({ stats, timelineData, localRefresh }) => (
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-8" key={`overview-${localRefresh}`}>
    {/* Enhanced Timeline with hints */}
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <TrendingUp className="w-6 h-6" />
          Andamento con Aiuti (Ultimi 20 Test)
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={300}>
          <LineChart data={timelineData} key={`line-${localRefresh}`}>
            <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" />
            <XAxis dataKey="test" tick={{ fontSize: 12 }} />
            <YAxis tick={{ fontSize: 12 }} />
            <Tooltip 
              contentStyle={{
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                border: 'none',
                borderRadius: '12px',
                boxShadow: '0 10px 25px rgba(0, 0, 0, 0.1)'
              }}
            />
            <Line 
              type="monotone" 
              dataKey="percentage" 
              stroke="#3b82f6" 
              strokeWidth={3}
              name="Precisione %"
            />
            <Line 
              type="monotone" 
              dataKey="hints" 
              stroke="#f59e0b" 
              strokeWidth={2}
              name="Aiuti"
            />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>

    {/* Performance Metrics */}
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Target className="w-6 h-6" />
          Metriche Performance
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div className="text-center p-4 bg-blue-50 rounded-xl">
              <div className="text-2xl font-bold text-blue-600">{stats.averageScore}%</div>
              <div className="text-blue-700 text-sm">Precisione Media</div>
            </div>
            <div className="text-center p-4 bg-orange-50 rounded-xl">
              <div className="text-2xl font-bold text-orange-600">{stats.hintsPercentage}%</div>
              <div className="text-orange-700 text-sm">% Aiuti Usati</div>
            </div>
          </div>
          
          <div className="text-center p-4 bg-green-50 rounded-xl">
            <div className="text-xl font-bold text-green-600">
              {Math.max(0, stats.averageScore - stats.hintsPercentage)}%
            </div>
            <div className="text-green-700 text-sm">Efficienza (senza aiuti)</div>
          </div>
          
          <div className="grid grid-cols-3 gap-2 text-sm">
            <div className="text-center p-2 bg-purple-50 rounded-lg">
              <div className="font-bold text-purple-600">{stats.totalCorrect}</div>
              <div className="text-purple-700 text-xs">Corrette</div>
            </div>
            <div className="text-center p-2 bg-red-50 rounded-lg">
              <div className="font-bold text-red-600">{stats.totalIncorrect}</div>
              <div className="text-red-700 text-xs">Sbagliate</div>
            </div>
            <div className="text-center p-2 bg-yellow-50 rounded-lg">
              <div className="font-bold text-yellow-600">{stats.totalHints}</div>
              <div className="text-yellow-700 text-xs">Aiuti</div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  </div>
);

// ⭐ ENHANCED: Chapters Section with efficiency metrics
const ChaptersSection = ({ chapterData, selectedChapter, setSelectedChapter, testHistory, localRefresh }) => (
  <div className="space-y-8" key={`chapters-${localRefresh}`}>
    {/* Chapter Performance Comparison - Redesigned */}
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <BookOpen className="w-6 h-6" />
          Efficienza per Capitolo (Precisione vs Aiuti)
        </CardTitle>
        <p className="text-purple-100 text-sm">Più alta è la barra verde, migliore è l'efficienza del capitolo</p>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={400}>
          <BarChart data={chapterData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }} key={`bar-${localRefresh}`}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="chapter" />
            <YAxis domain={[0, 100]} />
            <Tooltip 
              formatter={(value, name) => [
                `${value}%`,
                name === 'accuracy' ? 'Precisione' :
                name === 'hints' ? 'Aiuti Usati' :
                name === 'efficiency' ? 'Efficienza Netta' : name
              ]}
            />
            <Bar dataKey="accuracy" fill="#3b82f6" name="accuracy" />
            <Bar dataKey="hints" fill="#f59e0b" name="hints" />
            <Bar dataKey="efficiency" fill="#10b981" name="efficiency" />
          </BarChart>
        </ResponsiveContainer>
        
        <div className="mt-4 grid grid-cols-3 gap-4 text-center">
          <div className="flex items-center justify-center gap-2">
            <div className="w-4 h-4 bg-blue-500 rounded"></div>
            <span className="text-sm">Precisione %</span>
          </div>
          <div className="flex items-center justify-center gap-2">
            <div className="w-4 h-4 bg-yellow-500 rounded"></div>
            <span className="text-sm">Aiuti %</span>
          </div>
          <div className="flex items-center justify-center gap-2">
            <div className="w-4 h-4 bg-green-500 rounded"></div>
            <span className="text-sm">Efficienza Netta</span>
          </div>
        </div>
      </CardContent>
    </Card>
  </div>
);

// ⭐ NEW: Words Performance Section
const WordsSection = ({ wordsData, searchWord, setSearchWord, selectedChapter, setSelectedChapter, selectedWordId, setSelectedWordId, getWordAnalysis, localRefresh }) => {
  const availableChapters = [...new Set(wordsData.map(w => w.chapter).filter(Boolean))].sort();
  
  const getStatusColor = (status) => {
    const colors = {
      critical: 'bg-red-500',
      inconsistent: 'bg-orange-500',
      struggling: 'bg-yellow-500',
      promising: 'bg-blue-500',
      improving: 'bg-green-500',
      consolidated: 'bg-emerald-500',
      new: 'bg-gray-500'
    };
    return colors[status] || 'bg-gray-500';
  };

  const getStatusLabel = (status) => {
    const labels = {
      critical: '🔴 Critica',
      inconsistent: '🟠 Instabile',
      struggling: '🟡 In difficoltà',
      promising: '🔵 Promettente',
      improving: '🟢 Migliorando',
      consolidated: '🟢 Consolidata',
      new: '⚪ Nuova'
    };
    return labels[status] || '⚪ Sconosciuto';
  };

  return (
    <div className="space-y-8" key={`words-${localRefresh}`}>
      {/* Search and Filter */}
      <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200">
        <CardContent className="p-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="text-sm font-medium text-gray-700 mb-2 block">🔍 Cerca Parola</label>
              <Input
                placeholder="Scrivi la parola inglese..."
                value={searchWord}
                onChange={(e) => setSearchWord(e.target.value)}
                className="border-2 border-blue-300 rounded-xl focus:border-blue-500"
              />
            </div>
            <div>
              <label className="text-sm font-medium text-gray-700 mb-2 block">📚 Filtra per Capitolo</label>
              <select
                value={selectedChapter}
                onChange={(e) => setSelectedChapter(e.target.value)}
                className="w-full px-3 py-2 border-2 border-blue-300 rounded-xl focus:border-blue-500 bg-white"
              >
                <option value="all">Tutti i capitoli</option>
                {availableChapters.map(chapter => (
                  <option key={chapter} value={chapter}>📖 {chapter}</option>
                ))}
              </select>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Words Performance List */}
      <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
        <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
          <CardTitle className="flex items-center gap-3 text-white">
            <Search className="w-6 h-6" />
            Performance Parole ({wordsData.length} parole)
          </CardTitle>
          <p className="text-indigo-100 text-sm">Clicca su una parola per vedere il grafico dell'andamento temporale</p>
        </CardHeader>
        <CardContent className="p-6">
          {wordsData.length === 0 ? (
            <div className="text-center py-8">
              <div className="text-6xl mb-4">🔍</div>
              <p className="text-gray-600">Nessuna parola trovata con i filtri attuali</p>
            </div>
          ) : (
            <div className="space-y-3 max-h-96 overflow-y-auto">
              {wordsData.map((word) => (
                <WordPerformanceCard 
                  key={word.wordId} 
                  word={word} 
                  isSelected={selectedWordId === word.wordId}
                  onClick={() => setSelectedWordId(selectedWordId === word.wordId ? null : word.wordId)}
                  getStatusColor={getStatusColor}
                  getStatusLabel={getStatusLabel}
                />
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Selected Word Detail */}
      {selectedWordId && (
        <WordDetailSection 
          wordId={selectedWordId}
          getWordAnalysis={getWordAnalysis}
          localRefresh={localRefresh}
        />
      )}
    </div>
  );
};

// ⭐ NEW: Word Performance Card Component
const WordPerformanceCard = ({ word, isSelected, onClick, getStatusColor, getStatusLabel }) => (
  <div
    onClick={onClick}
    className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
      isSelected 
        ? 'border-blue-500 bg-blue-50 shadow-lg' 
        : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
    }`}
  >
    <div className="flex items-center justify-between">
      <div className="flex items-center gap-4">
        <div className="flex flex-col">
          <div className="font-bold text-lg text-gray-800">{word.english}</div>
          <div className="text-gray-600">{word.italian}</div>
          {word.chapter && (
            <div className="text-sm text-blue-600">📖 Capitolo {word.chapter}</div>
          )}
        </div>
      </div>
      
      <div className="flex items-center gap-4">
        <div className="text-center">
          <div className="text-lg font-bold text-blue-600">{word.accuracy}%</div>
          <div className="text-blue-700 text-xs">Precisione</div>
        </div>
        
        <div className="text-center">
          <div className="text-lg font-bold text-orange-600">{word.hintsPercentage}%</div>
          <div className="text-orange-700 text-xs">Aiuti</div>
        </div>
        
        <div className="text-center">
          <div className="text-lg font-bold text-green-600">{word.currentStreak}</div>
          <div className="text-green-700 text-xs">Streak</div>
        </div>
        
        <div className="text-center">
          <div className="text-lg font-bold text-purple-600">{word.avgTime}s</div>
          <div className="text-purple-700 text-xs">Tempo Medio</div>
        </div>
        
        <div className={`px-3 py-1 rounded-full text-white text-sm font-medium ${getStatusColor(word.status)}`}>
          {getStatusLabel(word.status)}
        </div>
      </div>
    </div>
    
    <div className="mt-3 text-sm text-gray-500">
      {word.totalAttempts} tentativi • Ultimo: {word.lastAttempt ? new Date(word.lastAttempt.timestamp).toLocaleDateString('it-IT') : 'Mai'}
    </div>
  </div>
);

// ⭐ NEW: Word Detail Section with Timeline
const WordDetailSection = ({ wordId, getWordAnalysis, localRefresh }) => {
  const wordAnalysis = getWordAnalysis ? getWordAnalysis(wordId) : null;
  
  if (!wordAnalysis) return null;

  const timelineData = wordAnalysis.attempts.map((attempt, index) => ({
    attempt: `#${index + 1}`,
    success: attempt.correct ? 100 : 0,
    hint: attempt.usedHint ? 50 : 0,
    time: Math.round(attempt.timeSpent / 1000),
    date: new Date(attempt.timestamp).toLocaleDateString('it-IT')
  }));

  return (
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden" key={`detail-${wordId}-${localRefresh}`}>
      <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Award className="w-6 h-6" />
          Andamento Temporale Parola
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Timeline Chart */}
          <div>
            <h4 className="font-bold text-lg text-gray-800 mb-4">Ultimi 10 Tentativi</h4>
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={timelineData} key={`word-line-${wordId}-${localRefresh}`}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="attempt" />
                <YAxis domain={[0, 100]} />
                <Tooltip 
                  formatter={(value, name) => [
                    name === 'success' ? (value === 100 ? 'Corretta' : 'Sbagliata') :
                    name === 'hint' ? (value === 50 ? 'Con aiuto' : 'Senza aiuto') :
                    `${value}s`,
                    name === 'success' ? 'Risultato' :
                    name === 'hint' ? 'Aiuto' : 'Tempo'
                  ]}
                />
                <Line 
                  type="monotone" 
                  dataKey="success" 
                  stroke="#10b981" 
                  strokeWidth={3}
                  name="success"
                  dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }}
                />
                <Line 
                  type="monotone" 
                  dataKey="hint" 
                  stroke="#f59e0b" 
                  strokeWidth={2}
                  name="hint"
                  strokeDasharray="5 5"
                />
                <Line 
                  type="monotone" 
                  dataKey="time" 
                  stroke="#8b5cf6" 
                  strokeWidth={2}
                  name="time"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>

          {/* Statistics */}
          <div>
            <h4 className="font-bold text-lg text-gray-800 mb-4">Statistiche Dettagliate</h4>
            <div className="grid grid-cols-2 gap-4">
              <div className="text-center p-3 bg-blue-50 rounded-xl">
                <div className="text-xl font-bold text-blue-600">{wordAnalysis.accuracy}%</div>
                <div className="text-blue-700 text-sm">Precisione</div>
              </div>
              <div className="text-center p-3 bg-orange-50 rounded-xl">
                <div className="text-xl font-bold text-orange-600">{wordAnalysis.hintsPercentage}%</div>
                <div className="text-orange-700 text-sm">% Aiuti</div>
              </div>
              <div className="text-center p-3 bg-green-50 rounded-xl">
                <div className="text-xl font-bold text-green-600">{wordAnalysis.currentStreak}</div>
                <div className="text-green-700 text-sm">Streak Attuale</div>
              </div>
              <div className="text-center p-3 bg-purple-50 rounded-xl">
                <div className="text-xl font-bold text-purple-600">{wordAnalysis.avgTime}s</div>
                <div className="text-purple-700 text-sm">Tempo Medio</div>
              </div>
            </div>
            
            <div className="mt-4 p-4 bg-gray-50 rounded-xl">
              <div className="text-sm text-gray-700">
                <div className="mb-2">
                  <strong>Tentativi totali:</strong> {wordAnalysis.totalAttempts}
                </div>
                <div className="mb-2">
                  <strong>Precisione recente:</strong> {wordAnalysis.recentAccuracy}% (ultimi 5)
                </div>
                <div>
                  <strong>Stato:</strong> <span className="font-medium">{wordAnalysis.status}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// ⭐ ENHANCED: Performance Section with hints
const PerformanceSection = ({ stats, timelineData, localRefresh }) => (
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-8" key={`performance-${localRefresh}`}>
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Trophy className="w-6 h-6" />
          Analisi Efficienza
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-4">
          <div className="text-center p-6 bg-green-50 rounded-2xl border border-green-200">
            <div className="text-3xl font-bold text-green-600 mb-2">{stats.averageScore}%</div>
            <div className="text-green-700">Precisione Media</div>
          </div>
          
          <div className="grid grid-cols-2 gap-4">
            <div className="text-center p-4 bg-orange-50 rounded-xl">
              <div className="text-xl font-bold text-orange-600">{stats.hintsPercentage}%</div>
              <div className="text-orange-700 text-sm">Aiuti Usati</div>
            </div>
            <div className="text-center p-4 bg-blue-50 rounded-xl">
              <div className="text-xl font-bold text-blue-600">
                {Math.max(0, stats.averageScore - stats.hintsPercentage)}%
              </div>
              <div className="text-blue-700 text-sm">Efficienza Netta</div>
            </div>
          </div>
          
          <div className="text-center p-4 bg-purple-50 rounded-xl">
            <div className="text-lg font-bold text-purple-600">
              {stats.totalWordsStudied > 0 ? ((stats.totalCorrect / stats.totalWordsStudied) * 100).toFixed(1) : 0}%
            </div>
            <div className="text-purple-700 text-sm">Accuratezza Globale</div>
          </div>
        </div>
      </CardContent>
    </Card>

    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Lightbulb className="w-6 h-6" />
          Andamento Aiuti vs Prestazioni
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={timelineData.slice(-10)} key={`performance-bar-${localRefresh}`}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="test" />
            <YAxis />
            <Tooltip />
            <Bar dataKey="correct" stackId="a" fill="#10b981" name="Corrette" />
            <Bar dataKey="incorrect" stackId="a" fill="#ef4444" name="Sbagliate" />
            <Bar dataKey="hints" fill="#f59e0b" name="Aiuti" />
          </BarChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  </div>
);

// ⭐ ENHANCED: Trends Section with timing analysis
const TrendsSection = ({ timelineData, stats, localRefresh }) => (
  <div className="space-y-8" key={`trends-${localRefresh}`}>
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Clock className="w-6 h-6" />
          Tendenze Temporali e Performance
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={400}>
          <LineChart data={timelineData} key={`trends-line-${localRefresh}`}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis />
            <Tooltip />
            <Line 
              type="monotone" 
              dataKey="percentage" 
              stroke="#8b5cf6" 
              strokeWidth={3}
              name="Percentuale"
            />
            <Line 
              type="monotone" 
              dataKey="hints" 
              stroke="#f59e0b" 
              strokeWidth={2}
              name="Aiuti"
            />
            <Line 
              type="monotone" 
              dataKey="avgTime" 
              stroke="#06b6d4" 
              strokeWidth={2}
              name="Tempo Medio (s)"
            />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>

    {/* Enhanced Insights */}
    <Card className="bg-gradient-to-r from-yellow-50 to-orange-50 border-2 border-yellow-200">
      <CardContent className="p-6">
        <h3 className="text-xl font-bold text-yellow-800 mb-4 flex items-center gap-2">
          <Sparkles className="w-6 h-6" />
          Insights e Raccomandazioni Avanzate
        </h3>
        <div className="space-y-3 text-yellow-700">
          <p>🎯 <strong>Precisione:</strong> {stats.averageScore}% (target: 80%+)</p>
          <p>💡 <strong>Uso aiuti:</strong> {stats.hintsPercentage}% (ideale: 20%+)</p>
          <p>⚡ <strong>Efficienza netta:</strong> {Math.max(0, stats.averageScore - stats.hintsPercentage)}%</p>
          
          {stats.hintsPercentage > 30 && (
            <div className="p-3 bg-orange-100 rounded-lg border border-orange-300">
              <p>⚠️ <strong>Suggerimento:</strong> Stai usando molti aiuti. Prova a riflettere di più prima di chiedere aiuto.</p>
            </div>
          )}
          
          {stats.averageScore >= 80 && stats.hintsPercentage <= 20 && (
            <div className="p-3 bg-green-100 rounded-lg border border-green-300">
              <p>🏆 <strong>Eccellente!</strong> Hai raggiunto un ottimo equilibrio tra precisione e autonomia.</p>
            </div>
          )}
          
          <p>📊 <strong>Stato attuale:</strong> {stats.totalTests} test con {stats.totalWordsStudied} parole studiate e {stats.totalHints} aiuti utilizzati.</p>
        </div>
      </CardContent>
    </Card>
  </div>
);

export default StatsOverview;

================================================================================

NOME FILE: components\TestCard.js

// /src/components/TestCard.js
// This file contains the TestCard component, which displays a vocabulary word card that can be flipped to show its meaning.
// It includes the word in English, its Italian translation, an example sentence, and any notes associated with the word.
// The card has a front and back side, with animations for flipping. It also includes category styling based on the word's group.
// The component is designed to be interactive, allowing users to click to flip the card and view the translation and additional information.
// The TestCard component is used in the vocabulary testing feature of the application, providing a visually appealing and functional way to learn vocabulary words.
// It is styled using Tailwind CSS for a modern and responsive design.

import { getCategoryStyle } from '../utils/categoryUtils';
import { formatNotes } from '../utils/textUtils';

const TestCard = ({ word, showMeaning, onFlip }) => {
  return (
    <div 
      className="relative cursor-pointer transform transition-transform duration-300 hover:scale-105"
      style={{ width: '26rem', height: '38rem', perspective: '1000px' }}
      onClick={onFlip}
    >
      <div 
        className="absolute inset-0 w-full h-full transition-transform duration-700 preserve-3d"
        style={{ 
          transformStyle: 'preserve-3d',
          transform: showMeaning ? 'rotateY(180deg)' : 'rotateY(0deg)'
        }}
      >
        {/* Front Card */}
        <div 
          className="absolute inset-0 w-full h-full rounded-3xl shadow-2xl overflow-hidden backface-hidden"
          style={{ backfaceVisibility: 'hidden' }}
        >
          <div className="absolute inset-0 bg-gradient-to-br from-indigo-500 via-purple-600 to-pink-500"></div>
          <div className="absolute inset-0 bg-black/20"></div>
          <div className="relative h-full flex flex-col items-center justify-center text-white p-8">
            <div className="text-center space-y-6">
              <div className="text-5xl font-bold drop-shadow-lg">
                {word.english}
              </div>
              <div className="text-xl opacity-90 animate-pulse">
                Clicca per vedere la traduzione
              </div>
              <div className="mt-8">
                <div className="inline-flex items-center justify-center w-16 h-16 border-2 border-white/30 rounded-2xl backdrop-blur-sm">
                  <span className="text-2xl font-bold">EN</span>
                </div>
              </div>
            </div>
            
            {/* Animated particles */}
            <div className="absolute top-4 right-4 w-2 h-2 bg-white/50 rounded-full animate-ping"></div>
            <div className="absolute bottom-8 left-8 w-1 h-1 bg-white/30 rounded-full animate-pulse"></div>
            <div className="absolute top-1/3 left-4 w-1.5 h-1.5 bg-white/40 rounded-full animate-bounce"></div>
          </div>
        </div>

        {/* Back Card */}
        <div 
          className={`absolute inset-0 w-full h-full rounded-3xl shadow-2xl overflow-hidden backface-hidden ${getCategoryStyle(word.group)?.bgGradient || 'bg-gradient-to-br from-emerald-500 to-cyan-600'}`}
          style={{ 
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)'
          }}
        >
          <div className="absolute inset-0 bg-black/20"></div>
          
          {/* Category badge */}
          {word.group && (
            <div className="absolute top-4 right-4 z-10">
              <div className="bg-white/20 backdrop-blur-sm text-white px-3 py-2 rounded-xl text-sm font-medium flex items-center gap-2 shadow-lg">
                <span>{getCategoryStyle(word.group).icon}</span>
                <span>{word.group}</span>
              </div>
            </div>
          )}
          
          <div className="relative h-full flex flex-col text-white p-8">
            {/* Header */}
            <div className="text-center border-b border-white/30 pb-6 mb-6">
              <div className="text-2xl font-bold drop-shadow-md">
                {word.english}
              </div>
            </div>

            {/* Main translation */}
            <div className="text-center mb-8">
              <div 
                className="font-bold drop-shadow-lg leading-tight"
                style={{
                  fontSize: word.italian.length > 25 ? '2rem' : 
                           word.italian.length > 15 ? '2.5rem' : 
                           word.italian.length > 10 ? '3rem' : '3.5rem'
                }}
              >
                {word.italian}
              </div>
            </div>

            {/* Example */}
            {word.sentence && (
              <div className="mb-6">
                <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-4 border border-white/20">
                  <div className="font-bold mb-2 text-sm flex items-center gap-2">
                    <span className="text-lg">💬</span>
                    Esempio:
                  </div>
                  <div className="italic text-sm leading-relaxed">
                    "{word.sentence}"
                  </div>
                </div>
              </div>
            )}

            {/* Notes */}
            {word.notes && (
              <div className="flex-1 min-h-0">
                <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-4 h-full flex flex-col border border-white/20">
                  <div className="font-bold mb-3 text-sm flex items-center gap-2">
                    <span className="text-lg">📝</span>
                    Note:
                  </div>
                  <div className="overflow-y-auto flex-1 text-sm leading-relaxed whitespace-pre-line">
                    {formatNotes(word.notes)}
                  </div>
                </div>
              </div>
            )}

            {/* Footer */}
            <div className="text-center text-sm opacity-90 border-t border-white/30 pt-4 mt-6">
              <span className="animate-pulse">Clicca per tornare al fronte</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TestCard;

================================================================================

NOME FILE: components\TestHistory.js

// /src/components/TestHistory.js
// This file contains the TestHistory component, which displays a history of vocabulary tests taken by the user.
// It shows the details of each test, including the percentage of correct answers, total words, correct words, incorrect words, and the date of the test.
// The component also allows users to clear the test history and highlights words that were answered incorrectly in each test.
// The TestHistory component is designed to provide users with a comprehensive view of their testing performance over time,
// helping them track their progress and identify areas for improvement. 
import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { ChevronDown, ChevronUp, BookOpen, Target, Calendar, Award } from 'lucide-react';

const TestHistory = ({ testHistory, onClearHistory }) => {
  const [expandedTest, setExpandedTest] = useState(null);

  if (testHistory.length === 0) return null;

  const toggleTestExpansion = (testId) => {
    setExpandedTest(expandedTest === testId ? null : testId);
  };

  const formatDifficulty = (difficulty) => {
    const difficultyMap = {
      'easy': { label: 'Facile', color: 'bg-green-500', emoji: '😊' },
      'medium': { label: 'Medio', color: 'bg-yellow-500', emoji: '😐' },
      'hard': { label: 'Difficile', color: 'bg-red-500', emoji: '😤' }
    };
    return difficultyMap[difficulty] || difficultyMap['medium'];
  };

  const formatTestType = (testType) => {
    const typeMap = {
      'complete': { label: 'Completo', color: 'bg-blue-500', emoji: '🎯' },
      'selective': { label: 'Selettivo', color: 'bg-purple-500', emoji: '📚' },
      'unknown': { label: 'Standard', color: 'bg-gray-500', emoji: '📝' }
    };
    return typeMap[testType] || typeMap['unknown'];
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-600 text-white">
        <div className="flex justify-between items-center">
          <CardTitle className="flex items-center gap-3 text-white">
            <Calendar className="w-6 h-6" />
            Cronologia Test Dettagliata ({testHistory.length})
          </CardTitle>
          <Button
            onClick={onClearHistory}
            variant="outline"
            className="border-white/30 text-white hover:bg-white/20 hover:border-white/50 rounded-xl"
          >
            <span className="w-4 h-4 mr-2">🗑️</span>
            Pulisci
          </Button>
        </div>
        <p className="text-indigo-100 mt-2">
          Storico completo con parametri di test, capitoli e performance dettagliate
        </p>
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-4 max-h-96 overflow-y-auto scrollbar-thin">
          {testHistory.map((test, index) => (
            <TestHistoryCard
              key={test.id}
              test={test}
              testNumber={testHistory.length - index}
              isExpanded={expandedTest === test.id}
              onToggleExpansion={() => toggleTestExpansion(test.id)}
              formatDifficulty={formatDifficulty}
              formatTestType={formatTestType}
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

const TestHistoryCard = ({ 
  test, 
  testNumber, 
  isExpanded, 
  onToggleExpansion, 
  formatDifficulty, 
  formatTestType 
}) => {
  const difficulty = formatDifficulty(test.difficulty);
  const testType = formatTestType(test.testType);
  
  return (
    <div className="bg-gradient-to-r from-gray-50 to-white rounded-2xl border border-gray-100 hover:shadow-lg transition-all duration-300 overflow-hidden">
      {/* Header del Test */}
      <div 
        className="p-6 cursor-pointer"
        onClick={onToggleExpansion}
      >
        <div className="flex justify-between items-start mb-4">
          <div className="flex-1">
            <div className="flex items-center gap-4 mb-3">
              <div className="text-xl font-bold text-gray-800">
                Test #{testNumber}
              </div>
              
              {/* Badge Percentuale */}
              <div className={`px-4 py-2 rounded-full text-sm font-bold shadow-lg text-white ${
                test.percentage >= 80 ? 'bg-gradient-to-r from-green-500 to-emerald-500' :
                test.percentage >= 60 ? 'bg-gradient-to-r from-blue-500 to-cyan-500' :
                'bg-gradient-to-r from-red-500 to-pink-500'
              }`}>
                {test.percentage}%
              </div>
              
              {/* Badge Tipo Test */}
              <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${testType.color}`}>
                <span className="mr-1">{testType.emoji}</span>
                {testType.label}
              </div>
              
              {/* Badge Difficoltà */}
              <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${difficulty.color}`}>
                <span className="mr-1">{difficulty.emoji}</span>
                {difficulty.label}
              </div>
            </div>
            
            {/* Informazioni Base */}
            <div className="text-sm text-gray-600 mb-4 flex items-center gap-6">
              <div className="flex items-center gap-1">
                📅 {new Date(test.timestamp).toLocaleDateString('it-IT', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                })}
              </div>
              
              {test.testParameters?.selectedChapters && (
                <div className="flex items-center gap-1">
                  📚 {test.testParameters.selectedChapters.length} 
                  {test.testParameters.selectedChapters.length === 1 ? ' capitolo' : ' capitoli'}
                </div>
              )}
              
              <div className="flex items-center gap-1">
                🎯 {test.totalWords} parole
              </div>
            </div>
            
            {/* Statistiche Rapide */}
            <div className="grid grid-cols-3 gap-4">
              <div className="bg-blue-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-blue-600">{test.totalWords}</div>
                <div className="text-blue-700 text-xs">Totale</div>
              </div>
              <div className="bg-green-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-green-600">{test.correctWords}</div>
                <div className="text-green-700 text-xs">Corrette</div>
              </div>
              <div className="bg-red-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-red-600">{test.incorrectWords}</div>
                <div className="text-red-700 text-xs">Sbagliate</div>
              </div>
            </div>
          </div>
          
          {/* Indicatore Espansione */}
          <div className="ml-4">
            {isExpanded ? (
              <ChevronUp className="w-5 h-5 text-gray-400" />
            ) : (
              <ChevronDown className="w-5 h-5 text-gray-400" />
            )}
          </div>
        </div>
      </div>
      
      {/* Dettagli Espansi */}
      {isExpanded && (
        <div className="border-t border-gray-200 bg-gray-50">
          <div className="p-6 space-y-6">
            
            {/* Parametri del Test */}
            {test.testParameters && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <Target className="w-5 h-5" />
                  Parametri del Test
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="bg-white p-4 rounded-xl border border-gray-200">
                    <div className="text-sm text-gray-600 mb-1">Capitoli Selezionati</div>
                    <div className="flex flex-wrap gap-2">
                      {test.testParameters.selectedChapters?.map(chapter => (
                        <span key={chapter} className="px-2 py-1 bg-blue-100 text-blue-700 rounded-lg text-xs">
                          {chapter === 'Senza Capitolo' ? '📋 Senza Cap.' : `📖 ${chapter}`}
                        </span>
                      ))}
                    </div>
                  </div>
                  <div className="bg-white p-4 rounded-xl border border-gray-200">
                    <div className="text-sm text-gray-600 mb-1">Configurazione</div>
                    <div className="space-y-1">
                      <div className="text-xs">
                        {test.testParameters.includeLearnedWords ? '✅' : '❌'} Parole apprese incluse
                      </div>
                      <div className="text-xs text-gray-500">
                        {test.testParameters.totalAvailableWords} parole disponibili totali
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
            
            {/* Performance per Capitolo */}
            {test.chapterStats && Object.keys(test.chapterStats).length > 0 && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <BookOpen className="w-5 h-5" />
                  Performance per Capitolo
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {Object.entries(test.chapterStats).map(([chapter, stats]) => (
                    <div key={chapter} className="bg-white p-4 rounded-xl border border-gray-200">
                      <div className="font-medium text-gray-800 mb-2">
                        {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`}
                      </div>
                      <div className="space-y-2">
                        <div className="flex justify-between items-center">
                          <span className="text-sm text-gray-600">Accuratezza:</span>
                          <span className={`font-bold ${
                            stats.percentage >= 80 ? 'text-green-600' :
                            stats.percentage >= 60 ? 'text-blue-600' : 'text-red-600'
                          }`}>
                            {stats.percentage}%
                          </span>
                        </div>
                        <div className="flex justify-between items-center text-xs text-gray-500">
                          <span>Corrette: {stats.correctWords}</span>
                          <span>Sbagliate: {stats.incorrectWords}</span>
                        </div>
                        <div className="w-full bg-gray-200 rounded-full h-2">
                          <div 
                            className={`h-2 rounded-full ${
                              stats.percentage >= 80 ? 'bg-green-500' :
                              stats.percentage >= 60 ? 'bg-blue-500' : 'bg-red-500'
                            }`}
                            style={{ width: `${stats.percentage}%` }}
                          ></div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Parole Sbagliate */}
            {test.wrongWords && test.wrongWords.length > 0 && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <Award className="w-5 h-5" />
                  Parole da Ripassare ({test.wrongWords.length})
                </h4>
                <div className="bg-red-50 p-4 rounded-xl border border-red-200">
                  <div className="flex flex-wrap gap-2">
                    {test.wrongWords.map((word, wordIndex) => (
                      <div
                        key={wordIndex}
                        className="bg-white border border-red-200 px-3 py-2 rounded-lg text-sm"
                      >
                        <span className="font-medium text-red-700">{word.english}</span>
                        <span className="mx-2 text-red-400">→</span>
                        <span className="text-red-600">{word.italian}</span>
                        {word.chapter && (
                          <span className="ml-2 text-xs text-red-500">
                            📖 {word.chapter}
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}
            
            {/* Raccomandazioni */}
            <div className="bg-blue-50 p-4 rounded-xl border border-blue-200">
              <h5 className="font-medium text-blue-800 mb-2">💡 Raccomandazioni per il prossimo test:</h5>
              <div className="text-sm text-blue-700 space-y-1">
                {test.percentage < 60 && (
                  <p>• Rivedi le parole sbagliate prima del prossimo test</p>
                )}
                {test.chapterStats && Object.values(test.chapterStats).some(s => s.percentage < 70) && (
                  <p>• Concentrati sui capitoli con performance inferiore al 70%</p>
                )}
                {test.testParameters?.selectedChapters?.length === 1 && (
                  <p>• Prova a combinare più capitoli per aumentare la varietà</p>
                )}
                {test.percentage >= 80 && (
                  <p>• Ottimo lavoro! Potresti provare un test più difficile</p>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default TestHistory;

================================================================================

NOME FILE: components\TestResults.js

// /src/components/TestResults.js - ENHANCED con timer e hints
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Play, RotateCcw, Check, X, Trophy, Clock, Lightbulb, Target } from 'lucide-react';
import { getTestResult } from '../utils/textUtils';
import { formatNotes } from '../utils/textUtils';

const TestResults = ({ stats, wrongWords, onStartNewTest, onResetTest }) => {
  
  console.log('📊 TestResults - Dati ricevuti:', {
    stats,
    wrongWords: wrongWords?.length || 0
  });

  // ⭐ ENHANCED: Gestione robusta dei dati stats con timing e hints
  const getCorrectStats = () => {
    if (stats && typeof stats.correct === 'number' && typeof stats.incorrect === 'number') {
      return {
        correct: stats.correct,
        incorrect: stats.incorrect,
        hints: stats.hints || 0,
        totalTime: stats.totalTime || 0,
        avgTimePerWord: stats.avgTimePerWord || 0
      };
    }
    
    if (stats) {
      const correct = stats.correct || stats.correctAnswers || stats.right || 0;
      const incorrect = stats.incorrect || stats.incorrectAnswers || stats.wrong || 0;
      const hints = stats.hints || 0;
      const totalTime = stats.totalTime || 0;
      const avgTimePerWord = stats.avgTimePerWord || 0;
      
      if (correct > 0 || incorrect > 0) {
        return { correct, incorrect, hints, totalTime, avgTimePerWord };
      }
    }
    
    // Fallback: calcola dalla lunghezza delle parole sbagliate
    if (wrongWords && Array.isArray(wrongWords)) {
      const incorrect = wrongWords.length;
      const correct = Math.max(0, (stats?.total || 10) - incorrect);
      
      return { 
        correct, 
        incorrect, 
        hints: 0, 
        totalTime: 0, 
        avgTimePerWord: 0 
      };
    }
    
    return { correct: 0, incorrect: 0, hints: 0, totalTime: 0, avgTimePerWord: 0 };
  };

  const finalStats = getCorrectStats();
  const totalAnswers = finalStats.correct + finalStats.incorrect;
  const percentage = totalAnswers > 0 
    ? Math.round((finalStats.correct / totalAnswers) * 100) 
    : 0;

  console.log('📊 TestResults - Stats calcolate:', {
    finalStats,
    totalAnswers,
    percentage
  });

  const result = getTestResult({ 
    correct: finalStats.correct, 
    incorrect: finalStats.incorrect,
    total: totalAnswers
  });

  // ⭐ NEW: Format time helper
  const formatTime = (seconds) => {
    if (!seconds) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  // ⭐ NEW: Calculate performance metrics
  const performanceMetrics = {
    accuracy: percentage,
    hintsUsed: finalStats.hints,
    hintsPercentage: totalAnswers > 0 ? Math.round((finalStats.hints / totalAnswers) * 100) : 0,
    totalTime: formatTime(finalStats.totalTime),
    avgTime: finalStats.avgTimePerWord,
    speedRating: finalStats.avgTimePerWord <= 10 ? 'Veloce' : 
                 finalStats.avgTimePerWord <= 20 ? 'Normale' : 'Lento'
  };

  return (
    <div className="space-y-8">
      <Card className="relative overflow-hidden backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl">
        {/* Background animato */}
        <div className="absolute inset-0 bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 opacity-50"></div>
        <div className="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>
        
        <CardHeader className="relative text-center py-12">
          <div className="text-8xl mb-6 animate-bounce">
            {result.type === 'victory' ? '🏆' : 
             result.type === 'good' ? '🎉' : '📚'}
          </div>
          <CardTitle className={`text-4xl font-bold mb-4 ${result.color}`}>
            {result.message}
          </CardTitle>
          <div className="text-6xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-2">
            {percentage}%
          </div>
          <p className="text-xl text-gray-600">
            {finalStats.correct} corrette su {totalAnswers} domande
          </p>
          
          {/* ⭐ NEW: Performance summary */}
          <div className="mt-4 flex justify-center gap-6 text-sm text-gray-600">
            {finalStats.hints > 0 && (
              <span className="flex items-center gap-1">
                <Lightbulb className="w-4 h-4 text-orange-500" />
                {finalStats.hints} aiuti ({performanceMetrics.hintsPercentage}%)
              </span>
            )}
            {finalStats.totalTime > 0 && (
              <span className="flex items-center gap-1">
                <Clock className="w-4 h-4 text-blue-500" />
                {performanceMetrics.totalTime} totale
              </span>
            )}
            {finalStats.avgTimePerWord > 0 && (
              <span className="flex items-center gap-1">
                <Target className="w-4 h-4 text-purple-500" />
                {finalStats.avgTimePerWord}s/parola ({performanceMetrics.speedRating})
              </span>
            )}
          </div>
        </CardHeader>
        
        <CardContent className="relative pb-12">
          {/* ⭐ ENHANCED: Statistiche con timer e hints */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-6 max-w-4xl mx-auto mb-8">
            <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{finalStats.correct}</div>
              <div className="text-green-100">Corrette</div>
              <Check className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
            <div className="bg-gradient-to-br from-red-500 to-pink-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{finalStats.incorrect}</div>
              <div className="text-red-100">Sbagliate</div>
              <X className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
            
            {/* ⭐ NEW: Hints card */}
            <div className="bg-gradient-to-br from-orange-500 to-yellow-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{finalStats.hints}</div>
              <div className="text-orange-100">Aiuti</div>
              <Lightbulb className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
            
            {/* ⭐ NEW: Time card */}
            <div className="bg-gradient-to-br from-blue-500 to-cyan-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{performanceMetrics.totalTime}</div>
              <div className="text-blue-100">Tempo</div>
              <Clock className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
          </div>

          {/* ⭐ NEW: Performance Analysis */}
          {(finalStats.hints > 0 || finalStats.totalTime > 0) && (
            <Card className="bg-gradient-to-r from-indigo-50 to-purple-50 border-2 border-indigo-200 rounded-3xl overflow-hidden shadow-xl mb-8">
              <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
                <CardTitle className="flex items-center gap-3">
                  <Target className="w-6 h-6" />
                  Analisi Performance
                </CardTitle>
              </CardHeader>
              <CardContent className="p-6">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <div className="text-center">
                    <div className="text-2xl font-bold text-indigo-600 mb-2">{performanceMetrics.accuracy}%</div>
                    <div className="text-indigo-800 font-medium">Precisione</div>
                    <div className="text-sm text-indigo-600 mt-1">
                      {performanceMetrics.accuracy >= 80 ? '🏆 Eccellente!' :
                       performanceMetrics.accuracy >= 60 ? '👍 Buono' : '📚 Da migliorare'}
                    </div>
                  </div>
                  
                  {finalStats.hints > 0 && (
                    <div className="text-center">
                      <div className="text-2xl font-bold text-orange-600 mb-2">{performanceMetrics.hintsPercentage}%</div>
                      <div className="text-orange-800 font-medium">Aiuti Usati</div>
                      <div className="text-sm text-orange-600 mt-1">
                        {performanceMetrics.hintsPercentage <= 20 ? '🎯 Ottimo controllo!' :
                         performanceMetrics.hintsPercentage <= 40 ? '👌 Uso moderato' : '💡 Molti aiuti'}
                      </div>
                    </div>
                  )}
                  
                  {finalStats.avgTimePerWord > 0 && (
                    <div className="text-center">
                      <div className="text-2xl font-bold text-blue-600 mb-2">{finalStats.avgTimePerWord}s</div>
                      <div className="text-blue-800 font-medium">Tempo Medio</div>
                      <div className="text-sm text-blue-600 mt-1">
                        {performanceMetrics.speedRating === 'Veloce' ? '⚡ Molto veloce!' :
                         performanceMetrics.speedRating === 'Normale' ? '⏱️ Buon ritmo' : '🐌 Prenditi il tempo'}
                      </div>
                    </div>
                  )}
                </div>
                
                {/* ⭐ NEW: Performance tips */}
                <div className="mt-6 p-4 bg-white rounded-xl border border-indigo-200">
                  <h4 className="font-bold text-indigo-800 mb-2">💡 Suggerimenti per migliorare:</h4>
                  <div className="text-sm text-indigo-700 space-y-1">
                    {percentage < 60 && (
                      <p>• Ripassa le parole sbagliate prima del prossimo test</p>
                    )}
                    {performanceMetrics.hintsPercentage > 30 && (
                      <p>• Prova a ricordare il significato prima di usare gli aiuti</p>
                    )}
                    {finalStats.avgTimePerWord > 25 && (
                      <p>• Pratica più spesso per migliorare i tempi di risposta</p>
                    )}
                    {percentage >= 80 && performanceMetrics.hintsPercentage <= 20 && (
                      <p>• 🏆 Ottima performance! Prova test più difficili o aggiungi nuove parole</p>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Bottoni azione */}
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button 
              onClick={onStartNewTest} 
              className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200"
            >
              <Play className="w-5 h-5 mr-2" />
              Nuovo Test
            </Button>
            <Button 
              onClick={onResetTest} 
              variant="outline"
              className="border-2 border-gray-300 hover:border-gray-400 px-8 py-4 text-lg rounded-2xl bg-white/80 backdrop-blur-sm shadow-lg hover:shadow-xl transition-all duration-200"
            >
              <RotateCcw className="w-5 h-5 mr-2" />
              Torna al Menu
            </Button>
          </div>

          {/* ⭐ ENHANCED: Parole Sbagliate con info hints */}
          {wrongWords && wrongWords.length > 0 && (
            <div className="mt-12">
              <Card className="bg-gradient-to-br from-orange-50 to-red-50 border-2 border-orange-200 rounded-3xl overflow-hidden shadow-xl">
                <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
                  <CardTitle className="flex items-center gap-3">
                    <Trophy className="w-6 h-6" />
                    Parole da Ripassare ({wrongWords.length})
                  </CardTitle>
                  <p className="text-orange-100">
                    Studia queste parole per migliorare nel prossimo test!
                  </p>
                </CardHeader>
                <CardContent className="p-6">
                  <div className="grid gap-4">
                    {wrongWords.map((word, index) => (
                      <div
                        key={`${word.id}-${index}`}
                        className="bg-white p-6 rounded-2xl border border-orange-200 shadow-lg hover:shadow-xl transition-shadow duration-200"
                      >
                        <div className="flex justify-between items-start">
                          <div className="flex-1">
                            <div className="flex items-center gap-3 mb-3">
                              <span className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">{word.english}</span>
                              <span className="text-orange-400">→</span>
                              <span className="text-xl text-gray-700">{word.italian}</span>
                              
                              {/* ⭐ NEW: Hint indicator */}
                              {word.usedHint && (
                                <span className="inline-flex items-center gap-1 bg-orange-100 text-orange-700 px-2 py-1 rounded-full text-xs font-medium">
                                  <Lightbulb className="w-3 h-3" />
                                  Aiuto usato
                                </span>
                              )}
                            </div>
                            
                            {word.group && (
                              <div className="mb-3">
                                <span className="inline-flex items-center gap-1 bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-sm font-medium">
                                  📂 {word.group}
                                </span>
                              </div>
                            )}
                            
                            {word.sentence && (
                              <div className="mb-3 p-4 bg-green-50 rounded-xl border border-green-200">
                                <div className="text-green-600 font-semibold text-sm mb-1 flex items-center gap-2">
                                  <span>💬</span> Esempio:
                                </div>
                                <div className="text-green-800 italic">"{word.sentence}"</div>
                              </div>
                            )}
                            
                            {word.notes && (
                              <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200">
                                <div className="text-yellow-600 font-semibold text-sm mb-1 flex items-center gap-2">
                                  <span>📝</span> Note:
                                </div>
                                <div className="text-yellow-800 text-sm whitespace-pre-line">
                                  {formatNotes(word.notes)}
                                </div>
                              </div>
                            )}
                          </div>
                          <div className="text-3xl text-orange-500 ml-4">❌</div>
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default TestResults;

================================================================================

NOME FILE: components\WordsList.js

import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Plus, Trash2, Edit3, ChevronDown, ChevronUp, BookOpen, CheckCircle, Circle, Filter, AlertTriangle } from 'lucide-react';

// Simulated utility functions (replace with your actual imports)
const getCategoryStyle = (group) => {
  const categoryMap = {
    'VERBI': { icon: '⚡', bgColor: 'bg-red-500' },
    'VERBI_IRREGOLARI': { icon: '🔄', bgColor: 'bg-red-600' },
    'SOSTANTIVI': { icon: '🏷️', bgColor: 'bg-blue-500' },
    'AGGETTIVI': { icon: '🎨', bgColor: 'bg-green-500' },
    'FAMIGLIA': { icon: '👨‍👩‍👧‍👦', bgColor: 'bg-pink-400' },
    'TECNOLOGIA': { icon: '💻', bgColor: 'bg-cyan-500' },
    'LAVORO': { icon: '💼', bgColor: 'bg-indigo-500' },
    'DEFAULT': { icon: '📚', bgColor: 'bg-gray-500' }
  };
  return categoryMap[group?.toUpperCase()] || categoryMap['DEFAULT'];
};

const formatNotes = (notes) => {
  if (!notes) return null;
  const keywords = ['Altri Significati', 'Sinonimi', 'Verbo Irregolare', 'Pronuncia', 'Esempi'];
  let formattedText = notes;
  keywords.forEach(keyword => {
    const regex = new RegExp(`(${keyword})\\s*:`, 'gi');
    formattedText = formattedText.replace(regex, `**$1:**`);
  });
  
  return formattedText.split(/(\*\*[^*]+\*\*)/).map((part, index) => {
    if (part.startsWith('**') && part.endsWith('**')) {
      return React.createElement('span', { key: index, className: 'font-bold' }, part.slice(2, -2));
    }
    return part;
  });
};

const WordsList = ({ words, onEditWord, onRemoveWord, onToggleLearned, onToggleDifficult, showWordsList, setShowWordsList }) => {
  const [filterChapter, setFilterChapter] = useState('');
  const [filterLearned, setFilterLearned] = useState('all'); // 'all', 'learned', 'not_learned'
  const [filterDifficult, setFilterDifficult] = useState('all'); // ⭐ NEW: 'all', 'difficult', 'not_difficult'
  const [filterGroup, setFilterGroup] = useState('');

  // Calcolo dati derivati all'inizio per evitare problemi di scope
  const availableChapters = React.useMemo(() => {
    const chapters = new Set();
    words.forEach(word => {
      if (word.chapter) chapters.add(word.chapter);
    });
    return Array.from(chapters).sort((a, b) => {
      const aNum = parseInt(a);
      const bNum = parseInt(b);
      return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
    });
  }, [words]);

  const availableGroups = React.useMemo(() => {
    const groups = new Set();
    words.forEach(word => {
      if (word.group) groups.add(word.group);
    });
    return Array.from(groups).sort();
  }, [words]);

  const wordsWithoutChapter = React.useMemo(() => {
    return words.filter(word => !word.chapter);
  }, [words]);

  // ⭐ ENHANCED: Filtra le parole includendo filtro difficoltà
  const filteredWords = words.filter(word => {
    // Filtro per capitolo
    if (filterChapter !== '') {
      if (filterChapter === 'no-chapter') {
        if (word.chapter) return false;
      } else {
        if (word.chapter !== filterChapter) return false;
      }
    }
    
    // Filtro per gruppo
    if (filterGroup && word.group !== filterGroup) return false;
    
    // Filtro per stato appreso
    if (filterLearned === 'learned' && !word.learned) return false;
    if (filterLearned === 'not_learned' && word.learned) return false;
    
    // ⭐ NEW: Filtro per stato difficile
    if (filterDifficult === 'difficult' && !word.difficult) return false;
    if (filterDifficult === 'not_difficult' && word.difficult) return false;
    
    return true;
  });

  // Raggruppa le parole per capitolo
  const groupedWords = filteredWords.reduce((groups, word) => {
    const chapter = word.chapter || 'Senza Capitolo';
    if (!groups[chapter]) groups[chapter] = [];
    groups[chapter].push(word);
    return groups;
  }, {});

  // ⭐ ENHANCED: Statistiche con parole difficili
  const stats = {
    total: words.length,
    learned: words.filter(w => w.learned).length,
    notLearned: words.filter(w => !w.learned).length,
    difficult: words.filter(w => w.difficult).length, // ⭐ NEW
    withChapter: words.filter(w => w.chapter).length,
    filtered: filteredWords.length
  };

  const clearFilters = () => {
    setFilterChapter('');
    setFilterLearned('all');
    setFilterDifficult('all'); // ⭐ NEW
    setFilterGroup('');
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader 
        className="cursor-pointer hover:bg-gray-50 transition-colors" 
        onClick={() => setShowWordsList(!showWordsList)}
      >
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <span className="text-2xl">📚</span>
            <div className="flex flex-col">
              <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
                Il Tuo Vocabolario ({stats.total} parole)
              </span>
              <div className="flex gap-4 text-sm text-gray-600 mt-1">
                <span>✅ {stats.learned} apprese</span>
                <span>📖 {stats.notLearned} da studiare</span>
                <span>⭐ {stats.difficult} difficili</span> {/* ⭐ NEW */}
                <span>📚 {stats.withChapter} con capitolo</span>
              </div>
            </div>
          </div>
          {showWordsList ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
        </CardTitle>
      </CardHeader>
      
      {showWordsList && (
        <CardContent className="animate-fade-in">
          {words.length === 0 ? (
            <div className="text-center py-16">
              <div className="text-8xl mb-6">📚</div>
              <h3 className="text-2xl font-bold text-gray-700 mb-4">Il tuo vocabolario è vuoto</h3>
              <p className="text-gray-600 text-lg mb-8">Aggiungi la tua prima parola per iniziare a studiare!</p>
              <div className="flex justify-center">
                <Button className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-8 py-4 text-lg rounded-2xl shadow-xl">
                  <Plus className="w-5 h-5 mr-2" />
                  Aggiungi Prima Parola
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-6">
              {/* ⭐ ENHANCED: Filtri con difficoltà */}
              <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200">
                <CardHeader className="pb-3">
                  <CardTitle className="flex items-center gap-2 text-lg">
                    <Filter className="w-5 h-5 text-blue-600" />
                    Filtri ({stats.filtered} parole mostrate)
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Capitolo</label>
                      <select
                        value={filterChapter}
                        onChange={(e) => setFilterChapter(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="">Tutti i capitoli</option>
                        {availableChapters.map(chapter => (
                          <option key={chapter} value={chapter}>📖 {chapter}</option>
                        ))}
                        {wordsWithoutChapter.length > 0 && (
                          <option value="no-chapter">📋 Senza capitolo</option>
                        )}
                      </select>
                    </div>
                    
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Stato Apprendimento</label>
                      <select
                        value={filterLearned}
                        onChange={(e) => setFilterLearned(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="all">Tutte le parole</option>
                        <option value="learned">✅ Solo apprese</option>
                        <option value="not_learned">📖 Solo da studiare</option>
                      </select>
                    </div>
                    
                    {/* ⭐ NEW: Filtro difficoltà */}
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Difficoltà</label>
                      <select
                        value={filterDifficult}
                        onChange={(e) => setFilterDifficult(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="all">Tutte le parole</option>
                        <option value="difficult">⭐ Solo difficili</option>
                        <option value="not_difficult">📚 Solo normali</option>
                      </select>
                    </div>
                    
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Categoria</label>
                      <select
                        value={filterGroup}
                        onChange={(e) => setFilterGroup(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="">Tutte le categorie</option>
                        {availableGroups.map(group => (
                          <option key={group} value={group}>
                            {getCategoryStyle(group).icon} {group}
                          </option>
                        ))}
                      </select>
                    </div>
                    
                    <div className="flex items-end">
                      <Button 
                        onClick={clearFilters}
                        variant="outline"
                        className="w-full"
                      >
                        Cancella Filtri
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* ⭐ ENHANCED: Statistiche Generali con difficoltà */}
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                <div className="text-center p-4 bg-blue-50 rounded-2xl border border-blue-200">
                  <div className="text-2xl font-bold text-blue-600">{stats.total}</div>
                  <div className="text-blue-700 text-sm">Totale Parole</div>
                </div>
                <div className="text-center p-4 bg-green-50 rounded-2xl border border-green-200">
                  <div className="text-2xl font-bold text-green-600">{stats.learned}</div>
                  <div className="text-green-700 text-sm">Apprese</div>
                </div>
                <div className="text-center p-4 bg-orange-50 rounded-2xl border border-orange-200">
                  <div className="text-2xl font-bold text-orange-600">{stats.notLearned}</div>
                  <div className="text-orange-700 text-sm">Da Studiare</div>
                </div>
                <div className="text-center p-4 bg-red-50 rounded-2xl border border-red-200">
                  <div className="text-2xl font-bold text-red-600">{stats.difficult}</div>
                  <div className="text-red-700 text-sm">⭐ Difficili</div>
                </div>
                <div className="text-center p-4 bg-purple-50 rounded-2xl border border-purple-200">
                  <div className="text-2xl font-bold text-purple-600">{availableChapters.length}</div>
                  <div className="text-purple-700 text-sm">Capitoli</div>
                </div>
              </div>

              {/* Lista Parole Raggruppate per Capitolo */}
              <div className="space-y-6 max-h-96 overflow-y-auto scrollbar-thin">
                {Object.entries(groupedWords)
                  .sort(([a], [b]) => {
                    if (a === 'Senza Capitolo') return 1;
                    if (b === 'Senza Capitolo') return -1;
                    const aNum = parseInt(a);
                    const bNum = parseInt(b);
                    return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
                  })
                  .map(([chapter, chapterWords]) => (
                    <div key={chapter} className="space-y-3">
                      {/* Header Capitolo Enhanced */}
                      <div className="flex items-center gap-3 p-3 bg-gradient-to-r from-indigo-100 to-purple-100 rounded-2xl border border-indigo-200">
                        <BookOpen className="w-5 h-5 text-indigo-600" />
                        <h3 className="font-bold text-indigo-800 text-lg">
                          {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`}
                        </h3>
                        <span className="text-sm text-indigo-600 bg-indigo-200 px-3 py-1 rounded-full">
                          {chapterWords.length} parole
                        </span>
                        <span className="text-sm text-green-600 bg-green-200 px-3 py-1 rounded-full">
                          {chapterWords.filter(w => w.learned).length} apprese
                        </span>
                        {/* ⭐ NEW: Difficili counter */}
                        <span className="text-sm text-red-600 bg-red-200 px-3 py-1 rounded-full">
                          {chapterWords.filter(w => w.difficult).length} difficili
                        </span>
                      </div>
                      
                      {/* Parole del Capitolo */}
                      <div className="space-y-3">
                        {chapterWords.map((word) => (
                          <WordCard 
                            key={word.id} 
                            word={word} 
                            onEdit={() => onEditWord(word)}
                            onRemove={() => onRemoveWord(word.id)}
                            onToggleLearned={() => onToggleLearned(word.id)}
                            onToggleDifficult={() => onToggleDifficult(word.id)} // ⭐ NEW
                          />
                        ))}
                      </div>
                    </div>
                  ))}
              </div>
            </div>
          )}
        </CardContent>
      )}
    </Card>
  );
};

// ⭐ ENHANCED: WordCard con gestione difficoltà
const WordCard = ({ word, onEdit, onRemove, onToggleLearned, onToggleDifficult }) => (
  <div className={`p-6 rounded-2xl border-2 hover:shadow-lg transition-all duration-300 hover-lift ${
    word.learned 
      ? 'bg-gradient-to-r from-green-50 to-emerald-50 border-green-200' 
      : word.difficult
        ? 'bg-gradient-to-r from-red-50 to-orange-50 border-red-200'
        : 'bg-gradient-to-r from-white to-gray-50 border-gray-100 hover:border-gray-200'
  }`}>
    <div className="flex justify-between items-start">
      <div className="flex-1">
        <div className="flex items-center gap-3 mb-3">
          <span className={`text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent ${
            word.learned ? 'opacity-75' : ''
          }`}>
            {word.english}
          </span>
          <span className="text-gray-400 text-xl">→</span>
          <span className={`text-xl font-medium ${
            word.learned ? 'text-gray-600' : 'text-gray-700'
          }`}>
            {word.italian}
          </span>
          
          {/* Stato Appreso */}
          <div 
            onClick={onToggleLearned}
            className="cursor-pointer"
            title={word.learned ? "Segna come non appresa" : "Segna come appresa"}
          >
            {word.learned ? (
              <CheckCircle className="w-6 h-6 text-green-500 hover:text-green-600 transition-colors" />
            ) : (
              <Circle className="w-6 h-6 text-gray-400 hover:text-green-500 transition-colors" />
            )}
          </div>
          
          {/* ⭐ NEW: Stato Difficile */}
          <div 
            onClick={onToggleDifficult}
            className="cursor-pointer"
            title={word.difficult ? "Rimuovi da parole difficili" : "Segna come difficile"}
          >
            {word.difficult ? (
              <AlertTriangle className="w-6 h-6 text-red-500 hover:text-red-600 transition-colors fill-current" />
            ) : (
              <AlertTriangle className="w-6 h-6 text-gray-400 hover:text-red-500 transition-colors" />
            )}
          </div>
        </div>
        
        <div className="flex flex-wrap gap-2 mb-3">
          {word.group && (
            <span className={`inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium text-white shadow-lg ${getCategoryStyle(word.group).bgColor}`}>
              <span>{getCategoryStyle(word.group).icon}</span>
              {word.group}
            </span>
          )}
          
          {word.chapter && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-700">
              <BookOpen className="w-4 h-4" />
              Cap. {word.chapter}
            </span>
          )}
          
          {word.learned && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-700">
              <CheckCircle className="w-4 h-4" />
              Appresa
            </span>
          )}
          
          {/* ⭐ NEW: Badge parola difficile */}
          {word.difficult && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-red-100 text-red-700">
              <AlertTriangle className="w-4 h-4" />
              ⭐ Difficile
            </span>
          )}
        </div>

        {word.sentence && (
          <div className="mb-3 p-4 bg-green-50 rounded-xl border border-green-200">
            <div className="text-green-600 font-semibold text-sm mb-1 flex items-center gap-2">
              <span>💬</span> Esempio:
            </div>
            <div className="text-green-800 italic">"{word.sentence}"</div>
          </div>
        )}

        {word.notes && (
          <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200">
            <div className="text-yellow-600 font-semibold text-sm mb-1 flex items-center gap-2">
              <span>📝</span> Note:
            </div>
            <div className="text-yellow-800 text-sm whitespace-pre-line">
              {formatNotes(word.notes)}
            </div>
          </div>
        )}
      </div>
      
      <div className="flex gap-2 ml-4">
        <Button
          onClick={onEdit}
          variant="ghost"
          size="sm"
          className="text-blue-500 hover:text-blue-700 hover:bg-blue-50 p-3 rounded-xl transition-colors"
          title="Modifica parola"
        >
          <Edit3 className="w-5 h-5" />
        </Button>
        <Button
          onClick={onRemove}
          variant="ghost"
          size="sm"
          className="text-red-500 hover:text-red-700 hover:bg-red-50 p-3 rounded-xl transition-colors"
          title="Elimina parola"
        >
          <Trash2 className="w-5 h-5" />
        </Button>
      </div>
    </div>
  </div>
);

export default WordsList;

================================================================================

NOME FILE: components\layout\AppHeader.js

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card';
import { Brain, Sparkles } from 'lucide-react';

export const AppHeader = React.memo(() => (
  <div className="text-center relative">
    <div className="absolute inset-0 bg-gradient-to-r from-blue-600 to-purple-600 rounded-3xl blur-3xl opacity-20"></div>
    <Card className="relative backdrop-blur-sm bg-white/80 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10"></div>
      <CardHeader className="relative py-8">
        <CardTitle className="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center justify-center gap-3">
          <Brain className="w-10 h-10 text-blue-600" />
          Vocabulary Master
          <Sparkles className="w-8 h-8 text-purple-600" />
        </CardTitle>
        <p className="text-gray-600 text-lg mt-2">La tua app intelligente per imparare l'inglese</p>
      </CardHeader>
    </Card>
  </div>
));

================================================================================

NOME FILE: components\layout\AppNavigation.js

import React from 'react';
import { useAppContext } from '../../contexts/AppContext';
import { Card, CardContent } from '../ui/card';
import { Button } from '../ui/button';
import { Brain, BarChart3, Settings } from 'lucide-react';

export const AppNavigation = React.memo(() => {
  const { currentView, dispatch, testHistory, stats } = useAppContext();

  const navItems = [
    {
      id: 'main',
      label: 'Studio & Vocabolario',
      icon: Brain,
      color: 'from-blue-500 to-purple-600'
    },
    {
      id: 'stats',
      label: 'Statistiche',
      icon: BarChart3,
      color: 'from-purple-500 to-pink-600',
      badge: testHistory.length > 0 ? testHistory.length : null
    },
    {
      id: 'stats-manager',
      label: 'Gestisci Stats',
      icon: Settings,
      color: 'from-emerald-500 to-teal-600',
      badge: stats.testsCompleted > 0 ? stats.testsCompleted : null
    }
  ];

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardContent className="p-2">
        <div className="flex gap-2 p-2">
          {navItems.map(item => (
            <Button
              key={item.id}
              onClick={() => dispatch({ type: 'SET_VIEW', payload: item.id })}
              className={`flex-1 py-4 px-6 rounded-2xl text-lg font-semibold transition-all duration-300 ${
                currentView === item.id 
                  ? `bg-gradient-to-r ${item.color} text-white shadow-lg transform scale-105` 
                  : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
              }`}
            >
              <item.icon className="w-6 h-6 mr-3" />
              {item.label}
              {item.badge && (
                <span className="ml-2 bg-white/20 text-white px-2 py-1 rounded-full text-sm">
                  {item.badge}
                </span>
              )}
            </Button>
          ))}
        </div>
      </CardContent>
    </Card>
  );
});


================================================================================

NOME FILE: components\main\ControlPanel.js

import React from 'react';
import { Card, CardContent, CardTitle } from '../ui/card';
import { Button } from '../ui/button';
import { Play, RefreshCw, BookOpen, AlertTriangle } from 'lucide-react';

export const ControlPanel = React.memo(({ 
  onStartTest, 
  onClearAllWords, 
  words, 
  wordStats,
  getAvailableChapters, 
  getChapterStats 
}) => {
  const availableWords = words.filter(word => !word.learned);
  const chapters = getAvailableChapters();
  
  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-1">
        <div className="bg-white rounded-3xl p-6">
          <CardTitle className="flex items-center gap-3 text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-6">
            <Play className="w-6 h-6 text-blue-600" />
            Controlli di Studio
          </CardTitle>
          
          {/* ⭐ ENHANCED: Statistiche con parole difficili */}
          <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
            <div className="text-center p-4 bg-blue-50 rounded-2xl border border-blue-200">
              <div className="text-2xl font-bold text-blue-600">{wordStats.total}</div>
              <div className="text-blue-700 text-sm">Totale Parole</div>
            </div>
            <div className="text-center p-4 bg-green-50 rounded-2xl border border-green-200">
              <div className="text-2xl font-bold text-green-600">{wordStats.learned}</div>
              <div className="text-green-700 text-sm">Apprese</div>
            </div>
            <div className="text-center p-4 bg-orange-50 rounded-2xl border border-orange-200">
              <div className="text-2xl font-bold text-orange-600">{wordStats.unlearned}</div>
              <div className="text-orange-700 text-sm">Da Studiare</div>
            </div>
            <div className="text-center p-4 bg-red-50 rounded-2xl border border-red-200">
              <div className="text-2xl font-bold text-red-600">{wordStats.difficult}</div>
              <div className="text-red-700 text-sm">⭐ Difficili</div>
            </div>
            <div className="text-center p-4 bg-purple-50 rounded-2xl border border-purple-200">
              <div className="text-2xl font-bold text-purple-600">{chapters.length}</div>
              <div className="text-purple-700 text-sm">Capitoli</div>
            </div>
          </div>

          {/* ⭐ NEW: Info box per parole difficili */}
          {wordStats.difficult > 0 && (
            <div className="mb-6 p-4 bg-gradient-to-r from-red-50 to-orange-50 border-2 border-red-200 rounded-2xl">
              <div className="flex items-center gap-3 mb-2">
                <AlertTriangle className="w-6 h-6 text-red-600" />
                <h4 className="font-bold text-red-800">Parole Difficili Disponibili</h4>
              </div>
              <p className="text-red-700 text-sm">
                Hai {wordStats.difficult} parole marcate come difficili. 
                Usa la modalità "Solo Parole Difficili" per concentrarti su di esse!
              </p>
            </div>
          )}
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Button 
              onClick={onStartTest} 
              disabled={availableWords.length === 0}
              className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white p-6 h-auto rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              <div className="flex flex-col items-center gap-2">
                <BookOpen className="w-8 h-8" />
                <span className="font-bold">Inizia Test</span>
                <span className="text-sm opacity-90">
                  ({availableWords.length} disponibili
                  {wordStats.difficult > 0 && `, ${wordStats.difficult} difficili`})
                </span>
              </div>
            </Button>

            <Button 
              onClick={onClearAllWords} 
              variant="outline" 
              disabled={words.length === 0}
              className="border-2 border-red-300 hover:border-red-400 p-6 h-auto rounded-2xl bg-red-50 hover:bg-red-100 transition-all duration-200 disabled:opacity-50"
            >
              <div className="flex flex-col items-center gap-2 text-red-600">
                <RefreshCw className="w-8 h-8" />
                <span className="font-bold">Pulisci Vocabolario</span>
                <span className="text-sm">Elimina tutte le parole</span>
              </div>
            </Button>
          </div>
        </div>
      </div>
    </Card>
  );
});

================================================================================

NOME FILE: components\modals\GlobalModals.js

import React from 'react';
import { useAppContext } from '../../contexts/AppContext';
import { useNotification } from '../../contexts/NotificationContext';
import { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter } from '../ui/modal';
import { Button } from '../ui/button';
import ChapterTestSelector from '../ChapterTestSelector';
import { Trash2, RefreshCw } from 'lucide-react';

export const GlobalModals = React.memo(() => {
  const { 
    confirmDelete, 
    showConfirmClear, 
    showChapterSelector,
    dispatch,
    words,
    // testHistory, // ✅ Removed unused variable
    removeWord,
    clearAllWords,
    startTest
  } = useAppContext();
  
  const { showSuccess } = useNotification();

  const handleConfirmDelete = () => {
    if (confirmDelete) {
      removeWord(confirmDelete.id);
      showSuccess(`✅ Parola "${confirmDelete.english}" eliminata!`);
      dispatch({ type: 'SET_CONFIRM_DELETE', payload: null });
    }
  };

  const handleConfirmClear = () => {
    clearAllWords();
    dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false });
    showSuccess('✅ Tutte le parole sono state eliminate!');
  };

  const handleTestStart = (filteredWords) => {
    startTest(filteredWords);
    dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: false });
  };

  return (
    <>
      {/* Delete Word Modal */}
      <Modal 
        isOpen={!!confirmDelete} 
        onClose={() => dispatch({ type: 'SET_CONFIRM_DELETE', payload: null })}
      >
        <ModalHeader className="bg-gradient-to-r from-red-500 to-pink-500 text-white rounded-t-2xl">
          <ModalTitle className="text-white flex items-center gap-2">
            <Trash2 className="w-5 h-5" />
            Conferma Eliminazione
          </ModalTitle>
        </ModalHeader>
        <ModalContent>
          <div className="text-center py-4">
            <div className="text-6xl mb-4">🗑️</div>
            <p className="text-gray-700 mb-2">Sei sicuro di voler eliminare la parola</p>
            <div className="bg-gray-100 rounded-lg p-3 mb-4">
              <span className="font-bold text-lg text-red-600">"{confirmDelete?.english}"</span>
              {confirmDelete?.italian && (
                <>
                  <span className="mx-2 text-gray-400">→</span>
                  <span className="text-gray-700">{confirmDelete.italian}</span>
                </>
              )}
            </div>
            <p className="text-sm text-gray-500">Questa azione non può essere annullata.</p>
          </div>
        </ModalContent>
        <ModalFooter>
          <Button 
            onClick={() => dispatch({ type: 'SET_CONFIRM_DELETE', payload: null })} 
            variant="outline"
          >
            Annulla
          </Button>
          <Button 
            onClick={handleConfirmDelete} 
            className="bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white"
          >
            Elimina
          </Button>
        </ModalFooter>
      </Modal>

      {/* Clear All Words Modal */}
      <Modal 
        isOpen={showConfirmClear} 
        onClose={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })}
      >
        <ModalHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white rounded-t-2xl">
          <ModalTitle className="text-white flex items-center gap-2">
            <RefreshCw className="w-5 h-5" />
            Eliminazione Completa
          </ModalTitle>
        </ModalHeader>
        <ModalContent>
          <div className="text-center py-4">
            <div className="text-6xl mb-4">⚠️</div>
            <p className="text-gray-700 mb-4">
              Sei sicuro di voler eliminare tutte le <strong>{words.length} parole</strong>?
            </p>
            <div className="bg-orange-50 border border-orange-200 rounded-lg p-4 mb-4">
              <p className="text-orange-800 text-sm">
                Questa azione eliminerà permanentemente tutto il tuo vocabolario e non può essere annullata.
              </p>
            </div>
          </div>
        </ModalContent>
        <ModalFooter>
          <Button 
            onClick={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: false })} 
            variant="outline"
          >
            Annulla
          </Button>
          <Button 
            onClick={handleConfirmClear} 
            className="bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white"
          >
            Elimina Tutto
          </Button>
        </ModalFooter>
      </Modal>

      {/* Chapter Test Selector */}
      {showChapterSelector && (
        <ChapterTestSelector
          words={words}
          onStartTest={handleTestStart}
          onClose={() => dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: false })}
        />
      )}
    </>
  );
});

================================================================================

NOME FILE: components\ui\BackgroundParticles.js

import React from 'react';

export const BackgroundParticles = React.memo(() => (
  <div className="fixed inset-0 overflow-hidden pointer-events-none">
    <div className="absolute top-10 left-10 w-72 h-72 bg-blue-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob"></div>
    <div className="absolute top-0 right-4 w-72 h-72 bg-yellow-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-2000"></div>
    <div className="absolute -bottom-8 left-20 w-72 h-72 bg-pink-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-4000"></div>
  </div>
));


================================================================================

NOME FILE: components\ui\button.js

// /src/components/ui/button.js
// This file contains the Button component with various styles and sizes.
// It is designed to be used in forms and other interactive elements, providing a consistent look and feel for buttons.
// It supports different variants like default, outline, ghost, and destructive, as well as size options like default, sm, and lg.
// The Button component can be customized with additional classes and styles as needed.

import React from 'react';

const Button = React.forwardRef(({
  className = "",
  variant = "default",
  size = "default",
  children,
  disabled = false,
  ...props
}, ref) => {
  const baseClasses = "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background";

  const variants = {
    default: "bg-primary text-primary-foreground hover:bg-primary/90 bg-slate-900 text-white hover:bg-slate-800",
    outline: "border border-input hover:bg-accent hover:text-accent-foreground border-gray-300 hover:bg-gray-50",
    ghost: "hover:bg-accent hover:text-accent-foreground hover:bg-gray-100",
    destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90 bg-red-600 text-white hover:bg-red-700"
  };

  const sizes = {
    default: "h-10 py-2 px-4",
    sm: "h-9 px-3 rounded-md",
    lg: "h-11 px-8 rounded-md"
  };

  const classes = `${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`;

  return (
    <button
      className={classes}
      ref={ref}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
});

Button.displayName = "Button";

export { Button };

================================================================================

NOME FILE: components\ui\card.js

// /src/components/ui/card.js
// This file contains the Card component and its subcomponents for displaying content in a card format.
// It includes CardHeader, CardTitle, CardDescription, CardContent, and CardFooter components
// to structure the card layout.
// It is designed to be used in various parts of the application where a card-like UI is needed.
// It provides a consistent look and feel for displaying information in a card format.
// The Card component can be customized with additional classes and styles as needed.   


import React from 'react';

const Card = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`rounded-lg border bg-card text-card-foreground shadow-sm bg-white border-gray-200 ${className}`}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`flex flex-col space-y-1.5 p-6 ${className}`}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef(({ className = "", ...props }, ref) => (
  <h3
    ref={ref}
    className={`text-2xl font-semibold leading-none tracking-tight ${className}`}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef(({ className = "", ...props }, ref) => (
  <p
    ref={ref}
    className={`text-sm text-muted-foreground text-gray-600 ${className}`}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef(({ className = "", ...props }, ref) => (
  <div ref={ref} className={`p-6 pt-0 ${className}`} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`flex items-center p-6 pt-0 ${className}`}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

================================================================================

NOME FILE: components\ui\input.js

// /src/components/ui/input.js
// This file contains the Input component with various styles and properties.
// It is designed to be used in forms and other input scenarios, providing a consistent look and feel for text inputs.
//
import React from 'react';

const Input = React.forwardRef(({ className = "", type = "text", ...props }, ref) => {
  return (
    <input
      type={type}
      className={`flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`}
      ref={ref}
      {...props}
    />
  );
});
Input.displayName = "Input";

export { Input };

================================================================================

NOME FILE: components\ui\textarea.js

// /src/components/ui/textarea.js
// This file contains the Textarea component with various styles and properties.
//

import React from 'react';

const Textarea = React.forwardRef(({ className = "", ...props }, ref) => {
  return (
    <textarea
      className={`flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };

================================================================================

NOME FILE: contexts\AppContext.js

import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { useOptimizedWords } from '../hooks/useOptimizedWords';
import { useOptimizedTest } from '../hooks/useOptimizedTest';
import { useOptimizedStats } from '../hooks/useOptimizedStats';

const AppContext = createContext();

const initialState = {
  currentView: 'main',
  showWordsList: true,
  editingWord: null,
  showChapterSelector: false,
  confirmDelete: null,
  showConfirmClear: false
};

const appReducer = (state, action) => {
  switch (action.type) {
    case 'SET_VIEW':
      return { ...state, currentView: action.payload };
    case 'TOGGLE_WORDS_LIST':
      return { ...state, showWordsList: !state.showWordsList };
    case 'SET_EDITING_WORD':
      return { ...state, editingWord: action.payload };
    case 'SET_SHOW_CHAPTER_SELECTOR':
      return { ...state, showChapterSelector: action.payload };
    case 'SET_CONFIRM_DELETE':
      return { ...state, confirmDelete: action.payload };
    case 'SET_SHOW_CONFIRM_CLEAR':
      return { ...state, showConfirmClear: action.payload };
    case 'RESET_MODALS':
      return { 
        ...state, 
        confirmDelete: null, 
        showConfirmClear: false, 
        showChapterSelector: false 
      };
    default:
      return state;
  }
};

export const AppProvider = ({ children }) => {
  const [state, dispatch] = useReducer(appReducer, initialState);
  
  // Hook centralizzati
  const wordsAPI = useOptimizedWords();
  const statsAPI = useOptimizedStats();
  
  // ⭐ ENHANCED: Test API with proper stats callback
  const testAPI = useOptimizedTest((testStats, testWords, wrongWords) => {
    console.log('🔗 AppContext: Test completed, calling handleTestComplete with:', {
      testStats,
      testWordsCount: testWords.length,
      wrongWordsCount: wrongWords.length
    });
    
    // ⭐ CRITICAL: Pass enhanced stats including hints and timing
    statsAPI.handleTestComplete(testStats, testWords, wrongWords);
  });

  // Sincronizzazione con editing word globale
  useEffect(() => {
    wordsAPI.setEditingWord(state.editingWord);
  }, [state.editingWord]);

  // ⭐ DEBUG: Log quando le funzioni stats sono disponibili
  useEffect(() => {
    console.log('📊 StatsAPI functions available:', {
      getAllWordsPerformance: !!statsAPI.getAllWordsPerformance,
      getWordAnalysis: !!statsAPI.getWordAnalysis,
      wordPerformance: !!statsAPI.wordPerformance
    });
  }, [statsAPI.getAllWordsPerformance, statsAPI.getWordAnalysis, statsAPI.wordPerformance]);

  const value = {
    // Stato UI
    ...state,
    dispatch,
    
    // API Words - ⭐ ENHANCED: Added difficult toggle
    words: wordsAPI.words,
    addWord: wordsAPI.addWord,
    removeWord: wordsAPI.removeWord,
    toggleWordLearned: wordsAPI.toggleWordLearned,
    toggleWordDifficult: wordsAPI.toggleWordDifficult,
    clearAllWords: wordsAPI.clearAllWords,
    importWords: wordsAPI.importWords,
    getAvailableChapters: wordsAPI.getAvailableChapters,
    getChapterStats: wordsAPI.getChapterStats,
    wordStats: wordsAPI.wordStats,
    
    // API Test - ⭐ ENHANCED: With timer and hints
    ...testAPI,
    
    // API Stats - ⭐ FIXED: Properly expose word performance functions
    stats: statsAPI.stats,
    testHistory: statsAPI.testHistory,
    wordPerformance: statsAPI.wordPerformance, // ⭐ CRITICAL: Expose word performance data
    calculatedStats: statsAPI.calculatedStats,
    updateTestStats: statsAPI.updateTestStats,
    addTestToHistory: statsAPI.addTestToHistory,
    clearHistoryOnly: statsAPI.clearHistoryOnly,
    refreshData: statsAPI.refreshData,
    forceUpdate: statsAPI.forceUpdate,
    resetStats: statsAPI.resetStats,
    exportStats: statsAPI.exportStats,
    importStats: statsAPI.importStats,
    
    // ⭐ CRITICAL: Word performance functions
    getAllWordsPerformance: statsAPI.getAllWordsPerformance, // ⭐ FIX: Must be exposed
    getWordAnalysis: statsAPI.getWordAnalysis, // ⭐ FIX: Must be exposed
    recordWordPerformance: statsAPI.recordWordPerformance // ⭐ FIX: Must be exposed
  };

  // ⭐ DEBUG: Final context value check
  console.log('🔗 AppContext value includes word functions:', {
    getAllWordsPerformance: !!value.getAllWordsPerformance,
    getWordAnalysis: !!value.getWordAnalysis,
    wordPerformance: !!value.wordPerformance
  });

  return (
    <AppContext.Provider value={value}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useAppContext must be used within AppProvider');
  }
  return context;
};

================================================================================

NOME FILE: contexts\NotificationContext.js

import React, { createContext, useContext, useReducer, useCallback } from 'react';

const NotificationContext = createContext();

const notificationReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [...state.notifications, action.payload]
      };
    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(n => n.id !== action.payload)
      };
    case 'CLEAR_ALL':
      return { ...state, notifications: [] };
    default:
      return state;
  }
};

const getUserFriendlyError = (errorMessage, context) => {
  const errorMap = {
    'JSON': '❌ File JSON non valido',
    'localStorage': '❌ Errore salvataggio dati',
    'Network': '❌ Errore di connessione',
    'Word already exists': '⚠️ Parola già esistente',
    'English word and Italian translation are required': '⚠️ Campi obbligatori mancanti',
    'All words already exist': '⚠️ Tutte le parole sono già presenti'
  };

  for (const [key, message] of Object.entries(errorMap)) {
    if (errorMessage.includes(key)) {
      return message;
    }
  }

  return `❌ Errore ${context}: ${errorMessage}`;
};

export const NotificationProvider = ({ children }) => {
  const [state, dispatch] = useReducer(notificationReducer, {
    notifications: []
  });

  const showNotification = useCallback((message, type = 'success', duration = 3000) => {
    const id = Date.now() + Math.random();
    
    dispatch({
      type: 'ADD_NOTIFICATION',
      payload: { id, message, type, timestamp: Date.now() }
    });

    setTimeout(() => {
      dispatch({ type: 'REMOVE_NOTIFICATION', payload: id });
    }, duration);

    return id;
  }, []);

  const showError = useCallback((error, context = '') => {
    console.error(`❌ Error in ${context}:`, error);
    
    const errorMessage = error.message || error.toString();
    const userFriendlyMessage = getUserFriendlyError(errorMessage, context);
    
    return showNotification(userFriendlyMessage, 'error', 5000);
  }, [showNotification]);

  const showSuccess = useCallback((message) => {
    return showNotification(message, 'success');
  }, [showNotification]);

  const showWarning = useCallback((message) => {
    return showNotification(message, 'warning', 4000);
  }, [showNotification]);

  const value = {
    notifications: state.notifications,
    showNotification,
    showError,
    showSuccess,
    showWarning,
    clearAllNotifications: useCallback(() => {
      dispatch({ type: 'CLEAR_ALL' });
    }, [])
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
};

export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification must be used within NotificationProvider');
  }
  return context;
};

================================================================================

NOME FILE: hooks\useLocalStorage.js

// /src/hooks/useLocalStorage.js
// This file contains a custom React hook for managing local storage.
// It allows you to store and retrieve values from local storage with automatic JSON serialization and deserialization
// while providing a default initial value.
// The hook also handles errors gracefully, ensuring that the application can continue to function even if local storage is not available or if there are issues with the stored data.
// The `useLocalStorage` hook can be used in any React component to persist state across page reloads or sessions, making it useful for settings, user preferences, or any data that needs to be retained between visits.
// It returns the stored value and a function to update it, which will also update the local storage accordingly.
// It is a convenient way to manage state that needs to be persistent in a React application.

import { useState } from 'react';

export const useLocalStorage = (key, initialValue) => {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error loading ${key} from localStorage:`, error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error saving ${key} to localStorage:`, error);
    }
  };

  return [storedValue, setValue];
};

================================================================================

NOME FILE: hooks\useNotification.js

// /src/hooks/useNotification.js
// This file contains a custom React hook for managing notifications.
// It provides functionality to show a notification message for a specified duration.

import { useState, useCallback } from 'react';

export const useNotification = () => {
  const [message, setMessage] = useState('');

  const showNotification = useCallback((msg, duration = 3000) => {
    setMessage(msg);
    setTimeout(() => setMessage(''), duration);
  }, []);

  return { message, showNotification };
};

================================================================================

NOME FILE: hooks\useOptimizedStats.js

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useLocalStorage } from './useLocalStorage';
import { useNotification } from '../contexts/NotificationContext';

const INITIAL_STATS = {
  totalWords: 0,
  correctAnswers: 0,
  incorrectAnswers: 0,
  hintsUsed: 0, // ⭐ NEW: Track hints globally
  averageScore: 0,
  testsCompleted: 0,
  timeSpent: 0,
  categoriesProgress: {},
  dailyProgress: {},
  streakDays: 0,
  lastStudyDate: null,
  difficultyStats: {
    easy: { correct: 0, total: 0 },
    medium: { correct: 0, total: 0 },
    hard: { correct: 0, total: 0 }
  },
  monthlyStats: {},
  migrated: false
};

// ⭐ NEW: Word-specific performance tracking
const INITIAL_WORD_PERFORMANCE = {};

const EMPTY_ARRAY = [];

export const useOptimizedStats = () => {
  const [testHistory, setTestHistory] = useLocalStorage('testHistory', EMPTY_ARRAY);
  const [stats, setStats] = useLocalStorage('vocabularyStats', INITIAL_STATS);
  const [wordPerformance, setWordPerformance] = useLocalStorage('wordPerformance', INITIAL_WORD_PERFORMANCE); // ⭐ NEW
  const { showSuccess, showError } = useNotification();
  
  const [optimizationState, setOptimizationState] = useState({
    isProcessing: false,
    lastUpdate: Date.now(),
    forceUpdate: 0
  });

  // ⭐ MEMOIZED SELECTORS with hints
  const selectors = useMemo(() => ({
    totalTests: testHistory.length,
    totalAnswers: stats.correctAnswers + stats.incorrectAnswers,
    totalHints: stats.hintsUsed, // ⭐ NEW
    accuracyRate: stats.correctAnswers + stats.incorrectAnswers > 0 
      ? Math.round((stats.correctAnswers / (stats.correctAnswers + stats.incorrectAnswers)) * 100)
      : 0,
    hintsRate: stats.correctAnswers + stats.incorrectAnswers > 0 
      ? Math.round((stats.hintsUsed / (stats.correctAnswers + stats.incorrectAnswers)) * 100)
      : 0, // ⭐ NEW: Percentage of answers with hints
    isActiveToday: (() => {
      const today = new Date().toISOString().split('T')[0];
      return Boolean(stats.dailyProgress[today]?.tests > 0);
    })(),
    avgTimePerTest: stats.testsCompleted > 0 
      ? Math.round(stats.timeSpent / stats.testsCompleted) 
      : 0
  }), [
    testHistory.length, 
    stats.correctAnswers, 
    stats.incorrectAnswers, 
    stats.hintsUsed, // ⭐ NEW
    stats.testsCompleted, 
    stats.timeSpent, 
    stats.dailyProgress
  ]);

  // ⭐ NEW: Word-specific analysis
  const getWordAnalysis = useCallback((wordId) => {
    const wordData = wordPerformance[wordId];
    if (!wordData) return null;

    const attempts = wordData.attempts || [];
    const totalAttempts = attempts.length;
    const correctAttempts = attempts.filter(a => a.correct).length;
    const hintsUsed = attempts.filter(a => a.usedHint).length;
    const lastAttempt = attempts[attempts.length - 1];
    
    // Calculate streak
    let currentStreak = 0;
    for (let i = attempts.length - 1; i >= 0; i--) {
      if (attempts[i].correct) {
        currentStreak++;
      } else {
        break;
      }
    }

    // Calculate improvement trend
    const recentAttempts = attempts.slice(-5);
    const recentCorrect = recentAttempts.filter(a => a.correct).length;
    const recentAccuracy = recentAttempts.length > 0 ? (recentCorrect / recentAttempts.length) * 100 : 0;

    // Word status classification
    let status = 'new';
    if (totalAttempts >= 3) {
      if (currentStreak >= 3) status = 'consolidated';
      else if (correctAttempts / totalAttempts >= 0.7) status = 'improving';
      else if (correctAttempts / totalAttempts <= 0.3) status = 'critical';
      else status = 'inconsistent';
    } else if (totalAttempts > 0) {
      status = currentStreak > 0 ? 'promising' : 'struggling';
    }

    return {
      totalAttempts,
      correctAttempts,
      accuracy: totalAttempts > 0 ? Math.round((correctAttempts / totalAttempts) * 100) : 0,
      hintsUsed,
      hintsPercentage: totalAttempts > 0 ? Math.round((hintsUsed / totalAttempts) * 100) : 0,
      currentStreak,
      lastAttempt,
      recentAccuracy: Math.round(recentAccuracy),
      status,
      avgTime: attempts.length > 0 ? Math.round(attempts.reduce((sum, a) => sum + (a.timeSpent || 0), 0) / attempts.length / 1000) : 0,
      attempts: attempts.slice(-10) // Last 10 attempts for trend
    };
  }, [wordPerformance]);

  // ⭐ NEW: Get all words with their performance
  const getAllWordsPerformance = useCallback(() => {
    return Object.keys(wordPerformance).map(wordId => {
      const analysis = getWordAnalysis(wordId);
      return {
        wordId,
        english: wordPerformance[wordId].english,
        italian: wordPerformance[wordId].italian,
        chapter: wordPerformance[wordId].chapter,
        ...analysis
      };
    }).sort((a, b) => {
      // Sort by status priority: critical -> inconsistent -> improving -> consolidated
      const statusPriority = {
        critical: 1,
        inconsistent: 2,
        struggling: 3,
        promising: 4,
        improving: 5,
        consolidated: 6,
        new: 7
      };
      return statusPriority[a.status] - statusPriority[b.status];
    });
  }, [wordPerformance, getWordAnalysis]);

  // ⭐ ENHANCED: Record word performance
  const recordWordPerformance = useCallback((word, isCorrect, usedHint, timeSpent) => {
    const wordId = word.id;
    const attempt = {
      timestamp: new Date().toISOString(),
      correct: isCorrect,
      usedHint: usedHint || false,
      timeSpent: timeSpent || 0
    };

    setWordPerformance(prev => ({
      ...prev,
      [wordId]: {
        english: word.english,
        italian: word.italian,
        chapter: word.chapter,
        attempts: [...(prev[wordId]?.attempts || []), attempt]
      }
    }));
  }, [setWordPerformance]);

  // ⭐ MEMOIZED WEEKLY PROGRESS
  const weeklyProgress = useMemo(() => {
    const last7Days = Array.from({ length: 7 }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - i);
      return date.toISOString().split('T')[0];
    });
    
    return last7Days.map(date => ({
      date,
      tests: stats.dailyProgress[date]?.tests || 0,
      correct: stats.dailyProgress[date]?.correct || 0,
      incorrect: stats.dailyProgress[date]?.incorrect || 0,
      hints: stats.dailyProgress[date]?.hints || 0 // ⭐ NEW
    }));
  }, [stats.dailyProgress]);

  // ⭐ OPTIMIZED STREAK CALCULATION
  const calculateStreak = useCallback((dailyProgress) => {
    const today = new Date();
    let streak = 0;
    
    for (let i = 0; i < 365; i++) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      
      if (dailyProgress[dateStr]?.tests > 0) {
        streak++;
      } else if (i === 0) {
        continue;
      } else {
        break;
      }
      
      if (i > 30 && streak === 0) break;
    }
    
    return streak;
  }, []);

  // ⭐ BATCH OPERATIONS
  const performBatchUpdate = useCallback((updates) => {
    setOptimizationState(prev => ({ ...prev, isProcessing: true }));
    
    try {
      if (updates.stats) {
        setStats(updates.stats);
      }
      if (updates.testHistory) {
        setTestHistory(updates.testHistory);
      }
      if (updates.wordPerformance) {
        setWordPerformance(updates.wordPerformance);
      }
      
      setOptimizationState(prev => ({
        ...prev,
        lastUpdate: Date.now(),
        forceUpdate: prev.forceUpdate + 1,
        isProcessing: false
      }));
      
    } catch (error) {
      console.error('❌ Batch update error:', error);
      showError(error, 'Batch Update');
      setOptimizationState(prev => ({ ...prev, isProcessing: false }));
    }
  }, [setStats, setTestHistory, setWordPerformance, showError]);

  // ⭐ OPTIMIZED MIGRATION
  const optimizedMigration = useCallback(() => {
    if (testHistory.length === 0) return;

    const migrationData = testHistory.reduce((acc, test) => {
      acc.correctAnswers += test.correctWords || 0;
      acc.incorrectAnswers += test.incorrectWords || 0;
      acc.hintsUsed += test.hintsUsed || 0; // ⭐ NEW
      acc.totalWords = Math.max(acc.totalWords, test.totalWords || 0);
      acc.timeSpent += test.timeSpent || Math.floor(Math.random() * 6) + 5;

      if (test.timestamp) {
        const testDate = new Date(test.timestamp).toISOString().split('T')[0];
        if (!acc.dailyProgress[testDate]) {
          acc.dailyProgress[testDate] = { tests: 0, correct: 0, incorrect: 0, hints: 0 };
        }
        acc.dailyProgress[testDate].tests += 1;
        acc.dailyProgress[testDate].correct += test.correctWords || 0;
        acc.dailyProgress[testDate].incorrect += test.incorrectWords || 0;
        acc.dailyProgress[testDate].hints += test.hintsUsed || 0; // ⭐ NEW
        
        if (!acc.lastStudyDate || testDate > acc.lastStudyDate) {
          acc.lastStudyDate = testDate;
        }
      }

      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, chapterData]) => {
          if (!acc.categoriesProgress[chapter]) {
            acc.categoriesProgress[chapter] = { correct: 0, total: 0, hints: 0 };
          }
          acc.categoriesProgress[chapter].correct += chapterData.correctWords || 0;
          acc.categoriesProgress[chapter].total += chapterData.totalWords || 0;
          acc.categoriesProgress[chapter].hints += chapterData.hintsUsed || 0; // ⭐ NEW
        });
      }

      return acc;
    }, {
      correctAnswers: 0,
      incorrectAnswers: 0,
      hintsUsed: 0, // ⭐ NEW
      totalWords: 0,
      timeSpent: 0,
      dailyProgress: {},
      categoriesProgress: {},
      lastStudyDate: null
    });

    const migratedStats = {
      ...INITIAL_STATS,
      ...migrationData,
      testsCompleted: testHistory.length,
      averageScore: migrationData.correctAnswers + migrationData.incorrectAnswers > 0 
        ? (migrationData.correctAnswers / (migrationData.correctAnswers + migrationData.incorrectAnswers)) * 100 
        : 0,
      streakDays: calculateStreak(migrationData.dailyProgress),
      migrated: true
    };

    performBatchUpdate({ stats: migratedStats });
    showSuccess(`✅ Migrati ${testHistory.length} test!`);
  }, [testHistory, calculateStreak, performBatchUpdate, showSuccess]);

  // ⭐ ENHANCED: Test completion with word tracking
  const handleTestComplete = useCallback((testStats, testWordsUsed, wrongWordsArray) => {
    console.log('📊 handleTestComplete called with:', { testStats, testWordsUsed: testWordsUsed.length, wrongWords: wrongWordsArray.length });

    const usedChapters = [...new Set(testWordsUsed.map(word => word.chapter || 'Senza Capitolo'))];
    
    const chapterStats = {};
    usedChapters.forEach(chapter => {
      const chapterWords = testWordsUsed.filter(word => 
        (word.chapter || 'Senza Capitolo') === chapter
      );
      const chapterWrongWords = wrongWordsArray.filter(word => 
        (word.chapter || 'Senza Capitolo') === chapter
      );
      
      // ⭐ NEW: Calculate hints for this chapter
      const chapterHints = testStats.wordTimes ? 
        testStats.wordTimes
          .filter(wt => chapterWords.some(cw => cw.id === wt.wordId))
          .filter(wt => wt.usedHint).length : 0;
      
      chapterStats[chapter] = {
        totalWords: chapterWords.length,
        correctWords: chapterWords.length - chapterWrongWords.length,
        incorrectWords: chapterWrongWords.length,
        hintsUsed: chapterHints, // ⭐ NEW
        percentage: chapterWords.length > 0 ? 
          Math.round(((chapterWords.length - chapterWrongWords.length) / chapterWords.length) * 100) : 0
      };
    });

    // ⭐ NEW: Record individual word performances
    if (testStats.wordTimes && Array.isArray(testStats.wordTimes)) {
      testStats.wordTimes.forEach(wordTime => {
        const word = testWordsUsed.find(w => w.id === wordTime.wordId);
        if (word) {
          recordWordPerformance(word, wordTime.isCorrect, wordTime.usedHint, wordTime.timeSpent);
        }
      });
    }

    const updates = {
      stats: { ...stats },
      testHistory: [
        {
          id: Date.now(),
          timestamp: new Date(),
          totalWords: testStats.correct + testStats.incorrect,
          correctWords: testStats.correct,
          incorrectWords: testStats.incorrect,
          hintsUsed: testStats.hints || 0, // ⭐ NEW
          totalTime: testStats.totalTime || 0, // ⭐ NEW
          avgTimePerWord: testStats.avgTimePerWord || 0, // ⭐ NEW
          percentage: Math.round((testStats.correct / (testStats.correct + testStats.incorrect)) * 100),
          wrongWords: [...wrongWordsArray],
          wordTimes: testStats.wordTimes || [], // ⭐ NEW: Store individual word times
          chapterStats,
          testParameters: {
            selectedChapters: usedChapters,
            includeLearnedWords: testWordsUsed.some(w => w.learned),
            totalAvailableWords: testWordsUsed.length
          },
          testType: usedChapters.length === 1 ? 'selective' : 'complete',
          difficulty: testWordsUsed.length < 10 ? 'easy' : testWordsUsed.length < 25 ? 'medium' : 'hard'
        },
        ...testHistory
      ]
    };

    // ⭐ ENHANCED: Update stats with hints
    updates.stats.testsCompleted += 1;
    updates.stats.correctAnswers += testStats.correct;
    updates.stats.incorrectAnswers += testStats.incorrect;
    updates.stats.hintsUsed += testStats.hints || 0; // ⭐ NEW
    updates.stats.timeSpent += testStats.totalTime || (Math.round(Math.random() * 10) + 5);
    
    const totalAnswers = updates.stats.correctAnswers + updates.stats.incorrectAnswers;
    updates.stats.averageScore = (updates.stats.correctAnswers / totalAnswers) * 100;

    const today = new Date().toISOString().split('T')[0];
    if (!updates.stats.dailyProgress[today]) {
      updates.stats.dailyProgress[today] = { tests: 0, correct: 0, incorrect: 0, hints: 0 };
    }
    updates.stats.dailyProgress[today].tests += 1;
    updates.stats.dailyProgress[today].correct += testStats.correct;
    updates.stats.dailyProgress[today].incorrect += testStats.incorrect;
    updates.stats.dailyProgress[today].hints += testStats.hints || 0; // ⭐ NEW
    
    updates.stats.lastStudyDate = today;
    updates.stats.streakDays = calculateStreak(updates.stats.dailyProgress);

    console.log('📊 Updating stats with:', updates.stats);
    performBatchUpdate(updates);
    showSuccess(`✅ Test completato! Risultato: ${updates.testHistory[0].percentage}%`);
  }, [stats, testHistory, calculateStreak, performBatchUpdate, showSuccess, recordWordPerformance]);

  // ⭐ EXPORT/IMPORT FUNCTIONS (enhanced)
  const exportStats = useCallback(() => {
    try {
      const exportData = {
        stats,
        testHistory,
        wordPerformance, // ⭐ NEW: Include word performance
        exportDate: new Date().toISOString(),
        version: '2.1', // ⭐ Updated version
        dataTypes: ['stats', 'testHistory', 'wordPerformance'],
        totalTests: testHistory.length,
        totalWords: Object.keys(wordPerformance).length,
        description: 'Backup completo v2.1: statistiche avanzate + cronologia test + performance parole'
      };
      
      const dataStr = JSON.stringify(exportData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `vocabulary-complete-backup-v2.1-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      showSuccess(`✅ Backup v2.1 esportato! (${testHistory.length} test + ${Object.keys(wordPerformance).length} parole)`);
    } catch (error) {
      showError(error, 'Export');
    }
  }, [stats, testHistory, wordPerformance, showSuccess, showError]);

  const importStats = useCallback((file) => {
    return new Promise((resolve, reject) => {
      if (optimizationState.isProcessing) {
        reject(new Error('Operazione già in corso'));
        return;
      }

      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          setOptimizationState(prev => ({ ...prev, isProcessing: true }));
          const importedData = JSON.parse(e.target.result);
          
          const isEnhancedBackup = importedData.version === '2.1' && importedData.wordPerformance;
          
          if (!importedData.stats && !importedData.testHistory) {
            throw new Error('Dati non validi');
          }
          
          const shouldOverwrite = window.confirm(
            isEnhancedBackup 
              ? `Backup Enhanced v2.1 rilevato (${importedData.testHistory?.length || 0} test + ${Object.keys(importedData.wordPerformance || {}).length} parole).\nOK = Sostituisci tutto | Annulla = Combina`
              : `Backup standard rilevato.\nOK = Sostituisci | Annulla = Combina`
          );
          
          let newStats = stats;
          let newHistory = testHistory;
          let newWordPerformance = wordPerformance;
          
          if (isEnhancedBackup) {
            if (shouldOverwrite) {
              newStats = { ...importedData.stats, migrated: true };
              newHistory = [...(importedData.testHistory || [])];
              newWordPerformance = { ...importedData.wordPerformance };
              showSuccess(`✅ Backup Enhanced importato! ${newHistory.length} test + ${Object.keys(newWordPerformance).length} parole`);
            } else {
              // Combine data
              const existingIds = new Set(testHistory.map(test => test.id));
              const newTests = (importedData.testHistory || []).filter(test => !existingIds.has(test.id));
              newHistory = [...testHistory, ...newTests].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
              
              // Merge word performance
              newWordPerformance = { ...wordPerformance };
              Object.entries(importedData.wordPerformance || {}).forEach(([wordId, data]) => {
                if (newWordPerformance[wordId]) {
                  // Merge attempts
                  const existingAttempts = newWordPerformance[wordId].attempts || [];
                  const newAttempts = data.attempts || [];
                  const allAttempts = [...existingAttempts, ...newAttempts]
                    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                  newWordPerformance[wordId] = { ...data, attempts: allAttempts };
                } else {
                  newWordPerformance[wordId] = data;
                }
              });
              
              showSuccess(`✅ Dati combinati! +${newTests.length} test, ${Object.keys(importedData.wordPerformance || {}).length} parole performance`);
            }
          }
          
          performBatchUpdate({ 
            stats: newStats, 
            testHistory: newHistory,
            wordPerformance: newWordPerformance
          });
          resolve({ newStats, newHistory, newWordPerformance });
          
        } catch (error) {
          showError(error, 'Import');
          reject(error);
        } finally {
          setOptimizationState(prev => ({ ...prev, isProcessing: false }));
        }
      };
      
      reader.onerror = () => {
        setOptimizationState(prev => ({ ...prev, isProcessing: false }));
        const error = new Error('Errore lettura file');
        showError(error, 'File Reading');
        reject(error);
      };
      
      reader.readAsText(file);
    });
  }, [stats, testHistory, wordPerformance, performBatchUpdate, showSuccess, showError, optimizationState.isProcessing]);

  // ⭐ COMPUTED VALUES
  const computedStats = useMemo(() => ({
    ...selectors,
    weeklyProgress,
    isMigrated: stats.migrated,
    isProcessing: optimizationState.isProcessing,
    forceUpdate: optimizationState.forceUpdate
  }), [selectors, weeklyProgress, stats.migrated, optimizationState]);

  // ⭐ AUTO-MIGRATION
  useEffect(() => {
    const shouldMigrate = !stats.migrated && testHistory.length > 0 && !optimizationState.isProcessing;
    
    if (shouldMigrate) {
      const timeoutId = setTimeout(optimizedMigration, 500);
      return () => clearTimeout(timeoutId);
    }
  }, [stats.migrated, testHistory.length, optimizationState.isProcessing, optimizedMigration]);

  return {
    stats,
    testHistory,
    wordPerformance, // ⭐ NEW
    calculatedStats: computedStats,
    
    handleTestComplete,
    addTestToHistory: useCallback((testResult) => {
      const updatedHistory = [testResult, ...testHistory];
      performBatchUpdate({ testHistory: updatedHistory });
    }, [testHistory, performBatchUpdate]),
    
    // ⭐ NEW: Word performance functions
    getWordAnalysis,
    getAllWordsPerformance,
    recordWordPerformance,
    
    refreshData: useCallback(() => {
      if (optimizationState.isProcessing) return;
      
      try {
        const freshHistory = JSON.parse(localStorage.getItem('testHistory') || '[]');
        const freshStats = JSON.parse(localStorage.getItem('vocabularyStats') || JSON.stringify(INITIAL_STATS));
        const freshWordPerformance = JSON.parse(localStorage.getItem('wordPerformance') || '{}');
        
        performBatchUpdate({
          stats: freshStats,
          testHistory: freshHistory,
          wordPerformance: freshWordPerformance
        });
      } catch (error) {
        showError(error, 'Refresh');
      }
    }, [optimizationState.isProcessing, performBatchUpdate, showError]),
    
    resetStats: useCallback(() => {
      if (window.confirm('⚠️ Cancellare tutto?')) {
        performBatchUpdate({
          stats: { ...INITIAL_STATS, migrated: true },
          testHistory: EMPTY_ARRAY,
          wordPerformance: INITIAL_WORD_PERFORMANCE
        });
        showSuccess('✅ Tutti i dati cancellati!');
      }
    }, [performBatchUpdate, showSuccess]),
    
    clearHistoryOnly: useCallback(() => {
      if (window.confirm(`Cancellare ${testHistory.length} test?`)) {
        performBatchUpdate({ testHistory: EMPTY_ARRAY });
        showSuccess('✅ Cronologia cancellata!');
      }
    }, [testHistory.length, performBatchUpdate, showSuccess]),

    exportStats,
    importStats,
    
    ...computedStats
  };
};

export { useOptimizedStats as useStats };

================================================================================

NOME FILE: hooks\useOptimizedTest.js

import { useState, useCallback, useMemo, useRef, useEffect } from 'react';

export const useOptimizedTest = (onTestComplete) => {
  const [currentWord, setCurrentWord] = useState(null);
  const [usedWordIds, setUsedWordIds] = useState(new Set());
  const [showMeaning, setShowMeaning] = useState(false);
  const [testMode, setTestMode] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [stats, setStats] = useState({ correct: 0, incorrect: 0, hints: 0 });
  const [wrongWords, setWrongWords] = useState([]);
  const [testWords, setTestWords] = useState([]);
  const [testSaved, setTestSaved] = useState(false);
  
  // ⭐ ENHANCED: Timer functionality
  const [wordTimes, setWordTimes] = useState([]);
  const testStartTimeRef = useRef(null);
  const wordStartTimeRef = useRef(null); // ⭐ CRITICAL: Track when word appears
  
  // ⭐ ENHANCED: Hint functionality
  const [showHint, setShowHint] = useState(false);
  const [hintUsedForCurrentWord, setHintUsedForCurrentWord] = useState(false);

  // ⭐ CRITICAL FIX: Start timing when word appears and reset meaning state
  useEffect(() => {
    if (currentWord && testMode) {
      console.log('⏱️ New word appeared, starting timer:', currentWord.english);
      wordStartTimeRef.current = Date.now();
      setHintUsedForCurrentWord(false);
      setShowHint(false);
      
      // ⭐ CRITICAL: Reset meaning state for new word
      setShowMeaning(false);
    }
  }, [currentWord, testMode]);

  // ⭐ ENHANCED: Record word completion time
  const recordWordTime = useCallback((isCorrect, usedHint = false) => {
    if (wordStartTimeRef.current && currentWord) {
      const timeSpent = Date.now() - wordStartTimeRef.current;
      console.log(`⏱️ Recording time for ${currentWord.english}:`, {
        timeSpent: Math.round(timeSpent / 1000) + 's',
        isCorrect,
        usedHint
      });
      
      const wordRecord = {
        wordId: currentWord.id,
        english: currentWord.english,
        italian: currentWord.italian,
        chapter: currentWord.chapter,
        timeSpent,
        isCorrect,
        usedHint,
        timestamp: new Date().toISOString()
      };
      
      setWordTimes(prev => {
        const newTimes = [...prev, wordRecord];
        console.log('📊 Updated wordTimes:', newTimes.length, 'total records');
        return newTimes;
      });
      
      // Reset timer reference
      wordStartTimeRef.current = null;
    } else {
      console.warn('⚠️ Cannot record time - missing wordStartTimeRef or currentWord');
    }
  }, [currentWord]);

  // ⭐ PROGRESS: Enhanced with hints
  const progressData = useMemo(() => {
    if (testWords.length === 0) return { current: 0, total: 0, percentage: 0, hints: 0 };
    
    const answered = stats.correct + stats.incorrect;
    
    return {
      current: answered + 1,
      total: testWords.length,
      percentage: Math.round((answered / testWords.length) * 100),
      hints: stats.hints
    };
  }, [stats.correct, stats.incorrect, stats.hints, testWords.length]);

  // ⭐ SUMMARY: Enhanced with hints and timing
  const summaryData = useMemo(() => {
    const totalAnswered = stats.correct + stats.incorrect;
    const accuracy = totalAnswered > 0 ? Math.round((stats.correct / totalAnswered) * 100) : 0;
    const totalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0;
    const avgTimePerWord = wordTimes.length > 0 
      ? Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000)
      : 0;
    
    return {
      current: totalAnswered + 1,
      total: testWords.length,
      percentage: Math.round((totalAnswered / testWords.length) * 100),
      answered: totalAnswered,
      remaining: testWords.length - totalAnswered,
      accuracy,
      correct: stats.correct,
      incorrect: stats.incorrect,
      hints: stats.hints,
      avgTimePerWord,
      totalTime: Math.round(totalTestTime / 1000)
    };
  }, [stats.correct, stats.incorrect, stats.hints, testWords.length, wordTimes, testStartTimeRef.current]);

  // ⭐ OPTIMIZED RANDOM WORD SELECTION
  const getRandomUnusedWord = useCallback((wordList, usedIds) => {
    const unusedWords = wordList.filter(word => !usedIds.has(word.id));
    if (unusedWords.length === 0) return null;
    
    const randomIndex = Math.floor(Math.random() * unusedWords.length);
    return unusedWords[randomIndex];
  }, []);

  // ⭐ ENHANCED: Save test results with complete stats
  const saveTestResultsWithStats = useCallback((finalStats) => {
    if (!testSaved && (finalStats.correct > 0 || finalStats.incorrect > 0) && onTestComplete) {
      const finalTestTime = testStartTimeRef.current ? Date.now() - testStartTimeRef.current : 0;
      
      console.log('💾 Saving test results:', {
        finalStats,
        wordTimesCount: wordTimes.length,
        totalTime: Math.round(finalTestTime / 1000) + 's'
      });
      
      const enhancedStats = {
        ...finalStats,
        totalTime: Math.round(finalTestTime / 1000),
        avgTimePerWord: wordTimes.length > 0 
          ? Math.round(wordTimes.reduce((sum, record) => sum + record.timeSpent, 0) / wordTimes.length / 1000)
          : 0,
        wordTimes: [...wordTimes] // ⭐ CRITICAL: Pass complete word times array
      };
      
      console.log('📤 Calling onTestComplete with enhancedStats:', enhancedStats);
      onTestComplete(enhancedStats, testWords, wrongWords);
      setTestSaved(true);
    }
  }, [testWords, wrongWords, testSaved, onTestComplete, wordTimes]);

  const startTest = useCallback((filteredWords = []) => {
    if (filteredWords.length === 0) return;
    
    console.log('🚀 Starting test with', filteredWords.length, 'words');
    
    setTestWords(filteredWords);
    setWrongWords([]);
    setTestSaved(false);
    setStats({ correct: 0, incorrect: 0, hints: 0 });
    setUsedWordIds(new Set());
    setWordTimes([]);
    testStartTimeRef.current = Date.now();
    wordStartTimeRef.current = null; // ⭐ Reset word timer
    
    const firstWord = getRandomUnusedWord(filteredWords, new Set());
    setCurrentWord(firstWord);
    
    if (firstWord) {
      setUsedWordIds(new Set([firstWord.id]));
      console.log('📝 First word set:', firstWord.english);
    }
    
    setShowMeaning(false);
    setShowHint(false);
    setHintUsedForCurrentWord(false);
    setTestMode(true);
  }, [getRandomUnusedWord]);

  const nextWord = useCallback(() => {
    const nextRandomWord = getRandomUnusedWord(testWords, usedWordIds);
    
    if (nextRandomWord) {
      console.log('➡️ Moving to next word:', nextRandomWord.english);
      setCurrentWord(nextRandomWord);
      setUsedWordIds(prev => new Set([...prev, nextRandomWord.id]));
      setShowMeaning(false);
      setShowHint(false);
      setHintUsedForCurrentWord(false);
      // ⭐ Timer will be started by useEffect when currentWord changes
    }
  }, [testWords, usedWordIds, getRandomUnusedWord]);

  // ⭐ ENHANCED: Hint functionality
  const toggleHint = useCallback(() => {
    if (!showHint && currentWord?.sentence) {
      console.log('💡 Showing hint for:', currentWord.english);
      setShowHint(true);
      setHintUsedForCurrentWord(true);
    } else {
      setShowHint(false);
    }
  }, [showHint, currentWord]);

  // ⭐ CRITICAL FIX: Answer handling with proper timing
  const handleAnswer = useCallback((isCorrect) => {
    console.log('📝 Handling answer:', { 
      isCorrect, 
      word: currentWord?.english, 
      hintUsed: hintUsedForCurrentWord,
      timeElapsed: wordStartTimeRef.current ? Math.round((Date.now() - wordStartTimeRef.current) / 1000) + 's' : 'no-timer'
    });
    
    // ⭐ CRITICAL: Record timing BEFORE any state changes
    recordWordTime(isCorrect, hintUsedForCurrentWord);
    
    // ⭐ Update stats with hints properly tracked
    const newStats = {
      correct: stats.correct + (isCorrect ? 1 : 0),
      incorrect: stats.incorrect + (isCorrect ? 0 : 1),
      hints: stats.hints + (hintUsedForCurrentWord ? 1 : 0)
    };
    
    console.log('📊 Updated stats:', newStats);
    setStats(newStats);
    
    // ⭐ Track wrong words with hint info
    if (!isCorrect && currentWord) {
      const wrongWord = { ...currentWord, usedHint: hintUsedForCurrentWord };
      setWrongWords(prev => [...prev, wrongWord]);
      console.log('❌ Added wrong word:', wrongWord.english, 'with hint:', hintUsedForCurrentWord);
    }
    
    const totalAnswered = newStats.correct + newStats.incorrect;
    const isLastQuestion = totalAnswered >= testWords.length;
    
    console.log('🎯 Test progress:', {
      answered: totalAnswered,
      total: testWords.length,
      isLastQuestion
    });
    
    if (showMeaning) {
      setShowMeaning(false);
      setTimeout(() => {
        if (isLastQuestion) {
          console.log('🏁 Test completed, saving results...');
          saveTestResultsWithStats(newStats);
          setTestMode(false);
          setShowResults(true);
          setCurrentWord(null);
        } else {
          nextWord();
        }
      }, 800);
    } else {
      setTimeout(() => {
        if (isLastQuestion) {
          console.log('🏁 Test completed, saving results...');
          saveTestResultsWithStats(newStats);
          setTestMode(false);
          setShowResults(true);
          setCurrentWord(null);
        } else {
          nextWord();
        }
      }, 300);
    }
  }, [currentWord, showMeaning, stats, testWords.length, hintUsedForCurrentWord, recordWordTime, saveTestResultsWithStats, nextWord]);

  const resetTest = useCallback(() => {
    if (!testSaved && (stats.correct > 0 || stats.incorrect > 0)) {
      console.log('💾 Auto-saving test before reset...');
      saveTestResultsWithStats(stats);
    }
    
    console.log('🔄 Resetting test...');
    setTestMode(false);
    setShowResults(false);
    setCurrentWord(null);
    setUsedWordIds(new Set());
    setWrongWords([]);
    setShowMeaning(false);
    setShowHint(false);
    setHintUsedForCurrentWord(false);
    setStats({ correct: 0, incorrect: 0, hints: 0 });
    setTestWords([]);
    setTestSaved(false);
    setWordTimes([]);
    testStartTimeRef.current = null;
    wordStartTimeRef.current = null; // ⭐ Reset word timer
  }, [stats, testSaved, saveTestResultsWithStats]);

  const startNewTest = useCallback(() => {
    console.log('🔄 Starting new test...');
    setShowResults(false);
    setWrongWords([]);
    setTestSaved(false);
    setStats({ correct: 0, incorrect: 0, hints: 0 });
    setUsedWordIds(new Set());
    setCurrentWord(null);
    setWordTimes([]);
    startTest(testWords);
  }, [startTest, testWords]);

  return {
    currentWord,
    usedWordIds,
    showMeaning,
    setShowMeaning,
    testMode,
    showResults,
    stats,
    wrongWords,
    testWords,
    
    // ⭐ ENHANCED: Hint functionality
    showHint,
    toggleHint,
    hintUsed: hintUsedForCurrentWord,
    
    // ⭐ ENHANCED: Timer functionality
    wordTimes,
    
    startTest,
    handleAnswer,
    resetTest,
    startNewTest,
    getTestProgress: useCallback(() => progressData, [progressData]),
    getTestSummary: useCallback(() => summaryData, [summaryData])
  };
};

================================================================================

NOME FILE: hooks\useOptimizedWords.js

import { useState, useCallback, useMemo } from 'react';
import { useLocalStorage } from './useLocalStorage';

const EMPTY_ARRAY = [];

export const useOptimizedWords = () => {
  const [words, setWords] = useLocalStorage('vocabularyWords', EMPTY_ARRAY);
  const [editingWord, setEditingWord] = useState(null);

  // ⭐ MEMOIZED COMPUTATIONS - Enhanced with difficult words
  const wordStats = useMemo(() => ({
    total: words.length,
    learned: words.filter(w => w.learned).length,
    unlearned: words.filter(w => !w.learned).length,
    difficult: words.filter(w => w.difficult).length,
    normal: words.filter(w => !w.difficult && !w.learned).length,
    chapters: [...new Set(words.map(w => w.chapter).filter(Boolean))].sort(),
    groups: [...new Set(words.map(w => w.group).filter(Boolean))].sort()
  }), [words]);

  // ⭐ MEMOIZED WORD MAP
  const wordMap = useMemo(() => {
    return words.reduce((map, word) => {
      map[word.id] = word;
      map[word.english.toLowerCase()] = word;
      return map;
    }, {});
  }, [words]);

  // ⭐ BATCH WORD OPERATIONS
  const batchUpdateWords = useCallback((updateFn) => {
    setWords(prevWords => {
      const newWords = updateFn(prevWords);
      return newWords.sort((a, b) => a.english.localeCompare(b.english));
    });
  }, [setWords]);

  // ⭐ OPTIMIZED ADD WORD - Enhanced with difficult flag
  const addWord = useCallback((wordData) => {
    if (!wordData.english?.trim() || !wordData.italian?.trim()) {
      throw new Error('English word and Italian translation are required');
    }

    const englishWord = wordData.english.trim().toLowerCase();
    
    if (!editingWord && wordMap[englishWord]) {
      throw new Error('Word already exists');
    }
    
    batchUpdateWords(prevWords => {
      if (editingWord) {
        return prevWords.map(word => 
          word.id === editingWord.id 
            ? { ...word, ...wordData, id: editingWord.id }
            : word
        );
      } else {
        const newWord = {
          id: Date.now() + Math.random(),
          english: wordData.english.trim(),
          italian: wordData.italian.trim(),
          group: wordData.group?.trim() || null,
          sentence: wordData.sentence?.trim() || null,
          notes: wordData.notes?.trim() || null,
          chapter: wordData.chapter?.trim() || null,
          learned: wordData.learned || false,
          difficult: wordData.difficult || false // ⭐ NEW: Difficult flag
        };
        return [...prevWords, newWord];
      }
    });
    
    setEditingWord(null);
  }, [editingWord, wordMap, batchUpdateWords]);

  // ⭐ FILTERED GETTERS - Enhanced with difficult words
  const getters = useMemo(() => ({
    getWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter),
    getDifficultWordsByChapter: (chapter) => words.filter(word => word.chapter === chapter && word.difficult),
    getAvailableChapters: () => {
      const chapters = new Set();
      words.forEach(word => {
        if (word.chapter) chapters.add(word.chapter);
      });
      return Array.from(chapters).sort((a, b) => {
        const aNum = parseInt(a);
        const bNum = parseInt(b);
        return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
      });
    },
    getChapterStats: (chapter) => {
      const chapterWords = words.filter(word => word.chapter === chapter);
      return {
        total: chapterWords.length,
        learned: chapterWords.filter(w => w.learned).length,
        unlearned: chapterWords.filter(w => !w.learned).length,
        difficult: chapterWords.filter(w => w.difficult).length,
        normal: chapterWords.filter(w => !w.difficult && !w.learned).length
      };
    }
  }), [words]);

  return {
    words,
    editingWord,
    setEditingWord,
    wordStats,
    addWord,
    
    removeWord: useCallback((id) => {
      batchUpdateWords(prevWords => prevWords.filter(word => word.id !== id));
      if (editingWord?.id === id) setEditingWord(null);
    }, [editingWord?.id, batchUpdateWords]),

    toggleWordLearned: useCallback((id) => {
      batchUpdateWords(prevWords => 
        prevWords.map(word => 
          word.id === id ? { ...word, learned: !word.learned } : word
        )
      );
    }, [batchUpdateWords]),

    // ⭐ NEW: Toggle difficult status
    toggleWordDifficult: useCallback((id) => {
      batchUpdateWords(prevWords => 
        prevWords.map(word => 
          word.id === id ? { ...word, difficult: !word.difficult } : word
        )
      );
    }, [batchUpdateWords]),

    clearAllWords: useCallback(() => {
      setWords(EMPTY_ARRAY);
      setEditingWord(null);
    }, [setWords]),

    importWords: useCallback((jsonText) => {
      const importedWords = JSON.parse(jsonText.trim());
      
      if (!Array.isArray(importedWords) || importedWords.length === 0) {
        throw new Error('Invalid JSON data');
      }

      const validWords = importedWords
        .filter(word => word?.english && word?.italian)
        .map(word => ({
          id: word.id || Date.now() + Math.random(),
          english: word.english,
          italian: word.italian,
          group: word.group || null,
          sentence: word.sentence || null,
          notes: word.notes || null,
          chapter: word.chapter || null,
          learned: word.learned || false,
          difficult: word.difficult || false // ⭐ NEW: Import difficult flag
        }));

      const existingEnglish = new Set(words.map(w => w.english.toLowerCase()));
      const newWords = validWords.filter(word => 
        !existingEnglish.has(word.english.toLowerCase())
      );

      if (newWords.length === 0) {
        throw new Error('All words already exist');
      }

      batchUpdateWords(prevWords => [...prevWords, ...newWords]);
      return newWords.length;
    }, [words, batchUpdateWords]),

    ...getters
  };
};

================================================================================

NOME FILE: layouts\AppLayout.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import { AppHeader } from '../components/layout/AppHeader';
import { AppNavigation } from '../components/layout/AppNavigation';
import { BackgroundParticles } from '../components/ui/BackgroundParticles';
import { NotificationToast } from '../components/ui/NotificationToast';
import { GlobalModals } from '../components/modals/GlobalModals';

export const AppLayout = ({ children }) => {
  const { testMode, showResults } = useAppContext();

  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-white to-cyan-50">
      <BackgroundParticles />
      <NotificationToast />
      <GlobalModals />
      
      <div className="relative z-10 max-w-6xl mx-auto p-6 space-y-8">
        {!testMode && !showResults && (
          <>
            <AppHeader />
            <AppNavigation />
          </>
        )}
        
        <main>
          {children}
        </main>
      </div>
    </div>
  );
};

================================================================================

NOME FILE: utils\categoryUtils.js

// /src/utils/categoryUtils.js
// This file contains utility functions for managing vocabulary categories.
// It provides functions to get the style for a category based on its name, and to retrieve a list of predefined groups.
// It is used to ensure consistent styling and categorization of vocabulary words in the application.

export const getCategoryStyle = (group) => {
  if (!group) return { 
    color: 'from-blue-400 via-blue-500 to-blue-600', 
    icon: '📚', 
    bgColor: 'bg-blue-500',
    bgGradient: 'bg-gradient-to-br from-blue-500 to-cyan-600'
  };
  
  const categoryMap = {
    'VERBI': { 
      color: 'from-red-400 via-red-500 to-red-600', 
      icon: '⚡', 
      bgColor: 'bg-red-500',
      bgGradient: 'bg-gradient-to-br from-red-500 to-orange-600'
    },
    'VERBI_IRREGOLARI': { 
      color: 'from-red-500 via-red-600 to-red-700', 
      icon: '🔄', 
      bgColor: 'bg-red-600',
      bgGradient: 'bg-gradient-to-br from-red-600 to-pink-600'
    },
    'SOSTANTIVI': { 
      color: 'from-blue-400 via-blue-500 to-blue-600', 
      icon: '🏷️', 
      bgColor: 'bg-blue-500',
      bgGradient: 'bg-gradient-to-br from-blue-500 to-indigo-600'
    },
    'AGGETTIVI': { 
      color: 'from-green-400 via-green-500 to-green-600', 
      icon: '🎨', 
      bgColor: 'bg-green-500',
      bgGradient: 'bg-gradient-to-br from-green-500 to-emerald-600'
    },
    'DESCRIZIONI_FISICHE': { 
      color: 'from-teal-400 via-teal-500 to-teal-600', 
      icon: '👤', 
      bgColor: 'bg-teal-500',
      bgGradient: 'bg-gradient-to-br from-teal-500 to-cyan-600'
    },
    'POSIZIONE_CORPO': { 
      color: 'from-purple-400 via-purple-500 to-purple-600', 
      icon: '🧘', 
      bgColor: 'bg-purple-500',
      bgGradient: 'bg-gradient-to-br from-purple-500 to-violet-600'
    },
    'EMOZIONI': { 
      color: 'from-pink-400 via-pink-500 to-pink-600', 
      icon: '❤️', 
      bgColor: 'bg-pink-500',
      bgGradient: 'bg-gradient-to-br from-pink-500 to-rose-600'
    },
    'EMOZIONI_POSITIVE': { 
      color: 'from-yellow-400 via-yellow-500 to-orange-500', 
      icon: '😊', 
      bgColor: 'bg-yellow-500',
      bgGradient: 'bg-gradient-to-br from-yellow-400 to-orange-500'
    },
    'EMOZIONI_NEGATIVE': { 
      color: 'from-gray-400 via-gray-500 to-gray-600', 
      icon: '😔', 
      bgColor: 'bg-gray-500',
      bgGradient: 'bg-gradient-to-br from-gray-500 to-slate-600'
    },
    'LAVORO': { 
      color: 'from-indigo-400 via-indigo-500 to-indigo-600', 
      icon: '💼', 
      bgColor: 'bg-indigo-500',
      bgGradient: 'bg-gradient-to-br from-indigo-500 to-blue-600'
    },
    'FAMIGLIA': { 
      color: 'from-pink-300 via-pink-400 to-rose-500', 
      icon: '👨‍👩‍👧‍👦', 
      bgColor: 'bg-pink-400',
      bgGradient: 'bg-gradient-to-br from-pink-400 to-rose-500'
    },
    'TECNOLOGIA': { 
      color: 'from-cyan-400 via-cyan-500 to-blue-500', 
      icon: '💻', 
      bgColor: 'bg-cyan-500',
      bgGradient: 'bg-gradient-to-br from-cyan-500 to-blue-500'
    },
    'VESTITI': { 
      color: 'from-purple-300 via-purple-400 to-pink-500', 
      icon: '👕', 
      bgColor: 'bg-purple-400',
      bgGradient: 'bg-gradient-to-br from-purple-400 to-pink-500'
    },
    'DEFAULT': { 
      color: 'from-emerald-400 via-emerald-500 to-cyan-500', 
      icon: '📚', 
      bgColor: 'bg-emerald-500',
      bgGradient: 'bg-gradient-to-br from-emerald-500 to-cyan-600'
    }
  };
  
  const upperGroup = group ? group.toUpperCase().trim() : '';
  return categoryMap[upperGroup] || categoryMap['DEFAULT'];
};

export const getPredefinedGroups = () => {
  return [
    'VERBI', 'VERBI_IRREGOLARI', 'SOSTANTIVI', 'AGGETTIVI',
    'DESCRIZIONI_FISICHE', 'POSIZIONE_CORPO', 'EMOZIONI',
    'EMOZIONI_POSITIVE', 'EMOZIONI_NEGATIVE', 'LAVORO',
    'FAMIGLIA', 'TECNOLOGIA', 'VESTITI'
  ].sort();
};

================================================================================

NOME FILE: utils\textUtils.js

// /src/utils/textUtils.js
// This file contains utility functions for formatting notes and calculating test results.
// It provides functions to format notes with specific keywords and to determine the result of a vocabulary test.
// The `formatNotes` function processes notes to highlight keywords, while the `getTestResult` function evaluates test statistics to provide feedback based on the user's performance.
// These utilities are essential for enhancing the user experience in a vocabulary learning application, making it easier for users to understand notes and assess their test results.
//  * @returns {Array} An array of React elements or strings representing the formatted notes.
//  */      
//

import React from 'react';

export const formatNotes = (notes) => {
  if (!notes) return null;
  
  const keywords = [
    'Altri Significati', 'Altre Traduzioni', 'Espressioni', 'Verbo Irregolare', 
    'Pronuncia', 'Sinonimi', 'Esempi', 'Attenzione', 'Nota', 'Importante',
    'Plurale irregolare', 'Tecnologia', 'Posizione', 'Contrario', 'Espressione',
    'Verbo', 'Phrasal verbs', 'Differenza', 'Abbreviazione', 'Sinonimo',
    'Tipico britannico', 'Vestiti', 'Preposizioni', 'Avverbio', 'Sostantivo',
    'Aggettivo', 'Congiunzione', 'Interiezione', 'Participio', 'Gerundio',
    'Passato', 'Presente', 'Futuro', 'Condizionale', 'Imperativo', 'Infinito',
    'Formale', 'Informale', 'Slang', 'Americano', 'Britannico', 'Australiano',
    'Tempo', 'Luogo', 'Modo', 'Causa', 'Effetto', 'Scopo', 'Confronto',
    'Origine', 'Destinazione', 'Materiale', 'Colore', 'Forma', 'Dimensione',
    'Quantità', 'Frequenza', 'Durata', 'Velocità', 'Temperatura', 'Peso',
    'Struttura', 'Espressione fissa', 'Figurativo', 'Specificità', 'Pattern',
    'Più specifico di'
  ];
  
  let formattedText = notes;
  
  keywords.forEach(keyword => {
    const regex = new RegExp(`(${keyword})\\s*:`, 'gi');
    formattedText = formattedText.replace(regex, `**$1:**`);
  });
  
  formattedText = formattedText.replace(/^([A-Za-z\s]+):/gm, '**$1:**');
  
  const parts = formattedText.split(/(\*\*[^*]+\*\*)/g);
  
  return parts.map((part, index) => {
    if (part.startsWith('**') && part.endsWith('**')) {
      const boldText = part.slice(2, -2);
      return React.createElement('span', { key: index, className: 'font-bold' }, boldText);
    }
    return part;
  });
};

export const getTestResult = (stats) => {
  const total = stats.correct + stats.incorrect;
  const percentage = total > 0 ? Math.round((stats.correct / total) * 100) : 0;
  
  if (percentage >= 80) {
    return { type: 'victory', message: 'Eccellente! 🏆', color: 'text-green-600', bgColor: 'bg-green-50' };
  } else if (percentage >= 60) {
    return { type: 'good', message: 'Buon lavoro! 👍', color: 'text-blue-600', bgColor: 'bg-blue-50' };
  } else {
    return { type: 'defeat', message: 'Continua a studiare! 📚', color: 'text-red-600', bgColor: 'bg-red-50' };
  }
};

================================================================================

NOME FILE: views\MainView.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import { useNotification } from '../contexts/NotificationContext';
import { ControlPanel } from '../components/main/ControlPanel';
import JSONManager from '../components/JSONManager';
import AddWordForm from '../components/AddWordForm';
import WordsList from '../components/WordsList';

export const MainView = React.memo(() => {
  const {
    words,
    editingWord,
    showWordsList,
    dispatch,
    addWord,
    toggleWordLearned,
    toggleWordDifficult, // ⭐ NEW: Difficult toggle
    importWords,
    getAvailableChapters,
    getChapterStats,
    wordStats
  } = useAppContext();

  const { showSuccess, showError, showWarning } = useNotification();

  const handleStartTest = React.useCallback(() => {
    const availableWords = words.filter(word => !word.learned);
    if (availableWords.length === 0) {
      showWarning('⚠️ Nessuna parola disponibile per il test!');
      return;
    }
    dispatch({ type: 'SET_SHOW_CHAPTER_SELECTOR', payload: true });
  }, [words, dispatch, showWarning]);

  const handleAddWord = React.useCallback((wordData) => {
    try {
      addWord(wordData);
      dispatch({ type: 'SET_EDITING_WORD', payload: null });
      showSuccess(
        editingWord 
          ? `✅ Parola "${wordData.english}" modificata!`
          : `✅ Parola "${wordData.english}" aggiunta!`
      );
    } catch (error) {
      showError(error, 'Add Word');
    }
  }, [addWord, editingWord, dispatch, showSuccess, showError]);

  const handleRemoveWord = React.useCallback((id) => {
    const wordToDelete = words.find(word => word.id === id);
    if (wordToDelete) {
      dispatch({ type: 'SET_CONFIRM_DELETE', payload: wordToDelete });
    }
  }, [words, dispatch]);

  const handleToggleWordLearned = React.useCallback((id) => {
    const word = words.find(w => w.id === id);
    if (word) {
      toggleWordLearned(id);
      showSuccess(
        word.learned 
          ? `📖 "${word.english}" segnata come da studiare`
          : `✅ "${word.english}" segnata come appresa!`
      );
    }
  }, [words, toggleWordLearned, showSuccess]);

  // ⭐ NEW: Handle difficult toggle
  const handleToggleWordDifficult = React.useCallback((id) => {
    const word = words.find(w => w.id === id);
    if (word) {
      toggleWordDifficult(id);
      showSuccess(
        word.difficult 
          ? `📚 "${word.english}" rimossa dalle parole difficili`
          : `⭐ "${word.english}" segnata come difficile!`
      );
    }
  }, [words, toggleWordDifficult, showSuccess]);

  const handleImportWords = React.useCallback((jsonText) => {
    try {
      const count = importWords(jsonText);
      showSuccess(`✅ ${count} parole importate con successo!`);
      return count;
    } catch (error) {
      showError(error, 'Import Words');
      throw error;
    }
  }, [importWords, showSuccess, showError]);

  return (
    <div className="space-y-8 animate-fade-in">
      <ControlPanel 
        onStartTest={handleStartTest}
        onClearAllWords={() => dispatch({ type: 'SET_SHOW_CONFIRM_CLEAR', payload: true })}
        words={words}
        wordStats={wordStats}
        getAvailableChapters={getAvailableChapters}
        getChapterStats={getChapterStats}
      />

      <JSONManager 
        words={words}
        onImportWords={handleImportWords}
      />

      <AddWordForm
        onAddWord={handleAddWord}
        editingWord={editingWord}
        onClearForm={() => dispatch({ type: 'SET_EDITING_WORD', payload: null })}
      />

      <WordsList
        words={words}
        onEditWord={(word) => dispatch({ type: 'SET_EDITING_WORD', payload: word })}
        onRemoveWord={handleRemoveWord}
        onToggleLearned={handleToggleWordLearned}
        onToggleDifficult={handleToggleWordDifficult} // ⭐ NEW: Difficult toggle
        showWordsList={showWordsList}
        setShowWordsList={() => dispatch({ type: 'TOGGLE_WORDS_LIST' })}
      />
    </div>
  );
});

================================================================================

NOME FILE: views\ResultsView.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext';
import TestResults from '../components/TestResults';

export const ResultsView = React.memo(() => {
  const {
    wrongWords,
    startNewTest,
    resetTest,
    // ⭐ PROVA TUTTE LE POSSIBILI PROPRIETÀ DEL TEST CORRENTE
    testCounters,
    getTestSummary,
    currentTestResults,
    lastTestStats,
    testResults,
    currentTestStats,
    finalTestResults
  } = useAppContext();

  // ⭐ DEBUG: Vediamo tutti i dati disponibili (ESCLUDENDO stats generali)
  console.log('🎯 ResultsView - Dati test corrente:', {
    testCounters,
    getTestSummary: getTestSummary ? getTestSummary() : null,
    currentTestResults,
    lastTestStats,
    testResults,
    currentTestStats,
    finalTestResults,
    wrongWords: wrongWords?.length || 0
  });

  // ⭐ LOGICA: Trova SOLO i dati del test appena completato (NON stats generali)
  const getTestResultData = () => {
    // 1. Prova testCounters (che funzionava durante il test)
    if (testCounters && (testCounters.correct >= 0 && testCounters.incorrect >= 0)) {
      console.log('✅ Usando testCounters:', testCounters);
      return testCounters;
    }
    
    // 2. Prova getTestSummary
    const summary = getTestSummary && getTestSummary();
    if (summary && (summary.correct >= 0 && summary.incorrect >= 0)) {
      console.log('✅ Usando summary:', summary);
      return {
        correct: summary.correct,
        incorrect: summary.incorrect
      };
    }
    
    // 3. Prova currentTestResults
    if (currentTestResults && (currentTestResults.correct >= 0 || currentTestResults.incorrect >= 0)) {
      console.log('✅ Usando currentTestResults:', currentTestResults);
      return currentTestResults;
    }
    
    // 4. Prova lastTestStats
    if (lastTestStats && (lastTestStats.correct >= 0 || lastTestStats.incorrect >= 0)) {
      console.log('✅ Usando lastTestStats:', lastTestStats);
      return lastTestStats;
    }
    
    // 5. Prova testResults
    if (testResults && (testResults.correct >= 0 || testResults.incorrect >= 0)) {
      console.log('✅ Usando testResults:', testResults);
      return testResults;
    }
    
    // 6. Prova currentTestStats
    if (currentTestStats && (currentTestStats.correct >= 0 || currentTestStats.incorrect >= 0)) {
      console.log('✅ Usando currentTestStats:', currentTestStats);
      return currentTestStats;
    }
    
    // 7. Prova finalTestResults
    if (finalTestResults && (finalTestResults.correct >= 0 || finalTestResults.incorrect >= 0)) {
      console.log('✅ Usando finalTestResults:', finalTestResults);
      return finalTestResults;
    }
    
    // 8. ULTIMO TENTATIVO: Calcola dalle parole sbagliate
    if (wrongWords && Array.isArray(wrongWords)) {
      // Se ho 5 parole sbagliate su un totale di parole del test...
      // Dovrei avere anche il totale del test da qualche parte
      const incorrect = wrongWords.length;
      
      // Prova a vedere se c'è un totale nelle funzioni
      const summary = getTestSummary && getTestSummary();
      if (summary && summary.total) {
        const correct = summary.total - incorrect;
        console.log('✅ Calcolato da wrongWords + summary.total:', { correct, incorrect });
        return { correct, incorrect };
      }
      
      // Fallback estremo: assumo che sia un test piccolo
      console.log('⚠️ Usando fallback da wrongWords:', { correct: 0, incorrect });
      return { correct: 0, incorrect };
    }
    
    // FALLBACK FINALE: nessun dato trovato
    console.log('❌ Nessun dato del test trovato, usando default');
    return { correct: 0, incorrect: 0 };
  };

  const finalTestData = getTestResultData();

  console.log('🎯 ResultsView - Dati finali scelti:', finalTestData);

  return (
    <TestResults
      stats={finalTestData}
      wrongWords={wrongWords}
      onStartNewTest={startNewTest}
      onResetTest={resetTest}
    />
  );
});

================================================================================

NOME FILE: views\StatsManagerView.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext'; // ✅ Fixed: named export
import StatsManager from '../components/StatsManager'; // ✅ Fixed: default import

export const StatsManagerView = React.memo(() => {
  const {
    refreshData,
    forceUpdate
  } = useAppContext();

  const handleDataUpdated = React.useCallback(() => {
    setTimeout(() => {
      refreshData();
    }, 100);
  }, [refreshData]);

  return (
    <StatsManager 
      onDataUpdated={handleDataUpdated}
      forceUpdate={forceUpdate}
    />
  );
});

================================================================================

NOME FILE: views\StatsView.js

import React from 'react';
import { useAppContext } from '../contexts/AppContext'; // ✅ Fixed: named export
import StatsOverview from '../components/StatsOverview'; // ✅ Fixed: default import

export const StatsView = React.memo(() => {
  const {
    testHistory,
    words,
    clearHistoryOnly,
    dispatch,
    forceUpdate
  } = useAppContext();

  return (
    <StatsOverview
      testHistory={testHistory}
      words={words}
      onClearHistory={clearHistoryOnly}
      onGoToMain={() => dispatch({ type: 'SET_VIEW', payload: 'main' })}
      forceUpdate={forceUpdate}
    />
  );
});

================================================================================

NOME FILE: views\TestView.js

import React, { useState, useEffect, useRef } from 'react';
import { useAppContext } from '../contexts/AppContext';
import { Card } from '../components/ui/card';
import { Button } from '../components/ui/button';
import TestCard from '../components/TestCard';
import { RotateCcw, Check, X, HelpCircle, Clock, Lightbulb } from 'lucide-react';

export const TestView = React.memo(() => {
  const {
    currentWord,
    showMeaning,
    setShowMeaning,
    handleAnswer,
    resetTest,
    getTestProgress,
    getTestSummary,
    showHint,
    toggleHint,
    hintUsed
  } = useAppContext();

  // ⭐ FIXED: Local timer management for UI display
  const [currentWordTime, setCurrentWordTime] = useState(0);
  const timerRef = useRef(null);
  const wordStartTimeRef = useRef(null);

  const progress = getTestProgress();
  const summary = getTestSummary();

  // ⭐ FIXED: Proper timer effect that starts when word appears
  useEffect(() => {
    // Clear any existing timer
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }

    // Start timer when word appears and meaning is not shown
    if (currentWord && !showMeaning) {
      console.log('🕐 Starting UI timer for word:', currentWord.english);
      setCurrentWordTime(0);
      wordStartTimeRef.current = Date.now();
      
      timerRef.current = setInterval(() => {
        if (wordStartTimeRef.current) {
          const elapsed = Math.floor((Date.now() - wordStartTimeRef.current) / 1000);
          setCurrentWordTime(elapsed);
        }
      }, 1000);
    } else {
      // Reset timer when showing meaning or no word
      setCurrentWordTime(0);
      wordStartTimeRef.current = null;
    }

    // Cleanup function
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [currentWord, showMeaning]);

  // ⭐ FIXED: Stop timer when component unmounts or test ends
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  // ⭐ ENHANCED: Handle answer with proper timer cleanup
  const handleAnswerWithTimer = (isCorrect) => {
    console.log('📝 Answer given, stopping timer at:', currentWordTime, 'seconds');
    
    // Stop the timer immediately
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
    
    // Call the original handler
    handleAnswer(isCorrect);
  };

  // ⭐ NEW: Format time helper
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <>
      {/* ⭐ ENHANCED: Test Header with Fixed Timer */}
      <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-2xl overflow-hidden">
        <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-1">
          <div className="bg-white rounded-2xl p-6">
            <div className="flex justify-between items-center mb-4">
              <div>
                <h2 className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                  Test in Corso
                </h2>
                <p className="text-gray-600">Parola {progress.current} di {progress.total}</p>
                <div className="flex items-center gap-4 text-sm text-gray-500 mt-1">
                  <span>Accuratezza: {summary.accuracy}%</span>
                  <span>Rimanenti: {summary.remaining}</span>
                  {progress.hints > 0 && (
                    <span className="flex items-center gap-1 text-orange-600">
                      <Lightbulb className="w-4 h-4" />
                      Aiuti: {progress.hints}
                    </span>
                  )}
                  {summary.totalTime > 0 && (
                    <span className="flex items-center gap-1 text-purple-600">
                      <Clock className="w-4 h-4" />
                      Totale: {formatTime(summary.totalTime)}
                    </span>
                  )}
                </div>
              </div>
              <div className="text-right">
                <div className="flex gap-4">
                  <div className="text-center">
                    <div className="text-2xl font-bold text-green-600">{summary.correct}</div>
                    <div className="text-sm text-green-700">Corrette</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-red-600">{summary.incorrect}</div>
                    <div className="text-sm text-red-700">Sbagliate</div>
                  </div>
                  {/* ⭐ FIXED: Current word timer display */}
                  <div className="text-center">
                    <div className={`text-2xl font-bold flex items-center gap-1 transition-colors ${
                      currentWordTime > 30 ? 'text-red-600' : 
                      currentWordTime > 15 ? 'text-orange-600' : 'text-blue-600'
                    }`}>
                      <Clock className="w-6 h-6" />
                      {formatTime(currentWordTime)}
                    </div>
                    <div className="text-sm text-blue-700">Tempo Parola</div>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Enhanced Progress bar */}
            <div className="relative">
              <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-blue-500 to-purple-600 rounded-full transition-all duration-500 ease-out relative"
                  style={{ width: `${progress.percentage}%` }}
                >
                  <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer"></div>
                </div>
              </div>
              <div className="text-center mt-2 text-sm font-medium text-gray-600">
                {progress.percentage}% completato
                {summary.avgTimePerWord > 0 && (
                  <span className="ml-4 text-purple-600">
                    Media: {summary.avgTimePerWord}s/parola
                  </span>
                )}
              </div>
            </div>
          </div>
        </div>
      </Card>

      {/* ⭐ ENHANCED: Hint Display */}
      {showHint && currentWord?.sentence && (
        <Card className="backdrop-blur-sm bg-orange-50 border-2 border-orange-200 shadow-xl rounded-2xl overflow-hidden animate-fade-in">
          <div className="bg-gradient-to-r from-orange-400 to-yellow-400 p-1">
            <div className="bg-white rounded-2xl p-4">
              <div className="flex items-center gap-3 mb-3">
                <Lightbulb className="w-6 h-6 text-orange-600" />
                <h3 className="text-lg font-bold text-orange-800">💡 Suggerimento</h3>
                <span className="text-sm bg-orange-100 text-orange-700 px-3 py-1 rounded-full">
                  Frase di contesto
                </span>
              </div>
              <div className="text-lg italic text-orange-900 bg-orange-50 p-4 rounded-xl border border-orange-200">
                "{currentWord.sentence}"
              </div>
              <p className="text-sm text-orange-600 mt-2 text-center">
                ⚠️ Questo aiuto verrà conteggiato nelle statistiche
              </p>
            </div>
          </div>
        </Card>
      )}

      {/* Test Card Area */}
      {currentWord && (
        <div className="relative min-h-[80vh] flex items-center justify-center">
          <TestCard 
            word={currentWord}
            showMeaning={showMeaning}
            onFlip={() => setShowMeaning(!showMeaning)}
          />

          {/* ⭐ FIXED: Answer Buttons with timer cleanup */}
          <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 w-full max-w-2xl">
            <div className="flex justify-center space-x-6 mb-6">
              {showMeaning ? (
                <>
                  <Button
                    onClick={() => handleAnswerWithTimer(true)}
                    className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-8 py-4 text-lg rounded-2xl shadow-2xl transform transition-all duration-200 hover:scale-105 border-0"
                  >
                    <Check className="w-6 h-6 mr-3" />
                    Sapevo la risposta!
                  </Button>
                  <Button
                    onClick={() => handleAnswerWithTimer(false)}
                    className="bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white px-8 py-4 text-lg rounded-2xl shadow-2xl transform transition-all duration-200 hover:scale-105 border-0"
                  >
                    <X className="w-6 h-6 mr-3" />
                    Non la sapevo
                  </Button>
                </>
              ) : (
                <div className="text-center space-y-4">
                  <p className="text-xl text-gray-700 font-medium">🎯 Clicca la carta per vedere la traduzione</p>
                  <p className="text-sm text-gray-500">Cerca di ricordare il significato prima di girare</p>
                  
                  {/* ⭐ ENHANCED: Hint Button with timer awareness */}
                  {currentWord?.sentence && (
                    <div className="flex justify-center">
                      <Button
                        onClick={toggleHint}
                        disabled={hintUsed}
                        className={`${
                          showHint 
                            ? 'bg-gradient-to-r from-orange-500 to-yellow-500 hover:from-orange-600 hover:to-yellow-600' 
                            : hintUsed
                              ? 'bg-gray-400 cursor-not-allowed'
                              : 'bg-gradient-to-r from-orange-400 to-yellow-400 hover:from-orange-500 hover:to-yellow-500'
                        } text-white px-6 py-3 text-base rounded-xl shadow-lg transform transition-all duration-200 hover:scale-105 border-0 disabled:transform-none disabled:hover:scale-100`}
                        title={hintUsed ? "Aiuto già utilizzato per questa parola" : "Mostra frase di contesto"}
                      >
                        <HelpCircle className="w-5 h-5 mr-2" />
                        {showHint ? '🔍 Nascondi Aiuto' : hintUsed ? '✅ Aiuto Usato' : '💡 Chiedi Aiuto'}
                      </Button>
                    </div>
                  )}
                  
                  {/* ⭐ NEW: Timer indicator for user */}
                  <div className="mt-4 text-center">
                    <div className={`inline-flex items-center gap-2 px-4 py-2 rounded-full transition-colors ${
                      currentWordTime > 30 ? 'bg-red-100 text-red-700' : 
                      currentWordTime > 15 ? 'bg-orange-100 text-orange-700' : 'bg-blue-100 text-blue-700'
                    }`}>
                      <Clock className="w-4 h-4" />
                      <span className="font-mono font-bold">{formatTime(currentWordTime)}</span>
                      <span className="text-sm">
                        {currentWordTime > 30 ? 'Tempo lungo!' : 
                         currentWordTime > 15 ? 'Continua a riflettere...' : 'Tempo di riflessione'}
                      </span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}
      
      {/* End Test Button */}
      <div className="flex justify-center">
        <Button 
          onClick={resetTest} 
          variant="outline"
          className="bg-white/80 backdrop-blur-sm border border-gray-200 hover:bg-white/90 rounded-xl px-6 py-3 shadow-lg"
        >
          <RotateCcw className="w-4 h-4 mr-2" />
          Termina Test
        </Button>
      </div>
    </>
  );
});

================================================================================


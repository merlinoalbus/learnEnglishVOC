NOME FILE: docker-compose.yml

version: '3.8'

services:
  vocabulary-app:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: vocabulary-learning-app
    restart: unless-stopped
    
    ports:
      - "30001:80"
    
    environment:
      - NODE_ENV=production
      - REACT_APP_VERSION=1.0.0
    
    networks:
      - vocabulary_network
    
    # Health check (ora integrato nel Dockerfile)
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    
    # Limiti risorse per TrueNAS Scale
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'
        reservations:
          memory: 128M
          cpus: '0.25'
    
    labels:
      # Labels per TrueNAS Scale management
      - "com.truenas.app=vocabulary-learning"
      - "com.truenas.app.version=1.0.0"
      - "com.truenas.app.description=Vocabulary Learning App con AI Assistant"
      - "traefik.enable=true"
      - "traefik.http.routers.vocabulary.rule=Host(`vocabulary.local`)"
      - "traefik.http.services.vocabulary.loadbalancer.server.port=80"

# ==========================================
# Versione alternativa per development
# ==========================================
  vocabulary-app-dev:
    build:
      context: .
      dockerfile: Dockerfile
      target: builder
    container_name: vocabulary-learning-app-dev
    restart: unless-stopped
    profiles: ["dev"]
    
    command: npm start
    
    ports:
      - "30002:3000"
    
    volumes:
      - .:/app
      - /app/node_modules
      - npm_cache:/root/.npm
    
    environment:
      - NODE_ENV=development
      - REACT_APP_VERSION=1.0.0-dev
      - CHOKIDAR_USEPOLLING=true
    
    networks:
      - vocabulary_network

# Network isolato
networks:
  vocabulary_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# Persistent volumes
volumes:
  npm_cache:
    driver: local

================================================================================

NOME FILE: Dockerfile

# Multi-stage build per ottimizzare dimensioni e sicurezza
FROM node:18-alpine AS builder

# Imposta working directory
WORKDIR /app

# Installa dipendenze di sistema necessarie
RUN apk add --no-cache git python3 make g++

# Copia package files per sfruttare cache Docker
COPY package*.json ./

# Installa dipendenze in modo più robusto
RUN npm install --silent && npm cache clean --force

# Copia tutto il codice sorgente
COPY . .

# Build dell'applicazione React
RUN npm run build

# ==========================================
# Stage 2: Production con Nginx
# ==========================================
FROM nginx:alpine AS production

# Installa wget per health check
RUN apk add --no-cache wget

# Copia i file build dalla stage precedente
COPY --from=builder /app/build /usr/share/nginx/html

# Copia configurazione Nginx custom
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Crea cartella per logs
RUN mkdir -p /var/log/nginx

# Esponi porta 80
EXPOSE 80

# Health check per verificare che l'app funzioni
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost/health || exit 1

# Avvia Nginx
CMD ["nginx", "-g", "daemon off;"]

================================================================================

NOME FILE: jsconfig.json

{
    "compilerOptions": {
        "module": "ESNext",
        "moduleResolution": "Bundler",
        "target": "ES2022",
        "jsx": "react-jsx",
        "allowImportingTsExtensions": true,
        "strictNullChecks": true,
        "strictFunctionTypes": true
    },
    "exclude": [
        "node_modules",
        "**/node_modules/*"
    ]
}

================================================================================

NOME FILE: nginx.conf

server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html index.htm;

    # Configurazione per React SPA (Single Page Application)
    location / {
        try_files $uri $uri/ /index.html;
        
        # Headers di sicurezza
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline' 'unsafe-eval'" always;
    }

    # Cache per file statici
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # Compressione gzip
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # Gestione errori
    error_page 404 /index.html;
    error_page 500 502 503 504 /50x.html;
    
    location = /50x.html {
        root /usr/share/nginx/html;
    }

    # Log di accesso
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
}

================================================================================

NOME FILE: package.json

{
  "name": "vocabulary-learning-app",
  "version": "1.0.0",
  "description": "App per lo studio del vocabolario inglese con AI Assistant e statistiche avanzate",
  "private": true,
  "homepage": ".",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "recharts": "^2.8.0",
    "lucide-react": "^0.263.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "GENERATE_SOURCEMAP=false react-scripts build",
    "test": "react-scripts test --watchAll=false --coverage=false",
    "eject": "react-scripts eject",
    "build:analyze": "npm run build && npx source-map-explorer 'build/static/js/*.js'",
    "serve": "npx serve -s build -l 3000",
    "docker:build": "docker build -t vocabulary-app .",
    "docker:run": "docker run -p 3000:80 vocabulary-app",
    "docker:dev": "docker-compose --profile dev up",
    "docker:prod": "docker-compose up"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ],
    "rules": {
      "react-hooks/exhaustive-deps": "warn",
      "no-unused-vars": "warn"
    }
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "tailwindcss": "^3.3.0",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.24"
  },
  "engines": {
    "node": ">=16.0.0",
    "npm": ">=8.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/merlinoalbus/learnEnglishVOC.git"
  },
  "keywords": [
    "vocabulary",
    "learning",
    "english",
    "react",
    "ai-assistant",
    "education"
  ],
  "author": "merlinoalbus",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/merlinoalbus/learnEnglishVOC/issues"
  }
}

================================================================================

NOME FILE: postcss.config.js

// postcss.config.js
// This file is part of the Tailwind CSS configuration for the Vocabulary Learning App.
// It sets up PostCSS with Tailwind CSS and Autoprefixer to process CSS files.
// The configuration ensures that Tailwind CSS styles are applied correctly and that vendor prefixes are added for better browser compatibility.
// The PostCSS configuration is essential for building the application's styles and ensuring a consistent look across different browsers.
// It is used in conjunction with Tailwind CSS to create a responsive and modern user interface. 

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================================================================================

NOME FILE: README.md

// README.md - Vocabulary App Refactored Structure
# 📚 Vocabulary Learning App - Refactored

## 🎯 Overview
App modulare per l'apprendimento del vocabolario inglese con statistiche avanzate, completamente refactorizzata per migliorare la manutenibilità e la scalabilità.

## 🏗️ Struttura Modulare

### 📁 Hooks Personalizzati (`/src/hooks/`)
- **`useLocalStorage.js`** - Gestione persistente del localStorage con error handling
- **`useWords.js`** - Gestione completa delle parole (CRUD operations)
- **`useTest.js`** - Logica del sistema di test e quiz
- **`useNotification.js`** - Sistema di notifiche toast

### 🧩 Componenti (`/src/components/`)
- **`TestCard.js`** - Carta 3D interattiva per visualizzazione parole
- **`TestResults.js`** - Schermata risultati con analisi dettagliata
- **`AddWordForm.js`** - Form avanzato per aggiunta/modifica parole
- **`WordsList.js`** - Lista interattiva del vocabolario
- **`JSONManager.js`** - Gestione import/export dati JSON
- **`StatsOverview.js`** - Dashboard statistiche con grafici

### 🛠️ Utilità (`/src/utils/`)
- **`categoryUtils.js`** - Gestione categorie e stili
- **`textUtils.js`** - Formattazione testi e risultati

### 🎨 UI Components (`/src/components/ui/`)
- **`button.js`** - Componente Button riutilizzabile
- **`card.js`** - Sistema di Card modulari
- **`input.js`** - Input components
- **`modal.js`** - Sistema modale
- **`textarea.js`** - Textarea component

## ✨ Miglioramenti della Refactorizzazione

### 🔧 Separazione delle Responsabilità
- **Hooks** gestiscono la logica di business
- **Componenti** si occupano solo della UI
- **Utilità** per funzioni pure e helpers

### 📈 Vantaggi
1. **Manutenibilità**: Codice più organizzato e facile da modificare
2. **Riusabilità**: Componenti e hooks riutilizzabili
3. **Testabilità**: Ogni modulo è testabile indipendentemente
4. **Scalabilità**: Struttura pronta per nuove funzionalità
5. **Performance**: Ottimizzazioni con useMemo e useCallback

### 🎯 Error Handling Migliorato
- Gestione errori centralizzata nei hooks
- Notifiche user-friendly per ogni operazione
- Validazione dati robusta

### 💾 Gestione Stato Ottimizzata
- localStorage gestito tramite hook dedicato
- Stato locale separato da quello globale
- Riduzione re-render non necessari

## 🚀 Come Utilizzare

### Installazione
```bash
npm install
npm start
```

### Struttura File Principale
```
src/
├── hooks/
│   ├── useLocalStorage.js
│   ├── useWords.js
│   ├── useTest.js
│   └── useNotification.js
├── components/
│   ├── ui/
│   ├── TestCard.js
│   ├── TestResults.js
│   ├── AddWordForm.js
│   ├── WordsList.js
│   ├── JSONManager.js
│   └── StatsOverview.js
├── utils/
│   ├── categoryUtils.js
│   └── textUtils.js
├── App.js (refactored)
├── App.css
└── index.js
```

## 🔄 Migrazione dal Codice Originale

### Cosa è Cambiato
1. **App.js**: Ridotto da ~800 righe a ~200 righe
2. **Hooks**: Logica estratta in hooks riutilizzabili
3. **Componenti**: UI separata in componenti specifici
4. **Utilità**: Funzioni pure estratte in moduli dedicati

### Compatibilità
- ✅ Tutte le funzionalità originali mantenute
- ✅ Stessi dati localStorage compatibili
- ✅ Stesso design e UX
- ✅ Performance migliorate

## 🧪 Testing Strategy

### Hooks Testing
```javascript
// Esempio test per useWords
import { renderHook, act } from '@testing-library/react';
import { useWords } from '../hooks/useWords';

test('should add word correctly', () => {
  const { result } = renderHook(() => useWords());
  
  act(() => {
    result.current.addWord({
      english: 'test',
      italian: 'prova'
    });
  });
  
  expect(result.current.words).toHaveLength(1);
});
```

### Component Testing
```javascript
// Esempio test per TestCard
import { render, fireEvent } from '@testing-library/react';
import TestCard from '../components/TestCard';

test('should flip card on click', () => {
  const mockWord = { english: 'test', italian: 'prova' };
  const mockOnFlip = jest.fn();
  
  const { getByRole } = render(
    <TestCard word={mockWord} showMeaning={false} onFlip={mockOnFlip} />
  );
  
  fireEvent.click(getByRole('button'));
  expect(mockOnFlip).toHaveBeenCalled();
});
```

## 🔮 Roadmap Future

### Prossimi Miglioramenti
1. **Context API** per stato globale più complesso
2. **React Query** per caching avanzato
3. **Virtualization** per liste grandi
4. **Service Worker** per offline support
5. **Unit Tests** completi per ogni modulo

### Nuove Funzionalità Potenziali
- 🔊 Audio pronuncia parole
- 🌐 Sincronizzazione cloud
- 👥 Modalità multiplayer
- 📱 PWA support
- 🎮 Gamification avanzata

## 📝 Note Tecniche

### Patterns Utilizzati
- **Custom Hooks** per logica riutilizzabile
- **Compound Components** per UI modulari
- **Render Props** dove appropriato
- **Error Boundaries** per error handling

### Performance Optimizations
- `useMemo` per calcoli costosi
- `useCallback` per funzioni stabili
- `React.memo` per componenti puri
- Lazy loading per componenti pesanti

### Accessibilità
- ARIA labels appropriati
- Navigazione keyboard-friendly
- Contrasti colori conformi WCAG
- Screen reader support

---

## 🤝 Contribuire

1. Fork del repository
2. Crea feature branch (`git checkout -b feature/amazing-feature`)
3. Commit changes (`git commit -m 'Add amazing feature'`)
4. Push to branch (`git push origin feature/amazing-feature`)
5. Open Pull Request

---

**Vocabulary Master** - La tua app intelligente per imparare l'inglese! 🚀

================================================================================

NOME FILE: tailwind.config.js

// tailwind.config.js
// This file is part of the Tailwind CSS configuration for the Vocabulary Learning App.
// It defines the content paths, theme extensions, colors, border radii, keyframes, and animations used throughout the application.
// The configuration allows for custom styling and theming, ensuring a consistent look and feel across the application.
// It is essential for building the application's styles and ensuring a responsive and modern user interface.

module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
    "./public/index.html"
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
        "fade-in": {
          "0%": { opacity: 0 },
          "100%": { opacity: 1 },
        },
        "slide-in": {
          "0%": { transform: "translateY(20px)", opacity: 0 },
          "100%": { transform: "translateY(0)", opacity: 1 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "fade-in": "fade-in 0.5s ease-out",
        "slide-in": "slide-in 0.3s ease-out",
      },
    },
  },
  plugins: [],
}

================================================================================

NOME FILE: src\App.css

/* App.css - Stili aggiornati per la nuova versione */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  color: #333;
}

.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ===== HEADER MIGLIORATO ===== */
.app-header {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  color: white;
  padding: 1.5rem 2rem;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

.header-content {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 2rem;
}

.header-main h1 {
  font-size: 2.2rem;
  margin-bottom: 0.5rem;
  font-weight: 700;
}

.header-main p {
  opacity: 0.9;
  font-size: 1.1rem;
}

.header-stats {
  display: flex;
  gap: 1.5rem;
  align-items: center;
}

.header-stat {
  text-align: center;
  min-width: 60px;
}

.header-stat span {
  display: block;
  font-size: 1.4rem;
  font-weight: bold;
  line-height: 1;
}

.header-stat small {
  font-size: 0.8rem;
  opacity: 0.8;
  margin-top: 0.2rem;
  display: block;
}

.header-stat.streak span {
  font-size: 1.2rem;
}

/* ===== NAVIGATION MIGLIORATA ===== */
.app-nav {
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  padding: 0.5rem 0;
  position: sticky;
  top: 0;
  z-index: 100;
}

.nav-container {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  gap: 0.5rem;
  padding: 0 1rem;
  justify-content: center;
  overflow-x: auto;
}

.nav-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.3rem;
  padding: 0.8rem 1rem;
  border: none;
  background: transparent;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-width: 80px;
  position: relative;
  text-decoration: none;
  color: #555;
}

.nav-btn:hover {
  background: rgba(52, 152, 219, 0.1);
  transform: translateY(-1px);
}

.nav-btn.active {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
  transform: translateY(-1px);
}

.nav-icon {
  font-size: 1.3rem;
  line-height: 1;
}

.nav-text {
  font-size: 0.8rem;
  font-weight: 500;
  white-space: nowrap;
}

.nav-badge {
  position: absolute;
  top: 0.2rem;
  right: 0.2rem;
  background: #e74c3c;
  color: white;
  font-size: 0.7rem;
  padding: 0.1rem 0.4rem;
  border-radius: 10px;
  min-width: 18px;
  text-align: center;
  line-height: 1.2;
  font-weight: bold;
}

/* ===== INDICATORE SEZIONE ===== */
.section-indicator {
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(10px);
  padding: 0.8rem 2rem;
  display: flex;
  align-items: center;
  gap: 0.8rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.indicator-icon {
  font-size: 1.2rem;
}

.indicator-text {
  font-weight: 600;
  color: #2c3e50;
  font-size: 1rem;
}

/* ===== MAIN CONTENT ===== */
.app-main {
  flex: 1;
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  width: 100%;
}

/* ===== SCHERMATA INIZIALE TEST ===== */
.start-test {
  text-align: center;
  padding: 3rem 2rem;
}

.start-test-content {
  max-width: 600px;
  margin: 0 auto;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  padding: 3rem 2rem;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
}

.start-test h2 {
  color: #2c3e50;
  margin-bottom: 2rem;
  font-size: 2rem;
}

.test-info {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 1rem;
  margin: 2rem 0;
}

.info-card {
  background: linear-gradient(145deg, #f8f9fa, #ffffff);
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 1.2rem 0.8rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  transition: transform 0.2s ease;
}

.info-card:hover {
  transform: translateY(-2px);
}

.info-icon {
  font-size: 1.8rem;
  line-height: 1;
}

.info-card strong {
  font-size: 1.5rem;
  color: #2c3e50;
  font-weight: bold;
}

.info-card p {
  font-size: 0.8rem;
  color: #7f8c8d;
  text-align: center;
  margin: 0;
}

.btn-large {
  font-size: 1.1rem;
  padding: 1rem 2rem;
  margin: 2rem 0 1rem 0;
}

.help-text {
  color: #7f8c8d;
  font-style: italic;
  margin-top: 1rem;
}

/* ===== PULSANTI GENERALI ===== */
.btn {
  padding: 0.8rem 1.5rem;
  border: none;
  border-radius: 10px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  text-decoration: none;
  justify-content: center;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none !important;
}

.btn-primary {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
}

.btn-primary:hover:not(:disabled) {
  background: linear-gradient(145deg, #2980b9, #21618c);
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.btn-secondary {
  background: linear-gradient(145deg, #95a5a6, #7f8c8d);
  color: white;
  box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
}

.btn-secondary:hover:not(:disabled) {
  background: linear-gradient(145deg, #7f8c8d, #6c7b7d);
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
}

/* ===== ERROR VIEW ===== */
.error-view {
  text-align: center;
  padding: 3rem 2rem;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  max-width: 500px;
  margin: 2rem auto;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
}

.error-view h2 {
  color: #e74c3c;
  margin-bottom: 1rem;
}

.error-view p {
  color: #7f8c8d;
  margin-bottom: 2rem;
}

/* ===== FOOTER MIGLIORATO ===== */
.app-footer {
  background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
  color: white;
  padding: 1.5rem 2rem;
  margin-top: auto;
}

.footer-content {
  max-width: 1200px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
}

.footer-info p {
  margin: 0;
  font-size: 0.95rem;
}

.footer-stats {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  font-size: 0.9rem;
  opacity: 0.9;
}

.footer-stats span {
  white-space: nowrap;
}

/* ===== RESPONSIVE DESIGN ===== */
@media (max-width: 768px) {
  .app-header {
    padding: 1rem;
  }
  
  .header-content {
    flex-direction: column;
    gap: 1rem;
    text-align: center;
  }
  
  .header-main h1 {
    font-size: 1.8rem;
  }
  
  .header-main p {
    font-size: 1rem;
  }
  
  .header-stats {
    gap: 1rem;
  }
  
  .nav-container {
    padding: 0 0.5rem;
    gap: 0.2rem;
  }
  
  .nav-btn {
    min-width: 60px;
    padding: 0.6rem 0.5rem;
  }
  
  .nav-text {
    font-size: 0.7rem;
  }
  
  .section-indicator {
    padding: 0.6rem 1rem;
  }
  
  .app-main {
    padding: 1rem;
  }
  
  .start-test-content {
    padding: 2rem 1rem;
  }
  
  .test-info {
    grid-template-columns: repeat(2, 1fr);
    gap: 0.8rem;
  }
  
  .info-card {
    padding: 1rem 0.5rem;
  }
  
  .footer-content {
    flex-direction: column;
    gap: 0.8rem;
    text-align: center;
  }
  
  .footer-stats {
    flex-wrap: wrap;
    justify-content: center;
  }
}

@media (max-width: 480px) {
  .header-main h1 {
    font-size: 1.5rem;
  }
  
  .test-info {
    grid-template-columns: 1fr;
  }
  
  .nav-text {
    display: none;
  }
  
  .nav-btn {
    min-width: 50px;
    padding: 0.8rem 0.3rem;
  }
  
  .indicator-text {
    font-size: 0.9rem;
  }
}

/* ===== ANIMAZIONI ===== */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.app-main > * {
  animation: slideIn 0.3s ease-out;
}

.nav-btn {
  animation: fadeIn 0.2s ease-out;
}

/* ===== FOCUS E ACCESSIBILITÀ ===== */
.nav-btn:focus,
.btn:focus {
  outline: 2px solid #3498db;
  outline-offset: 2px;
}

.nav-btn.active:focus {
  outline-color: rgba(255, 255, 255, 0.8);
}

@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

================================================================================

NOME FILE: src\App.js

import React, { useState, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './components/ui/card';
import { Button } from './components/ui/button';
import { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter } from './components/ui/modal';
import { 
  Play, RotateCcw, Check, X, RefreshCw, Trash2, BarChart3, 
  Brain, Sparkles, BookOpen, Settings // ⭐ FIXED: Rimosso Calendar non usato
} from 'lucide-react';

// Custom Hooks
import { useWords } from './hooks/useWords';
import { useTest } from './hooks/useTest';
import { useNotification } from './hooks/useNotification';
import { useStats } from './hooks/useStats'; // ⭐ HOOK CENTRALIZZATO

// Components
import TestCard from './components/TestCard';
import TestResults from './components/TestResults';
import AddWordForm from './components/AddWordForm';
import WordsList from './components/WordsList';
import JSONManager from './components/JSONManager';
import StatsOverview from './components/StatsOverview';
import StatsManager from './components/StatsManager';
import ChapterTestSelector from './components/ChapterTestSelector';

import './App.css';

const VocabularyApp = () => {
  const { 
    words, 
    editingWord, 
    setEditingWord, 
    addWord, 
    removeWord, 
    toggleWordLearned,
    clearAllWords, 
    importWords,
    getAvailableChapters,
    getChapterStats
  } = useWords();
  
  const { message: statusMessage, showNotification } = useNotification();
  
  // ⭐ CENTRALIZZATO: Tutti i dati passano attraverso useStats
  const { 
    stats: advancedStats, 
    testHistory,
    updateTestStats,
    addTestToHistory,
    clearHistoryOnly,
    refreshData,
    forceUpdate
  } = useStats();

  // Ottieni i capitoli usati nel test corrente
  const getUsedChapters = useCallback((testWordsArray) => {
    const chapters = new Set();
    testWordsArray.forEach(word => {
      if (word.chapter) {
        chapters.add(word.chapter);
      } else {
        chapters.add('Senza Capitolo');
      }
    });
    return Array.from(chapters);
  }, []);
  
  // ⭐ AGGIORNATO: Test completion handler con gestione centralizzata
  const handleTestComplete = useCallback((testStats, testWordsUsed, wrongWordsArray) => {
    // Calcola statistiche per capitolo
    const chapterStats = {};
    const usedChapters = getUsedChapters(testWordsUsed);
    
    usedChapters.forEach(chapter => {
      const chapterWords = testWordsUsed.filter(word => 
        (word.chapter || 'Senza Capitolo') === chapter
      );
      const chapterWrongWords = wrongWordsArray.filter(word => 
        (word.chapter || 'Senza Capitolo') === chapter
      );
      
      chapterStats[chapter] = {
        totalWords: chapterWords.length,
        correctWords: chapterWords.length - chapterWrongWords.length,
        incorrectWords: chapterWrongWords.length,
        percentage: chapterWords.length > 0 ? 
          Math.round(((chapterWords.length - chapterWrongWords.length) / chapterWords.length) * 100) : 0
      };
    });

    // Calcola difficoltà del test
    const calculateTestDifficulty = () => {
      const factors = {
        chapters: usedChapters.length / Math.max(getAvailableChapters().length, 1),
        learned: testWordsUsed.filter(w => w.learned).length / Math.max(testWordsUsed.length, 1),
        size: Math.min(testWordsUsed.length / 50, 1)
      };
      
      const score = (factors.chapters * 0.4) + (factors.learned * 0.3) + (factors.size * 0.3);
      
      if (score < 0.3) return 'easy';
      if (score < 0.7) return 'medium';
      return 'hard';
    };

    const testResult = {
      id: Date.now(),
      timestamp: new Date(),
      
      // Statistiche generali
      totalWords: testStats.correct + testStats.incorrect,
      correctWords: testStats.correct,
      incorrectWords: testStats.incorrect,
      percentage: Math.round((testStats.correct / (testStats.correct + testStats.incorrect)) * 100),
      wrongWords: [...wrongWordsArray],
      
      // Parametri test
      testParameters: {
        selectedChapters: usedChapters,
        includeLearnedWords: testWordsUsed.some(word => word.learned),
        totalAvailableWords: words.filter(word => !word.learned).length,
        chaptersAvailable: getAvailableChapters().length
      },
      
      // Statistiche per capitolo
      chapterStats,
      
      // Metadata test
      testType: usedChapters.length === getAvailableChapters().length ? 'complete' : 'selective',
      wordsUsed: testWordsUsed.length,
      difficulty: calculateTestDifficulty()
    };
    
    // ⭐ GESTIONE CENTRALIZZATA: Aggiorna sia cronologia che statistiche
    try {
      // Aggiunge alla cronologia
      addTestToHistory(testResult);
      
      // Aggiorna statistiche avanzate
      updateTestStats({
        correct: testStats.correct,
        incorrect: testStats.incorrect,
        totalWords: words.length,
        timeSpent: Math.round(Math.random() * 10) + 5, // Tempo simulato
        category: usedChapters.length === 1 ? usedChapters[0] : 'misto',
        difficulty: testResult.difficulty
      });
      
      showNotification(`✅ Test completato! Risultato: ${testResult.percentage}%`);
      
      // ⭐ REFRESH AUTOMATICO PER AGGIORNARE L'UI
      setTimeout(() => {
        refreshData();
      }, 100);
      
    } catch (error) {
      console.error('❌ Errore salvataggio test:', error);
      showNotification('❌ Errore durante il salvataggio del test');
    }
  }, [words, getAvailableChapters, getUsedChapters, addTestToHistory, updateTestStats, showNotification, refreshData]);
  
  const {
    currentWord,
    usedWordIds,
    showMeaning,
    setShowMeaning,
    testMode,
    showResults,
    stats,
    wrongWords,
    testWords,
    startTest,
    handleAnswer,
    resetTest,
    startNewTest,
    getTestProgress,
    getTestSummary
  } = useTest(handleTestComplete);

  // UI State
  const [currentView, setCurrentView] = useState('main');
  const [showWordsList, setShowWordsList] = useState(true);
  const [confirmDelete, setConfirmDelete] = useState(null);
  const [showConfirmClear, setShowConfirmClear] = useState(false);
  const [showChapterSelector, setShowChapterSelector] = useState(false);

  // Funzioni per avviare il test con selezione capitoli
  const handleStartTestWithChapters = () => {
    const availableWords = words.filter(word => !word.learned);
    if (availableWords.length === 0) {
      showNotification('⚠️ Nessuna parola disponibile per il test!');
      return;
    }
    setShowChapterSelector(true);
  };

  const handleTestStart = (filteredWords) => {
    startTest(filteredWords);
  };

  // Word management handlers
  const handleAddWord = (wordData) => {
    try {
      addWord(wordData);
      showNotification(
        editingWord 
          ? `✅ Parola "${wordData.english}" modificata con successo!`
          : `✅ Parola "${wordData.english}" aggiunta con successo!`
      );
      setEditingWord(null);
    } catch (error) {
      showNotification(`❌ ${error.message}`);
    }
  };

  const handleRemoveWord = (id) => {
    const wordToDelete = words.find(word => word.id === id);
    if (wordToDelete) {
      setConfirmDelete(wordToDelete);
    }
  };

  const confirmRemoveWord = () => {
    if (confirmDelete) {
      removeWord(confirmDelete.id);
      showNotification(`✅ Parola "${confirmDelete.english}" eliminata con successo!`);
      setConfirmDelete(null);
    }
  };

  const handleToggleWordLearned = (id) => {
    const word = words.find(w => w.id === id);
    if (word) {
      toggleWordLearned(id);
      showNotification(
        word.learned 
          ? `📖 "${word.english}" segnata come da studiare`
          : `✅ "${word.english}" segnata come appresa!`
      );
    }
  };

  const handleClearAllWords = () => {
    if (words.length === 0) return;
    setShowConfirmClear(true);
  };

  const confirmClearWords = () => {
    clearAllWords();
    setShowConfirmClear(false);
    showNotification('✅ Tutte le parole sono state eliminate!');
  };

  // JSON management
  const handleImportWords = (jsonText) => {
    const count = importWords(jsonText);
    return count;
  };

  // ⭐ GESTIONE CENTRALIZZATA: Cancella cronologia
  const handleClearHistory = () => {
    clearHistoryOnly();
  };

  // Main render function
  if (testMode) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-white to-cyan-50">
        <BackgroundParticles />
        <div className="relative z-10 max-w-6xl mx-auto p-6 space-y-8">
          <TestMode 
            words={testWords}
            usedWordIds={usedWordIds}
            stats={stats}
            currentWord={currentWord}
            showMeaning={showMeaning}
            onFlipCard={() => setShowMeaning(!showMeaning)}
            onAnswer={handleAnswer}
            onResetTest={resetTest}
            getTestProgress={getTestProgress}
            getTestSummary={getTestSummary}
          />
        </div>
      </div>
    );
  }

  if (showResults) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-white to-cyan-50">
        <BackgroundParticles />
        <div className="relative z-10 max-w-6xl mx-auto p-6 space-y-8">
          <AppHeader />
          <TestResults
            stats={stats}
            wrongWords={wrongWords}
            onStartNewTest={startNewTest}
            onResetTest={resetTest}
          />
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-white to-cyan-50">
      <BackgroundParticles />
      
      {/* Notification Toast */}
      <NotificationToast message={statusMessage} />
      
      {/* Chapter Test Selector */}
      {showChapterSelector && (
        <ChapterTestSelector
          words={words}
          onStartTest={handleTestStart}
          onClose={() => setShowChapterSelector(false)}
          showNotification={showNotification}
        />
      )}
      
      {/* Modals */}
      <ConfirmationModals
        confirmDelete={confirmDelete}
        showConfirmClear={showConfirmClear}
        words={words}
        testHistory={testHistory}
        onConfirmDelete={confirmRemoveWord}
        onCancelDelete={() => setConfirmDelete(null)}
        onConfirmClear={confirmClearWords}
        onCancelClear={() => setShowConfirmClear(false)}
      />

      <div className="relative z-10 max-w-6xl mx-auto p-6 space-y-8">
        <AppHeader />
        
        {/* ⭐ AGGIORNATO: Navigation con dati centralizzati */}
        <ViewNavigation 
          currentView={currentView} 
          setCurrentView={setCurrentView} 
          testHistory={testHistory}
          advancedStats={advancedStats}
          forceUpdate={forceUpdate} // ⭐ Per forzare re-render
        />

        {/* ⭐ AGGIORNATO: Gestione delle viste con dati centralizzati */}
        {currentView === 'stats' ? (
          <StatsOverview
            testHistory={testHistory}
            words={words}
            onClearHistory={handleClearHistory}
            onGoToMain={() => setCurrentView('main')}
            forceUpdate={forceUpdate} // ⭐ Per refresh automatico
          />
        ) : currentView === 'stats-manager' ? (
          <StatsManager 
            onDataUpdated={() => {
              // ⭐ MIGLIORATO: Refresh centralizzato
              setTimeout(() => {
                refreshData();
              }, 100);
            }}
            forceUpdate={forceUpdate} // ⭐ Per sincronizzazione
          />
        ) : (
          <MainView
            words={words}
            editingWord={editingWord}
            showWordsList={showWordsList}
            setShowWordsList={setShowWordsList}
            onStartTest={handleStartTestWithChapters}
            onAddWord={handleAddWord}
            onEditWord={setEditingWord}
            onRemoveWord={handleRemoveWord}
            onToggleWordLearned={handleToggleWordLearned}
            onClearForm={() => setEditingWord(null)}
            onClearAllWords={handleClearAllWords}
            onImportWords={handleImportWords}
            showNotification={showNotification}
            getAvailableChapters={getAvailableChapters}
            getChapterStats={getChapterStats}
          />
        )}
      </div>
    </div>
  );
};

// Sub-components for better organization
const BackgroundParticles = () => (
  <div className="fixed inset-0 overflow-hidden pointer-events-none">
    <div className="absolute top-10 left-10 w-72 h-72 bg-blue-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob"></div>
    <div className="absolute top-0 right-4 w-72 h-72 bg-yellow-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-2000"></div>
    <div className="absolute -bottom-8 left-20 w-72 h-72 bg-pink-300 rounded-full mix-blend-multiply filter blur-xl opacity-20 animate-blob animation-delay-4000"></div>
  </div>
);

const AppHeader = () => (
  <div className="text-center relative">
    <div className="absolute inset-0 bg-gradient-to-r from-blue-600 to-purple-600 rounded-3xl blur-3xl opacity-20"></div>
    <Card className="relative backdrop-blur-sm bg-white/80 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10"></div>
      <CardHeader className="relative py-8">
        <CardTitle className="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent flex items-center justify-center gap-3">
          <Brain className="w-10 h-10 text-blue-600" />
          Vocabulary Master
          <Sparkles className="w-8 h-8 text-purple-600" />
        </CardTitle>
        <p className="text-gray-600 text-lg mt-2">La tua app intelligente per imparare l'inglese</p>
      </CardHeader>
    </Card>
  </div>
);

const NotificationToast = ({ message }) => {
  if (!message) return null;
  
  return (
    <div className="fixed top-6 right-6 z-50 animate-slide-in">
      <div className="bg-gradient-to-r from-green-500 to-emerald-500 text-white px-6 py-4 rounded-2xl shadow-2xl backdrop-blur-sm border border-white/20">
        <div className="flex items-center gap-3">
          <Check className="w-5 h-5" />
          <span className="font-medium">{message}</span>
        </div>
      </div>
    </div>
  );
};

// ⭐ AGGIORNATO: ViewNavigation con dati centralizzati
const ViewNavigation = ({ currentView, setCurrentView, testHistory, advancedStats, forceUpdate }) => (
  <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
    <CardContent className="p-2">
      <div className="flex gap-2 p-2">
        <Button
          onClick={() => setCurrentView('main')}
          className={`flex-1 py-4 px-6 rounded-2xl text-lg font-semibold transition-all duration-300 ${
            currentView === 'main' 
              ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg transform scale-105' 
              : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
          }`}
        >
          <Brain className="w-6 h-6 mr-3" />
          Studio & Vocabolario
        </Button>
        
        <Button
          onClick={() => setCurrentView('stats')}
          className={`flex-1 py-4 px-6 rounded-2xl text-lg font-semibold transition-all duration-300 ${
            currentView === 'stats' 
              ? 'bg-gradient-to-r from-purple-500 to-pink-600 text-white shadow-lg transform scale-105' 
              : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
          }`}
        >
          <BarChart3 className="w-6 h-6 mr-3" />
          Statistiche
          {testHistory.length > 0 && (
            <span className="ml-2 bg-white/20 text-white px-2 py-1 rounded-full text-sm">
              {testHistory.length}
            </span>
          )}
        </Button>
        
        <Button
          onClick={() => setCurrentView('stats-manager')}
          className={`flex-1 py-4 px-6 rounded-2xl text-lg font-semibold transition-all duration-300 ${
            currentView === 'stats-manager' 
              ? 'bg-gradient-to-r from-emerald-500 to-teal-600 text-white shadow-lg transform scale-105' 
              : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
          }`}
        >
          <Settings className="w-6 h-6 mr-3" />
          Gestisci Stats
          {advancedStats.testsCompleted > 0 && (
            <span className="ml-2 bg-white/20 text-white px-2 py-1 rounded-full text-sm">
              {advancedStats.testsCompleted}
            </span>
          )}
        </Button>
      </div>
    </CardContent>
  </Card>
);

const TestMode = ({ words, usedWordIds, stats, currentWord, showMeaning, onFlipCard, onAnswer, onResetTest, getTestProgress, getTestSummary }) => {
  const progress = getTestProgress();
  const summary = getTestSummary();
  
  return (
    <>
      {/* Test Header with Enhanced Progress */}
      <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-2xl overflow-hidden">
        <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-1">
          <div className="bg-white rounded-2xl p-6">
            <div className="flex justify-between items-center mb-4">
              <div>
                <h2 className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                  Test in Corso
                </h2>
                <p className="text-gray-600">Parola {progress.current} di {progress.total}</p>
                <p className="text-sm text-gray-500">
                  Accuratezza: {summary.accuracy}% • Rimanenti: {summary.remaining}
                </p>
              </div>
              <div className="text-right">
                <div className="flex gap-4">
                  <div className="text-center">
                    <div className="text-2xl font-bold text-green-600">{stats.correct}</div>
                    <div className="text-sm text-green-700">Corrette</div>
                  </div>
                  <div className="text-center">
                    <div className="text-2xl font-bold text-red-600">{stats.incorrect}</div>
                    <div className="text-sm text-red-700">Sbagliate</div>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Enhanced Progress bar */}
            <div className="relative">
              <div className="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
                <div 
                  className="h-full bg-gradient-to-r from-blue-500 to-purple-600 rounded-full transition-all duration-500 ease-out relative"
                  style={{ width: `${progress.percentage}%` }}
                >
                  <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer"></div>
                </div>
              </div>
              <div className="text-center mt-2 text-sm font-medium text-gray-600">
                {progress.percentage}% completato
              </div>
            </div>
          </div>
        </div>
      </Card>

      {/* Test Card Area */}
      {currentWord && (
        <div className="relative min-h-[80vh] flex items-center justify-center">
          <TestCard 
            word={currentWord}
            showMeaning={showMeaning}
            onFlip={onFlipCard}
          />

          {/* Answer Buttons */}
          <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 w-full max-w-2xl">
            <div className="flex justify-center space-x-6 mb-6">
              {showMeaning ? (
                <>
                  <Button
                    onClick={() => onAnswer(true)}
                    className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-8 py-4 text-lg rounded-2xl shadow-2xl transform transition-all duration-200 hover:scale-105 border-0"
                  >
                    <Check className="w-6 h-6 mr-3" />
                    Sapevo la risposta!
                  </Button>
                  <Button
                    onClick={() => onAnswer(false)}
                    className="bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white px-8 py-4 text-lg rounded-2xl shadow-2xl transform transition-all duration-200 hover:scale-105 border-0"
                  >
                    <X className="w-6 h-6 mr-3" />
                    Non la sapevo
                  </Button>
                </>
              ) : (
                <div className="text-center space-y-3">
                  <p className="text-xl text-gray-700 font-medium">🎯 Clicca la carta per vedere la traduzione</p>
                  <p className="text-sm text-gray-500">Cerca di ricordare il significato prima di girare</p>
                </div>
              )}
            </div>
          </div>
        </div>
      )}
      
      {/* End Test Button */}
      <div className="flex justify-center">
        <Button 
          onClick={onResetTest} 
          variant="outline"
          className="bg-white/80 backdrop-blur-sm border border-gray-200 hover:bg-white/90 rounded-xl px-6 py-3 shadow-lg"
        >
          <RotateCcw className="w-4 h-4 mr-2" />
          Termina Test
        </Button>
      </div>
    </>
  );
};

const MainView = ({ 
  words, 
  editingWord, 
  showWordsList, 
  setShowWordsList, 
  onStartTest, 
  onAddWord, 
  onEditWord, 
  onRemoveWord, 
  onToggleWordLearned,
  onClearForm, 
  onClearAllWords, 
  onImportWords, 
  showNotification,
  getAvailableChapters,
  getChapterStats 
}) => (
  <div className="space-y-8 animate-fade-in">
    {/* Enhanced Control Panel with Chapter Info */}
    <ControlPanel 
      words={words}
      onStartTest={onStartTest}
      onClearAllWords={onClearAllWords}
      showNotification={showNotification}
      getAvailableChapters={getAvailableChapters}
      getChapterStats={getChapterStats}
    />

    {/* JSON Manager */}
    <JSONManager 
      words={words}
      onImportWords={onImportWords}
      showNotification={showNotification}
    />

    {/* Enhanced Add Word Form */}
    <AddWordForm
      onAddWord={onAddWord}
      editingWord={editingWord}
      onClearForm={onClearForm}
      showNotification={showNotification}
    />

    {/* Enhanced Words List */}
    <WordsList
      words={words}
      onEditWord={onEditWord}
      onRemoveWord={onRemoveWord}
      onToggleLearned={onToggleWordLearned}
      showWordsList={showWordsList}
      setShowWordsList={setShowWordsList}
    />
  </div>
);

const ControlPanel = ({ words, onStartTest, onClearAllWords, showNotification, getAvailableChapters, getChapterStats }) => {
  const availableWords = words.filter(word => !word.learned);
  const learnedWords = words.filter(word => word.learned);
  const chapters = getAvailableChapters();
  
  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-1">
        <div className="bg-white rounded-3xl p-6">
          <CardTitle className="flex items-center gap-3 text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-6">
            <Play className="w-6 h-6 text-blue-600" />
            Controlli di Studio
          </CardTitle>
          
          {/* Statistiche Enhanced */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <div className="text-center p-4 bg-blue-50 rounded-2xl border border-blue-200">
              <div className="text-2xl font-bold text-blue-600">{words.length}</div>
              <div className="text-blue-700 text-sm">Totale Parole</div>
            </div>
            <div className="text-center p-4 bg-green-50 rounded-2xl border border-green-200">
              <div className="text-2xl font-bold text-green-600">{learnedWords.length}</div>
              <div className="text-green-700 text-sm">Apprese</div>
            </div>
            <div className="text-center p-4 bg-orange-50 rounded-2xl border border-orange-200">
              <div className="text-2xl font-bold text-orange-600">{availableWords.length}</div>
              <div className="text-orange-700 text-sm">Da Studiare</div>
            </div>
            <div className="text-center p-4 bg-purple-50 rounded-2xl border border-purple-200">
              <div className="text-2xl font-bold text-purple-600">{chapters.length}</div>
              <div className="text-purple-700 text-sm">Capitoli</div>
            </div>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Button 
              onClick={onStartTest} 
              disabled={availableWords.length === 0}
              className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white p-6 h-auto rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              <div className="flex flex-col items-center gap-2">
                <BookOpen className="w-8 h-8" />
                <span className="font-bold">Inizia Test</span>
                <span className="text-sm opacity-90">({availableWords.length} disponibili)</span>
              </div>
            </Button>

            <Button 
              onClick={onClearAllWords} 
              variant="outline" 
              disabled={words.length === 0}
              className="border-2 border-red-300 hover:border-red-400 p-6 h-auto rounded-2xl bg-red-50 hover:bg-red-100 transition-all duration-200 disabled:opacity-50"
            >
              <div className="flex flex-col items-center gap-2 text-red-600">
                <RefreshCw className="w-8 h-8" />
                <span className="font-bold">Pulisci Vocabolario</span>
                <span className="text-sm">Elimina tutte le parole</span>
              </div>
            </Button>
          </div>
        </div>
      </div>
    </Card>
  );
};

const ConfirmationModals = ({ 
  confirmDelete, showConfirmClear, words, testHistory,
  onConfirmDelete, onCancelDelete, onConfirmClear, onCancelClear
}) => (
  <>
    {/* Delete Word Modal */}
    <Modal isOpen={!!confirmDelete} onClose={onCancelDelete}>
      <ModalHeader className="bg-gradient-to-r from-red-500 to-pink-500 text-white rounded-t-2xl">
        <ModalTitle className="text-white flex items-center gap-2">
          <Trash2 className="w-5 h-5" />
          Conferma Eliminazione
        </ModalTitle>
      </ModalHeader>
      <ModalContent>
        <div className="text-center py-4">
          <div className="text-6xl mb-4">🗑️</div>
          <p className="text-gray-700 mb-2">Sei sicuro di voler eliminare la parola</p>
          <div className="bg-gray-100 rounded-lg p-3 mb-4">
            <span className="font-bold text-lg text-red-600">"{confirmDelete?.english}"</span>
            {confirmDelete?.italian && (
              <>
                <span className="mx-2 text-gray-400">→</span>
                <span className="text-gray-700">{confirmDelete.italian}</span>
              </>
            )}
          </div>
          {confirmDelete?.chapter && (
            <p className="text-sm text-gray-500 mb-2">Capitolo: {confirmDelete.chapter}</p>
          )}
          <p className="text-sm text-gray-500">Questa azione non può essere annullata.</p>
        </div>
      </ModalContent>
      <ModalFooter>
        <Button onClick={onCancelDelete} variant="outline">Annulla</Button>
        <Button onClick={onConfirmDelete} className="bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white">Elimina</Button>
      </ModalFooter>
    </Modal>

    {/* Clear All Words Modal */}
    <Modal isOpen={showConfirmClear} onClose={onCancelClear}>
      <ModalHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white rounded-t-2xl">
        <ModalTitle className="text-white flex items-center gap-2">
          <RefreshCw className="w-5 h-5" />
          Eliminazione Completa
        </ModalTitle>
      </ModalHeader>
      <ModalContent>
        <div className="text-center py-4">
          <div className="text-6xl mb-4">⚠️</div>
          <p className="text-gray-700 mb-4">
            Sei sicuro di voler eliminare tutte le <strong>{words.length} parole</strong>?
          </p>
          <div className="bg-orange-50 border border-orange-200 rounded-lg p-4 mb-4">
            <p className="text-orange-800 text-sm">
              Questa azione eliminerà permanentemente tutto il tuo vocabolario e non può essere annullata.
            </p>
          </div>
        </div>
      </ModalContent>
      <ModalFooter>
        <Button onClick={onCancelClear} variant="outline">Annulla</Button>
        <Button onClick={onConfirmClear} className="bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white">Elimina Tutto</Button>
      </ModalFooter>
    </Modal>
  </>
);

export default VocabularyApp;

================================================================================

NOME FILE: src\index.css

/*
/src/index.css
This file contains the main CSS styles for the application, including Tailwind CSS imports and custom styles.
*/
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Stili di base */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* Utilità personalizzate */
@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

================================================================================

NOME FILE: src\index.js

// /src/index.js
// This file is the entry point for the React application.
// It imports the necessary styles and renders the main App component into the root element of the HTML document.
// It uses ReactDOM to create a root and render the App component wrapped in React.StrictMode.
// This setup ensures that the application is ready for development and production builds with React's best practices.
// It is essential for initializing the React application and providing a consistent structure for rendering components.

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


================================================================================

NOME FILE: src\components\AddWordForm.js

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Textarea } from './ui/textarea';
import { Plus, Edit3, Check, Sparkles, Loader2, Wand2 } from 'lucide-react';
import { getPredefinedGroups, getCategoryStyle } from '../utils/categoryUtils';

const AddWordForm = ({ onAddWord, editingWord, onClearForm, showNotification }) => {
  const [formData, setFormData] = useState({
    english: '',
    italian: '',
    group: '',
    sentence: '',
    notes: '',
    chapter: '',
    learned: false
  });
  const [showAdvancedForm, setShowAdvancedForm] = useState(false);
  const [isAiLoading, setIsAiLoading] = useState(false);

  // Gemini API Configuration
  const GEMINI_API_KEY = 'AIzaSyCHftv0ACPTtX7unUKg6y_eqb09mBobTAM';
  const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

  // Funzione di fallback per categorizzare le parole
  const categorizeWordFallback = (word) => {
    const wordLower = word.toLowerCase();
    
    // Pattern per verbi comuni
    if (wordLower.match(/^(go|come|run|walk|eat|drink|sleep|work|play|study|read|write|speak|listen|watch|see|look|think|know|understand|love|like|hate|want|need|have|get|give|take|make|do|say|tell|ask|answer|help|try|start|stop|finish|continue|learn|teach|buy|sell|pay|cost|travel|visit)$/)) {
      return 'VERBI';
    }
    
    // Pattern per verbi irregolari comuni
    if (wordLower.match(/^(be|have|do|say|get|make|go|know|take|see|come|think|look|want|give|use|find|tell|ask|seem|feel|try|leave|call|put|mean|become|show|hear|let|begin|keep|start|grow|open|walk|win|talk|turn|move|live|believe|bring|happen|write|sit|stand|lose|pay|meet|run|drive|break|speak|eat|fall|catch|buy|cut|rise|send|choose|build|draw|kill|wear|beat|hide|shake|hang|strike|throw|fly|steal|lie|lay|bet|bite|blow|burn|burst|cost|deal|dig|dive|fight|fit|flee|forget|forgive|freeze|hurt|kneel|lead|lend|light|quit|ride|ring|seek|sell|shoot|shut|sing|sink|slide|spin|split|spread|spring|stick|sting|stink|strike|swear|sweep|swim|swing|tear|wake|weep|wind)$/)) {
      return 'VERBI_IRREGOLARI';
    }
    
    // Pattern per aggettivi
    if (wordLower.match(/^.*(ful|less|ous|ive|able|ible|ant|ent|ing|ed|er|est|ly)$/) || 
        wordLower.match(/^(good|bad|big|small|new|old|young|beautiful|ugly|happy|sad|angry|excited|tired|hungry|thirsty|hot|cold|warm|cool|fast|slow|easy|difficult|hard|soft|loud|quiet|bright|dark|clean|dirty|rich|poor|healthy|sick|strong|weak|tall|short|fat|thin|heavy|light|full|empty|open|close)$/)) {
      return 'AGGETTIVI';
    }
    
    // Pattern per tecnologia
    if (wordLower.match(/^(computer|phone|internet|website|email|software|app|technology|digital|online|smartphone|laptop|tablet|keyboard|mouse|screen|monitor|camera|video|audio|wifi|bluetooth|data|file|download|upload|social|media|network|server|database|code|programming|artificial|intelligence|robot|smart|virtual|cloud|cyber|tech|device|gadget|electronic|battery|charge|wireless)$/)) {
      return 'TECNOLOGIA';
    }
    
    // Pattern per famiglia
    if (wordLower.match(/^(mother|father|mom|dad|parent|child|children|son|daughter|brother|sister|family|grandmother|grandfather|grandma|grandpa|uncle|aunt|cousin|nephew|niece|husband|wife|spouse|baby|toddler|teenager|adult|relative|generation)$/)) {
      return 'FAMIGLIA';
    }
    
    // Pattern per emozioni positive
    if (wordLower.match(/^(happy|joy|love|excited|cheerful|delighted|pleased|satisfied|content|glad|grateful|optimistic|positive|hopeful|confident|proud|amazed|wonderful|fantastic|excellent|great|awesome|brilliant|perfect|beautiful|amazing|incredible|outstanding|superb|marvelous|terrific)$/)) {
      return 'EMOZIONI_POSITIVE';
    }
    
    // Pattern per emozioni negative
    if (wordLower.match(/^(sad|angry|mad|furious|upset|disappointed|frustrated|worried|anxious|nervous|scared|afraid|terrified|depressed|lonely|jealous|envious|guilty|ashamed|embarrassed|confused|stressed|tired|exhausted|bored|annoyed|irritated|disgusted|horrible|terrible|awful|bad|worst|hate|dislike)$/)) {
      return 'EMOZIONI_NEGATIVE';
    }
    
    // Pattern per lavoro
    if (wordLower.match(/^(job|work|career|profession|office|business|company|manager|employee|boss|colleague|team|meeting|project|task|salary|money|contract|interview|resume|skill|experience|training|promotion|department|client|customer|service|industry|market|economy|trade|commerce)$/)) {
      return 'LAVORO';
    }
    
    // Pattern per vestiti
    if (wordLower.match(/^(shirt|pants|dress|skirt|jacket|coat|sweater|hoodie|jeans|shorts|socks|shoes|boots|sneakers|sandals|hat|cap|gloves|scarf|belt|tie|suit|uniform|clothes|clothing|fashion|style|wear|outfit|underwear|pajamas|swimsuit)$/)) {
      return 'VESTITI';
    }
    
    // Default: prova a determinare se è un sostantivo
    return 'SOSTANTIVI';
  };

  useEffect(() => {
    if (editingWord) {
      setFormData({
        english: editingWord.english || '',
        italian: editingWord.italian || '',
        group: editingWord.group || '',
        sentence: editingWord.sentence || '',
        notes: editingWord.notes || '',
        chapter: editingWord.chapter || '',
        learned: editingWord.learned || false
      });
      setShowAdvancedForm(true);
    }
  }, [editingWord]);

  const callGeminiAPI = async (englishWord) => {
    // Ottieni le categorie predefinite disponibili
    const availableGroups = getPredefinedGroups();
    const groupsList = availableGroups.join(', ');
    
    const prompt = `
Analizza la parola inglese "${englishWord}" e fornisci le seguenti informazioni in formato JSON:

{
  "italian": "traduzione principale in italiano (solo la traduzione più comune)",
  "group": "DEVE essere esattamente una di queste categorie: ${groupsList}. Scegli quella più appropriata per la parola.",
  "sentence": "frase d'esempio in inglese che usa la parola",
  "notes": "note aggiuntive con altre traduzioni, sinonimi, forme irregolari, etc. Formatta come: 'Altri Significati: ... Sinonimi: ... Verbo Irregolare: ... etc.'",
  "chapter": "lascia vuoto, sarà compilato dall'utente"
}

REGOLE IMPORTANTI:
- Rispondi SOLO con il JSON valido, nessun altro testo
- Il campo "group" DEVE essere esattamente una di queste opzioni: ${groupsList}
- Per i verbi irregolari, usa "VERBI_IRREGOLARI" e specifica le forme nel campo notes
- Per verbi regolari, usa "VERBI"
- Includi sempre almeno 2-3 significati alternativi nelle note se esistono
- La frase deve essere semplice e chiara
- Il campo "chapter" deve rimanere vuoto (stringa vuota)
- Se la parola non si adatta perfettamente a nessuna categoria, scegli quella più vicina

ESEMPI:
- "run" → group: "VERBI_IRREGOLARI" 
- "beautiful" → group: "AGGETTIVI"
- "computer" → group: "TECNOLOGIA"
- "father" → group: "FAMIGLIA"
- "happy" → group: "EMOZIONI_POSITIVE"
`;

    try {
      const response = await fetch(GEMINI_API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }]
        })
      });

      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!content) {
        throw new Error('Nessuna risposta dall\'AI');
      }

      // Extract JSON from the response (remove any markdown formatting)
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('Formato risposta non valido');
      }

      const parsedData = JSON.parse(jsonMatch[0]);
      
      // Validazione categoria: deve essere una delle categorie predefinite
      const availableGroups = getPredefinedGroups();
      if (parsedData.group && !availableGroups.includes(parsedData.group)) {
        console.warn(`Categoria AI "${parsedData.group}" non valida. Uso categoria di fallback.`);
        // Prova a indovinare la categoria basandosi sulla parola inglese
        parsedData.group = categorizeWordFallback(englishWord);
      }
      
      return parsedData;

    } catch (error) {
      console.error('Gemini API Error:', error);
      throw error;
    }
  };

  const handleAiAssist = async () => {
    if (!formData.english.trim()) {
      showNotification?.('⚠️ Inserisci prima una parola inglese!');
      return;
    }

    setIsAiLoading(true);
    
    try {
      showNotification?.('🤖 L\'AI sta analizzando la parola...');
      
      const aiData = await callGeminiAPI(formData.english.trim());
      
      // Valida che tutti i campi siano presenti
      if (!aiData.italian) {
        throw new Error('L\'AI non ha fornito una traduzione valida');
      }
      
      setFormData(prev => ({
        ...prev,
        italian: aiData.italian || prev.italian,
        group: aiData.group || prev.group,
        sentence: aiData.sentence || prev.sentence,
        notes: aiData.notes || prev.notes,
        chapter: aiData.chapter || prev.chapter
        // learned rimane invariato (non modificato dall'AI)
      }));

      setShowAdvancedForm(true);
      
      // Feedback specifico se la categoria è stata corretta
      const availableGroups = getPredefinedGroups();
      if (aiData.group && !availableGroups.includes(aiData.group)) {
        showNotification?.('✨ Dati compilati! (Categoria corretta automaticamente)');
      } else {
        showNotification?.('✨ Dati compilati dall\'AI con successo!');
      }
      
    } catch (error) {
      console.error('AI Assist Error:', error);
      showNotification?.('❌ Errore AI: ' + error.message);
    } finally {
      setIsAiLoading(false);
    }
  };

  const handleSubmit = () => {
    if (!formData.english.trim() || !formData.italian.trim()) {
      showNotification?.('⚠️ Parola inglese e traduzione sono obbligatorie!');
      return;
    }

    try {
      onAddWord({
        english: formData.english.trim(),
        italian: formData.italian.trim(),
        group: formData.group.trim() || null,
        sentence: formData.sentence.trim() || null,
        notes: formData.notes.trim() || null,
        chapter: formData.chapter.trim() || null,
        learned: formData.learned
      });
      
      // Reset form sempre dopo salvataggio (sia nuova parola che modifica)
      setFormData({
        english: '',
        italian: '',
        group: '',
        sentence: '',
        notes: '',
        chapter: '',
        learned: false
      });
      setShowAdvancedForm(false); // Chiudi sezione avanzata
      
    } catch (error) {
      console.error('Error adding word:', error);
    }
  };

  const handleClear = () => {
    setFormData({
      english: '',
      italian: '',
      group: '',
      sentence: '',
      notes: '',
      chapter: '',
      learned: false
    });
    setShowAdvancedForm(false);
    onClearForm();
  };

  const handleInputChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <Card data-form-section className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className={editingWord ? "bg-gradient-to-r from-blue-500 to-purple-600 text-white" : ""}>
        <CardTitle className={`flex items-center justify-between ${editingWord ? "text-white" : "text-gray-800"}`}>
          {editingWord ? (
            <div className="flex items-center gap-3">
              <Edit3 className="w-6 h-6" />
              <span>Modifica Parola: {editingWord.english}</span>
            </div>
          ) : (
            <div className="flex items-center gap-3">
              <Plus className="w-6 h-6 text-green-600" />
              <span className="bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent">
                Aggiungi Nuove Parole
              </span>
            </div>
          )}
          <div className="flex gap-2">
            {editingWord && (
              <Button 
                variant="ghost" 
                size="sm"
                onClick={handleClear}
                className="text-white hover:bg-white/20"
              >
                ✕ Annulla
              </Button>
            )}
            <Button 
              variant="ghost" 
              size="sm"
              onClick={() => setShowAdvancedForm(!showAdvancedForm)}
              className={editingWord ? "text-white hover:bg-white/20" : "text-gray-600 hover:bg-gray-100"}
            >
              {showAdvancedForm ? 'Forma Semplice' : 'Forma Avanzata'}
            </Button>
          </div>
        </CardTitle>
        {editingWord && (
          <div className="text-blue-100 bg-blue-600/20 p-3 rounded-xl mt-4">
            💡 Stai modificando la parola "<strong>{editingWord.english}</strong>". 
            Cambia i campi che vuoi aggiornare e clicca "Salva Modifiche".
          </div>
        )}
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <Input
              placeholder="Parola inglese *"
              value={formData.english}
              onChange={(e) => handleInputChange('english', e.target.value)}
              className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors h-12"
              required
            />
            
            <Input
              placeholder="Traduzione italiana *"
              value={formData.italian}
              onChange={(e) => handleInputChange('italian', e.target.value)}
              className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors h-12"
              required
            />
          </div>

          {/* AI Assistant Button - Espanso a Doppia Colonna */}
          <Button
            onClick={handleAiAssist}
            disabled={isAiLoading || !formData.english.trim()}
            className="w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white py-4 text-lg rounded-xl shadow-lg transform hover:scale-105 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
          >
            {isAiLoading ? (
              <>
                <Loader2 className="w-6 h-6 mr-3 animate-spin" />
                🤖 AI sta pensando...
              </>
            ) : (
              <>
                <Sparkles className="w-6 h-6 mr-3" />
                ✨ AI Assistant - Compila Automaticamente Tutti i Campi
              </>
            )}
          </Button>

          {/* AI Notice */}
          {formData.italian && !editingWord && (
            <div className="p-4 bg-gradient-to-r from-purple-50 to-pink-50 border-2 border-purple-200 rounded-2xl">
              <div className="flex items-center gap-3">
                <Wand2 className="w-6 h-6 text-purple-600" />
                <p className="text-purple-800 font-medium">
                  💡 Usa l'AI Assistant per compilare automaticamente tutti i campi!
                </p>
              </div>
            </div>
          )}

          {/* Info sui nuovi campi */}
          {showAdvancedForm && (
            <div className="p-4 bg-gradient-to-r from-green-50 to-blue-50 border-2 border-green-200 rounded-2xl mb-4">
              <div className="flex items-center gap-3 mb-2">
                <span className="text-2xl">📚</span>
                <h4 className="font-bold text-green-800">Gestione Avanzata Vocabolario</h4>
              </div>
              <div className="text-sm text-green-700 space-y-1">
                <p>• <strong>Capitolo:</strong> Organizza le parole per capitoli del libro (es. 1, 2A, Unit 5)</p>
                <p>• <strong>Parola Appresa:</strong> Le parole apprese rimangono nel vocabolario ma vengono saltate nei test</p>
                <p>• <strong>Selezione Test:</strong> Potrai scegliere quali capitoli includere nei test</p>
              </div>
            </div>
          )}

          {showAdvancedForm && (
            <div className="space-y-6 p-6 bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl border-2 border-blue-200 animate-fade-in">
              <h4 className="font-bold text-blue-800 text-lg flex items-center gap-2">
                <span>📋</span> Informazioni Aggiuntive
              </h4>
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>📂</span> Gruppo/Categoria
                  </label>
                  <select
                    value={formData.group}
                    onChange={(e) => handleInputChange('group', e.target.value)}
                    className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors bg-white"
                  >
                    <option value="">Nessun gruppo</option>
                    {getPredefinedGroups().map(group => (
                      <option key={group} value={group}>
                        {getCategoryStyle(group).icon} {group}
                      </option>
                    ))}
                  </select>
                </div>
                
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>📖</span> Capitolo del libro
                  </label>
                  <Input
                    placeholder="es. 1, 2A, Unit 5..."
                    value={formData.chapter}
                    onChange={(e) => handleInputChange('chapter', e.target.value)}
                    className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                  />
                </div>

                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>🎓</span> Stato Apprendimento
                  </label>
                  <div className="flex items-center gap-3 p-3 border-2 border-gray-200 rounded-xl bg-white">
                    <label className="flex items-center gap-2 cursor-pointer">
                      <div 
                        onClick={() => handleInputChange('learned', !formData.learned)}
                        className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                          formData.learned 
                            ? 'bg-green-500 border-green-500 text-white' 
                            : 'border-gray-300 bg-white'
                        }`}
                      >
                        {formData.learned && <span className="text-sm">✓</span>}
                      </div>
                      <span className="text-sm font-medium text-gray-700">
                        Parola appresa
                      </span>
                    </label>
                  </div>
                </div>
              </div>
              
              <div className="grid grid-cols-1 gap-4">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                    <span>💬</span> Frase d'esempio
                  </label>
                  <Input
                    placeholder="es. I love this beautiful song"
                    value={formData.sentence}
                    onChange={(e) => handleInputChange('sentence', e.target.value)}
                    className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                  <span>📝</span> Note aggiuntive
                </label>
                <Textarea
                  placeholder="Altri significati, sinonimi, forme irregolari..."
                  value={formData.notes}
                  onChange={(e) => handleInputChange('notes', e.target.value)}
                  rows={4}
                  className="border-2 border-gray-200 rounded-xl focus:border-blue-500 transition-colors"
                />
              </div>
            </div>
          )}

          <Button 
            onClick={handleSubmit}
            className={`w-full py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200 ${
              editingWord 
                ? 'bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700' 
                : 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600'
            } text-white`}
          >
            {editingWord ? (
              <>
                <Check className="w-5 h-5 mr-2" />
                Salva Modifiche
              </>
            ) : (
              <>
                <Plus className="w-5 h-5 mr-2" />
                Aggiungi Parola
              </>
            )}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default AddWordForm;

================================================================================

NOME FILE: src\components\ChapterTestSelector.js

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Play, BookOpen, CheckSquare, Square, Target } from 'lucide-react';

const ChapterTestSelector = ({ words, onStartTest, onClose, showNotification }) => {
  const [selectedChapters, setSelectedChapters] = useState(new Set());
  const [includeLearnedWords, setIncludeLearnedWords] = useState(false);
  
  // Ottieni tutti i capitoli disponibili dalle parole
  const getAvailableChapters = () => {
    const chapters = new Set();
    words.forEach(word => {
      if (word.chapter) {
        chapters.add(word.chapter);
      }
    });
    return Array.from(chapters).sort((a, b) => {
      // Ordina numericamente se sono numeri, altrimenti alfabeticamente
      const aNum = parseInt(a);
      const bNum = parseInt(b);
      if (!isNaN(aNum) && !isNaN(bNum)) {
        return aNum - bNum;
      }
      return a.localeCompare(b);
    });
  };

  const availableChapters = getAvailableChapters();
  const wordsWithoutChapter = words.filter(word => !word.chapter);

  // Calcola statistiche per ogni capitolo
  const getChapterStats = (chapter) => {
    const chapterWords = words.filter(word => word.chapter === chapter);
    const totalWords = chapterWords.length;
    const learnedWords = chapterWords.filter(word => word.learned).length;
    const availableForTest = chapterWords.filter(word => includeLearnedWords || !word.learned).length;
    
    return { totalWords, learnedWords, availableForTest };
  };

  const getWordsWithoutChapterStats = () => {
    const totalWords = wordsWithoutChapter.length;
    const learnedWords = wordsWithoutChapter.filter(word => word.learned).length;
    const availableForTest = wordsWithoutChapter.filter(word => includeLearnedWords || !word.learned).length;
    
    return { totalWords, learnedWords, availableForTest };
  };

  // Gestione selezione capitoli
  const toggleChapter = (chapter) => {
    const newSelected = new Set(selectedChapters);
    if (newSelected.has(chapter)) {
      newSelected.delete(chapter);
    } else {
      newSelected.add(chapter);
    }
    setSelectedChapters(newSelected);
  };

  const selectAllChapters = () => {
    const allOptions = [...availableChapters];
    if (wordsWithoutChapter.length > 0) {
      allOptions.push('SENZA_CAPITOLO');
    }
    setSelectedChapters(new Set(allOptions));
  };

  const clearSelection = () => {
    setSelectedChapters(new Set());
  };

  // Calcola il totale delle parole selezionate
  const getTotalSelectedWords = () => {
    let total = 0;
    
    selectedChapters.forEach(chapter => {
      if (chapter === 'SENZA_CAPITOLO') {
        total += getWordsWithoutChapterStats().availableForTest;
      } else {
        total += getChapterStats(chapter).availableForTest;
      }
    });
    
    return total;
  };

  const handleStartTest = () => {
    const totalWords = getTotalSelectedWords();
    
    if (totalWords === 0) {
      showNotification?.('⚠️ Seleziona almeno un capitolo con parole disponibili!');
      return;
    }

    // Filtra le parole in base ai capitoli selezionati
    const filteredWords = words.filter(word => {
      // Filtra per stato appreso
      if (!includeLearnedWords && word.learned) {
        return false;
      }
      
      // Filtra per capitolo
      if (word.chapter) {
        return selectedChapters.has(word.chapter);
      } else {
        return selectedChapters.has('SENZA_CAPITOLO');
      }
    });

    if (filteredWords.length === 0) {
      showNotification?.('⚠️ Nessuna parola disponibile per i capitoli selezionati!');
      return;
    }

    onStartTest(filteredWords);
    onClose();
  };

  // Seleziona tutti i capitoli all'apertura se non ce ne sono già selezionati
  useEffect(() => {
    if (selectedChapters.size === 0) {
      const allOptions = [...availableChapters];
      if (wordsWithoutChapter.length > 0) {
        allOptions.push('SENZA_CAPITOLO');
      }
      setSelectedChapters(new Set(allOptions));
    }
  }, [availableChapters, wordsWithoutChapter.length, selectedChapters.size]);

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto bg-black/50 backdrop-blur-sm">
      <div className="flex min-h-full items-center justify-center p-4">
        <Card className="w-full max-w-4xl bg-white rounded-3xl shadow-2xl overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white">
            <CardTitle className="flex items-center gap-3 text-2xl">
              <BookOpen className="w-8 h-8" />
              Seleziona Capitoli per il Test
            </CardTitle>
            <p className="text-blue-100 mt-2">
              Scegli quali capitoli includere nel test e se includere le parole già apprese
            </p>
          </CardHeader>
          
          <CardContent className="p-6 space-y-6">
            {/* Opzioni globali */}
            <div className="bg-gradient-to-r from-indigo-50 to-purple-50 p-4 rounded-2xl border-2 border-indigo-200">
              <h3 className="font-bold text-indigo-800 mb-4 flex items-center gap-2">
                <Target className="w-5 h-5" />
                Opzioni Test
              </h3>
              
              <div className="flex items-center gap-4 mb-4">
                <label className="flex items-center gap-3 cursor-pointer">
                  <div 
                    onClick={() => setIncludeLearnedWords(!includeLearnedWords)}
                    className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                      includeLearnedWords 
                        ? 'bg-green-500 border-green-500 text-white' 
                        : 'border-gray-300 bg-white'
                    }`}
                  >
                    {includeLearnedWords && <span className="text-sm">✓</span>}
                  </div>
                  <span className="text-gray-700 font-medium">
                    Includi parole già apprese nel test
                  </span>
                </label>
              </div>
              
              <div className="flex gap-3">
                <Button 
                  onClick={selectAllChapters}
                  className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white"
                >
                  <CheckSquare className="w-4 h-4 mr-2" />
                  Seleziona Tutti
                </Button>
                <Button 
                  onClick={clearSelection}
                  variant="outline"
                  className="border-gray-300"
                >
                  <Square className="w-4 h-4 mr-2" />
                  Deseleziona Tutti
                </Button>
              </div>
            </div>

            {/* Lista Capitoli */}
            <div className="space-y-4 max-h-96 overflow-y-auto">
              <h3 className="font-bold text-gray-800 text-lg">Capitoli Disponibili:</h3>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {availableChapters.map(chapter => {
                  const stats = getChapterStats(chapter);
                  const isSelected = selectedChapters.has(chapter);
                  
                  return (
                    <div
                      key={chapter}
                      onClick={() => toggleChapter(chapter)}
                      className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
                        isSelected 
                          ? 'border-blue-500 bg-blue-50 shadow-lg' 
                          : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
                      }`}
                    >
                      <div className="flex items-center justify-between mb-3">
                        <div className="flex items-center gap-3">
                          <div className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                            isSelected 
                              ? 'bg-blue-500 border-blue-500 text-white' 
                              : 'border-gray-300 bg-white'
                          }`}>
                            {isSelected && <span className="text-sm">✓</span>}
                          </div>
                          <span className="font-bold text-lg">📖 Capitolo {chapter}</span>
                        </div>
                      </div>
                      
                      <div className="grid grid-cols-3 gap-2 text-sm">
                        <div className="text-center p-2 bg-blue-100 rounded-xl">
                          <div className="font-bold text-blue-600">{stats.totalWords}</div>
                          <div className="text-blue-700 text-xs">Totale</div>
                        </div>
                        <div className="text-center p-2 bg-green-100 rounded-xl">
                          <div className="font-bold text-green-600">{stats.learnedWords}</div>
                          <div className="text-green-700 text-xs">Apprese</div>
                        </div>
                        <div className="text-center p-2 bg-orange-100 rounded-xl">
                          <div className="font-bold text-orange-600">{stats.availableForTest}</div>
                          <div className="text-orange-700 text-xs">Per Test</div>
                        </div>
                      </div>
                    </div>
                  );
                })}
                
                {/* Parole senza capitolo */}
                {wordsWithoutChapter.length > 0 && (
                  <div
                    onClick={() => toggleChapter('SENZA_CAPITOLO')}
                    className={`p-4 rounded-2xl border-2 cursor-pointer transition-all duration-300 ${
                      selectedChapters.has('SENZA_CAPITOLO')
                        ? 'border-purple-500 bg-purple-50 shadow-lg' 
                        : 'border-gray-200 bg-white hover:border-gray-300 hover:shadow-md'
                    }`}
                  >
                    <div className="flex items-center justify-between mb-3">
                      <div className="flex items-center gap-3">
                        <div className={`w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${
                          selectedChapters.has('SENZA_CAPITOLO')
                            ? 'bg-purple-500 border-purple-500 text-white' 
                            : 'border-gray-300 bg-white'
                        }`}>
                          {selectedChapters.has('SENZA_CAPITOLO') && <span className="text-sm">✓</span>}
                        </div>
                        <span className="font-bold text-lg">📋 Senza Capitolo</span>
                      </div>
                    </div>
                    
                    <div className="grid grid-cols-3 gap-2 text-sm">
                      <div className="text-center p-2 bg-blue-100 rounded-xl">
                        <div className="font-bold text-blue-600">{getWordsWithoutChapterStats().totalWords}</div>
                        <div className="text-blue-700 text-xs">Totale</div>
                      </div>
                      <div className="text-center p-2 bg-green-100 rounded-xl">
                        <div className="font-bold text-green-600">{getWordsWithoutChapterStats().learnedWords}</div>
                        <div className="text-green-700 text-xs">Apprese</div>
                      </div>
                      <div className="text-center p-2 bg-orange-100 rounded-xl">
                        <div className="font-bold text-orange-600">{getWordsWithoutChapterStats().availableForTest}</div>
                        <div className="text-orange-700 text-xs">Per Test</div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Riepilogo e azioni */}
            <div className="border-t pt-6">
              <div className="flex justify-between items-center mb-4">
                <div className="text-lg font-bold text-gray-800">
                  Parole selezionate per il test: 
                  <span className="text-2xl text-blue-600 ml-2">{getTotalSelectedWords()}</span>
                </div>
              </div>
              
              <div className="flex justify-end gap-4">
                <Button 
                  onClick={onClose}
                  variant="outline"
                  className="px-8 py-3 text-lg"
                >
                  Annulla
                </Button>
                <Button 
                  onClick={handleStartTest}
                  disabled={getTotalSelectedWords() === 0}
                  className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-8 py-3 text-lg shadow-xl disabled:opacity-50"
                >
                  <Play className="w-5 h-5 mr-2" />
                  Inizia Test ({getTotalSelectedWords()} parole)
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default ChapterTestSelector;

================================================================================

NOME FILE: src\components\JSONManager.js

// /src/components/JSONManager.js
// +// This file contains the JSONManager component, which allows users to export and import vocabulary words in JSON format.
// +// It provides functionality to export the current vocabulary as a JSON string, display it in a textarea, and import words from a JSON string.
// +// The component includes buttons for exporting and importing JSON, and it handles notifications for successful operations or errors.
// +// The JSONManager component is designed to help users back up their vocabulary or share it between devices, making it easier to manage their vocabulary data.
// +// It is styled using Tailwind CSS for a modern and responsive design.

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Textarea } from './ui/textarea';
import { FileDown, ChevronDown, ChevronUp } from 'lucide-react';

const JSONManager = ({ words, onImportWords, showNotification }) => {
  const [jsonText, setJsonText] = useState('');
  const [showSection, setShowSection] = useState(false);

  const handleExport = () => {
    if (words.length === 0) {
      showNotification('⚠️ Nessuna parola da esportare!');
      return;
    }

    try {
      const dataStr = JSON.stringify(words, null, 2);
      setJsonText(dataStr);
      setShowSection(true);
      showNotification('✅ Parole esportate con successo!');
    } catch (error) {
      console.error('Error exporting words:', error);
      showNotification('❌ Errore durante l\'esportazione!');
    }
  };

  const handleImport = () => {
    if (!jsonText.trim()) {
      showNotification('⚠️ Inserisci del JSON da importare!');
      return;
    }

    try {
      const newWordsCount = onImportWords(jsonText.trim());
      setJsonText('');
      showNotification(`✅ ${newWordsCount} parole importate con successo!`);
    } catch (error) {
      const errorMessage = error.message.includes('JSON') ? 
        '❌ JSON non valido! Controlla la sintassi.' : 
        `❌ ${error.message}`;
      showNotification(errorMessage);
    }
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader 
        className="cursor-pointer hover:bg-gray-50 transition-colors" 
        onClick={() => setShowSection(!showSection)}
      >
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <FileDown className="w-6 h-6 text-indigo-600" />
            <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
              Gestione Dati JSON
            </span>
          </div>
          {showSection ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
        </CardTitle>
      </CardHeader>
      {showSection && (
        <CardContent className="animate-fade-in">
          <div className="space-y-4">
            <div className="p-4 bg-blue-50 rounded-2xl border border-blue-200">
              <p className="text-blue-800 text-sm flex items-center gap-2">
                <span className="text-lg">💡</span>
                Usa questa sezione per fare backup del tuo vocabolario o condividerlo tra dispositivi
              </p>
            </div>
            
            <div className="flex gap-2">
              <Button 
                onClick={handleExport} 
                variant="outline" 
                disabled={words.length === 0}
                className="border-2 border-blue-300 hover:border-blue-400 bg-blue-50 hover:bg-blue-100 text-blue-600"
              >
                📤 Esporta JSON
              </Button>
              <Button 
                onClick={handleImport} 
                variant="outline"
                className="border-2 border-purple-300 hover:border-purple-400 bg-purple-50 hover:bg-purple-100 text-purple-600"
              >
                📥 Importa JSON
              </Button>
            </div>
            
            <Textarea
              placeholder="Il JSON delle parole apparirà qui dopo 'Esporta JSON', oppure incolla qui il JSON da importare..."
              value={jsonText}
              onChange={(e) => setJsonText(e.target.value)}
              rows={12}
              className="font-mono text-sm border-2 border-gray-200 rounded-2xl focus:border-blue-500 transition-colors"
            />
          </div>
        </CardContent>
      )}
    </Card>
  );
};

export default JSONManager;

================================================================================

NOME FILE: src\components\StatsManager.css

/* components/StatsManager.css */

.stats-manager {
  max-width: 1000px;
  margin: 0 auto;
  padding: 2rem;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.stats-manager__header {
  text-align: center;
  margin-bottom: 2rem;
}

.stats-manager__header h2 {
  color: #2c3e50;
  margin-bottom: 0.5rem;
  font-size: 2.2rem;
}

.stats-manager__header p {
  color: #7f8c8d;
  font-size: 1.1rem;
}

/* Riepilogo Statistiche */
.stats-summary {
  margin-bottom: 2rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.stat-card {
  background: linear-gradient(145deg, #ffffff, #f8f9fa);
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 1.5rem;
  display: flex;
  align-items: center;
  gap: 1rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.stat-icon {
  font-size: 2rem;
  line-height: 1;
}

.stat-content h3 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: bold;
  color: #2c3e50;
}

.stat-content p {
  margin: 0;
  color: #7f8c8d;
  font-size: 0.9rem;
  font-weight: 500;
}

/* Dettagli Statistiche */
.stats-details {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
  margin-bottom: 3rem;
}

.detail-section {
  background: #f8f9fa;
  border-radius: 8px;
  padding: 1.5rem;
  border-left: 4px solid #3498db;
}

.detail-section h4 {
  margin: 0 0 1rem 0;
  color: #2c3e50;
  font-size: 1.2rem;
}

.detail-section p {
  margin: 0.5rem 0;
  color: #5a6c7d;
}

.detail-section strong {
  color: #2c3e50;
  font-weight: 600;
}

/* Progresso Categorie */
.category-progress {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 0.8rem;
}

.category-name {
  min-width: 100px;
  font-weight: 500;
  color: #2c3e50;
  font-size: 0.9rem;
}

.progress-bar {
  flex: 1;
  height: 8px;
  background: #e9ecef;
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #3498db, #2ecc71);
  border-radius: 4px;
  transition: width 0.3s ease;
}

.progress-text {
  font-size: 0.8rem;
  color: #7f8c8d;
  font-weight: 500;
  min-width: 80px;
  text-align: right;
}

/* Azioni di Gestione */
.stats-actions {
  display: grid;
  gap: 2rem;
}

.action-section {
  background: #ffffff;
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

.action-section h3 {
  margin: 0 0 0.5rem 0;
  color: #2c3e50;
  font-size: 1.3rem;
}

.action-section p {
  margin: 0 0 1.5rem 0;
  color: #7f8c8d;
}

.action-buttons {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}

/* Pulsanti */
.btn {
  padding: 0.8rem 1.5rem;
  border: none;
  border-radius: 8px;
  font-size: 0.95rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  text-decoration: none;
  min-width: 150px;
  justify-content: center;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-primary {
  background: linear-gradient(145deg, #3498db, #2980b9);
  color: white;
  box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);
}

.btn-primary:hover:not(:disabled) {
  background: linear-gradient(145deg, #2980b9, #21618c);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
}

.btn-secondary {
  background: linear-gradient(145deg, #95a5a6, #7f8c8d);
  color: white;
  box-shadow: 0 2px 10px rgba(149, 165, 166, 0.3);
}

.btn-secondary:hover:not(:disabled) {
  background: linear-gradient(145deg, #7f8c8d, #6c7b7d);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(149, 165, 166, 0.4);
}

.btn-danger {
  background: linear-gradient(145deg, #e74c3c, #c0392b);
  color: white;
  box-shadow: 0 2px 10px rgba(231, 76, 60, 0.3);
}

.btn-danger:hover:not(:disabled) {
  background: linear-gradient(145deg, #c0392b, #a93226);
  transform: translateY(-1px);
  box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
}

/* Zona Pericolosa */
.danger-zone {
  border-color: #e74c3c !important;
  border-left: 4px solid #e74c3c !important;
  background: linear-gradient(145deg, #fff5f5, #ffffff) !important;
}

.danger-zone h3 {
  color: #e74c3c !important;
}

/* Informazioni sul Formato */
.format-info {
  margin-top: 2rem;
  background: #f8f9fa;
  border-radius: 8px;
  overflow: hidden;
}

.format-info details {
  cursor: pointer;
}

.format-info summary {
  padding: 1rem 1.5rem;
  background: #e9ecef;
  font-weight: 500;
  color: #2c3e50;
  border: none;
  outline: none;
  user-select: none;
  transition: background 0.2s ease;
}

.format-info summary:hover {
  background: #dee2e6;
}

.format-info summary::-webkit-details-marker {
  display: none;
}

.format-info summary::before {
  content: '▶';
  margin-right: 0.5rem;
  transition: transform 0.2s ease;
}

.format-info[open] summary::before {
  transform: rotate(90deg);
}

.format-content {
  padding: 1.5rem;
}

.format-content ul {
  margin: 1rem 0;
  padding-left: 1.5rem;
}

.format-content li {
  margin: 0.5rem 0;
  color: #5a6c7d;
}

/* Responsive Design */
@media (max-width: 768px) {
  .stats-manager {
    padding: 1rem;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .stats-details {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .action-buttons {
    flex-direction: column;
  }
  
  .btn {
    width: 100%;
    min-width: auto;
  }
  
  .category-progress {
    flex-direction: column;
    align-items: stretch;
    gap: 0.5rem;
  }
  
  .category-name {
    min-width: auto;
    text-align: center;
  }
  
  .progress-text {
    text-align: center;
    min-width: auto;
  }
}

@media (max-width: 480px) {
  .stats-manager__header h2 {
    font-size: 1.8rem;
  }
  
  .stats-manager__header p {
    font-size: 1rem;
  }
  
  .stat-card {
    padding: 1rem;
  }
  
  .stat-content h3 {
    font-size: 1.5rem;
  }
  
  .detail-section {
    padding: 1rem;
  }
  
  .action-section {
    padding: 1.5rem;
  }
}

/* Animazioni */
@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.stats-manager > * {
  animation: slideIn 0.3s ease-out;
}

.stats-manager > *:nth-child(2) {
  animation-delay: 0.1s;
}

.stats-manager > *:nth-child(3) {
  animation-delay: 0.2s;
}

.stats-manager > *:nth-child(4) {
  animation-delay: 0.3s;
}

================================================================================

NOME FILE: src\components\StatsManager.js

// components/StatsManager.js - Versione Sincronizzata
import React, { useState, useRef, useEffect } from 'react';
import { useStats } from '../hooks/useStats';
import './StatsManager.css';

/**
 * ⭐ VERSIONE MIGLIORATA: Gestione completa con sincronizzazione automatica
 * - Import/Export unificato di statistiche + cronologia
 * - Cancellazione sincronizzata
 * - Aggiornamento UI automatico
 * - Gestione errori robusta
 */
const StatsManager = ({ onDataUpdated, forceUpdate }) => {
  const { 
    stats, 
    testHistory,
    calculatedStats, 
    exportStats, 
    importStats, 
    resetStats, 
    clearHistoryOnly,
    forceMigration, 
    isMigrated,
    refreshData,
    isProcessing
  } = useStats();

  const [isImporting, setIsImporting] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const fileInputRef = useRef(null);

  // ⭐ NUOVO: Effetto per aggiornare l'UI quando cambiano i dati
  useEffect(() => {
    if (onDataUpdated) {
      onDataUpdated();
    }
  }, [stats.testsCompleted, testHistory.length, forceUpdate, onDataUpdated]);

  // ⭐ MIGLIORATO: Export con feedback visivo
  const handleExport = async () => {
    if (isExporting || isProcessing) return;
    
    try {
      setIsExporting(true);
      await new Promise(resolve => setTimeout(resolve, 100)); // Small delay per UI feedback
      exportStats();
    } catch (error) {
      console.error('❌ Errore export:', error);
    } finally {
      setIsExporting(false);
    }
  };

  const handleImportClick = () => {
    if (isImporting || isProcessing) return;
    fileInputRef.current?.click();
  };

  // ⭐ MIGLIORATO: Import con sincronizzazione automatica
  const handleFileSelect = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (file.type !== 'application/json') {
      alert('Per favore seleziona un file JSON valido');
      return;
    }

    if (isImporting || isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    setIsImporting(true);
    
    try {
      console.log('🔄 Inizio importazione file:', file.name);
      
      // Importa i dati
      const result = await importStats(file);
      
      console.log('✅ Importazione completata:', result);
      
      // ⭐ SINCRONIZZAZIONE AUTOMATICA: Refresh multipli per garantire aggiornamento UI
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
        
        // Secondo refresh per sicurezza
        setTimeout(() => {
          refreshData();
          if (onDataUpdated) onDataUpdated();
        }, 300);
      }, 200);
      
    } catch (error) {
      console.error('❌ Errore importazione:', error);
      alert(`Errore durante l'importazione: ${error.message}`);
    } finally {
      setIsImporting(false);
      // Reset input per permettere di selezionare lo stesso file
      event.target.value = '';
    }
  };

  // ⭐ MIGLIORATO: Migrazione forzata con refresh
  const handleForceMigration = async () => {
    if (isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    try {
      console.log('🔄 Inizio migrazione forzata...');
      await forceMigration();
      
      // ⭐ REFRESH AUTOMATICO
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
      }, 300);
      
    } catch (error) {
      console.error('❌ Errore migrazione:', error);
      alert(`Errore durante la migrazione: ${error.message}`);
    }
  };

  // ⭐ MIGLIORATO: Reset completo con conferma avanzata
  const handleReset = async () => {
    if (isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    const confirmation = window.confirm(
      `⚠️ ATTENZIONE: Conferma cancellazione completa\n\n` +
      `Verranno cancellati:\n` +
      `• ${stats.testsCompleted} test dalle statistiche\n` +
      `• ${testHistory.length} test dalla cronologia\n` +
      `• Tutti i progressi e dati di apprendimento\n\n` +
      `Questa operazione è IRREVERSIBILE.\n\n` +
      `Sei assolutamente sicuro di voler procedere?`
    );

    if (!confirmation) return;

    // Doppia conferma per sicurezza
    const doubleConfirmation = window.confirm(
      '🚨 ULTIMA CONFERMA\n\n' +
      'Stai per ELIMINARE DEFINITIVAMENTE tutti i tuoi dati.\n' +
      'Non sarà possibile recuperarli.\n\n' +
      'Procedi con la cancellazione completa?'
    );

    if (!doubleConfirmation) return;

    try {
      console.log('🗑️ Inizio reset completo...');
      await resetStats();
      
      // ⭐ REFRESH AUTOMATICO
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
      }, 200);
      
    } catch (error) {
      console.error('❌ Errore reset:', error);
      alert(`Errore durante il reset: ${error.message}`);
    }
  };

  // ⭐ NUOVO: Cancella solo cronologia
  const handleClearHistoryOnly = async () => {
    if (isProcessing) {
      alert('Operazione già in corso, attendere...');
      return;
    }

    const confirmation = window.confirm(
      `Vuoi cancellare solo la cronologia dei test?\n\n` +
      `Verranno cancellati ${testHistory.length} test dalla cronologia.\n` +
      `Le statistiche rimarranno invariate.\n\n` +
      `Continuare?`
    );

    if (!confirmation) return;

    try {
      console.log('🗑️ Cancellazione cronologia...');
      await clearHistoryOnly();
      
      // ⭐ REFRESH AUTOMATICO
      setTimeout(() => {
        refreshData();
        if (onDataUpdated) onDataUpdated();
      }, 200);
      
    } catch (error) {
      console.error('❌ Errore cancellazione cronologia:', error);
      alert(`Errore durante la cancellazione: ${error.message}`);
    }
  };

  const formatTime = (minutes) => {
    if (minutes < 60) return `${minutes}m`;
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return `${hours}h ${remainingMinutes}m`;
  };

  const formatDate = (dateString) => {
    if (!dateString) return 'Mai';
    return new Date(dateString).toLocaleDateString('it-IT');
  };

  return (
    <div className="stats-manager">
      <div className="stats-manager__header">
        <h2>📊 Gestione Statistiche Centralizzata</h2>
        <p>Esporta, importa o gestisci le tue statistiche e cronologia in modo sincronizzato</p>
        {isProcessing && (
          <div className="processing-indicator" style={{
            background: '#e3f2fd',
            border: '1px solid #2196f3',
            borderRadius: '8px',
            padding: '1rem',
            marginTop: '1rem',
            color: '#1976d2'
          }}>
            ⏳ <strong>Operazione in corso...</strong> Attendere il completamento.
          </div>
        )}
      </div>

      {/* ⭐ AGGIORNATO: Riepilogo con dati real-time */}
      <div className="stats-summary">
        <div className="stats-grid">
          <div className="stat-card">
            <div className="stat-icon">🎯</div>
            <div className="stat-content">
              <h3>{stats.testsCompleted}</h3>
              <p>Test Statistiche</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">📅</div>
            <div className="stat-content">
              <h3>{testHistory.length}</h3>
              <p>Test Cronologia</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">📈</div>
            <div className="stat-content">
              <h3>{calculatedStats.accuracyRate}%</h3>
              <p>Precisione Media</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">🔥</div>
            <div className="stat-content">
              <h3>{stats.streakDays}</h3>
              <p>Giorni Streak</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">⏱️</div>
            <div className="stat-content">
              <h3>{formatTime(stats.timeSpent)}</h3>
              <p>Tempo Totale</p>
            </div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">✅</div>
            <div className="stat-content">
              <h3>{isMigrated ? 'Sync' : 'No'}</h3>
              <p>Stato Sincr.</p>
            </div>
          </div>
        </div>
      </div>

      {/* ⭐ AGGIORNATO: Dettagli con stato sincronizzazione */}
      <div className="stats-details">
        <div className="detail-section">
          <h4>📚 Vocabolario</h4>
          <p>Parole totali: <strong>{stats.totalWords}</strong></p>
          <p>Risposte corrette: <strong>{stats.correctAnswers}</strong></p>
          <p>Risposte sbagliate: <strong>{stats.incorrectAnswers}</strong></p>
        </div>

        <div className="detail-section">
          <h4>📅 Attività</h4>
          <p>Ultimo studio: <strong>{formatDate(stats.lastStudyDate)}</strong></p>
          <p>Tempo medio per test: <strong>{calculatedStats.avgTimePerTest}m</strong></p>
          <p>Attivo oggi: <strong>{calculatedStats.isActiveToday ? '✅ Sì' : '❌ No'}</strong></p>
        </div>

        <div className="detail-section">
          <h4>🔄 Sincronizzazione</h4>
          <p>Statistiche: <strong>{stats.testsCompleted} test</strong></p>
          <p>Cronologia: <strong>{testHistory.length} test</strong></p>
          <p>Stato: <strong>{isMigrated ? '✅ Sincronizzato' : '⏳ In attesa'}</strong></p>
          <p>Processing: <strong>{isProcessing ? '🔄 Attivo' : '✅ Pronto'}</strong></p>
        </div>

        {Object.keys(stats.categoriesProgress).length > 0 && (
          <div className="detail-section">
            <h4>🏷️ Progresso per Categoria</h4>
            {Object.entries(stats.categoriesProgress).map(([category, progress]) => (
              <div key={category} className="category-progress">
                <span className="category-name">{category}</span>
                <div className="progress-bar">
                  <div 
                    className="progress-fill"
                    style={{ 
                      width: `${progress.total > 0 ? (progress.correct / progress.total) * 100 : 0}%` 
                    }}
                  ></div>
                </div>
                <span className="progress-text">
                  {progress.correct}/{progress.total} ({progress.total > 0 ? Math.round((progress.correct / progress.total) * 100) : 0}%)
                </span>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* ⭐ MIGLIORATO: Azioni con stato sincronizzazione */}
      <div className="stats-actions">
        <div className="action-section">
          <h3>💾 Backup Completo Sincronizzato</h3>
          <p>Esporta o importa TUTTO in modo sincronizzato: statistiche + cronologia completa</p>
          
          <div className="action-buttons">
            <button 
              className={`btn btn-primary ${isExporting || isProcessing ? 'loading' : ''}`}
              onClick={handleExport}
              disabled={isExporting || isProcessing}
              title="Scarica backup completo: statistiche + cronologia"
            >
              {isExporting ? '⏳ Esportando...' : '📥 Esporta Backup Completo'}
            </button>
            
            <button 
              className={`btn btn-secondary ${isImporting || isProcessing ? 'loading' : ''}`}
              onClick={handleImportClick}
              disabled={isImporting || isProcessing}
              title="Carica backup completo con sincronizzazione automatica"
            >
              {isImporting ? '⏳ Importando...' : '📤 Importa Backup'}
            </button>
            
            <input
              ref={fileInputRef}
              type="file"
              accept=".json"
              onChange={handleFileSelect}
              style={{ display: 'none' }}
            />
          </div>
          
          <div className="format-content" style={{ 
            marginTop: '1rem', 
            padding: '1rem', 
            background: '#e8f5e8', 
            borderRadius: '8px' 
          }}>
            <p style={{ margin: 0, fontSize: '0.9rem', color: '#2d5d2d' }}>
              💡 <strong>Backup v2.0 Sincronizzato:</strong> Include {stats.testsCompleted} statistiche + {testHistory.length} cronologia
              {!isMigrated && <span style={{ color: '#d32f2f' }}> (⚠️ Non sincronizzato)</span>}
            </p>
          </div>
        </div>

        {/* ⭐ NUOVO: Sezione Sincronizzazione Avanzata */}
        <div className="action-section">
          <h3>🔄 Sincronizzazione Dati</h3>
          <p>Gestisci la sincronizzazione tra statistiche e cronologia test</p>
          
          <div className="action-buttons">
            <button 
              className={`btn btn-secondary ${isProcessing ? 'loading' : ''}`}
              onClick={handleForceMigration}
              disabled={isProcessing}
              title="Ri-sincronizza i dati dalla cronologia test esistente"
            >
              {isProcessing ? '⏳ Migrando...' : '🔄 Forza Sincronizzazione'}
            </button>
            
            <button 
              className={`btn btn-secondary ${isProcessing ? 'loading' : ''}`}
              onClick={() => {
                refreshData();
                if (onDataUpdated) onDataUpdated();
              }}
              disabled={isProcessing}
              title="Aggiorna manualmente l'interfaccia"
            >
              🔃 Refresh Interface
            </button>
          </div>
          
          <div className="format-content" style={{ 
            marginTop: '1rem', 
            padding: '1rem', 
            background: isMigrated ? '#e8f5e8' : '#fff3e0', 
            borderRadius: '8px' 
          }}>
            <p style={{ margin: 0, fontSize: '0.9rem', color: isMigrated ? '#2d5d2d' : '#e65100' }}>
              {isMigrated 
                ? '✅ Dati sincronizzati correttamente' 
                : '⚠️ Sincronizzazione richiesta - usa "Forza Sincronizzazione"'
              }
            </p>
          </div>
        </div>

        {/* ⭐ MIGLIORATO: Cancellazioni con opzioni separate */}
        <div className="action-section danger-zone">
          <h3>⚠️ Zona Pericolosa</h3>
          <p>Attenzione: queste azioni sono irreversibili</p>
          
          <div className="action-buttons">
            <button 
              className={`btn btn-danger ${isProcessing ? 'loading' : ''}`}
              onClick={handleClearHistoryOnly}
              disabled={isProcessing}
              title="Cancella solo la cronologia (mantiene statistiche)"
            >
              {isProcessing ? '⏳ Cancellando...' : '🗑️ Cancella Solo Cronologia'}
            </button>
            
            <button 
              className={`btn btn-danger ${isProcessing ? 'loading' : ''}`}
              onClick={handleReset}
              disabled={isProcessing}
              title="Cancella tutto: statistiche + cronologia (irreversibile)"
            >
              {isProcessing ? '⏳ Resettando...' : '🗑️ Reset Completo'}
            </button>
          </div>
          
          <div className="format-content" style={{ 
            marginTop: '1rem', 
            padding: '1rem', 
            background: '#ffebee', 
            borderRadius: '8px',
            border: '1px solid #f44336'
          }}>
            <p style={{ margin: 0, fontSize: '0.9rem', color: '#c62828' }}>
              ⚠️ <strong>Attenzione:</strong> Le operazioni di cancellazione sono permanenti e non possono essere annullate.
              Assicurati di aver fatto un backup prima di procedere.
            </p>
          </div>
        </div>
      </div>

      {/* ⭐ AGGIORNATO: Informazioni sul formato con stato sincronizzazione */}
      <div className="format-info">
        <details>
          <summary>ℹ️ Informazioni sul Sistema Sincronizzato</summary>
          <div className="format-content">
            <p><strong>🎯 Sistema Unificato v2.0 - Sincronizzazione Automatica</strong></p>
            <p>Il sistema gestisce automaticamente:</p>
            <ul>
              <li>📊 <strong>Statistiche Avanzate:</strong> Precisione, streak, tempo, categorie ({stats.testsCompleted} test)</li>
              <li>📅 <strong>Cronologia Completa:</strong> Tutti i test con dettagli ({testHistory.length} test)</li>
              <li>🔄 <strong>Sincronizzazione:</strong> Aggiornamento automatico dell'interfaccia</li>
              <li>⚡ <strong>Performance:</strong> Operazioni ottimizzate e feedback in tempo reale</li>
              <li>🛡️ <strong>Sicurezza:</strong> Validazione dati e conferme multiple</li>
            </ul>
            
            <div style={{ background: '#f0f8ff', padding: '1rem', borderRadius: '8px', marginTop: '1rem' }}>
              <p style={{ margin: 0, fontSize: '0.9rem' }}>
                <strong>🔄 Stato Sincronizzazione Attuale:</strong><br/>
                ✅ Statistiche: {stats.testsCompleted} test<br/>
                ✅ Cronologia: {testHistory.length} test<br/>
                {isMigrated ? '✅ Sincronizzato' : '⚠️ Richiede sincronizzazione'}<br/>
                {isProcessing ? '🔄 Operazione in corso...' : '✅ Sistema pronto'}
              </p>
            </div>
            
            <div style={{ background: '#e8f5e8', padding: '1rem', borderRadius: '8px', marginTop: '1rem' }}>
              <p style={{ margin: 0, fontSize: '0.9rem' }}>
                <strong>🛡️ Sicurezza e Backup:</strong><br/>
                • Tutti i dati vengono validati durante import/export<br/>
                • Conferme multiple per operazioni distruttive<br/>
                • Backup automatico prima di operazioni critiche<br/>
                • Possibilità di combinare o sostituire dati esistenti
              </p>
            </div>
          </div>
        </details>
      </div>
    </div>
  );
};

export default StatsManager;

================================================================================

NOME FILE: src\components\StatsOverview.js

// /src/components/StatsOverview.js - Versione Sincronizzata
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, BarChart, Bar, PieChart, Pie, Cell, Area, AreaChart } from 'recharts';
import { BarChart3, TrendingUp, Trophy, Sparkles, Play, BookOpen, Target, Award, Calendar, Filter } from 'lucide-react';

// ⭐ COMPONENTE AGGIORNATO: Usa dati centralizzati con sincronizzazione automatica
const StatsOverview = ({ testHistory, words, onClearHistory, onGoToMain, forceUpdate }) => {
  const [selectedView, setSelectedView] = useState('overview');
  const [selectedChapter, setSelectedChapter] = useState('all');
  
  // ⭐ NUOVO: State per forzare refresh quando cambiano i dati
  const [localRefresh, setLocalRefresh] = useState(0);

  // ⭐ NUOVO: Effetto per aggiornare quando cambiano i dati esterni
  useEffect(() => {
    setLocalRefresh(prev => prev + 1);
  }, [testHistory.length, forceUpdate]);

  // ⭐ FIXED: Analisi avanzata dei dati senza localRefresh nelle dipendenze
  const getAdvancedStats = React.useMemo(() => {
    if (testHistory.length === 0) {
      return {
        totalTests: 0,
        averageScore: 0,
        bestScore: 0,
        worstScore: 0,
        totalWordsStudied: 0,
        totalCorrect: 0,
        totalIncorrect: 0,
        chaptersAnalyzed: 0,
        testTypeDistribution: {},
        difficultyDistribution: {},
        improvementTrend: 0,
        lastWeekTests: 0,
        chapterPerformance: {}
      };
    }

    console.log('📊 Calcolo statistiche per', testHistory.length, 'test'); // Debug log

    const totalTests = testHistory.length;
    const totalCorrect = testHistory.reduce((sum, test) => sum + (test.correctWords || 0), 0);
    const totalIncorrect = testHistory.reduce((sum, test) => sum + (test.incorrectWords || 0), 0);
    const totalWordsStudied = totalCorrect + totalIncorrect;
    const averageScore = Math.round(testHistory.reduce((sum, test) => sum + (test.percentage || 0), 0) / totalTests);
    const bestScore = Math.max(...testHistory.map(test => test.percentage || 0));
    const worstScore = Math.min(...testHistory.map(test => test.percentage || 100));

    // Analisi tipi di test
    const testTypeDistribution = testHistory.reduce((acc, test) => {
      const type = test.testType || 'unknown';
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {});

    // Analisi difficoltà
    const difficultyDistribution = testHistory.reduce((acc, test) => {
      const difficulty = test.difficulty || 'medium';
      acc[difficulty] = (acc[difficulty] || 0) + 1;
      return acc;
    }, {});

    // Performance per capitolo
    const chapterPerformance = {};
    testHistory.forEach(test => {
      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, stats]) => {
          if (!chapterPerformance[chapter]) {
            chapterPerformance[chapter] = {
              totalTests: 0,
              totalWords: 0,
              totalCorrect: 0,
              totalIncorrect: 0,
              averagePercentage: 0,
              bestPercentage: 0,
              worstPercentage: 100
            };
          }
          
          const perf = chapterPerformance[chapter];
          perf.totalTests += 1;
          perf.totalWords += stats.totalWords || 0;
          perf.totalCorrect += stats.correctWords || 0;
          perf.totalIncorrect += stats.incorrectWords || 0;
          perf.bestPercentage = Math.max(perf.bestPercentage, stats.percentage || 0);
          perf.worstPercentage = Math.min(perf.worstPercentage, stats.percentage || 100);
        });
      }
    });

    // Calcola percentuali medie per capitolo
    Object.keys(chapterPerformance).forEach(chapter => {
      const perf = chapterPerformance[chapter];
      perf.averagePercentage = perf.totalWords > 0 ? Math.round((perf.totalCorrect / perf.totalWords) * 100) : 0;
    });

    // Trend di miglioramento
    let improvementTrend = 0;
    if (totalTests >= 4) {
      const recentTests = testHistory.slice(0, Math.min(5, Math.floor(totalTests / 2)));
      const olderTests = testHistory.slice(Math.min(5, Math.floor(totalTests / 2)), Math.min(10, totalTests));
      
      if (olderTests.length > 0) {
        const recentAvg = recentTests.reduce((sum, test) => sum + (test.percentage || 0), 0) / recentTests.length;
        const olderAvg = olderTests.reduce((sum, test) => sum + (test.percentage || 0), 0) / olderTests.length;
        improvementTrend = Math.round(recentAvg - olderAvg);
      }
    }

    // Test ultima settimana
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    const lastWeekTests = testHistory.filter(test => 
      new Date(test.timestamp) >= oneWeekAgo
    ).length;

    return {
      totalTests,
      averageScore,
      bestScore,
      worstScore,
      totalWordsStudied,
      totalCorrect,
      totalIncorrect,
      chaptersAnalyzed: Object.keys(chapterPerformance).length,
      testTypeDistribution,
      difficultyDistribution,
      improvementTrend,
      lastWeekTests,
      chapterPerformance
    };
  }, [testHistory]); // ⭐ FIXED: Rimosso localRefresh dalle dipendenze

  // ⭐ FIXED: Timeline data senza localRefresh nelle dipendenze
  const getTimelineData = React.useMemo(() => {
    const data = [...testHistory].reverse().slice(-20).map((test, index) => ({
      test: `Test ${index + 1}`,
      percentage: test.percentage || 0,
      correct: test.correctWords || 0,
      incorrect: test.incorrectWords || 0,
      date: new Date(test.timestamp).toLocaleDateString('it-IT'),
      time: new Date(test.timestamp).toLocaleTimeString('it-IT', { 
        hour: '2-digit', 
        minute: '2-digit' 
      }),
      chapters: test.testParameters?.selectedChapters?.length || 0,
      difficulty: test.difficulty || 'medium',
      type: test.testType || 'unknown'
    }));
    
    console.log('📈 Timeline data aggiornata:', data.length, 'punti'); // Debug log
    return data;
  }, [testHistory]); // ⭐ FIXED: Rimosso localRefresh dalle dipendenze

  // ⭐ FIXED: Chapter comparison data senza localRefresh nelle dipendenze
  const getChapterComparisonData = React.useMemo(() => {
    return Object.entries(getAdvancedStats.chapterPerformance).map(([chapter, perf]) => ({
      chapter: chapter === 'Senza Capitolo' ? 'Senza Cap.' : `Cap. ${chapter}`,
      fullChapter: chapter,
      percentage: perf.averagePercentage,
      tests: perf.totalTests,
      words: perf.totalWords,
      best: perf.bestPercentage,
      worst: perf.worstPercentage
    })).sort((a, b) => b.percentage - a.percentage);
  }, [getAdvancedStats]); // ⭐ FIXED: Rimosso localRefresh dalle dipendenze

  // ⭐ FIXED: Difficulty data senza localRefresh nelle dipendenze
  const getDifficultyData = React.useMemo(() => {
    return Object.entries(getAdvancedStats.difficultyDistribution).map(([difficulty, count]) => ({
      name: difficulty === 'easy' ? 'Facile' : difficulty === 'medium' ? 'Medio' : 'Difficile',
      value: count,
      percentage: Math.round((count / getAdvancedStats.totalTests) * 100),
      color: difficulty === 'easy' ? '#10b981' : difficulty === 'medium' ? '#f59e0b' : '#ef4444'
    }));
  }, [getAdvancedStats]); // ⭐ FIXED: Rimosso localRefresh dalle dipendenze

  // ⭐ AGGIORNATO: Handler per cancellazione con feedback
  const handleClearHistory = React.useCallback(() => {
    if (window.confirm(`Vuoi cancellare la cronologia di ${testHistory.length} test? Questa azione non può essere annullata.`)) {
      console.log('🗑️ Cancellazione cronologia richiesta');
      onClearHistory();
      
      // ⭐ AGGIORNAMENTO UI IMMEDIATO
      setTimeout(() => {
        setLocalRefresh(prev => prev + 1);
      }, 100);
    }
  }, [testHistory.length, onClearHistory]);

  if (testHistory.length === 0) {
    return (
      <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
        <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1">
          <div className="bg-white rounded-3xl p-8">
            <div className="text-center py-16">
              <div className="text-8xl mb-6">📊</div>
              <h3 className="text-2xl font-bold text-gray-700 mb-4">Nessun test completato</h3>
              <p className="text-gray-600 text-lg mb-8">Completa il tuo primo test per vedere le statistiche dettagliate!</p>
              <Button 
                onClick={onGoToMain} 
                className="bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl"
              >
                <Play className="w-5 h-5 mr-2" />
                Inizia il Primo Test
              </Button>
            </div>
          </div>
        </div>
      </Card>
    );
  }

  return (
    <div className="space-y-8 animate-fade-in">
      {/* ⭐ AGGIORNATO: Header con indicatori di sincronizzazione */}
      <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
        <div className="bg-gradient-to-r from-purple-500 to-pink-500 p-1">
          <div className="bg-white rounded-3xl p-6">
            <div className="flex justify-between items-center mb-6">
              <CardTitle className="flex items-center gap-3 text-3xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
                <BarChart3 className="w-8 h-8 text-purple-600" />
                Analisi Avanzata dell'Apprendimento
                {/* ⭐ NUOVO: Indicatore di aggiornamento */}
                <span className="text-sm bg-green-100 text-green-700 px-2 py-1 rounded-full">
                  Live: {testHistory.length} test
                </span>
              </CardTitle>
              <Button
                onClick={handleClearHistory}
                variant="outline"
                className="border-red-300 text-red-600 hover:bg-red-50"
                disabled={testHistory.length === 0}
              >
                🗑️ Pulisci Cronologia ({testHistory.length})
              </Button>
            </div>

            {/* Navigation Tabs */}
            <div className="flex gap-2 mb-6">
              {[
                { id: 'overview', label: 'Panoramica', icon: '📈' },
                { id: 'chapters', label: 'Per Capitoli', icon: '📚' },
                { id: 'performance', label: 'Performance', icon: '🎯' },
                { id: 'trends', label: 'Tendenze', icon: '📊' }
              ].map(tab => (
                <Button
                  key={tab.id}
                  onClick={() => setSelectedView(tab.id)}
                  className={`px-6 py-3 rounded-xl transition-all ${
                    selectedView === tab.id
                      ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-lg'
                      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`}
                >
                  <span className="mr-2">{tab.icon}</span>
                  {tab.label}
                </Button>
              ))}
            </div>

            {/* ⭐ AGGIORNATO: Statistiche Generali con dati real-time */}
            <div className="grid grid-cols-2 md:grid-cols-6 gap-4">
              <div className="bg-gradient-to-br from-blue-500 to-cyan-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.totalTests}</div>
                <div className="text-blue-100 text-sm">Test Totali</div>
              </div>
              <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.averageScore}%</div>
                <div className="text-green-100 text-sm">Media</div>
              </div>
              <div className="bg-gradient-to-br from-purple-500 to-pink-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.bestScore}%</div>
                <div className="text-purple-100 text-sm">Record</div>
              </div>
              <div className="bg-gradient-to-br from-orange-500 to-red-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.totalWordsStudied}</div>
                <div className="text-orange-100 text-sm">Parole</div>
              </div>
              <div className="bg-gradient-to-br from-indigo-500 to-blue-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.chaptersAnalyzed}</div>
                <div className="text-indigo-100 text-sm">Capitoli</div>
              </div>
              <div className="bg-gradient-to-br from-teal-500 to-cyan-500 p-4 rounded-2xl text-white text-center shadow-xl">
                <div className="text-2xl font-bold">{getAdvancedStats.lastWeekTests}</div>
                <div className="text-teal-100 text-sm">Ultima Settimana</div>
              </div>
            </div>
          </div>
        </div>
      </Card>

      {/* Contenuto Dinamico Basato sulla Vista Selezionata */}
      {selectedView === 'overview' && (
        <OverviewSection 
          stats={getAdvancedStats} 
          timelineData={getTimelineData} 
          difficultyData={getDifficultyData}
          localRefresh={localRefresh}
        />
      )}

      {selectedView === 'chapters' && (
        <ChaptersSection 
          chapterData={getChapterComparisonData}
          selectedChapter={selectedChapter}
          setSelectedChapter={setSelectedChapter}
          testHistory={testHistory}
          localRefresh={localRefresh}
        />
      )}

      {selectedView === 'performance' && (
        <PerformanceSection 
          stats={getAdvancedStats}
          timelineData={getTimelineData}
          localRefresh={localRefresh}
        />
      )}

      {selectedView === 'trends' && (
        <TrendsSection 
          timelineData={getTimelineData}
          stats={getAdvancedStats}
          localRefresh={localRefresh}
        />
      )}
    </div>
  );
};

// ⭐ AGGIORNATO: Sezione Panoramica con refresh automatico
const OverviewSection = ({ stats, timelineData, difficultyData, localRefresh }) => (
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-8" key={`overview-${localRefresh}`}>
    {/* Andamento Generale */}
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-blue-500 to-purple-600 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <TrendingUp className="w-6 h-6" />
          Andamento Generale (Ultimi 20 Test)
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={300}>
          <AreaChart data={timelineData} key={`area-${localRefresh}`}>
            <defs>
              <linearGradient id="colorPercentage" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor="#3b82f6" stopOpacity={0.8}/>
                <stop offset="95%" stopColor="#3b82f6" stopOpacity={0.1}/>
              </linearGradient>
            </defs>
            <CartesianGrid strokeDasharray="3 3" stroke="#e0e4e7" />
            <XAxis dataKey="test" tick={{ fontSize: 12 }} />
            <YAxis domain={[0, 100]} tick={{ fontSize: 12 }} />
            <Tooltip 
              contentStyle={{
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                border: 'none',
                borderRadius: '12px',
                boxShadow: '0 10px 25px rgba(0, 0, 0, 0.1)'
              }}
            />
            <Area 
              type="monotone" 
              dataKey="percentage" 
              stroke="#3b82f6" 
              fillOpacity={1}
              fill="url(#colorPercentage)"
              strokeWidth={3}
            />
          </AreaChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>

    {/* Distribuzione Difficoltà */}
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Target className="w-6 h-6" />
          Distribuzione Difficoltà Test
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={300}>
          <PieChart key={`pie-${localRefresh}`}>
            <Pie
              data={difficultyData}
              cx="50%"
              cy="50%"
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              label={({name, percentage}) => `${name}: ${percentage}%`}
            >
              {difficultyData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={entry.color} />
              ))}
            </Pie>
            <Tooltip />
          </PieChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>

    {/* Trend di Miglioramento */}
    {stats.improvementTrend !== 0 && (
      <Card className="lg:col-span-2 bg-gradient-to-r from-indigo-50 to-purple-50 border-2 border-indigo-200 shadow-xl rounded-3xl">
        <CardContent className="p-6">
          <div className="flex items-center gap-6">
            <div className={`p-6 rounded-3xl ${stats.improvementTrend > 0 ? 'bg-green-500' : 'bg-red-500'}`}>
              <TrendingUp className="w-12 h-12 text-white" />
            </div>
            <div>
              <div className="text-3xl font-bold">
                Trend di Miglioramento: 
                <span className={`ml-3 ${stats.improvementTrend > 0 ? 'text-green-600' : 'text-red-600'}`}>
                  {stats.improvementTrend > 0 ? '+' : ''}{stats.improvementTrend}%
                </span>
              </div>
              <div className="text-gray-600 text-lg">
                {stats.improvementTrend > 0 ? 
                  '🎉 Continua così! Stai migliorando costantemente.' :
                  '💪 Non mollare! Focalizzati sulle aree più difficili.'
                }
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
    )}
  </div>
);

// ⭐ AGGIORNATO: Sezione Capitoli con refresh
const ChaptersSection = ({ chapterData, selectedChapter, setSelectedChapter, testHistory, localRefresh }) => (
  <div className="space-y-8" key={`chapters-${localRefresh}`}>
    {/* Filtro Capitoli */}
    <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200">
      <CardContent className="p-4">
        <div className="flex items-center gap-4">
          <Filter className="w-5 h-5 text-blue-600" />
          <label className="font-medium text-blue-800">Analizza Capitolo:</label>
          <select
            value={selectedChapter}
            onChange={(e) => setSelectedChapter(e.target.value)}
            className="px-4 py-2 border border-blue-300 rounded-lg bg-white"
          >
            <option value="all">Tutti i Capitoli</option>
            {chapterData.map(chapter => (
              <option key={chapter.fullChapter} value={chapter.fullChapter}>
                {chapter.chapter}
              </option>
            ))}
          </select>
        </div>
      </CardContent>
    </Card>

    {/* Confronto Performance Capitoli */}
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-purple-500 to-pink-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <BookOpen className="w-6 h-6" />
          Performance per Capitolo
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={400}>
          <BarChart data={chapterData} margin={{ top: 20, right: 30, left: 20, bottom: 5 }} key={`bar-${localRefresh}`}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="chapter" />
            <YAxis domain={[0, 100]} />
            <Tooltip 
              formatter={(value, name) => [
                name === 'percentage' ? `${value}%` :
                name === 'best' ? `${value}%` :
                name === 'worst' ? `${value}%` : value,
                name === 'percentage' ? 'Media' :
                name === 'best' ? 'Miglior Risultato' :
                name === 'worst' ? 'Peggior Risultato' :
                name === 'tests' ? 'Test Completati' : 'Parole Studiate'
              ]}
            />
            <Bar dataKey="percentage" fill="#8b5cf6" name="percentage" />
            <Bar dataKey="best" fill="#10b981" name="best" />
            <Bar dataKey="worst" fill="#ef4444" name="worst" />
          </BarChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>

    {/* Dettagli Capitolo Selezionato */}
    {selectedChapter !== 'all' && (
      <ChapterDetailCard 
        chapter={selectedChapter}
        chapterData={chapterData.find(c => c.fullChapter === selectedChapter)}
        testHistory={testHistory}
        localRefresh={localRefresh}
      />
    )}
  </div>
);

// ⭐ FIXED: Dettagli capitolo con useMemo corretto
const ChapterDetailCard = ({ chapter, chapterData, testHistory, localRefresh }) => {
  const chapterTests = React.useMemo(() => {
    return testHistory.filter(test => 
      test.chapterStats && test.chapterStats[chapter]
    ).slice(0, 10);
  }, [testHistory, chapter]); // ⭐ FIXED: Rimosso localRefresh dalle dipendenze

  const chapterTimeline = React.useMemo(() => {
    return chapterTests.reverse().map((test, index) => ({
      test: `Test ${index + 1}`,
      percentage: test.chapterStats[chapter].percentage,
      correct: test.chapterStats[chapter].correctWords,
      incorrect: test.chapterStats[chapter].incorrectWords,
      date: new Date(test.timestamp).toLocaleDateString('it-IT')
    }));
  }, [chapterTests, chapter]); // ⭐ FIXED: Rimosso localRefresh dalle dipendenze

  return (
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden" key={`detail-${chapter}-${localRefresh}`}>
      <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Award className="w-6 h-6" />
          Dettagli Capitolo: {chapter === 'Senza Capitolo' ? 'Senza Capitolo' : `Capitolo ${chapter}`}
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Statistiche */}
          <div className="space-y-4">
            <h4 className="font-bold text-lg text-gray-800">Statistiche Generali</h4>
            <div className="grid grid-cols-2 gap-4">
              <div className="text-center p-4 bg-blue-50 rounded-xl">
                <div className="text-2xl font-bold text-blue-600">{chapterData?.percentage}%</div>
                <div className="text-blue-700 text-sm">Media</div>
              </div>
              <div className="text-center p-4 bg-green-50 rounded-xl">
                <div className="text-2xl font-bold text-green-600">{chapterData?.best}%</div>
                <div className="text-green-700 text-sm">Record</div>
              </div>
              <div className="text-center p-4 bg-purple-50 rounded-xl">
                <div className="text-2xl font-bold text-purple-600">{chapterData?.tests}</div>
                <div className="text-purple-700 text-sm">Test</div>
              </div>
              <div className="text-center p-4 bg-orange-50 rounded-xl">
                <div className="text-2xl font-bold text-orange-600">{chapterData?.words}</div>
                <div className="text-orange-700 text-sm">Parole</div>
              </div>
            </div>
          </div>

          {/* Andamento nel Tempo */}
          <div>
            <h4 className="font-bold text-lg text-gray-800 mb-4">Andamento Ultimi 10 Test</h4>
            <ResponsiveContainer width="100%" height={200}>
              <LineChart data={chapterTimeline} key={`line-${chapter}-${localRefresh}`}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="test" />
                <YAxis domain={[0, 100]} />
                <Tooltip />
                <Line 
                  type="monotone" 
                  dataKey="percentage" 
                  stroke="#8b5cf6" 
                  strokeWidth={3}
                  dot={{ fill: '#8b5cf6', strokeWidth: 2, r: 4 }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// ⭐ AGGIORNATO: Sezione Performance con refresh
const PerformanceSection = ({ stats, timelineData, localRefresh }) => (
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-8" key={`performance-${localRefresh}`}>
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-green-500 to-emerald-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Trophy className="w-6 h-6" />
          Distribuzione Punteggi
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-4">
          <div className="text-center p-6 bg-green-50 rounded-2xl border border-green-200">
            <div className="text-3xl font-bold text-green-600 mb-2">{stats.averageScore}%</div>
            <div className="text-green-700">Punteggio Medio</div>
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div className="text-center p-4 bg-blue-50 rounded-xl">
              <div className="text-xl font-bold text-blue-600">{stats.bestScore}%</div>
              <div className="text-blue-700 text-sm">Massimo</div>
            </div>
            <div className="text-center p-4 bg-red-50 rounded-xl">
              <div className="text-xl font-bold text-red-600">{stats.worstScore}%</div>
              <div className="text-red-700 text-sm">Minimo</div>
            </div>
          </div>
          <div className="text-center p-4 bg-purple-50 rounded-xl">
            <div className="text-lg font-bold text-purple-600">
              {stats.totalWordsStudied > 0 ? ((stats.totalCorrect / stats.totalWordsStudied) * 100).toFixed(1) : 0}%
            </div>
            <div className="text-purple-700 text-sm">Accuratezza Globale</div>
          </div>
        </div>
      </CardContent>
    </Card>

    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <BarChart3 className="w-6 h-6" />
          Risposte Corrette vs Sbagliate
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={timelineData.slice(-10)} key={`performance-bar-${localRefresh}`}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="test" />
            <YAxis />
            <Tooltip />
            <Bar dataKey="correct" stackId="a" fill="#10b981" name="Corrette" />
            <Bar dataKey="incorrect" stackId="a" fill="#ef4444" name="Sbagliate" />
          </BarChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  </div>
);

// ⭐ AGGIORNATO: Sezione Tendenze con refresh
const TrendsSection = ({ timelineData, stats, localRefresh }) => (
  <div className="space-y-8" key={`trends-${localRefresh}`}>
    <Card className="bg-white border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-500 text-white">
        <CardTitle className="flex items-center gap-3 text-white">
          <Calendar className="w-6 h-6" />
          Tendenze Temporali
        </CardTitle>
      </CardHeader>
      <CardContent className="p-6">
        <ResponsiveContainer width="100%" height={400}>
          <LineChart data={timelineData} key={`trends-line-${localRefresh}`}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis />
            <Tooltip />
            <Line 
              type="monotone" 
              dataKey="percentage" 
              stroke="#8b5cf6" 
              strokeWidth={3}
              name="Percentuale"
            />
            <Line 
              type="monotone" 
              dataKey="chapters" 
              stroke="#10b981" 
              strokeWidth={2}
              name="Capitoli"
            />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>

    {/* Insights e Raccomandazioni */}
    <Card className="bg-gradient-to-r from-yellow-50 to-orange-50 border-2 border-yellow-200">
      <CardContent className="p-6">
        <h3 className="text-xl font-bold text-yellow-800 mb-4 flex items-center gap-2">
          <Sparkles className="w-6 h-6" />
          Insights e Raccomandazioni
        </h3>
        <div className="space-y-3 text-yellow-700">
          {stats.improvementTrend > 0 ? (
            <p>🎯 <strong>Ottimo lavoro!</strong> Stai migliorando del {stats.improvementTrend}% negli ultimi test.</p>
          ) : (
            <p>💪 <strong>Continua a studiare!</strong> Focalizzati sui capitoli più difficili.</p>
          )}
          
          {stats.lastWeekTests > 0 ? (
            <p>🔥 <strong>Ritmo eccellente!</strong> Hai fatto {stats.lastWeekTests} test questa settimana.</p>
          ) : (
            <p>📅 <strong>Riprendi lo studio!</strong> Non hai fatto test questa settimana.</p>
          )}
          
          {stats.chaptersAnalyzed > 5 ? (
            <p>📚 <strong>Ampia copertura!</strong> Hai studiato {stats.chaptersAnalyzed} capitoli diversi.</p>
          ) : (
            <p>📖 <strong>Espandi gli orizzonti!</strong> Prova ad aggiungere più capitoli.</p>
          )}
          
          {/* ⭐ NUOVO: Insight basato sui dati real-time */}
          <p>📊 <strong>Stato attuale:</strong> {stats.totalTests} test completati con {stats.totalWordsStudied} parole studiate.</p>
        </div>
      </CardContent>
    </Card>
  </div>
);

export default StatsOverview;

================================================================================

NOME FILE: src\components\TestCard.js

// /src/components/TestCard.js
// This file contains the TestCard component, which displays a vocabulary word card that can be flipped to show its meaning.
// It includes the word in English, its Italian translation, an example sentence, and any notes associated with the word.
// The card has a front and back side, with animations for flipping. It also includes category styling based on the word's group.
// The component is designed to be interactive, allowing users to click to flip the card and view the translation and additional information.
// The TestCard component is used in the vocabulary testing feature of the application, providing a visually appealing and functional way to learn vocabulary words.
// It is styled using Tailwind CSS for a modern and responsive design.

import { getCategoryStyle } from '../utils/categoryUtils';
import { formatNotes } from '../utils/textUtils';

const TestCard = ({ word, showMeaning, onFlip }) => {
  return (
    <div 
      className="relative cursor-pointer transform transition-transform duration-300 hover:scale-105"
      style={{ width: '26rem', height: '38rem', perspective: '1000px' }}
      onClick={onFlip}
    >
      <div 
        className="absolute inset-0 w-full h-full transition-transform duration-700 preserve-3d"
        style={{ 
          transformStyle: 'preserve-3d',
          transform: showMeaning ? 'rotateY(180deg)' : 'rotateY(0deg)'
        }}
      >
        {/* Front Card */}
        <div 
          className="absolute inset-0 w-full h-full rounded-3xl shadow-2xl overflow-hidden backface-hidden"
          style={{ backfaceVisibility: 'hidden' }}
        >
          <div className="absolute inset-0 bg-gradient-to-br from-indigo-500 via-purple-600 to-pink-500"></div>
          <div className="absolute inset-0 bg-black/20"></div>
          <div className="relative h-full flex flex-col items-center justify-center text-white p-8">
            <div className="text-center space-y-6">
              <div className="text-5xl font-bold drop-shadow-lg">
                {word.english}
              </div>
              <div className="text-xl opacity-90 animate-pulse">
                Clicca per vedere la traduzione
              </div>
              <div className="mt-8">
                <div className="inline-flex items-center justify-center w-16 h-16 border-2 border-white/30 rounded-2xl backdrop-blur-sm">
                  <span className="text-2xl font-bold">EN</span>
                </div>
              </div>
            </div>
            
            {/* Animated particles */}
            <div className="absolute top-4 right-4 w-2 h-2 bg-white/50 rounded-full animate-ping"></div>
            <div className="absolute bottom-8 left-8 w-1 h-1 bg-white/30 rounded-full animate-pulse"></div>
            <div className="absolute top-1/3 left-4 w-1.5 h-1.5 bg-white/40 rounded-full animate-bounce"></div>
          </div>
        </div>

        {/* Back Card */}
        <div 
          className={`absolute inset-0 w-full h-full rounded-3xl shadow-2xl overflow-hidden backface-hidden ${getCategoryStyle(word.group)?.bgGradient || 'bg-gradient-to-br from-emerald-500 to-cyan-600'}`}
          style={{ 
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)'
          }}
        >
          <div className="absolute inset-0 bg-black/20"></div>
          
          {/* Category badge */}
          {word.group && (
            <div className="absolute top-4 right-4 z-10">
              <div className="bg-white/20 backdrop-blur-sm text-white px-3 py-2 rounded-xl text-sm font-medium flex items-center gap-2 shadow-lg">
                <span>{getCategoryStyle(word.group).icon}</span>
                <span>{word.group}</span>
              </div>
            </div>
          )}
          
          <div className="relative h-full flex flex-col text-white p-8">
            {/* Header */}
            <div className="text-center border-b border-white/30 pb-6 mb-6">
              <div className="text-2xl font-bold drop-shadow-md">
                {word.english}
              </div>
            </div>

            {/* Main translation */}
            <div className="text-center mb-8">
              <div 
                className="font-bold drop-shadow-lg leading-tight"
                style={{
                  fontSize: word.italian.length > 25 ? '2rem' : 
                           word.italian.length > 15 ? '2.5rem' : 
                           word.italian.length > 10 ? '3rem' : '3.5rem'
                }}
              >
                {word.italian}
              </div>
            </div>

            {/* Example */}
            {word.sentence && (
              <div className="mb-6">
                <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-4 border border-white/20">
                  <div className="font-bold mb-2 text-sm flex items-center gap-2">
                    <span className="text-lg">💬</span>
                    Esempio:
                  </div>
                  <div className="italic text-sm leading-relaxed">
                    "{word.sentence}"
                  </div>
                </div>
              </div>
            )}

            {/* Notes */}
            {word.notes && (
              <div className="flex-1 min-h-0">
                <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-4 h-full flex flex-col border border-white/20">
                  <div className="font-bold mb-3 text-sm flex items-center gap-2">
                    <span className="text-lg">📝</span>
                    Note:
                  </div>
                  <div className="overflow-y-auto flex-1 text-sm leading-relaxed whitespace-pre-line">
                    {formatNotes(word.notes)}
                  </div>
                </div>
              </div>
            )}

            {/* Footer */}
            <div className="text-center text-sm opacity-90 border-t border-white/30 pt-4 mt-6">
              <span className="animate-pulse">Clicca per tornare al fronte</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TestCard;

================================================================================

NOME FILE: src\components\TestHistory.js

// /src/components/TestHistory.js
// This file contains the TestHistory component, which displays a history of vocabulary tests taken by the user.
// It shows the details of each test, including the percentage of correct answers, total words, correct words, incorrect words, and the date of the test.
// The component also allows users to clear the test history and highlights words that were answered incorrectly in each test.
// The TestHistory component is designed to provide users with a comprehensive view of their testing performance over time,
// helping them track their progress and identify areas for improvement. 
import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { ChevronDown, ChevronUp, BookOpen, Target, Calendar, Award } from 'lucide-react';

const TestHistory = ({ testHistory, onClearHistory }) => {
  const [expandedTest, setExpandedTest] = useState(null);

  if (testHistory.length === 0) return null;

  const toggleTestExpansion = (testId) => {
    setExpandedTest(expandedTest === testId ? null : testId);
  };

  const formatDifficulty = (difficulty) => {
    const difficultyMap = {
      'easy': { label: 'Facile', color: 'bg-green-500', emoji: '😊' },
      'medium': { label: 'Medio', color: 'bg-yellow-500', emoji: '😐' },
      'hard': { label: 'Difficile', color: 'bg-red-500', emoji: '😤' }
    };
    return difficultyMap[difficulty] || difficultyMap['medium'];
  };

  const formatTestType = (testType) => {
    const typeMap = {
      'complete': { label: 'Completo', color: 'bg-blue-500', emoji: '🎯' },
      'selective': { label: 'Selettivo', color: 'bg-purple-500', emoji: '📚' },
      'unknown': { label: 'Standard', color: 'bg-gray-500', emoji: '📝' }
    };
    return typeMap[testType] || typeMap['unknown'];
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl overflow-hidden">
      <CardHeader className="bg-gradient-to-r from-indigo-500 to-purple-600 text-white">
        <div className="flex justify-between items-center">
          <CardTitle className="flex items-center gap-3 text-white">
            <Calendar className="w-6 h-6" />
            Cronologia Test Dettagliata ({testHistory.length})
          </CardTitle>
          <Button
            onClick={onClearHistory}
            variant="outline"
            className="border-white/30 text-white hover:bg-white/20 hover:border-white/50 rounded-xl"
          >
            <span className="w-4 h-4 mr-2">🗑️</span>
            Pulisci
          </Button>
        </div>
        <p className="text-indigo-100 mt-2">
          Storico completo con parametri di test, capitoli e performance dettagliate
        </p>
      </CardHeader>
      <CardContent className="p-6">
        <div className="space-y-4 max-h-96 overflow-y-auto scrollbar-thin">
          {testHistory.map((test, index) => (
            <TestHistoryCard
              key={test.id}
              test={test}
              testNumber={testHistory.length - index}
              isExpanded={expandedTest === test.id}
              onToggleExpansion={() => toggleTestExpansion(test.id)}
              formatDifficulty={formatDifficulty}
              formatTestType={formatTestType}
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

const TestHistoryCard = ({ 
  test, 
  testNumber, 
  isExpanded, 
  onToggleExpansion, 
  formatDifficulty, 
  formatTestType 
}) => {
  const difficulty = formatDifficulty(test.difficulty);
  const testType = formatTestType(test.testType);
  
  return (
    <div className="bg-gradient-to-r from-gray-50 to-white rounded-2xl border border-gray-100 hover:shadow-lg transition-all duration-300 overflow-hidden">
      {/* Header del Test */}
      <div 
        className="p-6 cursor-pointer"
        onClick={onToggleExpansion}
      >
        <div className="flex justify-between items-start mb-4">
          <div className="flex-1">
            <div className="flex items-center gap-4 mb-3">
              <div className="text-xl font-bold text-gray-800">
                Test #{testNumber}
              </div>
              
              {/* Badge Percentuale */}
              <div className={`px-4 py-2 rounded-full text-sm font-bold shadow-lg text-white ${
                test.percentage >= 80 ? 'bg-gradient-to-r from-green-500 to-emerald-500' :
                test.percentage >= 60 ? 'bg-gradient-to-r from-blue-500 to-cyan-500' :
                'bg-gradient-to-r from-red-500 to-pink-500'
              }`}>
                {test.percentage}%
              </div>
              
              {/* Badge Tipo Test */}
              <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${testType.color}`}>
                <span className="mr-1">{testType.emoji}</span>
                {testType.label}
              </div>
              
              {/* Badge Difficoltà */}
              <div className={`px-3 py-1 rounded-full text-xs font-medium text-white ${difficulty.color}`}>
                <span className="mr-1">{difficulty.emoji}</span>
                {difficulty.label}
              </div>
            </div>
            
            {/* Informazioni Base */}
            <div className="text-sm text-gray-600 mb-4 flex items-center gap-6">
              <div className="flex items-center gap-1">
                📅 {new Date(test.timestamp).toLocaleDateString('it-IT', {
                  year: 'numeric',
                  month: 'long',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                })}
              </div>
              
              {test.testParameters?.selectedChapters && (
                <div className="flex items-center gap-1">
                  📚 {test.testParameters.selectedChapters.length} 
                  {test.testParameters.selectedChapters.length === 1 ? ' capitolo' : ' capitoli'}
                </div>
              )}
              
              <div className="flex items-center gap-1">
                🎯 {test.totalWords} parole
              </div>
            </div>
            
            {/* Statistiche Rapide */}
            <div className="grid grid-cols-3 gap-4">
              <div className="bg-blue-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-blue-600">{test.totalWords}</div>
                <div className="text-blue-700 text-xs">Totale</div>
              </div>
              <div className="bg-green-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-green-600">{test.correctWords}</div>
                <div className="text-green-700 text-xs">Corrette</div>
              </div>
              <div className="bg-red-50 p-3 rounded-xl text-center">
                <div className="text-lg font-bold text-red-600">{test.incorrectWords}</div>
                <div className="text-red-700 text-xs">Sbagliate</div>
              </div>
            </div>
          </div>
          
          {/* Indicatore Espansione */}
          <div className="ml-4">
            {isExpanded ? (
              <ChevronUp className="w-5 h-5 text-gray-400" />
            ) : (
              <ChevronDown className="w-5 h-5 text-gray-400" />
            )}
          </div>
        </div>
      </div>
      
      {/* Dettagli Espansi */}
      {isExpanded && (
        <div className="border-t border-gray-200 bg-gray-50">
          <div className="p-6 space-y-6">
            
            {/* Parametri del Test */}
            {test.testParameters && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <Target className="w-5 h-5" />
                  Parametri del Test
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="bg-white p-4 rounded-xl border border-gray-200">
                    <div className="text-sm text-gray-600 mb-1">Capitoli Selezionati</div>
                    <div className="flex flex-wrap gap-2">
                      {test.testParameters.selectedChapters?.map(chapter => (
                        <span key={chapter} className="px-2 py-1 bg-blue-100 text-blue-700 rounded-lg text-xs">
                          {chapter === 'Senza Capitolo' ? '📋 Senza Cap.' : `📖 ${chapter}`}
                        </span>
                      ))}
                    </div>
                  </div>
                  <div className="bg-white p-4 rounded-xl border border-gray-200">
                    <div className="text-sm text-gray-600 mb-1">Configurazione</div>
                    <div className="space-y-1">
                      <div className="text-xs">
                        {test.testParameters.includeLearnedWords ? '✅' : '❌'} Parole apprese incluse
                      </div>
                      <div className="text-xs text-gray-500">
                        {test.testParameters.totalAvailableWords} parole disponibili totali
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
            
            {/* Performance per Capitolo */}
            {test.chapterStats && Object.keys(test.chapterStats).length > 0 && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <BookOpen className="w-5 h-5" />
                  Performance per Capitolo
                </h4>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {Object.entries(test.chapterStats).map(([chapter, stats]) => (
                    <div key={chapter} className="bg-white p-4 rounded-xl border border-gray-200">
                      <div className="font-medium text-gray-800 mb-2">
                        {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`}
                      </div>
                      <div className="space-y-2">
                        <div className="flex justify-between items-center">
                          <span className="text-sm text-gray-600">Accuratezza:</span>
                          <span className={`font-bold ${
                            stats.percentage >= 80 ? 'text-green-600' :
                            stats.percentage >= 60 ? 'text-blue-600' : 'text-red-600'
                          }`}>
                            {stats.percentage}%
                          </span>
                        </div>
                        <div className="flex justify-between items-center text-xs text-gray-500">
                          <span>Corrette: {stats.correctWords}</span>
                          <span>Sbagliate: {stats.incorrectWords}</span>
                        </div>
                        <div className="w-full bg-gray-200 rounded-full h-2">
                          <div 
                            className={`h-2 rounded-full ${
                              stats.percentage >= 80 ? 'bg-green-500' :
                              stats.percentage >= 60 ? 'bg-blue-500' : 'bg-red-500'
                            }`}
                            style={{ width: `${stats.percentage}%` }}
                          ></div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
            
            {/* Parole Sbagliate */}
            {test.wrongWords && test.wrongWords.length > 0 && (
              <div>
                <h4 className="font-bold text-gray-800 mb-3 flex items-center gap-2">
                  <Award className="w-5 h-5" />
                  Parole da Ripassare ({test.wrongWords.length})
                </h4>
                <div className="bg-red-50 p-4 rounded-xl border border-red-200">
                  <div className="flex flex-wrap gap-2">
                    {test.wrongWords.map((word, wordIndex) => (
                      <div
                        key={wordIndex}
                        className="bg-white border border-red-200 px-3 py-2 rounded-lg text-sm"
                      >
                        <span className="font-medium text-red-700">{word.english}</span>
                        <span className="mx-2 text-red-400">→</span>
                        <span className="text-red-600">{word.italian}</span>
                        {word.chapter && (
                          <span className="ml-2 text-xs text-red-500">
                            📖 {word.chapter}
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            )}
            
            {/* Raccomandazioni */}
            <div className="bg-blue-50 p-4 rounded-xl border border-blue-200">
              <h5 className="font-medium text-blue-800 mb-2">💡 Raccomandazioni per il prossimo test:</h5>
              <div className="text-sm text-blue-700 space-y-1">
                {test.percentage < 60 && (
                  <p>• Rivedi le parole sbagliate prima del prossimo test</p>
                )}
                {test.chapterStats && Object.values(test.chapterStats).some(s => s.percentage < 70) && (
                  <p>• Concentrati sui capitoli con performance inferiore al 70%</p>
                )}
                {test.testParameters?.selectedChapters?.length === 1 && (
                  <p>• Prova a combinare più capitoli per aumentare la varietà</p>
                )}
                {test.percentage >= 80 && (
                  <p>• Ottimo lavoro! Potresti provare un test più difficile</p>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default TestHistory;

================================================================================

NOME FILE: src\components\TestResults.js

// /src/components/TestResults.js
// This file contains the TestResults component, which displays the results of a vocabulary test.
// It shows the user's performance statistics, including the number of correct and incorrect answers, and provides options to start a new test or return to the menu.
// The component also highlights words that were answered incorrectly, allowing users to review and learn from their mistakes.

import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Play, RotateCcw, Check, X, Trophy } from 'lucide-react';
import { getTestResult } from '../utils/textUtils';
import { formatNotes } from '../utils/textUtils';

const TestResults = ({ stats, wrongWords, onStartNewTest, onResetTest }) => {
  const result = getTestResult(stats);
  const percentage = Math.round((stats.correct / (stats.correct + stats.incorrect)) * 100);

  return (
    <div className="space-y-8">
      <Card className="relative overflow-hidden backdrop-blur-sm bg-white/90 border-0 shadow-2xl rounded-3xl">
        {/* Background animato */}
        <div className="absolute inset-0 bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 opacity-50"></div>
        <div className="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>
        
        <CardHeader className="relative text-center py-12">
          <div className="text-8xl mb-6 animate-bounce">
            {result.type === 'victory' ? '🏆' : 
             result.type === 'good' ? '🎉' : '📚'}
          </div>
          <CardTitle className={`text-4xl font-bold mb-4 ${result.color}`}>
            {result.message}
          </CardTitle>
          <div className="text-6xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-2">
            {percentage}%
          </div>
          <p className="text-xl text-gray-600">
            {stats.correct} corrette su {stats.correct + stats.incorrect} domande
          </p>
        </CardHeader>
        
        <CardContent className="relative pb-12">
          {/* Statistiche */}
          <div className="grid grid-cols-2 gap-6 max-w-md mx-auto mb-8">
            <div className="bg-gradient-to-br from-green-500 to-emerald-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{stats.correct}</div>
              <div className="text-green-100">Corrette</div>
              <Check className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
            <div className="bg-gradient-to-br from-red-500 to-pink-500 p-6 rounded-2xl text-white text-center shadow-xl transform hover:scale-105 transition-transform">
              <div className="text-3xl font-bold">{stats.incorrect}</div>
              <div className="text-red-100">Sbagliate</div>
              <X className="w-8 h-8 mx-auto mt-2 opacity-80" />
            </div>
          </div>

          {/* Bottoni azione */}
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Button 
              onClick={onStartNewTest} 
              className="bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white px-8 py-4 text-lg rounded-2xl shadow-xl transform hover:scale-105 transition-all duration-200"
            >
              <Play className="w-5 h-5 mr-2" />
              Nuovo Test
            </Button>
            <Button 
              onClick={onResetTest} 
              variant="outline"
              className="border-2 border-gray-300 hover:border-gray-400 px-8 py-4 text-lg rounded-2xl bg-white/80 backdrop-blur-sm shadow-lg hover:shadow-xl transition-all duration-200"
            >
              <RotateCcw className="w-5 h-5 mr-2" />
              Torna al Menu
            </Button>
          </div>

          {/* Parole Sbagliate */}
          {wrongWords.length > 0 && (
            <div className="mt-12">
              <Card className="bg-gradient-to-br from-orange-50 to-red-50 border-2 border-orange-200 rounded-3xl overflow-hidden shadow-xl">
                <CardHeader className="bg-gradient-to-r from-orange-500 to-red-500 text-white">
                  <CardTitle className="flex items-center gap-3">
                    <Trophy className="w-6 h-6" />
                    Parole da Ripassare ({wrongWords.length})
                  </CardTitle>
                  <p className="text-orange-100">
                    Studia queste parole per migliorare nel prossimo test!
                  </p>
                </CardHeader>
                <CardContent className="p-6">
                  <div className="grid gap-4">
                    {wrongWords.map((word, index) => (
                      <div
                        key={`${word.id}-${index}`}
                        className="bg-white p-6 rounded-2xl border border-orange-200 shadow-lg hover:shadow-xl transition-shadow duration-200"
                      >
                        <div className="flex justify-between items-start">
                          <div className="flex-1">
                            <div className="flex items-center gap-3 mb-3">
                              <span className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">{word.english}</span>
                              <span className="text-orange-400">→</span>
                              <span className="text-xl text-gray-700">{word.italian}</span>
                            </div>
                            
                            {word.group && (
                              <div className="mb-3">
                                <span className="inline-flex items-center gap-1 bg-blue-100 text-blue-700 px-3 py-1 rounded-full text-sm font-medium">
                                  📂 {word.group}
                                </span>
                              </div>
                            )}
                            
                            {word.sentence && (
                              <div className="mb-3 p-4 bg-green-50 rounded-xl border border-green-200">
                                <div className="text-green-600 font-semibold text-sm mb-1 flex items-center gap-2">
                                  <span>💬</span> Esempio:
                                </div>
                                <div className="text-green-800 italic">"{word.sentence}"</div>
                              </div>
                            )}
                            
                            {word.notes && (
                              <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200">
                                <div className="text-yellow-600 font-semibold text-sm mb-1 flex items-center gap-2">
                                  <span>📝</span> Note:
                                </div>
                                <div className="text-yellow-800 text-sm whitespace-pre-line">
                                  {formatNotes(word.notes)}
                                </div>
                              </div>
                            )}
                          </div>
                          <div className="text-3xl text-orange-500 ml-4">❌</div>
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default TestResults;

================================================================================

NOME FILE: src\components\WordsList.js

import React, { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Plus, Trash2, Edit3, ChevronDown, ChevronUp, BookOpen, CheckCircle, Circle, Filter } from 'lucide-react';

// Simulated utility functions (replace with your actual imports)
const getCategoryStyle = (group) => {
  const categoryMap = {
    'VERBI': { icon: '⚡', bgColor: 'bg-red-500' },
    'VERBI_IRREGOLARI': { icon: '🔄', bgColor: 'bg-red-600' },
    'SOSTANTIVI': { icon: '🏷️', bgColor: 'bg-blue-500' },
    'AGGETTIVI': { icon: '🎨', bgColor: 'bg-green-500' },
    'FAMIGLIA': { icon: '👨‍👩‍👧‍👦', bgColor: 'bg-pink-400' },
    'TECNOLOGIA': { icon: '💻', bgColor: 'bg-cyan-500' },
    'LAVORO': { icon: '💼', bgColor: 'bg-indigo-500' },
    'DEFAULT': { icon: '📚', bgColor: 'bg-gray-500' }
  };
  return categoryMap[group?.toUpperCase()] || categoryMap['DEFAULT'];
};

const formatNotes = (notes) => {
  if (!notes) return null;
  const keywords = ['Altri Significati', 'Sinonimi', 'Verbo Irregolare', 'Pronuncia', 'Esempi'];
  let formattedText = notes;
  keywords.forEach(keyword => {
    const regex = new RegExp(`(${keyword})\\s*:`, 'gi');
    formattedText = formattedText.replace(regex, `**$1:**`);
  });
  
  return formattedText.split(/(\*\*[^*]+\*\*)/).map((part, index) => {
    if (part.startsWith('**') && part.endsWith('**')) {
      return React.createElement('span', { key: index, className: 'font-bold' }, part.slice(2, -2));
    }
    return part;
  });
};

const WordsList = ({ words, onEditWord, onRemoveWord, onToggleLearned, showWordsList, setShowWordsList }) => {
  const [filterChapter, setFilterChapter] = useState('');
  const [filterLearned, setFilterLearned] = useState('all'); // 'all', 'learned', 'not_learned'
  const [filterGroup, setFilterGroup] = useState('');

  // Calcolo dati derivati all'inizio per evitare problemi di scope
  const availableChapters = React.useMemo(() => {
    const chapters = new Set();
    words.forEach(word => {
      if (word.chapter) chapters.add(word.chapter);
    });
    return Array.from(chapters).sort((a, b) => {
      const aNum = parseInt(a);
      const bNum = parseInt(b);
      return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
    });
  }, [words]);

  const availableGroups = React.useMemo(() => {
    const groups = new Set();
    words.forEach(word => {
      if (word.group) groups.add(word.group);
    });
    return Array.from(groups).sort();
  }, [words]);

  const wordsWithoutChapter = React.useMemo(() => {
    return words.filter(word => !word.chapter);
  }, [words]);

  // Filtra le parole
  const filteredWords = words.filter(word => {
    // Filtro per capitolo
    if (filterChapter !== '') {
      if (filterChapter === 'no-chapter') {
        // "Senza capitolo" - mostra solo parole senza capitolo
        if (word.chapter) return false;
      } else {
        // Capitolo specifico - mostra solo parole di quel capitolo
        if (word.chapter !== filterChapter) return false;
      }
    }
    
    // Filtro per gruppo
    if (filterGroup && word.group !== filterGroup) return false;
    
    // Filtro per stato appreso
    if (filterLearned === 'learned' && !word.learned) return false;
    if (filterLearned === 'not_learned' && word.learned) return false;
    
    return true;
  });

  // Raggruppa le parole per capitolo
  const groupedWords = filteredWords.reduce((groups, word) => {
    const chapter = word.chapter || 'Senza Capitolo';
    if (!groups[chapter]) groups[chapter] = [];
    groups[chapter].push(word);
    return groups;
  }, {});

  // Statistiche
  const stats = {
    total: words.length,
    learned: words.filter(w => w.learned).length,
    notLearned: words.filter(w => !w.learned).length,
    withChapter: words.filter(w => w.chapter).length,
    filtered: filteredWords.length
  };

  const clearFilters = () => {
    setFilterChapter('');
    setFilterLearned('all');
    setFilterGroup('');
  };

  return (
    <Card className="backdrop-blur-sm bg-white/90 border-0 shadow-xl rounded-3xl overflow-hidden">
      <CardHeader 
        className="cursor-pointer hover:bg-gray-50 transition-colors" 
        onClick={() => setShowWordsList(!showWordsList)}
      >
        <CardTitle className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <span className="text-2xl">📚</span>
            <div className="flex flex-col">
              <span className="bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">
                Il Tuo Vocabolario ({stats.total} parole)
              </span>
              <div className="flex gap-4 text-sm text-gray-600 mt-1">
                <span>✅ {stats.learned} apprese</span>
                <span>📖 {stats.notLearned} da studiare</span>
                <span>📚 {stats.withChapter} con capitolo</span>
              </div>
            </div>
          </div>
          {showWordsList ? <ChevronUp className="w-5 h-5 text-gray-400" /> : <ChevronDown className="w-5 h-5 text-gray-400" />}
        </CardTitle>
      </CardHeader>
      
      {showWordsList && (
        <CardContent className="animate-fade-in">
          {words.length === 0 ? (
            <div className="text-center py-16">
              <div className="text-8xl mb-6">📚</div>
              <h3 className="text-2xl font-bold text-gray-700 mb-4">Il tuo vocabolario è vuoto</h3>
              <p className="text-gray-600 text-lg mb-8">Aggiungi la tua prima parola per iniziare a studiare!</p>
              <div className="flex justify-center">
                <Button className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-8 py-4 text-lg rounded-2xl shadow-xl">
                  <Plus className="w-5 h-5 mr-2" />
                  Aggiungi Prima Parola
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-6">
              {/* Filtri */}
              <Card className="bg-gradient-to-r from-blue-50 to-purple-50 border-2 border-blue-200">
                <CardHeader className="pb-3">
                  <CardTitle className="flex items-center gap-2 text-lg">
                    <Filter className="w-5 h-5 text-blue-600" />
                    Filtri ({stats.filtered} parole mostrate)
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Capitolo</label>
                      <select
                        value={filterChapter}
                        onChange={(e) => setFilterChapter(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="">Tutti i capitoli</option>
                        {availableChapters.map(chapter => (
                          <option key={chapter} value={chapter}>📖 {chapter}</option>
                        ))}
                        {wordsWithoutChapter.length > 0 && (
                          <option value="no-chapter">📋 Senza capitolo</option>
                        )}
                      </select>
                    </div>
                    
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Stato</label>
                      <select
                        value={filterLearned}
                        onChange={(e) => setFilterLearned(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="all">Tutte le parole</option>
                        <option value="learned">✅ Solo apprese</option>
                        <option value="not_learned">📖 Solo da studiare</option>
                      </select>
                    </div>
                    
                    <div>
                      <label className="text-sm font-medium text-gray-700 mb-2 block">Categoria</label>
                      <select
                        value={filterGroup}
                        onChange={(e) => setFilterGroup(e.target.value)}
                        className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:border-blue-500 bg-white"
                      >
                        <option value="">Tutte le categorie</option>
                        {availableGroups.map(group => (
                          <option key={group} value={group}>
                            {getCategoryStyle(group).icon} {group}
                          </option>
                        ))}
                      </select>
                    </div>
                    
                    <div className="flex items-end">
                      <Button 
                        onClick={clearFilters}
                        variant="outline"
                        className="w-full"
                      >
                        Cancella Filtri
                      </Button>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* Statistiche Generali */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div className="text-center p-4 bg-blue-50 rounded-2xl border border-blue-200">
                  <div className="text-2xl font-bold text-blue-600">{stats.total}</div>
                  <div className="text-blue-700 text-sm">Totale Parole</div>
                </div>
                <div className="text-center p-4 bg-green-50 rounded-2xl border border-green-200">
                  <div className="text-2xl font-bold text-green-600">{stats.learned}</div>
                  <div className="text-green-700 text-sm">Apprese</div>
                </div>
                <div className="text-center p-4 bg-orange-50 rounded-2xl border border-orange-200">
                  <div className="text-2xl font-bold text-orange-600">{stats.notLearned}</div>
                  <div className="text-orange-700 text-sm">Da Studiare</div>
                </div>
                <div className="text-center p-4 bg-purple-50 rounded-2xl border border-purple-200">
                  <div className="text-2xl font-bold text-purple-600">{availableChapters.length}</div>
                  <div className="text-purple-700 text-sm">Capitoli</div>
                </div>
              </div>

              {/* Lista Parole Raggruppate per Capitolo */}
              <div className="space-y-6 max-h-96 overflow-y-auto scrollbar-thin">
                {Object.entries(groupedWords)
                  .sort(([a], [b]) => {
                    if (a === 'Senza Capitolo') return 1;
                    if (b === 'Senza Capitolo') return -1;
                    const aNum = parseInt(a);
                    const bNum = parseInt(b);
                    return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
                  })
                  .map(([chapter, chapterWords]) => (
                    <div key={chapter} className="space-y-3">
                      {/* Header Capitolo */}
                      <div className="flex items-center gap-3 p-3 bg-gradient-to-r from-indigo-100 to-purple-100 rounded-2xl border border-indigo-200">
                        <BookOpen className="w-5 h-5 text-indigo-600" />
                        <h3 className="font-bold text-indigo-800 text-lg">
                          {chapter === 'Senza Capitolo' ? '📋 Senza Capitolo' : `📖 Capitolo ${chapter}`}
                        </h3>
                        <span className="text-sm text-indigo-600 bg-indigo-200 px-3 py-1 rounded-full">
                          {chapterWords.length} parole
                        </span>
                        <span className="text-sm text-green-600 bg-green-200 px-3 py-1 rounded-full">
                          {chapterWords.filter(w => w.learned).length} apprese
                        </span>
                      </div>
                      
                      {/* Parole del Capitolo */}
                      <div className="space-y-3">
                        {chapterWords.map((word) => (
                          <WordCard 
                            key={word.id} 
                            word={word} 
                            onEdit={() => onEditWord(word)}
                            onRemove={() => onRemoveWord(word.id)}
                            onToggleLearned={() => onToggleLearned(word.id)}
                          />
                        ))}
                      </div>
                    </div>
                  ))}
              </div>
            </div>
          )}
        </CardContent>
      )}
    </Card>
  );
};

const WordCard = ({ word, onEdit, onRemove, onToggleLearned }) => (
  <div className={`p-6 rounded-2xl border-2 hover:shadow-lg transition-all duration-300 hover-lift ${
    word.learned 
      ? 'bg-gradient-to-r from-green-50 to-emerald-50 border-green-200' 
      : 'bg-gradient-to-r from-white to-gray-50 border-gray-100 hover:border-gray-200'
  }`}>
    <div className="flex justify-between items-start">
      <div className="flex-1">
        <div className="flex items-center gap-3 mb-3">
          <span className={`text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent ${
            word.learned ? 'opacity-75' : ''
          }`}>
            {word.english}
          </span>
          <span className="text-gray-400 text-xl">→</span>
          <span className={`text-xl font-medium ${
            word.learned ? 'text-gray-600' : 'text-gray-700'
          }`}>
            {word.italian}
          </span>
          
          {/* Stato Appreso */}
          <div 
            onClick={onToggleLearned}
            className="cursor-pointer"
            title={word.learned ? "Segna come non appresa" : "Segna come appresa"}
          >
            {word.learned ? (
              <CheckCircle className="w-6 h-6 text-green-500 hover:text-green-600 transition-colors" />
            ) : (
              <Circle className="w-6 h-6 text-gray-400 hover:text-green-500 transition-colors" />
            )}
          </div>
        </div>
        
        <div className="flex flex-wrap gap-2 mb-3">
          {word.group && (
            <span className={`inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium text-white shadow-lg ${getCategoryStyle(word.group).bgColor}`}>
              <span>{getCategoryStyle(word.group).icon}</span>
              {word.group}
            </span>
          )}
          
          {word.chapter && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-700">
              <BookOpen className="w-4 h-4" />
              Cap. {word.chapter}
            </span>
          )}
          
          {word.learned && (
            <span className="inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-700">
              <CheckCircle className="w-4 h-4" />
              Appresa
            </span>
          )}
        </div>

        {word.sentence && (
          <div className="mb-3 p-4 bg-green-50 rounded-xl border border-green-200">
            <div className="text-green-600 font-semibold text-sm mb-1 flex items-center gap-2">
              <span>💬</span> Esempio:
            </div>
            <div className="text-green-800 italic">"{word.sentence}"</div>
          </div>
        )}

        {word.notes && (
          <div className="p-4 bg-yellow-50 rounded-xl border border-yellow-200">
            <div className="text-yellow-600 font-semibold text-sm mb-1 flex items-center gap-2">
              <span>📝</span> Note:
            </div>
            <div className="text-yellow-800 text-sm whitespace-pre-line">
              {formatNotes(word.notes)}
            </div>
          </div>
        )}
      </div>
      
      <div className="flex gap-2 ml-4">
        <Button
          onClick={onEdit}
          variant="ghost"
          size="sm"
          className="text-blue-500 hover:text-blue-700 hover:bg-blue-50 p-3 rounded-xl transition-colors"
          title="Modifica parola"
        >
          <Edit3 className="w-5 h-5" />
        </Button>
        <Button
          onClick={onRemove}
          variant="ghost"
          size="sm"
          className="text-red-500 hover:text-red-700 hover:bg-red-50 p-3 rounded-xl transition-colors"
          title="Elimina parola"
        >
          <Trash2 className="w-5 h-5" />
        </Button>
      </div>
    </div>
  </div>
);

export default WordsList;

================================================================================

NOME FILE: src\components\ui\button.js

// /src/components/ui/button.js
// This file contains the Button component with various styles and sizes.
// It is designed to be used in forms and other interactive elements, providing a consistent look and feel for buttons.
// It supports different variants like default, outline, ghost, and destructive, as well as size options like default, sm, and lg.
// The Button component can be customized with additional classes and styles as needed.

import React from 'react';

const Button = React.forwardRef(({
  className = "",
  variant = "default",
  size = "default",
  children,
  disabled = false,
  ...props
}, ref) => {
  const baseClasses = "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background";

  const variants = {
    default: "bg-primary text-primary-foreground hover:bg-primary/90 bg-slate-900 text-white hover:bg-slate-800",
    outline: "border border-input hover:bg-accent hover:text-accent-foreground border-gray-300 hover:bg-gray-50",
    ghost: "hover:bg-accent hover:text-accent-foreground hover:bg-gray-100",
    destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90 bg-red-600 text-white hover:bg-red-700"
  };

  const sizes = {
    default: "h-10 py-2 px-4",
    sm: "h-9 px-3 rounded-md",
    lg: "h-11 px-8 rounded-md"
  };

  const classes = `${baseClasses} ${variants[variant]} ${sizes[size]} ${className}`;

  return (
    <button
      className={classes}
      ref={ref}
      disabled={disabled}
      {...props}
    >
      {children}
    </button>
  );
});

Button.displayName = "Button";

export { Button };

================================================================================

NOME FILE: src\components\ui\card.js

// /src/components/ui/card.js
// This file contains the Card component and its subcomponents for displaying content in a card format.
// It includes CardHeader, CardTitle, CardDescription, CardContent, and CardFooter components
// to structure the card layout.
// It is designed to be used in various parts of the application where a card-like UI is needed.
// It provides a consistent look and feel for displaying information in a card format.
// The Card component can be customized with additional classes and styles as needed.   


import React from 'react';

const Card = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`rounded-lg border bg-card text-card-foreground shadow-sm bg-white border-gray-200 ${className}`}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`flex flex-col space-y-1.5 p-6 ${className}`}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef(({ className = "", ...props }, ref) => (
  <h3
    ref={ref}
    className={`text-2xl font-semibold leading-none tracking-tight ${className}`}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef(({ className = "", ...props }, ref) => (
  <p
    ref={ref}
    className={`text-sm text-muted-foreground text-gray-600 ${className}`}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef(({ className = "", ...props }, ref) => (
  <div ref={ref} className={`p-6 pt-0 ${className}`} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef(({ className = "", ...props }, ref) => (
  <div
    ref={ref}
    className={`flex items-center p-6 pt-0 ${className}`}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

================================================================================

NOME FILE: src\components\ui\input.js

// /src/components/ui/input.js
// This file contains the Input component with various styles and properties.
// It is designed to be used in forms and other input scenarios, providing a consistent look and feel for text inputs.
//
import React from 'react';

const Input = React.forwardRef(({ className = "", type = "text", ...props }, ref) => {
  return (
    <input
      type={type}
      className={`flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`}
      ref={ref}
      {...props}
    />
  );
});
Input.displayName = "Input";

export { Input };

================================================================================

NOME FILE: src\components\ui\modal.js

// /src/components/ui/modal.js
// This file contains the Modal component and its subcomponents for displaying modal dialogs.
//

import React from 'react';

const Modal = ({ isOpen, onClose, children, className = "" }) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      {/* Backdrop */}
      <div 
        className="fixed inset-0 bg-black bg-opacity-50 transition-opacity duration-300 backdrop-blur-sm"
        onClick={onClose}
      />
      
      {/* Modal Container */}
      <div className="flex min-h-full items-center justify-center p-4">
        <div 
          className={`relative bg-white rounded-2xl shadow-2xl transform transition-all duration-300 scale-100 max-w-md w-full mx-auto ${className}`}
          onClick={(e) => e.stopPropagation()}
        >
          {children}
        </div>
      </div>
    </div>
  );
};

const ModalHeader = ({ children, className = "" }) => (
  <div className={`px-6 py-4 border-b border-gray-200 ${className}`}>
    {children}
  </div>
);

const ModalTitle = ({ children, className = "" }) => (
  <h3 className={`text-lg font-semibold text-gray-900 ${className}`}>
    {children}
  </h3>
);

const ModalContent = ({ children, className = "" }) => (
  <div className={`px-6 py-4 ${className}`}>
    {children}
  </div>
);

const ModalFooter = ({ children, className = "" }) => (
  <div className={`px-6 py-4 border-t border-gray-200 flex justify-end gap-3 ${className}`}>
    {children}
  </div>
);

export { Modal, ModalHeader, ModalTitle, ModalContent, ModalFooter };

================================================================================

NOME FILE: src\components\ui\textarea.js

// /src/components/ui/textarea.js
// This file contains the Textarea component with various styles and properties.
//

import React from 'react';

const Textarea = React.forwardRef(({ className = "", ...props }, ref) => {
  return (
    <textarea
      className={`flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 border-gray-300 bg-white placeholder:text-gray-500 focus:border-blue-500 focus:ring-blue-500 ${className}`}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };

================================================================================

NOME FILE: src\hooks\useLocalStorage.js

// /src/hooks/useLocalStorage.js
// This file contains a custom React hook for managing local storage.
// It allows you to store and retrieve values from local storage with automatic JSON serialization and deserialization
// while providing a default initial value.
// The hook also handles errors gracefully, ensuring that the application can continue to function even if local storage is not available or if there are issues with the stored data.
// The `useLocalStorage` hook can be used in any React component to persist state across page reloads or sessions, making it useful for settings, user preferences, or any data that needs to be retained between visits.
// It returns the stored value and a function to update it, which will also update the local storage accordingly.
// It is a convenient way to manage state that needs to be persistent in a React application.

import { useState } from 'react';

export const useLocalStorage = (key, initialValue) => {
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error loading ${key} from localStorage:`, error);
      return initialValue;
    }
  });

  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error saving ${key} to localStorage:`, error);
    }
  };

  return [storedValue, setValue];
};

================================================================================

NOME FILE: src\hooks\useNotification.js

// /src/hooks/useNotification.js
// This file contains a custom React hook for managing notifications.
// It provides functionality to show a notification message for a specified duration.

import { useState, useCallback } from 'react';

export const useNotification = () => {
  const [message, setMessage] = useState('');

  const showNotification = useCallback((msg, duration = 3000) => {
    setMessage(msg);
    setTimeout(() => setMessage(''), duration);
  }, []);

  return { message, showNotification };
};

================================================================================

NOME FILE: src\hooks\useStats.js

// hooks/useStats.js - Versione Centralizzata e Sincronizzata
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useLocalStorage } from './useLocalStorage';
import { useNotification } from './useNotification';

export const useStats = () => {
  // ⭐ CENTRALIZZATO: Un solo punto di accesso per entrambi i dati
  const [testHistory, setTestHistory] = useLocalStorage('testHistory', []);
  const [stats, setStats] = useLocalStorage('vocabularyStats', {
    totalWords: 0,
    correctAnswers: 0,
    incorrectAnswers: 0,
    averageScore: 0,
    testsCompleted: 0,
    timeSpent: 0,
    categoriesProgress: {},
    dailyProgress: {},
    streakDays: 0,
    lastStudyDate: null,
    difficultyStats: {
      easy: { correct: 0, total: 0 },
      medium: { correct: 0, total: 0 },
      hard: { correct: 0, total: 0 }
    },
    monthlyStats: {},
    migrated: false
  });

  const { showNotification } = useNotification();
  
  // ⭐ SISTEMA DI SINCRONIZZAZIONE MIGLIORATO
  const [forceUpdate, setForceUpdate] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);

  // ⭐ FUNZIONE DI REFRESH ROBUSTA
  const refreshData = useCallback(() => {
    if (isProcessing) return; // Evita sovrapposizioni
    
    try {
      setIsProcessing(true);
      
      // Forza rilettura da localStorage
      const freshHistoryStr = localStorage.getItem('testHistory');
      const freshStatsStr = localStorage.getItem('vocabularyStats');
      
      if (freshHistoryStr) {
        const freshHistory = JSON.parse(freshHistoryStr);
        setTestHistory(freshHistory);
      }
      
      if (freshStatsStr) {
        const freshStats = JSON.parse(freshStatsStr);
        setStats(freshStats);
      }
      
      // Forza re-render
      setForceUpdate(prev => prev + 1);
      
      console.log('🔄 Dati aggiornati:', {
        history: freshHistoryStr ? JSON.parse(freshHistoryStr).length : 0,
        statsTests: freshStatsStr ? JSON.parse(freshStatsStr).testsCompleted : 0
      });
      
    } catch (error) {
      console.error('❌ Errore refresh:', error);
    } finally {
      setIsProcessing(false);
    }
  }, [setTestHistory, setStats, isProcessing]);

  // ⭐ FUNZIONE DI SALVATAGGIO SINCRONIZZATO
  const saveDataSync = useCallback((newStats, newHistory) => {
    try {
      setIsProcessing(true);
      
      // Salva entrambi contemporaneamente
      if (newStats) {
        localStorage.setItem('vocabularyStats', JSON.stringify(newStats));
        setStats(newStats);
      }
      
      if (newHistory) {
        localStorage.setItem('testHistory', JSON.stringify(newHistory));
        setTestHistory(newHistory);
      }
      
      // Forza aggiornamento
      setTimeout(() => {
        setForceUpdate(prev => prev + 1);
        setIsProcessing(false);
      }, 50);
      
    } catch (error) {
      console.error('❌ Errore salvataggio sincronizzato:', error);
      setIsProcessing(false);
    }
  }, [setStats, setTestHistory]);

  // Calcola streak di giorni consecutivi
  const calculateStreak = useCallback((dailyProgress) => {
    const today = new Date();
    let streak = 0;
    
    for (let i = 0; i < 365; i++) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      
      if (dailyProgress[dateStr] && dailyProgress[dateStr].tests > 0) {
        streak++;
      } else if (i === 0) {
        continue;
      } else {
        break;
      }
    }
    
    return streak;
  }, []);

  // ⭐ MIGRAZIONE MIGLIORATA
  const migrateFromTestHistory = useCallback(() => {
    if (testHistory.length === 0) return;

    const migratedStats = {
      totalWords: 0,
      correctAnswers: 0,
      incorrectAnswers: 0,
      averageScore: 0,
      testsCompleted: testHistory.length,
      timeSpent: 0,
      categoriesProgress: {},
      dailyProgress: {},
      streakDays: 0,
      lastStudyDate: null,
      difficultyStats: {
        easy: { correct: 0, total: 0 },
        medium: { correct: 0, total: 0 },
        hard: { correct: 0, total: 0 }
      },
      monthlyStats: {},
      migrated: true
    };

    // Elabora ogni test nella cronologia
    testHistory.forEach(test => {
      migratedStats.correctAnswers += test.correctWords || 0;
      migratedStats.incorrectAnswers += test.incorrectWords || 0;
      migratedStats.totalWords = Math.max(migratedStats.totalWords, test.totalWords || 0);
      
      const estimatedTime = test.timeSpent || Math.floor(Math.random() * 6) + 5;
      migratedStats.timeSpent += estimatedTime;

      if (test.timestamp) {
        const testDate = new Date(test.timestamp).toISOString().split('T')[0];
        if (!migratedStats.dailyProgress[testDate]) {
          migratedStats.dailyProgress[testDate] = { tests: 0, correct: 0, incorrect: 0 };
        }
        migratedStats.dailyProgress[testDate].tests += 1;
        migratedStats.dailyProgress[testDate].correct += test.correctWords || 0;
        migratedStats.dailyProgress[testDate].incorrect += test.incorrectWords || 0;
        
        if (!migratedStats.lastStudyDate || testDate > migratedStats.lastStudyDate) {
          migratedStats.lastStudyDate = testDate;
        }
      }

      if (test.chapterStats) {
        Object.entries(test.chapterStats).forEach(([chapter, chapterData]) => {
          if (!migratedStats.categoriesProgress[chapter]) {
            migratedStats.categoriesProgress[chapter] = { correct: 0, total: 0 };
          }
          migratedStats.categoriesProgress[chapter].correct += chapterData.correctWords || 0;
          migratedStats.categoriesProgress[chapter].total += chapterData.totalWords || 0;
        });
      }

      const difficulty = test.difficulty || 'medium';
      if (migratedStats.difficultyStats[difficulty]) {
        migratedStats.difficultyStats[difficulty].correct += test.correctWords || 0;
        migratedStats.difficultyStats[difficulty].total += test.totalWords || 0;
      }

      if (test.timestamp) {
        const month = new Date(test.timestamp).toISOString().substring(0, 7);
        if (!migratedStats.monthlyStats[month]) {
          migratedStats.monthlyStats[month] = { tests: 0, correct: 0, incorrect: 0, timeSpent: 0 };
        }
        migratedStats.monthlyStats[month].tests += 1;
        migratedStats.monthlyStats[month].correct += test.correctWords || 0;
        migratedStats.monthlyStats[month].incorrect += test.incorrectWords || 0;
        migratedStats.monthlyStats[month].timeSpent += estimatedTime;
      }
    });

    const totalAnswers = migratedStats.correctAnswers + migratedStats.incorrectAnswers;
    migratedStats.averageScore = totalAnswers > 0 ? (migratedStats.correctAnswers / totalAnswers) * 100 : 0;
    migratedStats.streakDays = calculateStreak(migratedStats.dailyProgress);

    // ⭐ SALVATAGGIO SINCRONIZZATO
    saveDataSync(migratedStats, testHistory);
    showNotification(`✅ Migrati ${testHistory.length} test dalla cronologia!`);
    console.log('✅ Migrazione completata:', migratedStats);
    
  }, [testHistory, calculateStreak, saveDataSync, showNotification]);

  // ⭐ AGGIORNA STATISTICHE DOPO TEST
  const updateTestStats = useCallback((testResults) => {
    const newStats = { ...stats };
    
    newStats.testsCompleted += 1;
    newStats.correctAnswers += testResults.correct;
    newStats.incorrectAnswers += testResults.incorrect;
    newStats.totalWords = Math.max(newStats.totalWords, testResults.totalWords);
    newStats.averageScore = ((newStats.correctAnswers / (newStats.correctAnswers + newStats.incorrectAnswers)) * 100);
    newStats.timeSpent += testResults.timeSpent || 0;
    
    if (testResults.category) {
      if (!newStats.categoriesProgress[testResults.category]) {
        newStats.categoriesProgress[testResults.category] = { correct: 0, total: 0 };
      }
      newStats.categoriesProgress[testResults.category].correct += testResults.correct;
      newStats.categoriesProgress[testResults.category].total += testResults.correct + testResults.incorrect;
    }
    
    const today = new Date().toISOString().split('T')[0];
    if (!newStats.dailyProgress[today]) {
      newStats.dailyProgress[today] = { tests: 0, correct: 0, incorrect: 0 };
    }
    newStats.dailyProgress[today].tests += 1;
    newStats.dailyProgress[today].correct += testResults.correct;
    newStats.dailyProgress[today].incorrect += testResults.incorrect;
    
    newStats.lastStudyDate = today;
    newStats.streakDays = calculateStreak(newStats.dailyProgress);
    
    if (testResults.difficulty) {
      const difficulty = testResults.difficulty.toLowerCase();
      if (newStats.difficultyStats[difficulty]) {
        newStats.difficultyStats[difficulty].correct += testResults.correct;
        newStats.difficultyStats[difficulty].total += testResults.correct + testResults.incorrect;
      }
    }
    
    const currentMonth = new Date().toISOString().substring(0, 7);
    if (!newStats.monthlyStats[currentMonth]) {
      newStats.monthlyStats[currentMonth] = { tests: 0, correct: 0, incorrect: 0, timeSpent: 0 };
    }
    newStats.monthlyStats[currentMonth].tests += 1;
    newStats.monthlyStats[currentMonth].correct += testResults.correct;
    newStats.monthlyStats[currentMonth].incorrect += testResults.incorrect;
    newStats.monthlyStats[currentMonth].timeSpent += testResults.timeSpent || 0;
    
    // ⭐ SALVATAGGIO SINCRONIZZATO
    saveDataSync(newStats, null);
  }, [stats, saveDataSync, calculateStreak]);

  // ⭐ EXPORT COMPLETO MIGLIORATO
  const exportStats = useCallback(() => {
    try {
      const exportData = {
        stats,
        testHistory,
        exportDate: new Date().toISOString(),
        version: '2.0',
        dataTypes: ['stats', 'testHistory'],
        totalTests: testHistory.length,
        description: 'Backup completo: statistiche avanzate + cronologia test'
      };
      
      const dataStr = JSON.stringify(exportData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `vocabulary-complete-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      showNotification(`✅ Backup completo esportato! (${testHistory.length} test + statistiche)`);
    } catch (error) {
      console.error('❌ Errore export:', error);
      showNotification('❌ Errore durante l\'esportazione');
    }
  }, [stats, testHistory, showNotification]);

  // ⭐ IMPORT COMPLETO MIGLIORATO
  const importStats = useCallback((file) => {
    return new Promise((resolve, reject) => {
      if (isProcessing) {
        reject(new Error('Operazione già in corso'));
        return;
      }

      const reader = new FileReader();
      
      reader.onload = (e) => {
        try {
          setIsProcessing(true);
          const importedData = JSON.parse(e.target.result);
          
          const isCompleteBackup = importedData.version === '2.0' && importedData.testHistory;
          
          // Validazione
          if (!importedData.stats && !importedData.testHistory) {
            throw new Error('Dati non validi');
          }
          
          const shouldOverwrite = window.confirm(
            isCompleteBackup 
              ? `Backup completo rilevato (${importedData.testHistory?.length || 0} test).\nOK = Sostituisci tutto | Annulla = Combina`
              : `Backup statistiche rilevato.\nOK = Sostituisci | Annulla = Combina`
          );
          
          let newStats = stats;
          let newHistory = testHistory;
          
          if (isCompleteBackup) {
            if (shouldOverwrite) {
              newStats = { ...importedData.stats, migrated: true };
              newHistory = [...(importedData.testHistory || [])];
              showNotification(`✅ Backup completo importato! ${newHistory.length} test ripristinati`);
            } else {
              // Combina cronologie
              const existingIds = new Set(testHistory.map(test => test.id));
              const newTests = (importedData.testHistory || []).filter(test => !existingIds.has(test.id));
              newHistory = [...testHistory, ...newTests].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
              
              // Combina statistiche
              newStats = { ...stats };
              if (importedData.stats) {
                newStats.correctAnswers += importedData.stats.correctAnswers || 0;
                newStats.incorrectAnswers += importedData.stats.incorrectAnswers || 0;
                newStats.testsCompleted += importedData.stats.testsCompleted || 0;
                newStats.timeSpent += importedData.stats.timeSpent || 0;
                
                const totalAnswers = newStats.correctAnswers + newStats.incorrectAnswers;
                newStats.averageScore = totalAnswers > 0 ? (newStats.correctAnswers / totalAnswers) * 100 : 0;
                newStats.migrated = true;
              }
              
              showNotification(`✅ Dati combinati! +${newTests.length} test aggiunti`);
            }
          } else {
            // Solo statistiche
            if (shouldOverwrite) {
              newStats = { ...importedData.stats, migrated: true };
            } else {
              newStats = { ...stats };
              newStats.correctAnswers += importedData.stats.correctAnswers || 0;
              newStats.incorrectAnswers += importedData.stats.incorrectAnswers || 0;
              newStats.testsCompleted += importedData.stats.testsCompleted || 0;
              newStats.timeSpent += importedData.stats.timeSpent || 0;
              
              const totalAnswers = newStats.correctAnswers + newStats.incorrectAnswers;
              newStats.averageScore = totalAnswers > 0 ? (newStats.correctAnswers / totalAnswers) * 100 : 0;
              newStats.migrated = true;
            }
            showNotification('✅ Statistiche importate!');
          }
          
          // ⭐ SALVATAGGIO SINCRONIZZATO COMPLETO
          saveDataSync(newStats, newHistory);
          
          // ⭐ REFRESH MULTIPLI PER SICUREZZA
          setTimeout(() => {
            refreshData();
            setTimeout(() => refreshData(), 200);
          }, 100);
          
          resolve({ newStats, newHistory });
          
        } catch (error) {
          console.error('❌ Errore import:', error);
          showNotification('❌ Errore durante l\'importazione: file non valido');
          reject(error);
        } finally {
          setIsProcessing(false);
        }
      };
      
      reader.onerror = () => {
        setIsProcessing(false);
        const error = new Error('Errore lettura file');
        showNotification('❌ Errore nella lettura del file');
        reject(error);
      };
      
      reader.readAsText(file);
    });
  }, [stats, testHistory, saveDataSync, refreshData, showNotification, isProcessing]);

  // ⭐ RESET COMPLETO SINCRONIZZATO
  const resetStats = useCallback(() => {
    if (window.confirm('⚠️ ATTENZIONE: Vuoi cancellare TUTTO (statistiche + cronologia)?\nQuesta azione è irreversibile!')) {
      try {
        setIsProcessing(true);
        
        const emptyStats = {
          totalWords: 0,
          correctAnswers: 0,
          incorrectAnswers: 0,
          averageScore: 0,
          testsCompleted: 0,
          timeSpent: 0,
          categoriesProgress: {},
          dailyProgress: {},
          streakDays: 0,
          lastStudyDate: null,
          difficultyStats: {
            easy: { correct: 0, total: 0 },
            medium: { correct: 0, total: 0 },
            hard: { correct: 0, total: 0 }
          },
          monthlyStats: {},
          migrated: true
        };
        
        const emptyHistory = [];
        
        // ⭐ CANCELLAZIONE SINCRONIZZATA
        saveDataSync(emptyStats, emptyHistory);
        
        showNotification('✅ Tutti i dati sono stati cancellati!');
        
        // Refresh per sicurezza
        setTimeout(() => refreshData(), 100);
        
      } catch (error) {
        console.error('❌ Errore reset:', error);
        showNotification('❌ Errore durante la cancellazione');
      } finally {
        setIsProcessing(false);
      }
    }
  }, [saveDataSync, refreshData, showNotification]);

  // ⭐ CANCELLA SOLO CRONOLOGIA (mantiene statistiche)
  const clearHistoryOnly = useCallback(() => {
    if (window.confirm('Vuoi cancellare solo la cronologia test? (Le statistiche rimarranno)')) {
      try {
        setIsProcessing(true);
        const emptyHistory = [];
        saveDataSync(null, emptyHistory);
        showNotification('✅ Cronologia cancellata!');
        setTimeout(() => refreshData(), 100);
      } catch (error) {
        console.error('❌ Errore cancellazione cronologia:', error);
        showNotification('❌ Errore durante la cancellazione cronologia');
      } finally {
        setIsProcessing(false);
      }
    }
  }, [saveDataSync, refreshData, showNotification]);

  // ⭐ MIGRAZIONE FORZATA
  const forceMigration = useCallback(() => {
    if (window.confirm(`Vuoi ri-migrare ${testHistory.length} test dalla cronologia?`)) {
      const resetStats = { ...stats, migrated: false };
      saveDataSync(resetStats, null);
      
      setTimeout(() => {
        migrateFromTestHistory();
        setTimeout(() => refreshData(), 200);
      }, 100);
    }
  }, [testHistory, stats, saveDataSync, migrateFromTestHistory, refreshData]);

  // ⭐ AGGIUNGE TEST ALLA CRONOLOGIA (per nuovi test)
  const addTestToHistory = useCallback((testResult) => {
    try {
      const updatedHistory = [testResult, ...testHistory];
      saveDataSync(null, updatedHistory);
      console.log('✅ Test aggiunto alla cronologia:', testResult.id);
    } catch (error) {
      console.error('❌ Errore aggiunta test:', error);
    }
  }, [testHistory, saveDataSync]);

  // ⭐ FIXED: Statistiche calcolate senza forceUpdate nelle dipendenze
  const calculatedStats = useMemo(() => {
    const totalAnswers = stats.correctAnswers + stats.incorrectAnswers;
    const accuracyRate = totalAnswers > 0 ? (stats.correctAnswers / totalAnswers) * 100 : 0;
    
    const last7Days = Array.from({ length: 7 }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - i);
      return date.toISOString().split('T')[0];
    });
    
    const weeklyProgress = last7Days.map(date => ({
      date,
      tests: stats.dailyProgress[date]?.tests || 0,
      correct: stats.dailyProgress[date]?.correct || 0,
      incorrect: stats.dailyProgress[date]?.incorrect || 0
    }));
    
    return {
      accuracyRate: Math.round(accuracyRate * 100) / 100,
      totalAnswers,
      weeklyProgress,
      isActiveToday: stats.dailyProgress[new Date().toISOString().split('T')[0]]?.tests > 0,
      avgTimePerTest: stats.testsCompleted > 0 ? Math.round(stats.timeSpent / stats.testsCompleted) : 0
    };
  }, [stats]); // ⭐ FIXED: Rimosso forceUpdate dalle dipendenze

  // ⭐ MIGRAZIONE AUTOMATICA
  useEffect(() => {
    const shouldMigrate = (!stats.migrated && testHistory.length > 0) ||
                         (stats.migrated && testHistory.length > 0 && stats.testsCompleted === 0);
    
    if (shouldMigrate && !isProcessing) {
      console.log('🔄 Migrazione automatica...');
      migrateFromTestHistory();
    }
  }, [testHistory, stats.migrated, stats.testsCompleted, migrateFromTestHistory, isProcessing]);

  // ⭐ LISTENER CROSS-TAB
  useEffect(() => {
    const handleStorageChange = (e) => {
      if ((e.key === 'vocabularyStats' || e.key === 'testHistory') && !isProcessing) {
        console.log('📡 Storage change detected:', e.key);
        setTimeout(() => refreshData(), 50);
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [refreshData, isProcessing]);

  return {
    // ⭐ DATI CENTRALIZZATI
    stats,
    testHistory,
    calculatedStats,
    
    // ⭐ OPERAZIONI SINCRONIZZATE
    updateTestStats,
    addTestToHistory,
    exportStats,
    importStats,
    resetStats,
    clearHistoryOnly,
    forceMigration,
    
    // ⭐ UTILITÀ
    refreshData,
    isMigrated: stats.migrated,
    isProcessing,
    forceUpdate
  };
};

================================================================================

NOME FILE: src\hooks\useTest.js

import { useState, useCallback } from 'react';

export const useTest = (onTestComplete) => {
  const [currentWord, setCurrentWord] = useState(null);
  const [usedWordIds, setUsedWordIds] = useState(new Set());
  const [showMeaning, setShowMeaning] = useState(false);
  const [testMode, setTestMode] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [stats, setStats] = useState({ correct: 0, incorrect: 0 });
  const [wrongWords, setWrongWords] = useState([]);
  const [testWords, setTestWords] = useState([]); // Parole per il test corrente
  const [testSaved, setTestSaved] = useState(false); // Flag per evitare salvataggi multipli

  const getRandomUnusedWord = useCallback((wordList, usedIds) => {
    const unusedWords = wordList.filter(word => !usedIds.has(word.id));
    if (unusedWords.length === 0) return null;
    
    const randomIndex = Math.floor(Math.random() * unusedWords.length);
    return unusedWords[randomIndex];
  }, []);

  // Funzione per salvare i risultati del test con statistiche specifiche
  const saveTestResultsWithStats = useCallback((finalStats) => {
    if (!testSaved && (finalStats.correct > 0 || finalStats.incorrect > 0) && onTestComplete) {
      console.log('🔄 Salvando test con stats finali:', finalStats); // Debug log
      onTestComplete(finalStats, testWords, wrongWords);
      setTestSaved(true);
      console.log('✅ Test salvato con successo'); // Debug log
    } else if (testSaved) {
      console.log('⏭️ Test già salvato, skip'); // Debug log
    }
  }, [testWords, wrongWords, testSaved, onTestComplete]);

  // Funzione per salvare i risultati del test (versione con stato corrente)
  const saveTestResults = useCallback(() => {
    if (!testSaved && (stats.correct > 0 || stats.incorrect > 0) && onTestComplete) {
      console.log('🔄 Salvando test:', stats); // Debug log
      onTestComplete(stats, testWords, wrongWords);
      setTestSaved(true);
      console.log('✅ Test salvato con successo'); // Debug log
    } else if (testSaved) {
      console.log('⏭️ Test già salvato, skip'); // Debug log
    }
  }, [stats, testWords, wrongWords, testSaved, onTestComplete]);

  // Funzione aggiornata che accetta parole filtrate
  const startTest = useCallback((filteredWords = []) => {
    if (filteredWords.length === 0) return;
    
    setTestWords(filteredWords);
    setUsedWordIds(new Set());
    setWrongWords([]);
    setTestSaved(false); // Reset flag salvataggio
    const firstWord = getRandomUnusedWord(filteredWords, new Set());
    setCurrentWord(firstWord);
    setUsedWordIds(new Set([firstWord.id]));
    setShowMeaning(false);
    setTestMode(true);
    setStats({ correct: 0, incorrect: 0 });
  }, [getRandomUnusedWord]);

  const nextWord = useCallback(() => {
    const nextRandomWord = getRandomUnusedWord(testWords, usedWordIds);
    
    if (nextRandomWord) {
      setUsedWordIds(prev => new Set([...prev, nextRandomWord.id]));
      setCurrentWord(nextRandomWord);
      setShowMeaning(false);
    }
    // Rimosso il salvataggio automatico da qui - ora viene fatto in handleAnswer
  }, [testWords, usedWordIds, getRandomUnusedWord]);

  const handleAnswer = useCallback((isCorrect) => {
    // Calcola immediatamente le nuove statistiche
    const newStats = {
      correct: stats.correct + (isCorrect ? 1 : 0),
      incorrect: stats.incorrect + (isCorrect ? 0 : 1)
    };
    
    // Aggiorna lo stato
    setStats(newStats);
    
    if (!isCorrect && currentWord) {
      setWrongWords(prev => [...prev, currentWord]);
    }
    
    // Passa le statistiche aggiornate per verificare se è l'ultima domanda
    const totalAnswered = newStats.correct + newStats.incorrect;
    const isLastQuestion = totalAnswered >= testWords.length;
    
    if (showMeaning) {
      setShowMeaning(false);
      setTimeout(() => {
        if (isLastQuestion) {
          // Test completato - salva con le statistiche aggiornate
          saveTestResultsWithStats(newStats);
          setTestMode(false);
          setShowResults(true);
          setCurrentWord(null);
        } else {
          nextWord();
        }
      }, 800);
    } else {
      setTimeout(() => {
        if (isLastQuestion) {
          // Test completato - salva con le statistiche aggiornate
          saveTestResultsWithStats(newStats);
          setTestMode(false);
          setShowResults(true);
          setCurrentWord(null);
        } else {
          nextWord();
        }
      }, 300);
    }
  }, [currentWord, showMeaning, stats, testWords.length, saveTestResultsWithStats, nextWord]);

  const resetTest = useCallback(() => {
    // Salva il test se c'erano risposte e non è già stato salvato
    if (!testSaved && (stats.correct > 0 || stats.incorrect > 0)) {
      saveTestResults();
    }
    
    setTestMode(false);
    setShowResults(false);
    setCurrentWord(null);
    setUsedWordIds(new Set());
    setWrongWords([]);
    setShowMeaning(false);
    setStats({ correct: 0, incorrect: 0 });
    setTestWords([]);
    setTestSaved(false);
  }, [stats, testSaved, saveTestResults]);

  const startNewTest = useCallback(() => {
    // Il test precedente è già stato salvato, non serve rifarlo
    setShowResults(false);
    setWrongWords([]);
    setTestSaved(false); // IMPORTANTE: Reset flag per il NUOVO test
    setStats({ correct: 0, incorrect: 0 }); // Reset stats per il nuovo test
    setUsedWordIds(new Set()); // Reset parole usate
    setCurrentWord(null); // Reset parola corrente
    startTest(testWords); // Riusa le stesse parole del test
  }, [startTest, testWords]);

  // Nuove funzioni di utilità
  const getTestProgress = useCallback(() => {
    if (testWords.length === 0) return { current: 0, total: 0, percentage: 0 };
    
    return {
      current: usedWordIds.size,
      total: testWords.length,
      percentage: Math.round((usedWordIds.size / testWords.length) * 100)
    };
  }, [usedWordIds, testWords]);

  const getTestSummary = useCallback(() => {
    const progress = getTestProgress();
    const totalAnswered = stats.correct + stats.incorrect;
    const accuracy = totalAnswered > 0 ? Math.round((stats.correct / totalAnswered) * 100) : 0;
    
    return {
      ...progress,
      answered: totalAnswered,
      remaining: testWords.length - usedWordIds.size,
      accuracy,
      stats
    };
  }, [getTestProgress, stats, testWords.length, usedWordIds.size]);

  return {
    currentWord,
    usedWordIds,
    showMeaning,
    setShowMeaning,
    testMode,
    showResults,
    stats,
    wrongWords,
    testWords,
    startTest,
    handleAnswer,
    resetTest,
    startNewTest,
    // Nuove funzioni
    getTestProgress,
    getTestSummary,
    saveTestResults // Esportiamo per uso manuale se necessario
  };
};

================================================================================

NOME FILE: src\hooks\useWords.js

// /src/hooks/useWords.js
// This file contains a custom React hook for managing vocabulary words.
// It provides functionality to add, remove, edit, and import words, as well as manage the current editing state.
// The hook uses local storage to persist the vocabulary words, allowing them to be retained across sessions.
// It also includes validation to ensure that words are unique and that required fields are filled out.
// The `useWords` hook can be used in any React component to manage vocabulary words, making it easy to build a vocabulary learning application.
// It returns the list of words, the current editing word, and functions to manipulate the vocabulary.
// It is a convenient way to manage vocabulary state in a React application.
import { useState, useCallback } from 'react';
import { useLocalStorage } from './useLocalStorage';

export const useWords = () => {
  const [words, setWords] = useLocalStorage('vocabularyWords', []);
  const [editingWord, setEditingWord] = useState(null);

  const addWord = useCallback((wordData) => {
    if (!wordData.english?.trim() || !wordData.italian?.trim()) {
      throw new Error('English word and Italian translation are required');
    }

    const englishWord = wordData.english.trim().toLowerCase();
    
    if (!editingWord) {
      const wordExists = words.some(word => word.english.toLowerCase() === englishWord);
      if (wordExists) {
        throw new Error('Word already exists');
      }
    }
    
    if (editingWord) {
      const updatedWords = words.map(word => 
        word.id === editingWord.id 
          ? { 
              ...word, 
              ...wordData, 
              id: editingWord.id,
              // Mantieni i nuovi campi se non specificati
              learned: wordData.learned !== undefined ? wordData.learned : word.learned,
              chapter: wordData.chapter !== undefined ? wordData.chapter : word.chapter
            }
          : word
      );
      setWords(updatedWords.sort((a, b) => a.english.localeCompare(b.english)));
    } else {
      const newWord = {
        id: Date.now(),
        english: wordData.english.trim(),
        italian: wordData.italian.trim(),
        group: wordData.group?.trim() || null,
        sentence: wordData.sentence?.trim() || null,
        notes: wordData.notes?.trim() || null,
        chapter: wordData.chapter?.trim() || null,
        learned: wordData.learned || false
      };
      setWords(prev => [...prev, newWord].sort((a, b) => a.english.localeCompare(b.english)));
    }
    
    setEditingWord(null);
  }, [words, editingWord, setWords]);

  const removeWord = useCallback((id) => {
    setWords(prev => prev.filter(word => word.id !== id));
    if (editingWord && editingWord.id === id) {
      setEditingWord(null);
    }
  }, [setWords, editingWord]);

  const toggleWordLearned = useCallback((id) => {
    setWords(prev => prev.map(word => 
      word.id === id 
        ? { ...word, learned: !word.learned }
        : word
    ));
  }, [setWords]);

  const clearAllWords = useCallback(() => {
    setWords([]);
    setEditingWord(null);
  }, [setWords]);

  const importWords = useCallback((jsonText) => {
    const importedWords = JSON.parse(jsonText.trim());
    
    if (!Array.isArray(importedWords)) {
      throw new Error('JSON must contain an array of words');
    }

    if (importedWords.length === 0) {
      throw new Error('Array is empty');
    }

    const validWords = importedWords.filter(word => 
      word && word.english && word.italian
    ).map(word => ({
      id: word.id || Date.now() + Math.random(),
      english: word.english,
      italian: word.italian,
      group: word.group || null,
      sentence: word.sentence || null,
      notes: word.notes || null,
      chapter: word.chapter || null,
      learned: word.learned || false
    }));

    if (validWords.length === 0) {
      throw new Error('No valid words found in JSON');
    }

    const existingWords = words.map(w => w.english.toLowerCase());
    const newWords = validWords.filter(word => 
      !existingWords.includes(word.english.toLowerCase())
    );

    if (newWords.length === 0) {
      throw new Error('All words already exist in vocabulary');
    }

    setWords(prev => [...prev, ...newWords].sort((a, b) => a.english.localeCompare(b.english)));
    return newWords.length;
  }, [words, setWords]);

  // Nuove funzioni di utilità per le statistiche
  const getWordsByChapter = useCallback((chapter) => {
    return words.filter(word => word.chapter === chapter);
  }, [words]);

  const getLearnedWords = useCallback(() => {
    return words.filter(word => word.learned);
  }, [words]);

  const getUnlearnedWords = useCallback(() => {
    return words.filter(word => !word.learned);
  }, [words]);

  const getAvailableChapters = useCallback(() => {
    const chapters = new Set();
    words.forEach(word => {
      if (word.chapter) {
        chapters.add(word.chapter);
      }
    });
    return Array.from(chapters).sort((a, b) => {
      const aNum = parseInt(a);
      const bNum = parseInt(b);
      return !isNaN(aNum) && !isNaN(bNum) ? aNum - bNum : a.localeCompare(b);
    });
  }, [words]);

  const getChapterStats = useCallback((chapter) => {
    const chapterWords = getWordsByChapter(chapter);
    return {
      total: chapterWords.length,
      learned: chapterWords.filter(w => w.learned).length,
      unlearned: chapterWords.filter(w => !w.learned).length
    };
  }, [getWordsByChapter]);

  return {
    words,
    editingWord,
    setEditingWord,
    addWord,
    removeWord,
    toggleWordLearned,
    clearAllWords,
    importWords,
    // Nuove funzioni di utilità
    getWordsByChapter,
    getLearnedWords,
    getUnlearnedWords,
    getAvailableChapters,
    getChapterStats
  };
};

================================================================================

NOME FILE: src\utils\categoryUtils.js

// /src/utils/categoryUtils.js
// This file contains utility functions for managing vocabulary categories.
// It provides functions to get the style for a category based on its name, and to retrieve a list of predefined groups.
// It is used to ensure consistent styling and categorization of vocabulary words in the application.

export const getCategoryStyle = (group) => {
  if (!group) return { 
    color: 'from-blue-400 via-blue-500 to-blue-600', 
    icon: '📚', 
    bgColor: 'bg-blue-500',
    bgGradient: 'bg-gradient-to-br from-blue-500 to-cyan-600'
  };
  
  const categoryMap = {
    'VERBI': { 
      color: 'from-red-400 via-red-500 to-red-600', 
      icon: '⚡', 
      bgColor: 'bg-red-500',
      bgGradient: 'bg-gradient-to-br from-red-500 to-orange-600'
    },
    'VERBI_IRREGOLARI': { 
      color: 'from-red-500 via-red-600 to-red-700', 
      icon: '🔄', 
      bgColor: 'bg-red-600',
      bgGradient: 'bg-gradient-to-br from-red-600 to-pink-600'
    },
    'SOSTANTIVI': { 
      color: 'from-blue-400 via-blue-500 to-blue-600', 
      icon: '🏷️', 
      bgColor: 'bg-blue-500',
      bgGradient: 'bg-gradient-to-br from-blue-500 to-indigo-600'
    },
    'AGGETTIVI': { 
      color: 'from-green-400 via-green-500 to-green-600', 
      icon: '🎨', 
      bgColor: 'bg-green-500',
      bgGradient: 'bg-gradient-to-br from-green-500 to-emerald-600'
    },
    'DESCRIZIONI_FISICHE': { 
      color: 'from-teal-400 via-teal-500 to-teal-600', 
      icon: '👤', 
      bgColor: 'bg-teal-500',
      bgGradient: 'bg-gradient-to-br from-teal-500 to-cyan-600'
    },
    'POSIZIONE_CORPO': { 
      color: 'from-purple-400 via-purple-500 to-purple-600', 
      icon: '🧘', 
      bgColor: 'bg-purple-500',
      bgGradient: 'bg-gradient-to-br from-purple-500 to-violet-600'
    },
    'EMOZIONI': { 
      color: 'from-pink-400 via-pink-500 to-pink-600', 
      icon: '❤️', 
      bgColor: 'bg-pink-500',
      bgGradient: 'bg-gradient-to-br from-pink-500 to-rose-600'
    },
    'EMOZIONI_POSITIVE': { 
      color: 'from-yellow-400 via-yellow-500 to-orange-500', 
      icon: '😊', 
      bgColor: 'bg-yellow-500',
      bgGradient: 'bg-gradient-to-br from-yellow-400 to-orange-500'
    },
    'EMOZIONI_NEGATIVE': { 
      color: 'from-gray-400 via-gray-500 to-gray-600', 
      icon: '😔', 
      bgColor: 'bg-gray-500',
      bgGradient: 'bg-gradient-to-br from-gray-500 to-slate-600'
    },
    'LAVORO': { 
      color: 'from-indigo-400 via-indigo-500 to-indigo-600', 
      icon: '💼', 
      bgColor: 'bg-indigo-500',
      bgGradient: 'bg-gradient-to-br from-indigo-500 to-blue-600'
    },
    'FAMIGLIA': { 
      color: 'from-pink-300 via-pink-400 to-rose-500', 
      icon: '👨‍👩‍👧‍👦', 
      bgColor: 'bg-pink-400',
      bgGradient: 'bg-gradient-to-br from-pink-400 to-rose-500'
    },
    'TECNOLOGIA': { 
      color: 'from-cyan-400 via-cyan-500 to-blue-500', 
      icon: '💻', 
      bgColor: 'bg-cyan-500',
      bgGradient: 'bg-gradient-to-br from-cyan-500 to-blue-500'
    },
    'VESTITI': { 
      color: 'from-purple-300 via-purple-400 to-pink-500', 
      icon: '👕', 
      bgColor: 'bg-purple-400',
      bgGradient: 'bg-gradient-to-br from-purple-400 to-pink-500'
    },
    'DEFAULT': { 
      color: 'from-emerald-400 via-emerald-500 to-cyan-500', 
      icon: '📚', 
      bgColor: 'bg-emerald-500',
      bgGradient: 'bg-gradient-to-br from-emerald-500 to-cyan-600'
    }
  };
  
  const upperGroup = group ? group.toUpperCase().trim() : '';
  return categoryMap[upperGroup] || categoryMap['DEFAULT'];
};

export const getPredefinedGroups = () => {
  return [
    'VERBI', 'VERBI_IRREGOLARI', 'SOSTANTIVI', 'AGGETTIVI',
    'DESCRIZIONI_FISICHE', 'POSIZIONE_CORPO', 'EMOZIONI',
    'EMOZIONI_POSITIVE', 'EMOZIONI_NEGATIVE', 'LAVORO',
    'FAMIGLIA', 'TECNOLOGIA', 'VESTITI'
  ].sort();
};

================================================================================

NOME FILE: src\utils\textUtils.js

// /src/utils/textUtils.js
// This file contains utility functions for formatting notes and calculating test results.
// It provides functions to format notes with specific keywords and to determine the result of a vocabulary test.
// The `formatNotes` function processes notes to highlight keywords, while the `getTestResult` function evaluates test statistics to provide feedback based on the user's performance.
// These utilities are essential for enhancing the user experience in a vocabulary learning application, making it easier for users to understand notes and assess their test results.
//  * @returns {Array} An array of React elements or strings representing the formatted notes.
//  */      
//

import React from 'react';

export const formatNotes = (notes) => {
  if (!notes) return null;
  
  const keywords = [
    'Altri Significati', 'Altre Traduzioni', 'Espressioni', 'Verbo Irregolare', 
    'Pronuncia', 'Sinonimi', 'Esempi', 'Attenzione', 'Nota', 'Importante',
    'Plurale irregolare', 'Tecnologia', 'Posizione', 'Contrario', 'Espressione',
    'Verbo', 'Phrasal verbs', 'Differenza', 'Abbreviazione', 'Sinonimo',
    'Tipico britannico', 'Vestiti', 'Preposizioni', 'Avverbio', 'Sostantivo',
    'Aggettivo', 'Congiunzione', 'Interiezione', 'Participio', 'Gerundio',
    'Passato', 'Presente', 'Futuro', 'Condizionale', 'Imperativo', 'Infinito',
    'Formale', 'Informale', 'Slang', 'Americano', 'Britannico', 'Australiano',
    'Tempo', 'Luogo', 'Modo', 'Causa', 'Effetto', 'Scopo', 'Confronto',
    'Origine', 'Destinazione', 'Materiale', 'Colore', 'Forma', 'Dimensione',
    'Quantità', 'Frequenza', 'Durata', 'Velocità', 'Temperatura', 'Peso',
    'Struttura', 'Espressione fissa', 'Figurativo', 'Specificità', 'Pattern',
    'Più specifico di'
  ];
  
  let formattedText = notes;
  
  keywords.forEach(keyword => {
    const regex = new RegExp(`(${keyword})\\s*:`, 'gi');
    formattedText = formattedText.replace(regex, `**$1:**`);
  });
  
  formattedText = formattedText.replace(/^([A-Za-z\s]+):/gm, '**$1:**');
  
  const parts = formattedText.split(/(\*\*[^*]+\*\*)/g);
  
  return parts.map((part, index) => {
    if (part.startsWith('**') && part.endsWith('**')) {
      const boldText = part.slice(2, -2);
      return React.createElement('span', { key: index, className: 'font-bold' }, boldText);
    }
    return part;
  });
};

export const getTestResult = (stats) => {
  const total = stats.correct + stats.incorrect;
  const percentage = total > 0 ? Math.round((stats.correct / total) * 100) : 0;
  
  if (percentage >= 80) {
    return { type: 'victory', message: 'Eccellente! 🏆', color: 'text-green-600', bgColor: 'bg-green-50' };
  } else if (percentage >= 60) {
    return { type: 'good', message: 'Buon lavoro! 👍', color: 'text-blue-600', bgColor: 'bg-blue-50' };
  } else {
    return { type: 'defeat', message: 'Continua a studiare! 📚', color: 'text-red-600', bgColor: 'bg-red-50' };
  }
};

================================================================================

